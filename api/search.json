[{"id":"02d1724bb70f847f99a6b9b1b37f943a","title":"MacDock介绍","content":"MacDock：使用 QtWidget 开发的强大桌面 DockMacDock 是一个使用 QtWidget 开发的桌面应用程序，具备类似 macOS Dock 的功能。该应用程序提供了一种方便的方式来管理和启动常用应用程序，用户可以通过点击 Dock 中的图标来快速启动、删除或添加新的应用。凭借 Qt 的跨平台特性，MacDock 能在 Windows、Linux 和 macOS 上无缝运行。\n\n\n功能特点\n桌面吸附显示：MacDock 可以灵活地吸附在屏幕的上下左右四个边缘。用户可以自由拖动 Dock 到屏幕的任意边缘，Dock 会自动检测当前的边缘并紧贴吸附。这个功能使得 MacDock 非常灵活，适合不同的桌面布局和使用习惯。此外，吸附功能还支持智能调整，确保 Dock 不会遮挡重要的桌面内容或窗口。\n\n滑动动画：MacDock 的交互体验以流畅为目标。无论是显示或隐藏 Dock，还是在切换应用程序时，都会触发平滑的滑动动画。用户在与 Dock 进行交互时，动画能增强视觉上的愉悦感，使整个过程更为自然。通过 QPropertyAnimation 实现的滑动动画，确保 Dock 在打开和关闭时没有卡顿感。\n\n启动应用：MacDock 中的每个图标代表一个应用程序，用户可以直接点击图标来启动相应的程序。每个图标都与系统中的应用程序快捷方式相关联，点击图标会调用系统的 API 来执行启动命令。这使得 MacDock 成为了一个方便、直观的应用启动平台，减少了用户查找和打开应用程序的时间。\n\n删除应用：用户可以通过简单的交互来删除 Dock 中的应用图标。该功能设计非常直观，用户只需点击并删除图标，即可将不需要的应用从 Dock 中移除。而且，这一操作只会影响 Dock，不会影响应用程序本身的运行或安装状态。\n\n\n\n界面展示MacDock 提供了灵活的布局选项，用户可以在屏幕的四个边缘摆放 Dock，适应不同的桌面布局习惯。以下是一些界面展示：\n\n底部吸附显示：\n\n左侧吸附显示：\n\n顶部吸附显示：\n\n右侧吸附显示：\n\n功能菜单：\n\n\n\n技术实现1. QtWidgets 开发MacDock 通过 QtWidgets 实现了强大的用户界面，提供跨平台支持，并在多个操作系统中保持一致的用户体验。QtWidgets 作为 Qt 框架的核心组件之一，专门用于开发桌面应用程序，具备高度的灵活性和丰富的 UI 控件，确保界面交互流畅且功能强大。\n2. 吸附功能实现吸附功能的实现通过监控窗口在桌面上的位置，并根据窗口与屏幕边缘的距离来调整窗口的位置。在 MacDock 中，通过不断检查窗口的边缘位置，来决定窗口是否吸附到最近的屏幕边缘。这项功能不仅提升了用户体验，也确保了应用窗口不会随意漂浮在桌面上，能够与屏幕更好地融合。\n3. 滑动动画滑动动画的实现通过 QPropertyAnimation，这是 Qt 提供的动画类，能够对窗口属性（如位置、大小等）进行动画处理。MacDock 在显示和隐藏时，触发了与窗口位置相关的动画，确保动画的顺滑度和响应速度。滑动动画的属性可以根据用户需求进行定制，例如动画持续时间、动画曲线等，以提供更灵活的视觉效果。\n4. 应用管理应用管理是 MacDock 的核心功能之一，借助系统 API，MacDock 可以启动、删除和管理应用程序。通过与系统交互，MacDock 能够快速启动指定的应用，且用户可以通过拖放的方式轻松添加或移除应用图标，极大提升了操作便捷性。\n\n代码实现与详细注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class MacDock : public QWidget&#123;    Q_OBJECT    // 使用 Q_PROPERTY 声明属性 enterChange 和 moucePos，支持动画效果    Q_PROPERTY(qreal enterChange READ enterChange WRITE setEnterChange)    Q_PROPERTY(QPoint moucePos READ getMoucePos WRITE setMoucePos)public:    // 枚举 Direction 表示 Dock 方向：上下左右    enum Direction &#123; Up, Down, Left, Right &#125;;    explicit MacDock(QWidget *parent = nullptr);    // 显示 Dock    void show();    // 初始化 Dock，设置默认布局和按钮    void init();    // 添加新按钮（程序图标），包括启动命令和提示    void addButton(const QString &amp;program, const QStringList &amp;arguments, const QString&amp; tip);    // 在特定位置插入新按钮    void insertButton(const int &amp;index, const QString &amp;program, const QStringList &amp;arguments, const QString&amp; tip);    // 从 Dock 中移除按钮    void removeButton(const QString &amp;program);    // 获取和设置进入动画的进度（用于滑动动画）    qreal enterChange() const;    void setEnterChange(const qreal &amp;enterChange);    // 获取和设置 Dock 的方向    Qt::Alignment alignment() const;    Direction direction() const;    void setDirection(const Direction &amp;direction);    // 判断当前 Dock 方向是否为水平    inline bool isHorizontal() &#123; return Up == m_direction || Down == m_direction;&#125;    // 获取和设置鼠标位置（用于拖动和吸附功能）    QPoint getMoucePos() const;    void setMoucePos(const QPoint &amp;moucePos);protected:    // 绘制 Dock 界面    void paintEvent(QPaintEvent *event);    // 鼠标移动事件，用于拖动 Dock    void mouseMoveEvent(QMouseEvent *event);    // 鼠标释放事件，用于完成 Dock 的位置调整    void mouseReleaseEvent(QMouseEvent *event);    // 进入和离开 Dock 的事件，触发显示和隐藏动画    void enterEvent(QEvent *);    void leaveEvent(QEvent *);    // 实现拖放功能    void dragEnterEvent(QDragEnterEvent *event);    void dragMoveEvent(QDragMoveEvent *event);    void dropEvent(QDropEvent *event);    void dragLeaveEvent(QDragLeaveEvent *event);    // 清理布局    void clearLayout(QLayout *pMainLayout);    // 更新几何布局，调整 Dock 大小和位置    virtual void updateGeometry() = 0;    // 更新 Dock 布局    virtual void updateLayout() = 0;    // 获取 Dock 区域，用于吸附显示    virtual QRect getDockArea() = 0;    // 启动动画（可扩展为自定义动画）    virtual void startUpAnimation() &#123;&#125;protected slots:    // 槽函数：添加、移除、插入和替换按钮    void add();    void remove();    void insert(int index, const QString &amp;program);    void replace();    void position(Qt::Alignment alignment);protected:    QList&lt;AniButton*&gt; m_listBtns;              // 按钮列表    QList&lt;AniButtonInfo&gt; m_listBtnsInfo;       // 按钮信息列表    QMap&lt;int, QLabel*&gt; m_mapSpace;             // 空白区域映射    bool m_bFirstEnter;                        // 标记是否为首次进入    QPoint m_moucePos;                         // 当前鼠标位置    qreal m_enterChange;                       // 进入动画进度    QPropertyAnimation *m_enterAnimation;      // 动画属性类    Direction m_direction;                     // Dock 的方向    bool m_init;                               // 是否已经初始化    QParallelAnimationGroup *m_startAnimationGroup; // 启动动画组    QPropertyAnimation *m_startAnimation;      // 启动动画    bool m_inAdding;                           // 标记是否处于添加状态    QBoxLayout *m_layoutDock;                  // Dock 布局    int m_indexDrag;                           // 拖动的按钮索引&#125;;\n\n\n总结MacDock 是一款基于 QtWidget 的轻量级桌面工具条，具备吸附显示、平滑动画、应用程序管理等功能。其设计简单易用，用户可以根据自己的需求自定义应用程序图标和布局，同时通过流畅的交互动画提升整体用户体验。通过 Qt 的强大功能和跨平台支持，MacDock 可以在不同的操作系统上提供一致的体验，适用于各种桌面环境。\n","slug":"mackdock介绍","date":"2024-11-11T07:15:45.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"63c8a92f74a53e2268681abcf94a416e","title":"Qt WebAssembly 初体验","content":"标题：Qt WebAssembly 初体验：开启Web开发新纪元\n在近年来，Web开发领域经历了巨大的变革。随着WebAssembly技术的出现，我们能够以前所未有的方式将高性能应用程序带到Web浏览器中。而在这个过程中，Qt WebAssembly发挥了重要作用。本文将分享我对Qt WebAssembly的初体验，并探讨它如何改变Web开发的游戏规则。\n什么是Qt WebAssembly？Qt WebAssembly是一个基于Qt框架和WebAssembly技术的开发工具包。它允许开发者使用熟悉的C++语言和Qt框架编写Web应用程序，然后将其编译成WebAssembly字节码，直接在Web浏览器中运行。这意味着我们可以利用Qt的强大功能和高效性能，开发出与原生应用媲美的Web应用。\n开始Qt WebAssembly之旅为了体验Qt WebAssembly的魅力，我首先安装了Emscripten和Qt for WebAssembly的开发环境。安装过程相对简单，只需按照官方文档的指引进行操作即可。一旦环境准备就绪，我们就可以使用Qt Creator或命令行工具开始编写代码。\n编写Qt WebAssembly应用我选择了编写一个简单的图形应用程序作为初体验的项目。通过使用Qt的丰富控件和布局管理器，我轻松地创建了一个用户界面。在编写过程中，我发现Qt WebAssembly的开发体验与原生Qt开发非常相似，这使得我能够快速上手并专注于实现功能。\n编译与部署编写完代码后，我使用Emscripten工具链将应用程序编译成WebAssembly字节码。这个过程可能需要一些时间，但一旦完成，我们就可以将生成的文件部署到Web服务器上。在浏览器中访问应用程序时，Qt WebAssembly运行时将加载并执行编译后的字节码，带来流畅且高性能的用户体验。\n初体验总结通过对Qt WebAssembly的初体验，我深刻感受到了它对Web开发的巨大潜力。它结合了Qt框架的强大功能和WebAssembly的高性能特性，使得我们能够以全新的方式开发Web应用程序。这种技术的出现，不仅降低了Web开发的门槛，还使得我们能够开发出更高性能和更丰富的应用程序。\n然而，作为一项新技术，Qt WebAssembly目前仍处于不断发展和完善的阶段。未来，随着更多的开发者和公司的加入，我们有理由相信它将为Web开发领域带来更多的创新和突破。对于我们这些热爱技术的人来说，这无疑是一个令人期待的时刻。\n示例项目你可以访问我们的网站：示例demo\n","slug":"Qt/进阶教程/Qt WebAssembly 初体验","date":"2023-10-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"78d706026c7ad286c335846453427351","title":"FFmpeg初体验","content":"\n","slug":"FFmpeg/FFmpeg初体验","date":"2023-09-20T05:35:00.000Z","categories_index":"FFmpeg","tags_index":"C++,FFmpeg","author_index":"阿木大叔"},{"id":"85d75116aefe90c7e26f6d4e2c2f9e5c","title":"Qt UI组件库","content":"HUI📚简介本项目旨在利用Qt实现多个基础UI控件，确保它们具有统一的风格，并通过样式统一管理，以提升用户界面的一致性和美观度。Qt框架是一个功能强大且跨平台的工具集，可以轻松构建各种界面元素和交互效果。通过此项目，我们将开发出易于使用且高度可定制的UI控件，包括按钮、文本框、下拉框等，确保它们在不同的应用场景中都能表现出一致的外观和行为。同时，通过样式统一管理，我们能够更加灵活地对UI控件进行主题切换和样式调整，以适应不同的需求和设计要求。这将大大简化开发流程，提高开发效率，同时为用户提供更加一致和优化的界面体验。\n该项目的目标不仅仅是实现基础UI控件的统一风格，还包括提供丰富的功能和交互效果，以增强用户界面的吸引力和可用性。使用Qt框架的优势在于其跨平台特性，使得开发人员能够轻松地将应用程序移植到不同的操作系统设计和开发按钮样式，文本框交互，下拉框选保这些控件在各种场景中都能呈现出一致的外观和行为，并满足用户的期望和需求。\n此外，通过样式统一管理，我们能够更加简便地修改和调整UI控件的外观，无需逐个操作每个控件，从而大大节省了开发时间和精力。我们将制定一套清晰的样式规范和维护方法，使得开发团队可以轻松地管理和更新UI风格，同时确保与整体设计的一致性。\n这个项目的结果将意味着更高效的开发流程和更短的上线时间，开发人员可以专注于业务逻辑的实现，而无需花费过多时间处理UI方面的问题。对于最终用户来说，他们将获得一个功能完善、美观且易于使用的界面，无论他们是在桌面、移动设备还是其他平台上使用应用程序，都能享受到一致和优化的用户体验。\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上都支持\n\n🗺️软件截图按钮\n输入框\n下拉框\n表格\n菜单\n标准对话框\n提示对话框\n确认对话框\n等待框\n侧边抽屉\n顶部提示\n滑块进度条\n轮播图\n评分控件q\n气泡确认框\n选择框\n数字输入框\n全局通知\n日期选择器\n水波进度条\n折叠面板\n悬浮按钮\n导航栏\n通用主窗口\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/UI组件库","date":"2023-06-20T08:40:04.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"4dc19acbc442d3c601963ca4bb14ef60","title":"QPainter：Qt图形渲染引擎","content":"QPainter：Qt图形渲染引擎Qt 是一种跨平台的 C++ 应用程序框架，拥有丰富而强大的绘图功能。在 Qt 中，用于绘制图形和文本的主要类是 QPainter。QPainter 是一种基于扫描线的图形渲染引擎，可绘制线条、多边形、图像和文字等。\n在本章中，我们将学习如何使用 QPainter 类进行绘图，在此之前，您需要了解以下内容：\n\nC++ 的基本语法和面向对象编程\nQt 的基本组件和 API\nQt 信号和的机制\n\nQPainter 类概述QPainter 是 Qt 的核心绘图类之一，提供了各种方法来画出各种图形和文本。QPainter 类通过与特定设备的 QPainterDevice 对象交互，将二维图形呈现到窗口之上。\nQPainter 可以与 QWidget 或其他显示设备（如 QImage 或 QPrinter）配合使用，因此您可以在屏幕上轻松地呈现复杂的几何图形和文本。\nQPainter 的高效性可能会产生混淆，尤其是对新手，但实际上 QPainter 使用了优化的算法，能够快速渲染大部分类型的图形和文本数据。此外，QPainter 还实现了双缓冲技术。\nQPainter 还提供了丰富的 API 来轻松实现以下操作：\n\n绘制基本的几何形状，如线段，多边形和椭圆。\n填充矩形，多边形和复杂路径。\n绘制文本并根据需要进行布局。\n绘制图像和像素数据。\n变换和移动绘图对象。\n\n让我们开始学习 QPainter 的使用吧！\nQPainter 绘画设备QPainter 与不同的 QPainterDevice 类交互（例如窗口、pixmap、printer 等），通过 QPainterDevice 的 begin() 和 end() 方法以及 QPaintDeviceMetrics 来控制绘画设备。\n在下面的代码片段中，我们看到当生成 QImage （图像）并将其用作 QPainterDevice 时，就使用 QPainter 在其上绘制图片：\n1234567891011121314QImage image(400, 400, QImage::Format_RGB32); QPainter painter(&amp;image); // 创建一个绘制器并将它与 Image 关联起来 painter.fillRect(image.rect(), Qt::white); // 填充矩形背景为白色 QPen pen(Qt::green, 4, Qt::DashLine, Qt::RoundCap, Qt::RoundJoin);painter.setPen(pen); painter.drawLine(50, 250, 200, 100);  // 绘制直线painter.drawRect(150, 150, 50, 50);  // 绘制矩形painter.drawEllipse(250, 50, 100, 150);  // 绘制椭圆 painter.end();    // 和上面一样，必须要调用 end() 结束绘画\n\n将 QImage 作为 QPainterDevice 可以实现离屏渲染，以便在窗口或打印机外绘图，并保存到文件中。下面是一个将 QImage 写入文件的例子：\n1image.save(&quot;example.jpg&quot;, &quot;JPG&quot;);\n\n除 QImage 外，还可以使用 QWidget（或派生类）作为 QPainterDevice，这种情况下 QPainter 将自动在窗口上绘制。请注意，在绘制 QWidget 上的内容之前，您需要首先在QWidget 上选择 QPainter。\n以 QWidget 作为 QPainterDevice 的示例代码：\n123456789101112void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);     painter.fillRect(rect(), Qt::white);     QPen pen(Qt::blue, 3);    painter.setPen(pen);     painter.drawLine(0, 0,(), height());    painter.drawLine(width(), 0, 0, height());&#125;\n\n绘制几何形状QPainter 提供了各种方法来绘制基本的几何形状，例如线段、矩形、圆和椭圆。当使用 QPainter 时，首先需要设置图形属性，刷和颜色。\n画笔和画刷尽管你可以为每个几何形状设置自己的颜色和笔刷，但很多时候，这些属性会适用于在 QPainter 上绘制的所有几何形状。QPainter 使用 QPen 和 QBrush 类来管理这些属性。\nQPen 定义划，可以定义颜色、宽度、样式、线端点以及角的类型。创建 QPen 对象时，需要指定颜色和线宽，其他选项也可以通过设置不同的属性来调整。\nQBrush 定义了一个图案或颜色填充，可以定义颜色、渐变和纹理等。在创建 QBrush 对象时，可以为其传递 QColor 对象（如果要填充一种颜色），也可以使用 QGradient （如 QLinearGradient 或 QRadialGradient）来创建渐变效果。\n现在让我们看看如何绘制几何形状。下面是绘制三角形和梯形的例子：\n1234567891011121314151617181920212223242526void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);     QLinearGradient gradient(0, 0, width(), height());    // 渐变色填充    gradient.setColorAt(0, Qt::red);    gradient.setColorAt(0.5, Qt::green);    gradient.setColorAt(1, Qt::blue);    QBrush brush(gradient);     // 带有渐变色的画刷    painter.setBrush(brush);   // 设置画刷    painter.setPen(Qt::black); // 设置铅笔颜色     // 绘制三角形    QPolygonF triangle;    triangle &lt;&lt; QPointF(0, 0) &lt;&lt; QPointF(width(), 0) &lt;&lt; QPointF(0, height());    painter.drawPolygon(triangle);     // 绘制梯形    QPolygonF trapezoid;    trapezoid &lt;&lt; QPointF(0, 0) &lt;&lt; QPointF(width(), 0) &lt;&lt; QPointF(width() - 50, height()) &lt;&lt; QPointF(50, height());    painter.drawPolygon(trapezoid);&#125;\n\n在上面的例子中，我们使用 QPolygonF 来定义三角形和梯形的顶点。然后，我们将其传递到 QPainter 的 drawPolygon 函数中进行绘制。\n值得注意的是，在定义 QPolygonF 对象时，需要指定所有的点坐标。这些坐标是以局部坐标系为参考的。\n矩形和圆形QPainter 还提供了其他一些常见图形的绘制方法，如矩形和圆形。下面是一个简单的例子，它使用 QPen 和 QBrush 分别设置矩形和圆形的外观：\n123456789101112131415161718void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);     QPen pen(Qt::black, 2, Qt::SolidLine);   // 定义铅笔    painter.setPen(pen);                     // 设置铅笔     Q::blue, Qt::Dense4Pattern);// 定义画刷    painter.setBrush(brush);                 // 设置画刷     // 绘制矩形    QRectF rect(10, 10, 100, 50);           // 定义矩形区域    painter.drawRect(rect);                 // 绘制矩形     // 绘制圆    QRectF circle(150, 10, 50, 50);          // 定义圆形的外接矩形    painter.drawEllipse(circle);             // 绘制圆形&#125;\n\n在上面的例子中，我们使用 QRectF 来指定矩形和圆形的位置和尺寸。我们还将 QPen、QBrush 和 QRectF 对象作为参数传递给 QPainter 类的绘制函数。\n绘制文本QPainter 还提供了一种绘制文本的方法。使用 drawText 函数来完成此操作。您需要指定字符串，以及位于字符串底部水平对齐和垂直对齐的坐标。如果需要更大的控制，可以使用 drawStaticText。\n下面的代码演示如何向窗口中绘制文本：\n1234567891011121314void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);     QFont font;    font.setPointSize(24);    font.setBold(true);    painter.setFont(font);     QString text = &quot;Hello, world!&quot;;    QRect rect = painter.boundingRect(0, 0, width(), height(), Qt::AlignCenter, text);     painter.drawText(rect, text, Qt::AlignCenter);&#125;\n\n在上面的代码中，我们首先创建 QFont 对象来设置字体的大小和粗细程度。然后，我们创建一个字符串，并获取其引起的矩形对象。最后，我们使用 QRect 和 QString 参数调用 drawText 函数来在窗口上显示字符串。\n如果您没有指定对齐方式，则文字将位于 Painter 指定的矩形左上角。\n性能QPainter 是一个功能强大的绘图工具，可以用于呈现任意形状、文本和图像。由于其灵活性和高度优化的算法，它也被广泛用于绘制实时图形。\n但是，由于绘制复杂几何形状和使用大量的纹理或网格会影响绘制性能，QPainter 在某些情况下可能并不是最好的选择。在这种情况下，可能需要使用专门的图形库，比如 OpenGL 或 Vulkan。\n另外，为了获得更好的性能，建议您在使用 QPainter 时遵循以下准则：\n\n避免每次调用 paintEvent 函数时重新创建 QPen 和 QBrush 对象。尽可能复用先前创建的对象。\n使用 QPixmap 而不是 QImage，在窗口中绘制简单的图形时。因为 QPixmap 通常比 QImage 更高效地呈现到屏幕上。\n避免在 paintEvent 中进行过多的计算（例如计算多边形路径或生成渐变）。如果必须要进行复杂的计算，请将预先计算的结果存储在成员变量或全局变量中，并在需要时重用它们。\n\n在 Qt 中，使用 QPainter 绘图是非常常见的操作。如果您了解 QPainter 的 API 并按照最佳实践使用它，那么将可以轻松地创建复杂的图形和文本布局，并以高效的方式呈现到屏幕上。## QPainter 与 Qt 组件\n在 Qt 应用程序中，除了直接绘制到窗口上之外，您还可以将 QPainter 用于 Qt 组件的绘制（例如 QPushButton、QLabel 和 QGraphicsScene 等）。\n通过继承 QWidget 和实现 paintEvent 函数来进行绘制是一种常见的方法。如果您使用的是更高级别的组件，则可能需要重写更具体的绘制函数（例如 QStylePainter::drawControl 和 QStyle::drawPrimitive）来控制组件的呈现。\n下面是一个简单的例子，演示如何在 QWidget 上绘制一个文本字符串：\n1234567891011121314void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);     QFont font;    font.setPointSize(24);    font.setBold(true);    painter.setFont(font);     QString text = &quot;Hello, world!&quot;;    QRect rect = painter.boundingRect(0, 0, width(), height(), Qt::AlignCenter, text);     painter.drawText(rect, text, Qt::AlignCenter);&#125;\n\n在上面的代码中，我们将 QPainter 直接传递给 QWidget 实例，并且在 paintEvent 函数中绘制文本。\n在更高级别的 Qt 组件中，您通常需要使用 QStylePainter 或 QPainterPath 类来控制组件的样式和几何形状。以下是一个示例，演示如何使用 QStylePainter 来自定义 QPushButton 的外观：\n1234567void MyButton::paintEvent(QPaintEvent *event)&#123;    QStylePainter painter(this);     QStyleOptionButton option;    painter.drawControl(QStyle::CE_PushButton, option);&#125;\n\n在上面的代码中，我们定义了一个自定义 QPushButton 子类，然后在 paintEvent 函数中使用 QStylePainter 进行绘制。QStyleOptionButton 对象用于指定按钮的状态和文本，然后调用 QStylePainter 的 drawControl 函数来绘制按钮。\n总结在 Qt 中，QPainter 是一种强大的图形绘制工具，可用于将几何形状、文本和图像呈现到窗口或 Qt 组件中。您可以通过设置属性（如铅笔宽度、画刷颜色和字体）来控制绘制过程，并使用 QPainterPath 类型来创建复杂的形状。\n为了获得最佳性能，请注意遵循最佳实践，并使用优化过的算法来计算和绘制形状。如果您更高级别的绘图功能，则可以考虑使用 OpenGL 或 Vulkan 等专业库来进行绘图。除了本文所述的基本功能之外，QPainter 还具有另外许多高级功能。\n例如，QPainter 还支持裁剪功能，可以通过 QPainter::setClipRect() 或 QPainter::setClipPath() 函数将绘制区域限制为一个矩形或 Qt 路径。这对于在不同部分绘制颜色和图案时非常有用，避免了渲染到整个窗口的需要。\nQPainter 还支持在图形上应用变换，包括旋转、缩放和移动，这可以使用 QTransform 对象完成。您可以使用 QPainter::setWorldTransform() 函数将变换应用于 QPainter，并使用 QPainter::resetTransform() 函数将其重置回默认状态。\n如果您需要在图形上应用混合效果，QPainter 也提供了支持。您可以使用 QPainter::setCompositionMode() 函数将绘制操作与现有画布内容组合，以产生透明效果，或者使用其他混合模式实现各种效果。\n最后但并非最不重要的是，Qt 文档中还有大量额外的示例、教程和解释，深入探索 QPainter 的使用方法。无论您是新手还是有经验的 Qt 开发人员，都可以从中获益。\n希望本文对您加深对 QPainter 的理解，并帮助您更好地使用它进行图形绘制！\n","slug":"Qt/进阶教程/QPainter：Qt图形渲染引擎","date":"2023-06-13T03:12:58.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"93c9bfd646dfd76fb6a48df45545ae28","title":"Qt实现多内核播放器","content":"MusicPlayer📚简介本项目为Qt实现一款小巧轻便的视频播放器，集成vlc，ffmpeg，mpv三种解码内核，一键切换解码模式，支持4k，GPU加速等\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上msvc编译器都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\nQPainter\n部分窗口的绘制，例如实时天气界面\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\nffmpeg\n音视频解码\n\n\nmpv\n音视频解码\n\n\nvlc\n音视频解码\n\n\n🗺️软件截图\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现多内核播放器","date":"2023-06-05T02:54:54.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"fbaaa363297ea0ad24d687796af4340f","title":"HTTPS工作原理","content":"HTTPS工作原理HTTPS（HyperText Transfer Protocol Secure）是一种基于SSL&#x2F;TLS协议的安全加密通信协议，用于保证网络通信的安全性和完整性。本文将详细介绍HTTPS的工作原理，并使用mermaid语法绘制交互时序图。\nHTTPS协议交互过程HTTPS通信协议的交互流程如下：\n\n客户端发送连接请求。\n\n服务器发送数字证书给客户端。\n\n客户端验证数字证书的合法性。\n\n客户端生成对称加密密钥，并使用服务器的公钥进行加密后发送给服务器。\n\n服务器使用私钥解密对称加密密钥，并使用该密钥对随后的通信数据进行加密。\n\n双方开始安全通信，使用对称加密技术对通信数据进行加密和解密，以保证数据的机密性和完整性。\n\n\n下面将通过mermaid语法绘制交互时序图，进一步解释HTTPS通信协议交互过程。\n时序图12345678910111213sequenceDiagram    participant Client    participant Server    Note over Client,Server: SSL握手阶段    Client-&gt;&gt;Server: 请求连接    Server-&gt;&gt;Client: 发送数字证书    Client-&gt;&gt;Server: 验证数字证书的合法性    Client-&gt;&gt;+Server: 发送对称加密密钥    Server-&gt;&gt;-Client: 使用私钥解密对称加密密钥    Note over Client,Server: 安全通信阶段    Client-&gt;&gt;Server: 加密数据    Server-&gt;&gt;Client: 解密数据\n\n以上的时序图中，第一部分展示了HTTPS握手阶段，客户端请求连接并验证服务器发送的数字证书的合法性。在第二部分中，双方使用对称加密密钥进行安全通信，其中客户端负责加密数据，服务器则负责解密数据。\n结论HTTPS协议是一种基于SSL&#x2F;TLS协议的加密通信协议，其工作原理包括握手阶段和安全通信阶段。在握手阶段中，客户端与服务器之间通过数字证书交换公钥，并生成对称加密密钥。在安全通信阶段中，双方使用对称加密密钥对通信数据进行加密和解密。\n虽然HTTPS协议可以提供相对较高的安全级别，但仍存在着某些安全风险，如数字证书泄露、密码学算法弱化等问题。因此，在实际应用中，需要采取适当的措施来完善安全机制，以确保通信的安全性和可靠性。\n总结HTTPS是一种基于SSL&#x2F;TLS协议的加密通信协议，用于保证网络通信的安全性和完整性。HTTPS的工作原理如下：\n\n客户端发起HTTPS请求\n\n客户端使用HTTPS请求连接服务器时，会发送一个HTTPS请求给服务器。\n\n服务器提供SSL证书\n\n服务器收到HTTPS请求后，会向客户端发送其数字证书，其中包含了服务器公钥、证书颁发机构、服务器名称等信息。\n\n客户端验证证书\n\n客户端接收到服务器的数字证书后，会进行以下步骤来验证证书的合法性：\n\n验证证书是否由受信任的证书颁发机构签名。\n验证服务器名称与证书是否匹配。\n验证证书是否已过期。\n\n如果证书验证成功，则客户端可以开始使用证书中包含的公钥和服务器进行安全通信。\n\n建立安全连接\n\n客户端使用服务器的公钥对随机生成的对称加密密钥进行加密，并将其发送给服务器。服务器使用私钥解密该密钥，并使用该密钥对通信数据进行加密。\n此时客户端和服务器之间就建立了一个安全的加密通道，可以通过该通道进行安全的数据传输。\n\n安全通信\n\n一旦安全连接建立，客户端和服务器就可以使用对称加密技术对通信数据进行加密和解密，以保证数据的机密性和完整性。在通信过程中，客户端和服务器还可以使用摘要算法对消息进行验证，从而保证数据的真实性和完整性。\n需要注意的是，HTTPS协议是基于SSL或TLS协议的，因此它具有与这些协议相同的缺点和安全问题。例如，如果数字证书被篡改或伪造，则会导致通信的不安全性；如果密码学算法弱化或密钥管理不当，则也可能会导致加密数据泄露。因此，在使用HTTPS时，必须采取适当的安全措施来确保通信的安全性和可靠性。\n","slug":"其他/HTTPS工作原理","date":"2023-05-23T05:29:48.000Z","categories_index":"其他教程","tags_index":"https","author_index":"阿木大叔"},{"id":"5ad5ce4ee7b2f8c117390804baa8feb4","title":"OpenSSL库实现AES加解密算法","content":"下面是使用OpenSSL库进行AES-128-CBC加密和解密，支持PKCS7Padding、PKCS5Padding、ZEROPadding三种填充方式的示例代码。在实现中，我们使用了EVP接口和CryptoPP库。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;openssl/evp.h&gt;#include &lt;crypto++/modes.h&gt;#include &lt;crypto++/aes.h&gt;#define AES_BLOCK_SIZE 16// PKCS7Padding填充方式bool pkcs7_padding(unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len)&#123;    size_t padded_len = AES_BLOCK_SIZE - (in_len % AES_BLOCK_SIZE);    out_len = in_len + padded_len;    memcpy(out, in, in_len);    for (size_t i = in_len; i &lt; out_len; ++i) &#123;        out[i] = padded_len;    &#125;    return true;&#125;size_t pkcs7_unpadding(unsigned char *in, size_t in_len)&#123;    unsigned char padding_byte = in[in_len - 1];    if (padding_byte &gt; AES_BLOCK_SIZE || padding_byte &gt; in_len) &#123;        return 0;    &#125;    return in_len - padding_byte;&#125;// PKCS5Padding填充方式bool pkcs5_padding(unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len)&#123;    size_t padded_len = (in_len / AES_BLOCK_SIZE + 1) * AES_BLOCK_SIZE;    size_t padding_len = padded_len - in_len;    unsigned char padding_byte = (unsigned char)padding_len;    memcpy(out, in, in_len);    for (size_t i = in_len; i &lt; padded_len; ++i) &#123;        out[i] = padding_byte;    &#125;    out_len = padded_len;    return true;&#125;size_t pkcs5_unpadding(unsigned char *in, size_t in_len)&#123;    size_t unpadded_len = in_len;    unsigned char padding_byte = in[in_len - 1];    if (padding_byte &gt; AES_BLOCK_SIZE || unpadded_len &lt; padding_byte) &#123;        return 0;    &#125;    unpadded_len -= padding_byte;    return unpadded_len;&#125;// ZEROPadding填充方式bool zero_padding(unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len)&#123;    size_t padded_len = ((in_len / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE;    memcpy(out, in, in_len);    memset(out + in_len, 0, padded_len - in_len);    out_len = padded_len;    return true;&#125;size_t zero_unpadding(unsigned char *in, size_t in_len)&#123;    size_t unpadded_len = in_len;    while (in[unpadded_len - 1] == 0) &#123;        --unpadded_len;    &#125;    return unpadded_len;&#125;// 使用EVP接口进行AES-128-CBC加解密bool aes_encrypt_evp(const unsigned char *key, const unsigned char *iv, const unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len, int padding_mode)&#123;    EVP_CIPHER_CTX *ctx = NULL;    int len, outlen;    bool ret = false;    if (!(ctx = EVP_CIPHER_CTX_new())) &#123;        return false;    &#125;    const EVP_CIPHER *cipher;    switch (padding_mode) &#123;        case 0:            cipher = EVP_aes_128_cbc();            break;        case 1:            cipher = EVP_aes_128_cbc();            break;        case 2:            cipher = EVP_aes_128_cbc();            break;        default:            goto clean_up;    &#125;    if (EVP_EncryptInit_ex(ctx, cipher, NULL, key, iv) != 1) &#123;        goto clean_up;    &#125;    unsigned char *padded_in = new unsigned char[in_len + AES_BLOCK_SIZE];    switch (padding_mode) &#123;        case 0:            memcpy(padded_in, in, in_len);            out_len = in_len;            break;        case 1:            pkcs5_padding(in, in_len, padded_in, out_len);            break;        case 2:            zero_padding(in, in_len, padded_in, out_len);            break;        default:            goto clean_up;    &#125;    if (EVP_EncryptUpdate(ctx, out, &amp;len, padded_in, out_len) != 1) &#123;        goto clean_up;    &#125;    outlen = len;    if (EVP_EncryptFinal_ex(ctx, out + len, &amp;len) != 1) &#123;        goto clean_up;    &#125;    outlen += len;    out_len = outlen;    ret = true;clean_up:    EVP_CIPHER_CTX_free(ctx);    delete[] padded_in;    return ret;&#125;bool aes_decrypt_evp(const unsigned char *key, const unsigned char *iv, const unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len, int padding_mode)&#123;    EVP_CIPHER_CTX *ctx = NULL;    int len, outlen;    bool ret = false;    if (!(ctx = EVP_CIPHER_CTX_new())) &#123;        return false;    &#125;    const EVP_CIPHER *cipher;    switch (padding_mode) &#123;        case 0:            cipher = EVP_aes_128_cbc();            break;        case 1:            cipher = EVP_aes_128_cbc();            break;        case 2:            cipher = EVP_aes_128_cbc();            break;        default:            goto clean_up;    &#125;    if (EVP_DecryptInit_ex(ctx, cipher, NULL, key, iv) != 1) &#123;        goto clean_up;    &#125;    if (EVP_DecryptUpdate(ctx, out, &amp;len, in, in_len) != 1) &#123;        goto clean_up;    &#125;    outlen = len;    if (EVP_DecryptFinal_ex(ctx, out + len, &amp;len) != 1) &#123;        goto clean_up;    &#125;    outlen += len;    unsigned char *unpadded_out = new unsigned char[outlen];    switch (padding_mode) &#123;        case 0:            out_len = outlen;            break;        case 1:            out_len = pkcs5_unpadding(out, outlen);            break;        case 2:            out_len = zero_unpadding(out, outlen);            break;        default:            goto clean_up;    &#125;    if (out_len == 0) &#123;        delete[] unpadded_out;        ret = false;        goto clean_up;    &#125;    memcpy(unpadded_out, out, out_len);    memcpy(out, unpadded_out, out_len);    out_len = outlen;    ret = true;clean_up:    EVP_CIPHER_CTX_free(ctx);    delete[] unpadded_out;    return ret;&#125;// 使用CryptoPP库进行AES-128-CBC加解密bool aes_encrypt_cryptopp(const unsigned char *key, const unsigned char *iv, const unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len, int padding_mode)&#123;    CryptoPP::AES::Encryption aes(key, AES_BLOCK_SIZE);    std::string cipher;    switch (padding_mode) &#123;        case 0:            CryptoPP::CBC_Mode_ExternalCipher::Encryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(cipher));            filter.Put(in, in_len);            filter.MessageEnd();            break;        case 1:            CryptoPP::PKCS_PADDING::Pad(padded_in, in, in_len, in_len + AES_BLOCK_SIZE);            CryptoPP::CBC_Mode_ExternalCipher::Encryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(cipher));            filter.Put(padded_in, in_len + AES_BLOCK_SIZE);            filter.MessageEnd();            break;        case 2:            CryptoPP::ZeroPadding().Pad(in, in_len, in_len + AES_BLOCK_SIZE);            CryptoPP::CBC_Mode_ExternalCipher::Encryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(cipher));            filter.Put(in, in_len + AES_BLOCK_SIZE);            filter.MessageEnd();            break;        default:            return false;    &#125;    out_len = cipher.size();    memcpy(out, cipher.data(), out_len);    return true;&#125;bool aes_decrypt_cryptopp(const unsigned char *key, const unsigned char *iv, const unsigned char *in, size_t in_len, unsigned char *out, size_t &amp;out_len, int padding_mode)&#123;    if (in_len % AES_BLOCK_SIZE != 0) &#123;        return false;    &#125;    CryptoPP::AES::Decryption aes(key, AES_BLOCK_SIZE);    std::string plain;    switch (padding_mode) &#123;        case 0:            CryptoPP::CBC_Mode_ExternalCipher::Decryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(plain));            filter.Put(in, in_len);            filter.MessageEnd();            break;        case 1:            CryptoPP::CBC_Mode_ExternalCipher::Decryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(plain));            filter.Put(in, in_len);            filter.MessageEnd();            CryptoPP::PKCS_PADDING::Unpad(out, plain.data(), plain.size());            out_len = plain.size();            break;        case 2:            CryptoPP::CBC_Mode_ExternalCipher::Decryption cbc(aes, iv);            CryptoPP::StreamTransformationFilter filter(cbc, new CryptoPP::StringSink(plain));            filter.Put(in, in_len);            filter.MessageEnd();            CryptoPP::ZeroPadding().Unpad(out, plain.data(), plain.size());            out_len = plain.size();            break;        default:            return false;    &#125;    return true;&#125;int main()&#123;    const unsigned char key[] = &quot;0123456789abcdef&quot;;    const unsigned char iv[] = &quot;0123456789abcdef&quot;;    unsigned char in[128] = &#123;0&#125;;    unsigned char out[256] = &#123;0&#125;;    size_t outlen = 0;    // 测试PKCS7Padding填充方式    std::cout &lt;&lt; &quot;使用PKCS7Padding填充方式进行加解密&quot; &lt;&lt; std::endl;    strcpy((char *)in, &quot;hello world&quot;);    aes_encrypt_evp(key, iv, in, strlen((char *)in), out, outlen, 1);    std::cout &lt;&lt; &quot;加密后的结果为：&quot; &lt;&lt; std::endl;    for (size_t i = 0; i &lt; outlen; ++i) &#123;        printf(&quot;%02x &quot;, out[i]);    &#125;    std::cout &lt;&lt; std::endl;    memset(in, 0, sizeof(in));    aes_decrypt_evp(key, iv, out, outlen, in, outlen, 1);    std::cout &lt;&lt; &quot;解密后的结果为：&quot; &lt;&lt; (char *)in &lt;&lt; std::endl;    // 测试PKCS5Padding填充方式    std::cout &lt;&lt; &quot;使用PKCS5Padding填充方式进行加解密&quot; &lt;&lt; std::endl;    strcpy((char *)in, &quot;hello world&quot;);    aes_encrypt_evp(key, iv, in, strlen((char *)in), out, outlen, 2);    std::cout &lt;&lt; &quot;加密后的结果为：&quot; &lt;&lt; std::endl;    for (size_t i = 0; i &lt; outlen; ++i) &#123;        printf(&quot;%02x &quot;, out[i]);    &#125;    std::cout &lt;&lt; std::endl;    memset(in, 0, sizeof(in));    aes_decrypt_evp(key, iv, out, outlen, in, outlen, 2);    std::cout &lt;&lt; &quot;解密后的结果为：&quot; &lt;&lt; (char *)in &lt;&lt; std::endl;    // 测试ZEROPadding填充方式    std::cout &lt;&lt; &quot;使用ZEROPadding填充方式进行加解密&quot; &lt;&lt; std::endl;    strcpy((char *)in, &quot;hello world&quot;);    aes_encrypt_evp(key, iv, in, strlen((char *)in), out, outlen, 3);    std::cout &lt;&lt; &quot;加密后的结果为：&quot; &lt;&lt; std::endl;    for (size_t i = 0; i &lt; outlen; ++i) &#123;        printf(&quot;%02x &quot;, out[i]);    &#125;    std::cout &lt;&lt; std::endl;    memset(in, 0, sizeof(in));    aes_decrypt_evp(key, iv, out, outlen, in, outlen, 3);    std::cout &lt;&lt; &quot;解密后的结果为：&quot; &lt;&lt; (char *)in &lt;&lt; std::endl;    return 0;&#125;\n\n以上代码中，我们首先定义了三种填充方式的对应函数：pkcs7_padding、pkcs5_padding、zero_padding，以及它们的反向操作函数：pkcs7_unpadding、pkcs5_unpadding、zero_unpadding。接着，我们使用EVP接口和CryptoPP库分别实现了AES-128-CBC加密和解密。在实现过程中，我们根据填充方式的不同，在加密之前对原始数据进行了填充，而在解密之后则进行了反向操作去除填充。最后，我们在main函数中分别测试了这三种填充方式的加解密效果，并打印了结果。这段代码的主要功能是进行AES-128-CBC加解密，支持三种填充方式：PKCS7Padding、PKCS5Padding和ZEROPadding。主函数中对这些填充方式进行了测试，验证了它们的正确性。\n此外，在代码实现中，我们使用了EVP接口和CryptoPP库两种不同的方式进行加解密。在实际应用中，我们可以根据自己的具体需求选择不同的方式。EVP接口是OpenSSL库提供的一个高层次的加密接口，使用简单，但速度相对较慢；而CryptoPP库则是一个开源的密码学库，提供了许多高效的加密算法实现，速度比EVP更快。不过需要注意的是，无论使用哪种方式进行加解密，都应该严格遵循密码学安全的最佳实践。以下是一些建议：\n\n密钥管理：密钥应该定期更换，并且应该在系统中存储和传输时进行加密。密钥应该仅限于授权用户访问。\n填充方式：应该始终使用填充方式对数据进行处理，以避免明文长度泄露信息。常见的填充方式包括PKCS7Padding、PKCS5Padding和ZEROPadding。\n随机性：初始化向量应该具有强随机性，并且不能重复使用。每次使用一个新的随机的初始化向量来保证安全性。\n加密模式：除了ECB模式外，其他加密模式都应该得到优先考虑。CBC、CTR和GCM模式被认为是最安全和最常见的模式。\n\n总之，AES-128-CBC是一种流行的对称加密算法，应用广泛。但是，在使用它进行加解密时必须要注意安全性问题，采取相应的措施来防止攻击。同时也需要注意选择合适的库或者接口，确保程序正确且高效地完成加解密操作。\n","slug":"其他/OpenSSL库实现AES加解密算法","date":"2023-05-23T05:29:48.000Z","categories_index":"其他教程","tags_index":"openssl","author_index":"阿木大叔"},{"id":"47c166aa1551adcab409a420e5d0d7ce","title":"客户端通信安全设计","content":"消息传输方案方案一\n公钥加密，私钥解密\n握手后，采用对称加密1234567891011sequenceDiagram    participant A as 客户端A    participant B as 客户端B    A-&gt;&gt;+B: 发送好友查找广播消息    B-&gt;&gt;+B: 组建本身信息，广播发送出来    B--&gt;&gt;-A: 收到广播消息后，添加到好友列表内    A-&gt;&gt;+B: 建立连接并发送握手消息    B--&gt;&gt;+A: 收到握手消息后，提示用户是否允许聊天    A-&gt;&gt;+B: 发送加密后的随机密码    B--&gt;&gt;-A: 收到密码后，利用私钥解密密码    A-&gt;&gt;B: 使用此密码进行对称加密，进行消息传输\n\n方案二\n两套公钥和私钥\n分别使用对方公钥加密，自身私钥解密123456789101112sequenceDiagram    participant A as 客户端A    participant B as 客户端B    A-&gt;&gt;+B: 发送好友查找广播消息    B-&gt;&gt;+B: 组建本身信息，广播发送出来    B--&gt;&gt;-A: 收到广播消息后，添加到好友列表内    A-&gt;&gt;+B: 连接并发送握手消息    B--&gt;&gt;+A: 收到握手消息后，提示是否允许聊天    B--&gt;&gt;+A: 发送携带公钥的接受消息    A-&gt;&gt;+B: 发送自己的公钥    B--&gt;&gt;-A: 收到公钥后，回复成功消息完成握手仪式    A-&gt;&gt;B: 使用对方公钥进行消息加解密，进行聊天\n\n方案三\n两套公钥和私钥\n分别使用对方公钥加密，自身私钥解密\n每个消息都使用自身私钥对消息的哈希值进程加密签名，从而验证消息的完整性和来源123456789101112131415161718sequenceDiagram    participant A as 客户端A    participant B as 客户端B    A-&gt;&gt;+B: 发送好友查找广播消息    B-&gt;&gt;+B: 组建本身信息，广播发送出来    B--&gt;&gt;-A: 收到广播消息后，添加到好友列表内    A-&gt;&gt;+B: 连接并发送握手消息    B--&gt;&gt;+A: 收到握手消息后，提示是否允许聊天    B--&gt;&gt;+A: 发送携带公钥的接受消息    A-&gt;&gt;+B: 发送自己的公钥    B--&gt;&gt;-A: 收到公钥后，回复成功消息完成握手仪式    A-&gt;&gt;+B: 使用哈希算法对消息进行计算得到散列值M    A-&gt;&gt;+B: 使用私钥将散列值M进行加密得到签名S    A-&gt;&gt;+B: 使用A的公钥将消息加密得到M2    A-&gt;&gt;+B: 将消息M2和签名S发送给B    B--&gt;&gt;+A: 收到消息M2和签名S后，用私钥解密M2并得到M3    B--&gt;&gt;-A: 用A的公钥解密签名S并得到签名S1    B-&gt;&gt;+A: 对M3使用相同哈希算法计算散列值得到M4，并根据S1和M4是否一致判断消息的真实性\n\n","slug":"其他/客户端通信安全设计","date":"2023-05-23T05:29:48.000Z","categories_index":"其他教程","tags_index":"加密,aes,rsa","author_index":"阿木大叔"},{"id":"71fd0f421f976303f8841082c0a437ed","title":"Qt状态机与Qt动画的结合使用","content":"Qt状态机与Qt动画的结合使用Qt是一个流行的跨平台应用程序框架，它可以帮助开发者轻松地创建面向对象的GUI应用程序。Qt框架提供了许多有用的工具和库，其中包括状态机和动画。状态机是一种自动机，用于管理对象的状态转换，而动画则可以使这些状态转换更加流畅和自然。在本文中，我们将探讨如何将Qt状态机与Qt动画结合使用。\n简介Qt状态机是一个轻量级的框架，用于管理对象的状态转换。状态机由状态、转换和动作组成。状态表示对象可能处于的状态，转换表示对象从一个状态到另一个状态的转换，而动作是在状态转换期间执行的操作。\nQt动画是一个库，用于创建动态的用户界面效果。它可以用于创建动画、过渡和其他效果，使应用程序更加生动和吸引人。\n将这两个框架结合使用可以使开发者轻松地创建具有复杂状态转换和动画效果的应用程序。\n状态机和动画的结合使用在Qt中，状态机和动画可以很容易地结合使用。在状态转换期间，可以使用动画来使过渡更加平滑和自然。\n例如，假设我们有一个包含两个状态的对象：状态A和状态B。我们希望在对象从状态A转换到状态B时使用动画。我们可以使用以下代码来实现这一点：\n12345678910111213141516171819202122// 创建状态机QStateMachine *machine = new QStateMachine();// 创建状态AQState *stateA = new QState(machine);stateA-&gt;assignProperty(object, &quot;x&quot;, 0);// 创建状态BQState *stateB = new QState(machine);stateB-&gt;assignProperty(object, &quot;x&quot;, 100);// 创建转换QAbstractTransition *transition = stateA-&gt;addTransition(signal, stateB);// 创建动画QPropertyAnimation *animation = new QPropertyAnimation(object, &quot;x&quot;, this);animation-&gt;setDuration(1000);transition-&gt;addAnimation(animation);// 启动状态机machine-&gt;setInitialState(stateA);machine-&gt;start();\n\n在这个例子中，我们创建了一个包含两个状态的状态机，状态A和状态B。我们还创建了一个信号，当接收到这个信号时，我们希望对象从状态A转换到状态B。我们还创建了一个动画，用于使过渡更加平滑和自然。动画将对象的x属性从0变为100，持续时间为1秒。最后，我们启动了状态机。\n示例代码以下是一个完整的示例代码，演示如何使用Qt状态机和Qt动画结合使用：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;QApplication&gt;#include &lt;QStateMachine&gt;#include &lt;QState&gt;#include &lt;QAbstractTransition&gt;#include &lt;QPushButton&gt;#include &lt;QPropertyAnimation&gt;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    // 创建一个按钮    QPushButton button(&quot;Click me!&quot;);    // 创建状态机    QStateMachine *machine = new QStateMachine();    // 创建状态A    QState *stateA = new QState(machine);    stateA-&gt;assignProperty(&amp;button, &quot;text&quot;, &quot;Click me!&quot;);    // 创建状态B    QState *stateB = new QState(machine);    stateB-&gt;assignProperty(&amp;button, &quot;text&quot;, &quot;Hello!&quot;);    // 创建转换    QAbstractTransition *transition = stateA-&gt;addTransition(&amp;button, SIGNAL(clicked()), stateB);    // 创建动画    QPropertyAnimation *animation = new QPropertyAnimation(&amp;button, &quot;geometry&quot;, &amp;button);    animation-&gt;setDuration(1000);    transition-&gt;addAnimation(animation);    // 启动状态机    machine-&gt;setInitialState(stateA);    machine-&gt;start();    // 显示按钮    button.setGeometry(100, 100, 100, 50);    button.show();    return app.exec();&#125;\n\n在这个示例中，我们创建了一个按钮，并使用状态机和动画来管理按钮的状态转换。当用户单击按钮时，按钮将从状态A转换到状态B，并使用动画使过渡更加平滑和自然。按钮的文本将从“Click me!”变为“Hello!”。\n结论在本文中，我们介绍了如何将Qt状态机与Qt动画结合使用。状态机可以管理对象的状态转换，而动画可以使这些状态转换更加平滑和自然。通过将这两个框架结合使用，开发者可以轻松地创建具有复杂状态转换和动画效果的应用程序。\nQt状态机与Qt动画一起使用Qt是一个强大的应用程序框架，其中包含了许多有用的工具和库，可以帮助开发者更轻松地构建跨平台的应用程序。在这篇博客中，我们将探讨如何使用Qt状态机和Qt动画来创建更加流畅和交互式的用户界面。\n什么是Qt状态机？Qt状态机是一种设计模式，用于管理和控制对象的状态转换。它提供了一种简洁且易于理解的方式来处理状态变化，使得代码更加可维护和可扩展。\n在Qt中，状态机通常由两个主要组件组成：状态和转换。状态表示对象的当前状态，而转换则定义状态之间的关系。当对象接收到某个事件时，状态机会根据当前状态和事件类型执行相应的转换，进而改变对象的状态。\n以下是一个简单的示例，展示了如何在Qt中实现状态机：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 定义两种状态enum State &#123;    IdleState,    RunningState&#125;;// 定义两种事件enum Event &#123;    StartEvent,    StopEvent&#125;;class MyObject : public QObject &#123;    Q_OBJECT    public:    MyObject(QObject* parent = nullptr) : QObject(parent) &#123;        // 创建状态机        m_stateMachine = new QStateMachine(this);                // 创建状态        QState* idleState = new QState();        QState* runningState = new QState();                // 将状态添加到状态机中        m_stateMachine-&gt;addState(idleState);        m_stateMachine-&gt;addState(runningState);                // 创建转换        QSignalTransition* startTransition = new QSignalTransition(this, &amp;MyObject::start);        QSignalTransition* stopTransition = new QSignalTransition(this, &amp;MyObject::stop);                // 定义转换的源状态和目标状态        startTransition-&gt;setSourceState(idleState);        startTransition-&gt;setTargetState(runningState);                stopTransition-&gt;setSourceState(runningState);        stopTransition-&gt;setTargetState(idleState);                // 添加转换到状态机中        idleState-&gt;addTransition(startTransition);        runningState-&gt;addTransition(stopTransition);                m_stateMachine-&gt;setInitialState(idleState);        m_stateMachine-&gt;start();    &#125;    signals:    void start();    void stop();    private:    QStateMachine* m_stateMachine;&#125;;\n\n在上面的示例中，我们创建了一个名为MyObject的类，并实现了一个简单的状态机。该状态机包含两个状态（IdleState和RunningState）和两个事件（StartEvent和StopEvent）。当对象接收到StartEvent事件时，状态机会从IdleState转换到RunningState，当接收到StopEvent事件时，则会从RunningState转换回IdleState。\n什么是Qt动画？Qt动画是一种用于创建平滑和动态效果的工具。它允许开发者创建复杂的动画序列，包括缓动效果、透明度变化、旋转和缩放等。\n在Qt中，动画通常由以下组件组成：\n\nQPropertyAnimation：用于控制属性值的动画类。\nQEasingCurve：用于定义缓动效果的类。\nQSequentialAnimationGroup：用于按顺序播放多个动画的类。\nQParallelAnimationGroup：用于同时播放多个动画的类。\n\n以下是一个简单的示例，展示了如何在Qt中实现动画：\n123456789101112131415161718192021222324// 创建翻转动画QPropertyAnimation* flipAnimation = new QPropertyAnimation(myWidget, &quot;rotation&quot;);flipAnimation-&gt;setDuration(500);flipAnimation-&gt;setStartValue(0);flipAnimation-&gt;setEndValue(180);// 定义缓动效果// 创建缓动效果QEasingCurve easeInCubic(QEasingCurve::InCubic);flipAnimation-&gt;setEasingCurve(easeInCubic);// 创建平移动画QPropertyAnimation* translateAnimation = new QPropertyAnimation(myWidget, &quot;pos&quot;);translateAnimation-&gt;setDuration(1000);translateAnimation-&gt;setStartValue(QPoint(0, 0));translateAnimation-&gt;setEndValue(QPoint(100, 100));// 定义并行动画组QParallelAnimationGroup* animationGroup = new QParallelAnimationGroup();animationGroup-&gt;addAnimation(flipAnimation);animationGroup-&gt;addAnimation(translateAnimation);// 启动动画组animationGroup-&gt;start();\n\n在上面的示例中，我们创建了两个动画：一个旋转动画和一个平移动画。然后，我们将它们添加到一个并行动画组中，并同时启动这两个动画。\n将Qt状态机与Qt动画结合使用现在，我们已经了解了如何使用Qt状态机和Qt动画来分别实现状态管理和动画播放。接下来，让我们将它们结合使用，创建一个更加流畅和交互式的用户界面。\n以下是一个示例，展示了如何在Qt中将状态机和动画结合使用：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class MyObject : public QObject &#123;    Q_OBJECT    public:    MyObject(QWidget* parent = nullptr) : QObject(parent) &#123;        // 创建状态机        m_stateMachine = new QStateMachine(this);                // 创建状态        QState* idleState = new QState();        QState* runningState = new QState();                // 将状态添加到状态机中        m_stateMachine-&gt;addState(idleState);        m_stateMachine-&gt;addState(runningState);                // 创建转换        QSignalTransition* startTransition = new QSignalTransition(this, &amp;MyObject::start);        QSignalTransition* stopTransition = new QSignalTransition(this, &amp;MyObject::stop);                // 定义转换的源状态和目标状态        startTransition-&gt;setSourceState(idleState);        startTransition-&gt;setTargetState(runningState);                stopTransition-&gt;setSourceState(runningState);        stopTransition-&gt;setTargetState(idleState);                // 添加转换到状态机中        idleState-&gt;addTransition(startTransition);        runningState-&gt;addTransition(stopTransition);                // 创建旋转动画        QPropertyAnimation* flipAnimation = new QPropertyAnimation(parent, &quot;rotation&quot;);        flipAnimation-&gt;setDuration(500);        flipAnimation-&gt;setStartValue(0);        flipAnimation-&gt;setEndValue(180);                // 定义缓动效果        QEasingCurve easeInCubic(QEasingCurve::InCubic);        flipAnimation-&gt;setEasingCurve(easeInCubic);                // 创建平移动画        QPropertyAnimation* translateAnimation = new QPropertyAnimation(parent, &quot;pos&quot;);        translateAnimation-&gt;setDuration(1000);        translateAnimation-&gt;setStartValue(QPoint(0, 0));        translateAnimation-&gt;setEndValue(QPoint(100, 100));                // 定义并行动画组        QParallelAnimationGroup* animationGroup = new QParallelAnimationGroup();        animationGroup-&gt;addAnimation(flipAnimation);        animationGroup-&gt;addAnimation(translateAnimation);                // 创建状态机动画        QAbstractTransition* runningTransition = runningState-&gt;addTransition(animationGroup);                // 添加状态机到对象中        m_stateMachine-&gt;setInitialState(idleState);        m_stateMachine-&gt;start();    &#125;    signals:    void start();    void stop();    private:    QStateMachine* m_stateMachine;&#125;;\n\n在上面的示例中，我们创建了一个名为MyObject的类，并实现了一个将状态机和动画结合使用的示例。该类包含一个状态机和两个信号（start()和stop()）。当对象接收到start()信号时，状态机会从idleState转换到runningState，并同时播放旋转和平移动画；当接收到stop()信号时，则会从runningState转换回idleState。\n总结Qt状态机和Qt动画是两个非常强大的工具，可以帮助开发者创建更加流畅和交互式的用户界面。通过将它们结合使用，我们可以轻松地管理对象的状态，并同时播放复杂的动画效果。\n在本文中，我们探讨了如何在Qt中实现状态机和动画，以及如何将它们结合使用。通过这些示例代码，您可以更好地理解如何在自己的项目中使用这些功能。\n","slug":"Qt/进阶教程/Qt状态机与Qt动画的结合使用","date":"2023-05-13T05:46:53.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"ab15d9005aa078928d65bb1db59a3d04","title":"QGraphicsView图形视图框架详解","content":"QGraphicsView图形视图框架详解什么是QGraphicsView？QGraphicsView是Qt中的一个图形视图框架，它提供了一种方便的方式来显示和编辑大量的2D图形元素。QGraphicsView可以与QGraphicsScene一起使用，QGraphicsScene是一个2D图形场景，它包含了一组图形项，可以在其中添加、删除、移动和变换图形项。QGraphicsView提供了一种交互式的方式来显示和编辑QGraphicsScene中的图形项，包括平移、缩放、旋转、选择、拖拽等操作。\nQGraphicsView的基本用法使用QGraphicsView需要以下几个步骤：\n\n创建一个QGraphicsScene对象，并在其中添加图形项。\n创建一个QGraphicsView对象，并将其设置为QGraphicsScene的视图。\n将QGraphicsView添加到窗口中，并显示出来。\n\n下面是一个简单的示例代码，演示了如何使用QGraphicsView显示一个矩形和一个文本项：\n123456789101112131415#include &lt;QtWidgets&gt;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QGraphicsScene scene;    QGraphicsRectItem *rectItem = scene.addRect(QRectF(0, 0, 100, 100), QPen(Qt::black), QBrush(Qt::red));    QGraphicsTextItem *textItem = scene.addText(&quot;Hello, QGraphicsView!&quot;);    QGraphicsView view(&amp;scene);    view.show();    return app.exec();&#125;\n\n在上面的代码中，我们首先创建了一个QGraphicsScene对象，并在其中添加了一个矩形和一个文本项。然后，我们创建了一个QGraphicsView对象，并将其设置为QGraphicsScene的视图。最后，我们将QGraphicsView添加到窗口中，并显示出来。\nQGraphicsView的交互操作QGraphicsView提供了一系列交互操作，可以方便地对QGraphicsScene中的图形项进行操作。下面是一些常用的交互操作：\n\n平移：按住鼠标左键并拖动视图，可以平移视图。\n缩放：使用鼠标滚轮可以缩放视图。\n旋转：按住鼠标右键并拖动视图，可以旋转视图。\n选择：单击图形项可以选择它，按住Ctrl键可以多选图形项。\n拖拽：按住鼠标左键并拖动图形项，可以拖拽它。\n\n下面是一个示例代码，演示了如何使用QGraphicsView的交互操作：\n123456789101112131415161718#include &lt;QtWidgets&gt;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QGraphicsScene scene;    QGraphicsRectItem *rectItem = scene.addRect(QRectF(0, 0, 100, 100), QPen(Qt::black), QBrush(Qt::red));    QGraphicsTextItem *textItem = scene.addText(&quot;Hello, QGraphicsView!&quot;);    QGraphicsView view(&amp;scene);    view.setRenderHint(QPainter::Antialiasing);    view.setDragMode(QGraphicsView::ScrollHandDrag);    view.setInteractive(true);    view.show();    return app.exec();&#125;\n\n在上面的代码中，我们设置了QGraphicsView的渲染选项为抗锯齿，设置了拖拽模式为滚动手柄拖拽，并将交互模式设置为可交互。这样，我们就可以使用QGraphicsView的交互操作来操作QGraphicsScene中的图形项了。\nQGraphicsView的高级用法除了基本用法和交互操作外，QGraphicsView还提供了一些高级用法，包括：\n\n自定义视图：可以继承QGraphicsView类，并重写它的一些函数来实现自定义的视图。\n自定义图形项：可以继承QGraphicsItem类，并重写它的一些函数来实现自定义的图形项。\n图形项组合：可以将多个图形项组合成一个组，并对组进行操作。\n图形项动画：可以使用QPropertyAnimation类来实现图形项的动画效果。\n\n下面是一个示例代码，演示了如何使用QGraphicsView的高级用法：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;QtWidgets&gt;class CustomView : public QGraphicsView&#123;public:    CustomView(QGraphicsScene *scene, QWidget *parent = nullptr) : QGraphicsView(scene, parent)    &#123;        setRenderHint(QPainter::Antialiasing);        setDragMode(QGraphicsView::ScrollHandDrag);        setInteractive(true);    &#125;protected:    void wheelEvent(QWheelEvent *event) override    &#123;        if (event-&gt;modifiers() &amp; Qt::ControlModifier) &#123;            double scaleFactor = 1.15;            if (event-&gt;delta() &gt; 0) &#123;                scale(scaleFactor, scaleFactor);            &#125; else &#123;                scale(1 / scaleFactor, 1 / scaleFactor);            &#125;            event-&gt;accept();        &#125; else &#123;            QGraphicsView::wheelEvent(event);        &#125;    &#125;&#125;;class CustomItem : public QGraphicsItem&#123;public:    CustomItem(QGraphicsItem *parent = nullptr) : QGraphicsItem(parent)    &#123;        setFlag(QGraphicsItem::ItemIsMovable);    &#125;    QRectF boundingRect() const override    &#123;        return QRectF(-50, -50, 100, 100);    &#125;    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override    &#123;        painter-&gt;setPen(Qt::black);        painter-&gt;setBrush(Qt::yellow);        painter-&gt;drawEllipse(-50, -50, 100, 100);    &#125;&#125;;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QGraphicsScene scene;    CustomItem *item = new CustomItem;    scene.addItem(item);    CustomView view(&amp;scene);    view.show();    return app.exec();&#125;\n\n在上面的代码中，我们首先创建了一个CustomView类，继承自QGraphicsView类，并重写了它的wheelEvent函数，实现了缩放视图的功能。然后，我们创建了一个CustomItem类，继承自QGraphicsItem类，并重写了它的boundingRect和paint函数，实现了一个自定义的图形项。最后，我们将CustomItem添加到QGraphicsScene中，并使用CustomView来显示QGraphicsScene。\n通过上面的示例代码，我们可以看到QGraphicsView的高级用法非常灵活，可以根据需要进行自定义和扩展。如果您想要进一步了解QGraphicsView的高级用法，可以参考Qt官方文档或者相关书籍。\n","slug":"Qt/进阶教程/QGraphicsView图形视图框架详解","date":"2023-05-13T03:00:12.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"dc668aa3f9d7827fe3cbf73af04ed4c5","title":"Qt多进程通信","content":"Qt多进程通信在许多应用程序中，多进程通信（IPC）是必不可少的。例如，一个应用程序可能需要将数据从一个进程传递到另一个进程，或者需要在两个进程之间同步信息。Qt 提供了一些方法来实现多进程通信，本文将介绍其中的一些。\n进程间通信方式Qt提供了几种进程间通信的方式，常见的有：\n1. 信号和槽信号和槽是Qt中最常用的通信机制，它可以在单个进程内发送消息并响应消息。如果我们想在不同进程之间使用信号和槽进行通信，则需要使用QSharedMemory和QLocalServer等类来实现跨进程访问共享内存和监听套接字。\n2. 套接字套接字是Linux和Windows操作系统上实现进程间通信的标准方法。Qt提供了QTcpSocket和QTcpServer作为基于TCP&#x2F;IP协议的套接字实现以及QUdpSocket和QUdpServer作为UDP协议的套接字实现。\n3. 共享内存共享内存是一种非常快速的进程间通信方式。Qt提供了QSharedMemory类来实现共享内存。\n4. 本地进程间通信Qt提供了QLocalSocket和QLocalServer类来实现本地进程间通信。这些类使用套接字实现，但它们可以在本地计算机上快速地进行通信，而不必通过网络。\n实现方式下面将针对以上四种方式分别介绍如何在Qt中实现多进程通信。\n1. 信号和槽信号和槽是一种非常方便的方式来跨线程或进程发送消息并响应消息。在Qt中，我们可以使用QSharedMemory类来实现跨进程访问共享内存和监听套接字。\n首先，我们需要创建一个QSharedMemory对象，并调用create()方法来创建共享内存段：\n12QSharedMemory sharedMemory;sharedMemory.create(sizeof(int)); // 创建一个大小为int的共享内存段\n\n然后，我们需要将数据写入共享内存：\n123int value = 42;char *data = (char *)sharedMemory.data();memcpy(data, &amp;value, sizeof(value));\n\n最后，我们需要发送一个信号，以便另一个进程可以读取共享内存中的值：\n1emit valueChanged(sharedMemory.nativeKey());\n\n在另一个进程中，我们需要连接到这个信号并读取共享内存：\n123456789101112void MyClass::onValueChanged(int key)&#123;    QSharedMemory sharedMemory;    sharedMemory.setNativeKey(key);    if (!sharedMemory.attach()) &#123;        // 处理共享内存附加失败的情况    &#125;    int value;    char *data = (char *)sharedMemory.data();    memcpy(&amp;value, data, sizeof(value));    qDebug() &lt;&lt; &quot;Value: &quot; &lt;&lt; value;&#125;\n\n2. 套接字要在两个进程之间使用套接字进行通信，我们需要使用QTcpSocket和QTcpServer（或QUdpSocket和QUdpServer）类。首先，在服务器进程中，我们需要创建一个QTcpServer对象并将其绑定到一个端口：\n1234QTcpServer server;if (!server.listen(QHostAddress::Any, 1234)) &#123;    // 处理服务器启动失败的情况&#125;\n\n然后，我们需要等待客户端连接：\n1234567891011121314void MyClass::onNewConnection()&#123;    QTcpSocket *socket = server.nextPendingConnection();    connect(socket, &amp;QTcpSocket::readyRead, this, &amp;MyClass::onReadyRead);&#125;在客户端进程中，我们需要创建一个QTcpSocket对象，并连接到服务器：```cppQTcpSocket socket;socket.connectToHost(&quot;localhost&quot;, 1234);if (!socket.waitForConnected()) &#123;    // 处理连接失败的情况&#125;\n\n然后，我们可以使用write()方法向服务器发送数据：\n12QDataStream out(&amp;socket);out &lt;&lt; QString(&quot;Hello, server!&quot;);\n\n最后，服务器可以使用readyRead()信号来读取数据：\n12345678910void MyClass::onReadyRead()&#123;    QTcpSocket *socket = qobject_cast&lt;QTcpSocket *&gt;(sender());    if (socket) &#123;        QDataStream in(socket);        QString message;        in &gt;&gt; message;        qDebug() &lt;&lt; &quot;Received message: &quot; &lt;&lt; message;    &#125;&#125;\n\n3. 共享内存共享内存是一种非常快速的进程间通信方式。Qt提供了QSharedMemory类来实现共享内存。\n首先，我们需要创建一个QSharedMemory对象，并调用create()方法来创建共享内存段：\n12QSharedMemory sharedMemory;sharedMemory.create(sizeof(int)); // 创建一个大小为int的共享内存段\n\n然后，我们需要将数据写入共享内存：\n123int value = 42;char *data = (char *)sharedMemory.data();memcpy(data, &amp;value, sizeof(value));\n\n最后，我们需要发送一个信号，以便另一个进程可以读取共享内存中的值：\n1emit valueChanged(sharedMemory.nativeKey());\n\n在另一个进程中，我们需要连接到这个信号并读取共享内存：\n123456789101112void MyClass::onValueChanged(int key)&#123;    QSharedMemory sharedMemory;    sharedMemory.setNativeKey(key);    if (!sharedMemory.attach()) &#123;        // 处理共享内存附加失败的情况    &#125;    int value;    char *data = (char *)sharedMemory.data();    memcpy(&amp;value, data, sizeof(value));    qDebug() &lt;&lt; &quot;Value: &quot; &lt;&lt; value;&#125;\n\n4. 本地进程间通信Qt提供了QLocalSocket和QLocalServer类来实现本地进程间通信。这些类使用套接字实现，但它们可以在本地计算机上快速地进行通信，而不必通过网络。\n首先，在服务器进程中，我们需要创建一个QLocalServer对象并将其绑定到一个地址：\n12QLocalServer server;server.listen(&quot;myserver&quot;);\n\n然后，我们需要等待客户端连接：\n12345void MyClass::onNewConnection()&#123;    QLocalSocket *socket = server.nextPendingConnection();    connect(socket, &amp;QLocalSocket::readyRead, this, &amp;MyClass::onReadyRead);&#125;\n\n在客户端进程中，我们需要创建一个QLocalSocket对象，并连接到服务器：\n12345QLocalSocket socket;socket.connectToServer(&quot;myserver&quot;);if (!socket.waitForConnected()) &#123;    // 处理连接失败的情况&#125;\n\n然后，我们可以使用write()方法向服务器发送数据：\n12QDataStream out(&amp;socket);out &lt;&lt; QString(&quot;Hello, server!&quot;);\n\n最后，服务器可以使用readyRead()信号来读取数据：\n12345678910void MyClass::onReadyRead()&#123;    QLocalSocket *socket = qobject_cast&lt;QLocalSocket *&gt;(sender());    if (socket) &#123;        QDataStream in(socket);        QString message;        in &gt;&gt; message;        qDebug() &lt;&lt; &quot;Received message: &quot; &lt;&lt; message;    &#125;&#125;\n\n总结在Qt中，我们可以使用几种不同的方法来实现多进程之间的通信。每种方法都有其优点和缺点，具体要根据实际情况进行选择。无论采用哪种方式，Qt都提供了丰富的类和方法来帮助我们实现高效、稳定的进程间通信。\n以上就是本文的全部内容，希望能对你在Qt中实现多进程通信有所帮助！## 附加代码示例\n以下是一个使用共享内存实现进程间通信的简单代码示例：\n12345678910111213141516171819// sender.cpp#include &lt;QCoreApplication&gt;#include &lt;QSharedMemory&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    QSharedMemory sharedMemory;    sharedMemory.create(sizeof(int));    int value = 42;    char *data = (char *)sharedMemory.data();    memcpy(data, &amp;value, sizeof(value));    emit valueChanged(sharedMemory.nativeKey());    return a.exec();&#125;\n\n1234567891011121314151617181920212223// receiver.cpp#include &lt;QCoreApplication&gt;#include &lt;QSharedMemory&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    QSharedMemory sharedMemory;    sharedMemory.setNativeKey(1234); // 假定sender已经创建了共享内存，key为1234    if (!sharedMemory.attach()) &#123;        qDebug() &lt;&lt; &quot;Failed to attach to shared memory.&quot;;        return -1;    &#125;    int value;    char *data = (char *)sharedMemory.data();    memcpy(&amp;value, data, sizeof(value));    qDebug() &lt;&lt; &quot;Received value: &quot; &lt;&lt; value;    return a.exec();&#125;\n\n在这个示例中，sender.cpp将一个整数值写入共享内存并发出一个信号。receiver.cpp连接到这个信号并读取共享内存中的值。\n参考资料\nQt Documentation: Interprocess Communication in Qt\nQt Forum: Inter-process communication through signals and slots\nTowards Data Science: A Comprehensive Guide to Shared Memory in C++\n\n","slug":"Qt/进阶教程/Qt多进程通信","date":"2023-05-13T03:00:12.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"bfa7a2b6ebbeca6f6d16afb84bd5fd2a","title":"UDP的基础知识-单播、组播和广播","content":"UDP的基础知识UDP（User Datagram Protocol）是一种无连接协议，它将数据报文发送出去，由接收端来进行处理。UDP不提供可靠性，也不保证数据的正确性和顺序。但是，UDP具有较低的延迟和较少的开销。在网络游戏、视频流传输、DNS等应用中广泛使用。\nUDP使用IP协议来传输数据，每个UDP数据包被封装在一个IP数据包中并通过网络的其他节点进行路由。UDP使用端口来标识不同应用程序之间的通信，并为每个UDP数据包提供源端口和目的端口。源端口和目标端口的结合形成了一个套接字（socket），套接字可以唯一标识两个应用程序之间的单独的会话。\n单播单播（Unicast） 是一对一通信模式，在这种模式下，一个发送者向一个接收者发送数据包。单播通过以下程序示例实现：\n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;cstring&gt;using namespace std;int main() &#123;    // 创建一个IPv4 UDP套接字    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);    // 构造服务器地址    struct sockaddr_in server_addr;    memset(&amp;server_addr, 0, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(8888);    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    // 发送数据    char buf[] = &quot;Hello, this is a unicast message!&quot;;    sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));    // 关闭套接字    close(sockfd);    return 0;&#125;\n\n在上面的程序中，我们使用socket函数创建了一个IPv4 UDP套接字，并使用sendto函数向指定的服务器IP地址和端口发送数据包。\n组播组播是一种用于在网络中向多个接收方同时传输数据的通信方式。在UDP协议中，组播使用特定的IP地址范围（224.0.0.0 - 239.255.255.255）进行标识。发送方通过将数据包发送到组播地址，而不是单独的目标地址，可以将数据传输给一组接收方。\n组播需要使用专门的协议支持，如IGMP（Internet Group Management Protocol），以便确定哪些接收方对该组播感兴趣，并将数据包路由到正确的接收方。\n在C++中使用UDP进行组播的示例代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#define PORT 8888#define GROUP &quot;239.0.0.1&quot;int main()&#123;    struct sockaddr_in addr;    int sock, cnt;    char message[] = &quot;Hello, multicast!&quot;;    sock = socket(AF_INET, SOCK_DGRAM, 0);    if(sock &lt; 0)    &#123;        perror(&quot;socket&quot;);        exit(EXIT_FAILURE);    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_addr.s_addr = inet_addr(GROUP);    addr.sin_port = htons(PORT);    while(1)    &#123;        cnt = sendto(sock, message, sizeof(message), 0, (struct sockaddr *)&amp;addr, sizeof(addr));        if(cnt &lt; 0)        &#123;            perror(&quot;sendto&quot;);            exit(EXIT_FAILURE);        &#125;        sleep(1);    &#125;    close(sock);    return 0;&#125;\n\n在上述代码中，使用socket()函数创建一个UDP套接字并指定组播的IP地址和端口号。发送方通过sendto()函数将数据包发送到组播地址，并以一定的时间间隔重复执行此操作。\n广播广播是另一种用于向一组接收方传输数据的通信方式，在网络中向同一子网中的所有主机发送数据包。在IPv4网络中，广播使用特殊的IP地址（255.255.255.255）进行标识。\n在C++中使用UDP进行广播的示例代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#define PORT 8888#define BROADCAST &quot;255.255.255.255&quot;int main()&#123;    struct sockaddr_in addr;    int sock, cnt;    char message[] = &quot;Hello, broadcast!&quot;;    sock = socket(AF_INET, SOCK_DGRAM, 0);    if(sock &lt; 0)    &#123;        perror(&quot;socket&quot;);        exit(EXIT_FAILURE);    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_addr.s_addr = inet_addr(BROADCAST);    addr.sin_port = htons(PORT);    int optval = 1;    setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &amp;optval, sizeof(optval));    while(1)    &#123;        cnt = sendto(sock, message, sizeof(message), 0, (struct sockaddr *)&amp;addr, sizeof(addr));        if(cnt &lt; 0)        &#123;            perror(&quot;sendto&quot;);            exit(EXIT_FAILURE);        &#125;        sleep(1);    &#125;    close(sock);    return 0;&#125;\n\n在上述代码中，使用socket()函数创建一个UDP套接字并指定广播的IP地址和端口号。发送方通过setsockopt()函数将SO_BROADCAST选项设置为启用广播功能，并使用sendto()函数将数据包发送到广播地址，并以一定的时间间隔重复执行此操作。\n总结单播、组播和广播都是UDP协议中常用的通信方式。单播适用于点对点的通信，组播和广播适用于向多个接收方传输数据。其中组播需要使用IGMP协议支持，并使用特定的IP地址范围进行标识；广播需要使用特殊的IP地址（255.255.255.255）进行标识，并启用SO_BROADCAST选项。\n在C++中，可以使用socket()函数创建UDP套接字，并使用sendto()函数将数据包发送到目标地址、组播地址或广播地址，以实现单播、组播和广播功能。\n","slug":"C++/UDP的基础知识-单播、组播和广播","date":"2023-05-12T05:52:41.000Z","categories_index":"C++基础","tags_index":"C++,网络通信","author_index":"阿木大叔"},{"id":"8f33bd7fed458691a6f6e03ce02f258a","title":"vs2017编译FFmpeg","content":"编译环境\n操作系统: Window10 64位\n需要下载的文件\nvs2017\nMSYS2\n\n\n\n编译步骤安装vs2017\n网络上很多安装教程，这里不再赘述，自行安装\n\n\n安装MSYS2\nMSYS2官网https://www.msys2.org/下载上图安装包，默认安装即可，安装路径C:\\msys64\n\n如何启动 msys2 ？打开WinCMD 进入 C:\\msys64 目录，执行以下命令 进入 mingw32 或者 mingw64位环境。\n\n.\\msys2_shell.cmd -mingw32\n.\\msys2_shell.cmd -mingw64msys2 实际上是一个 在 Windows 系统模拟 Linux 的一个命令窗口程序\n\n\n\n\nmsvc+MSYS2编译ffmpeg准备环境\n修改C:\\msys64\\msys2_shell.cmd文件将rem set MSYS2_PATH_TYPE&#x3D;inherit前面的rem去除\n\n执行vs2017命令行工具\n\n执行以下命令，启动msys2模拟mingw64环境\n12cd c:\\msys64\\.\\msys2_shell.cmd -mingw64\n\n\n测试环境\n1which cl.exe\n在msys2命令行窗口输入上方命令，输出如下界面即为成功\n\n安装依赖输入以下命令，安装依赖组件\n1pacman -S diffutils make pkg-config yasm\n\n\n\n开始编译\n下载ffmpeg源码ffmpeg开源地址：https://github.com/FFmpeg/FFmpeg可以下载最新代码\n\n演示代码目录：E:\\CODE\\gitee_code\\FFmpeg\\src\\ffmpeg\n\n修改源码修改fftools\\ffprobe.c、fftools\\opt_common.c两个文件将包含 CC_IDENT 的行注释掉，不影响功能，只是打印输出编码有点问题，注释掉即可\n\n进入目录\n1cd E:\\CODE\\gitee_code\\FFmpeg\\src\\ffmpeg\n创建编译输出目录：E:&#x2F;CODE&#x2F;gitee_code&#x2F;FFmpeg&#x2F;build64&#x2F;ffmepg-4.4-msvc\n\n开始编译\n12345678910111213./configure \\--prefix=E:/CODE/gitee_code/FFmpeg/build64/ffmepg-4.4-msvc \\--enable-gpl \\--enable-nonfree \\--enable-shared \\--disable-optimizations \\--disable-asm \\--disable-stripping \\--toolchain=msvcmake -j8# 要执行 make installmake install\n\n顺利的话，执行完以上命令，便可编译完成，在E:&#x2F;CODE&#x2F;gitee_code&#x2F;FFmpeg&#x2F;build64&#x2F;ffmepg-4.4-msvc目录可以看见输出文件\n\n测试\nffmpeg.exe -i http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/prog_index.m3u8 -vcodec copy -f mp4 1.mp4 &#x2F;&#x2F; 苹果测试源，此命令为将在线视频源保存为mp4文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640ffmpeg version N-108922-ge27bef9a56 Copyright (c) 2000-2022 the FFmpeg developers  built with gcc 9 (Ubuntu 9.4.0-1ubuntu1~20.04.1)  configuration: --enable-shared --enable-nonfree --enable-gpl --enable-pthreads --enable-libx264 --enable-libx265 --prefix=../ffmpeg_output  libavutil      57. 40.100 / 57. 40.100  libavcodec     59. 51.101 / 59. 51.101  libavformat    59. 34.101 / 59. 34.101  libavdevice    59.  8.101 / 59.  8.101  libavfilter     8. 49.101 /  8. 49.101  libswscale      6.  8.112 /  6.  8.112  libswresample   4.  9.100 /  4.  9.100  libpostproc    56.  7.100 / 56.  7.100[hls @ 0x563459342040] Skip (&#x27;#EXT-X-VERSION:3&#x27;)[hls @ 0x563459342040] Opening &#x27;http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/fileSequence0.ts&#x27; for reading[hls @ 0x563459342040] Opening &#x27;http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/fileSequence1.ts&#x27; for reading[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=903000, dts=906000, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=903000, dts=906000, size=1078[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=909000, dts=912000, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=909000, dts=912000, size=1353[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=915000, dts=918000, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=915000, dts=918000, size=1260[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=921000, dts=924000, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=921000, dts=924000, size=1211[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=927000, dts=930150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=927000, dts=930150, size=1271[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=933150, dts=936150, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=933150, dts=936150, size=1059[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=939150, dts=942150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=939150, dts=942150, size=1381[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=945150, dts=948150, size=709[hls @ 0x563459342040] Invalid timestamps stream=0, pts=945150, dts=948150, size=829[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=951150, dts=954150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=951150, dts=954150, size=1303[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=957150, dts=960150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=957150, dts=960150, size=1207Input #0, hls, from &#x27;http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/prog_index.m3u8&#x27;:  Duration: 00:30:00.00, start: 9.904222, bitrate: 0 kb/s  Program 0     Metadata:      variant_bitrate : 0  Stream #0:0: Video: h264 (Main) ([27][0][0][0] / 0x001B), yuv420p(tv, smpte170m/smpte170m/bt709), 640x480, Closed Captions, 29.92 fps, 29.92 tbr, 90k tbn    Metadata:      variant_bitrate : 0  Stream #0:1: Audio: aac (LC) ([15][0][0][0] / 0x000F), 22050 Hz, stereo, fltp    Metadata:      variant_bitrate : 0Stream mapping:  Stream #0:0 -&gt; #0:0 (copy)  Stream #0:1 -&gt; #0:1 (aac (native) -&gt; aac (native))Press [q] to stop, [?] for helpOutput #0, mp4, to &#x27;1.mp4&#x27;:  Metadata:    encoder         : Lavf59.34.101  Stream #0:0: Video: h264 (Main) (avc1 / 0x31637661), yuv420p(tv, smpte170m/smpte170m/bt709), 640x480, q=2-31, 29.92 fps, 29.92 tbr, 90k tbn    Metadata:      variant_bitrate : 0  Stream #0:1: Audio: aac (LC) (mp4a / 0x6134706D), 22050 Hz, stereo, fltp, 128 kb/s    Metadata:      variant_bitrate : 0      encoder         : Lavc59.51.101 aac[mp4 @ 0x563459363200] Invalid DTS: 14620 PTS: 11620 in output stream 0:0, replacing by guess    [mp4 @ 0x563459363200] Invalid DTS: 20620 PTS: 17620 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 26620 PTS: 23620 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 32620 PTS: 29620 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 38770 PTS: 35620 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 44770 PTS: 41770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=963150, dts=966150, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=963150, dts=966150, size=898[mp4 @ 0x563459363200] Invalid DTS: 50770 PTS: 47770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 56770 PTS: 53770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 62770 PTS: 59770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 68770 PTS: 65770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 74770 PTS: 71770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=975150, dts=978150, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=975150, dts=978150, size=1192[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=981150, dts=984150, size=1445[mp4 @ 0x563459363200] Invalid DTS: 86770 PTS: 83770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=981150, dts=984150, size=1270[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=987150, dts=990150, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=987150, dts=990150, size=1215[mp4 @ 0x563459363200] Invalid DTS: 92770 PTS: 89770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=993150, dts=996150, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=993150, dts=996150, size=1092[mp4 @ 0x563459363200] Invalid DTS: 98770 PTS: 95770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 104770 PTS: 101770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=999150, dts=1002150, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=999150, dts=1002150, size=1436[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1005150, dts=1008150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1005150, dts=1008150, size=1291[mp4 @ 0x563459363200] Invalid DTS: 110770 PTS: 107770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1011150, dts=1014150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1011150, dts=1014150, size=1214[mp4 @ 0x563459363200] Invalid DTS: 116770 PTS: 113770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1017150, dts=1020150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1017150, dts=1020150, size=1274[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1023150, dts=1026150, size=1077[mp4 @ 0x563459363200] Invalid DTS: 122770 PTS: 119770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1023150, dts=1026150, size=1025[mp4 @ 0x563459363200] Invalid DTS: 128770 PTS: 125770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 134770 PTS: 131770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1029150, dts=1032150, size=1629[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1029150, dts=1032150, size=1468[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1035150, dts=1038150, size=893[mp4 @ 0x563459363200] Invalid DTS: 140770 PTS: 137770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1035150, dts=1038150, size=921[mp4 @ 0x563459363200] Invalid DTS: 146770 PTS: 143770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1047150, dts=1050150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1047150, dts=1050150, size=1208[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1053150, dts=1056150, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1053150, dts=1056150, size=951[mp4 @ 0x563459363200] Invalid DTS: 158770 PTS: 155770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1059150, dts=1062150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1059150, dts=1062150, size=1222[mp4 @ 0x563459363200] Invalid DTS: 164770 PTS: 161770 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 170770 PTS: 167770 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1065150, dts=1068150, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1065150, dts=1068150, size=1155[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1071150, dts=1074150, size=1445[mp4 @ 0x563459363200] Invalid DTS: 176770 PTS: 173770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1071150, dts=1074150, size=1289[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1077150, dts=1080300, size=1077[mp4 @ 0x563459363200] Invalid DTS: 182770 PTS: 179770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1077150, dts=1080300, size=1100[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1083300, dts=1086300, size=893[mp4 @ 0x563459363200] Invalid DTS: 188920 PTS: 185770 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1083300, dts=1086300, size=1074[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1089300, dts=1092300, size=1261[mp4 @ 0x563459363200] Invalid DTS: 194920 PTS: 191920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1089300, dts=1092300, size=1360[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1095300, dts=1098300, size=1261[mp4 @ 0x563459363200] Invalid DTS: 200920 PTS: 197920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1095300, dts=1098300, size=1257[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1101300, dts=1104300, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1101300, dts=1104300, size=1226[mp4 @ 0x563459363200] Invalid DTS: 206920 PTS: 203920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 212920 PTS: 209920 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1107300, dts=1110300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1107300, dts=1110300, size=1263[mp4 @ 0x563459363200] Invalid DTS: 218920 PTS: 215920 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1119300, dts=1122300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1119300, dts=1122300, size=1317[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1125300, dts=1128300, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1125300, dts=1128300, size=820[mp4 @ 0x563459363200] Invalid DTS: 230920 PTS: 227920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 236920 PTS: 233920 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1131300, dts=1134300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1131300, dts=1134300, size=1325[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1137300, dts=1140300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1137300, dts=1140300, size=1173[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1143300, dts=1146300, size=893[mp4 @ 0x563459363200] Invalid DTS: 242920 PTS: 239920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 248920 PTS: 245920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1143300, dts=1146300, size=925[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1149300, dts=1152300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1149300, dts=1152300, size=1160[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1155300, dts=1158300, size=1077[mp4 @ 0x563459363200] Invalid DTS: 254920 PTS: 251920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 260920 PTS: 257920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1155300, dts=1158300, size=1109[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1161300, dts=1164300, size=1261[mp4 @ 0x563459363200] Invalid DTS: 266920 PTS: 263920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1161300, dts=1164300, size=1275[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1167300, dts=1170300, size=1077[mp4 @ 0x563459363200] Invalid DTS: 272920 PTS: 269920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1167300, dts=1170300, size=1169[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1173300, dts=1176300, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1173300, dts=1176300, size=1044[mp4 @ 0x563459363200] Invalid DTS: 278920 PTS: 275920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 284920 PTS: 281920 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1179300, dts=1182300, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1179300, dts=1182300, size=1410[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1191300, dts=1194300, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1191300, dts=1194300, size=1140[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1197300, dts=1200300, size=1261[mp4 @ 0x563459363200] Invalid DTS: 290920 PTS: 287920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 302920 PTS: 299920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1197300, dts=1200300, size=1239[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1203300, dts=1206300, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1203300, dts=1206300, size=1004[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1209300, dts=1212300, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1209300, dts=1212300, size=1383[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1215300, dts=1218300, size=893[mp4 @ 0x563459363200] Invalid DTS: 308920 PTS: 305920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1215300, dts=1218300, size=894[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1221300, dts=1224300, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1221300, dts=1224300, size=1317[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1227300, dts=1230450, size=1077[mp4 @ 0x563459363200] Invalid DTS: 314920 PTS: 311920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 320920 PTS: 317920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 326920 PTS: 323920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 332920 PTS: 329920 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1227300, dts=1230450, size=1221[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1233450, dts=1236450, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1233450, dts=1236450, size=948[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1239450, dts=1242450, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1239450, dts=1242450, size=1218[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1245450, dts=1248450, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1245450, dts=1248450, size=1146[mp4 @ 0x563459363200] Invalid DTS: 339070 PTS: 335920 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 345070 PTS: 342070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 351070 PTS: 348070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 357070 PTS: 354070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1251450, dts=1254450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1251450, dts=1254450, size=1297[mp4 @ 0x563459363200] Invalid DTS: 363070 PTS: 360070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1263450, dts=1266450, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1263450, dts=1266450, size=1076[mp4 @ 0x563459363200] Invalid DTS: 375070 PTS: 372070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1269450, dts=1272450, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1269450, dts=1272450, size=1348[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1275450, dts=1278450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1275450, dts=1278450, size=1260[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1281450, dts=1284450, size=1077[mp4 @ 0x563459363200] Invalid DTS: 381070 PTS: 378070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1281450, dts=1284450, size=1214[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1287450, dts=1290450, size=1261[mp4 @ 0x563459363200] Invalid DTS: 387070 PTS: 384070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1287450, dts=1290450, size=1284[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1293450, dts=1296450, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1293450, dts=1296450, size=1053[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1299450, dts=1302450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1299450, dts=1302450, size=1426[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1305450, dts=1308450, size=709[mp4 @ 0x563459363200] Invalid DTS: 393070 PTS: 390070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1305450, dts=1308450, size=829[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1311450, dts=1314450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1311450, dts=1314450, size=1281[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1317450, dts=1320450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1317450, dts=1320450, size=1207[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1323450, dts=1326450, size=893[mp4 @ 0x563459363200] Invalid DTS: 399070 PTS: 396070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 405070 PTS: 402070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1323450, dts=1326450, size=903[mp4 @ 0x563459363200] Invalid DTS: 411070 PTS: 408070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 417070 PTS: 414070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 423070 PTS: 420070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 429070 PTS: 426070 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 435070 PTS: 432070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1335450, dts=1338450, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1335450, dts=1338450, size=1194[mp4 @ 0x563459363200] Invalid DTS: 447070 PTS: 444070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1341450, dts=1344450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1341450, dts=1344450, size=1356[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1347450, dts=1350450, size=1261[mp4 @ 0x563459363200] Invalid DTS: 453070 PTS: 450070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1347450, dts=1350450, size=1200[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1353450, dts=1356450, size=1077[mp4 @ 0x563459363200] Invalid DTS: 459070 PTS: 456070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1353450, dts=1356450, size=1095[mp4 @ 0x563459363200] Invalid DTS: 465070 PTS: 462070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1359450, dts=1362450, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1359450, dts=1362450, size=1445[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1365450, dts=1368450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1365450, dts=1368450, size=1286[mp4 @ 0x563459363200] Invalid DTS: 471070 PTS: 468070 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1371450, dts=1374450, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1371450, dts=1374450, size=1207[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1377450, dts=1380600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 477070 PTS: 474070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1377450, dts=1380600, size=1287[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1383600, dts=1386600, size=893[mp4 @ 0x563459363200] Invalid DTS: 483070 PTS: 480070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1383600, dts=1386600, size=1020[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1389600, dts=1392600, size=1445[mp4 @ 0x563459363200] Invalid DTS: 489220 PTS: 486070 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1389600, dts=1392600, size=1429[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1395600, dts=1398600, size=893[mp4 @ 0x563459363200] Invalid DTS: 495220 PTS: 492220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1395600, dts=1398600, size=862[mp4 @ 0x563459363200] Invalid DTS: 501220 PTS: 498220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 507220 PTS: 504220 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1407600, dts=1410600, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1407600, dts=1410600, size=1196[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1413600, dts=1416600, size=1077[mp4 @ 0x563459363200] Invalid DTS: 519220 PTS: 516220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1413600, dts=1416600, size=944[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1419600, dts=1422600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 525220 PTS: 522220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1419600, dts=1422600, size=1200[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1425600, dts=1428600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1425600, dts=1428600, size=1155[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1431600, dts=1434600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 531220 PTS: 528220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 537220 PTS: 534220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1431600, dts=1434600, size=1296[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1437600, dts=1440600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1437600, dts=1440600, size=1103[mp4 @ 0x563459363200] Invalid DTS: 543220 PTS: 540220 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1443600, dts=1446600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1443600, dts=1446600, size=1065[mp4 @ 0x563459363200] Invalid DTS: 549220 PTS: 546220 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1449600, dts=1452600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 555220 PTS: 552220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1449600, dts=1452600, size=1358[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1455600, dts=1458600, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1455600, dts=1458600, size=1260[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1461600, dts=1464600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 561220 PTS: 558220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 567220 PTS: 564220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1461600, dts=1464600, size=1220[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1467600, dts=1470600, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1467600, dts=1470600, size=1256[mp4 @ 0x563459363200] Invalid DTS: 573220 PTS: 570220 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1479600, dts=1482600, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1479600, dts=1482600, size=1360[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1485600, dts=1488600, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1485600, dts=1488600, size=819[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1491600, dts=1494600, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1491600, dts=1494600, size=1279[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1497600, dts=1500600, size=1077[mp4 @ 0x563459363200] Invalid DTS: 579220 PTS: 576220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 591220 PTS: 588220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 597220 PTS: 594220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 603220 PTS: 600220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1497600, dts=1500600, size=1169[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1503600, dts=1506600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1503600, dts=1506600, size=926[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1509600, dts=1512600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1509600, dts=1512600, size=1151[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1515600, dts=1518600, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1515600, dts=1518600, size=1112[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1521600, dts=1524600, size=1261[mp4 @ 0x563459363200] Invalid DTS: 609220 PTS: 606220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 615220 PTS: 612220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 621220 PTS: 618220 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 627220 PTS: 624220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1521600, dts=1524600, size=1279[mp4 @ 0x563459363200] Invalid DTS: 633220 PTS: 630220 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1527600, dts=1530750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1527600, dts=1530750, size=1183[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1533750, dts=1536750, size=1077[mp4 @ 0x563459363200] Invalid DTS: 639370 PTS: 636220 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1533750, dts=1536750, size=1056[mp4 @ 0x563459363200] Invalid DTS: 645370 PTS: 642370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1539750, dts=1542750, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1539750, dts=1542750, size=1398[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1551750, dts=1554750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1551750, dts=1554750, size=1099[mp4 @ 0x563459363200] Invalid DTS: 651370 PTS: 648370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1557750, dts=1560750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1557750, dts=1560750, size=1220[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1563750, dts=1566750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1563750, dts=1566750, size=974[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1569750, dts=1572750, size=1445[mp4 @ 0x563459363200] Invalid DTS: 663370 PTS: 660370 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 669370 PTS: 666370 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 675370 PTS: 672370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1569750, dts=1572750, size=1384[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1575750, dts=1578750, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1575750, dts=1578750, size=837[mp4 @ 0x563459363200] Invalid DTS: 681370 PTS: 678370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1581750, dts=1584750, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1581750, dts=1584750, size=1323[mp4 @ 0x563459363200] Invalid DTS: 687370 PTS: 684370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1587750, dts=1590750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1587750, dts=1590750, size=1180[mp4 @ 0x563459363200] Invalid DTS: 693370 PTS: 690370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1593750, dts=1596750, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1593750, dts=1596750, size=914[mp4 @ 0x563459363200] Invalid DTS: 699370 PTS: 696370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1599750, dts=1602750, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1599750, dts=1602750, size=1225[mp4 @ 0x563459363200] Invalid DTS: 705370 PTS: 702370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1605750, dts=1608750, size=1077[mp4 @ 0x563459363200] Invalid DTS: 711370 PTS: 708370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1605750, dts=1608750, size=1167[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1611750, dts=1614750, size=1261[mp4 @ 0x563459363200] Invalid DTS: 717370 PTS: 714370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1611750, dts=1614750, size=1295[mp4 @ 0x563459363200] Invalid DTS: 723370 PTS: 720370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1623750, dts=1626750, size=1575.8x    [mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1623750, dts=1626750, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1623750, dts=1626750, size=1079[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1629750, dts=1632750, size=1445[mp4 @ 0x563459363200] Invalid DTS: 735370 PTS: 732370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1629750, dts=1632750, size=1349[mp4 @ 0x563459363200] Invalid DTS: 741370 PTS: 738370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1635750, dts=1638750, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1635750, dts=1638750, size=1279[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1641750, dts=1644750, size=1261[mp4 @ 0x563459363200] Invalid DTS: 747370 PTS: 744370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1641750, dts=1644750, size=1235[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1647750, dts=1650750, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1647750, dts=1650750, size=1284[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1653750, dts=1656750, size=1077[mp4 @ 0x563459363200] Invalid DTS: 753370 PTS: 750370 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 759370 PTS: 756370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1653750, dts=1656750, size=1060[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1659750, dts=1662750, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1659750, dts=1662750, size=1387[mp4 @ 0x563459363200] Invalid DTS: 765370 PTS: 762370 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1665750, dts=1668750, size=709[mp4 @ 0x563459363200] Invalid DTS: 771370 PTS: 768370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1665750, dts=1668750, size=825[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1671750, dts=1674750, size=1261[mp4 @ 0x563459363200] Invalid DTS: 777370 PTS: 774370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1671750, dts=1674750, size=1292[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1677750, dts=1680900, size=1077[mp4 @ 0x563459363200] Invalid DTS: 783370 PTS: 780370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1677750, dts=1680900, size=1206[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1683900, dts=1686900, size=893[mp4 @ 0x563459363200] Invalid DTS: 789520 PTS: 786370 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1683900, dts=1686900, size=906[mp4 @ 0x563459363200] Invalid DTS: 795520 PTS: 792520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1695900, dts=1698900, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1695900, dts=1698900, size=1214[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1701900, dts=1704900, size=1261[mp4 @ 0x563459363200] Invalid DTS: 807520 PTS: 804520 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1701900, dts=1704900, size=1269[mp4 @ 0x563459363200] Invalid DTS: 813520 PTS: 810520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1707900, dts=1710900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1707900, dts=1710900, size=1204[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1713900, dts=1716900, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1713900, dts=1716900, size=1091[mp4 @ 0x563459363200] Invalid DTS: 819520 PTS: 816520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 825520 PTS: 822520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1719900, dts=1722900, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1719900, dts=1722900, size=1428[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1725900, dts=1728900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1725900, dts=1728900, size=1299[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1731900, dts=1734900, size=1077[mp4 @ 0x563459363200] Invalid DTS: 831520 PTS: 828520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 837520 PTS: 834520 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1731900, dts=1734900, size=1209[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1737900, dts=1740900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1737900, dts=1740900, size=1277[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1743900, dts=1746900, size=1077[mp4 @ 0x563459363200] Invalid DTS: 843520 PTS: 840520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 849520 PTS: 846520 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1743900, dts=1746900, size=1021[mp4 @ 0x563459363200] Invalid DTS: 855520 PTS: 852520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1749900, dts=1752900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1749900, dts=1752900, size=1382[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1755900, dts=1758900, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1755900, dts=1758900, size=869[mp4 @ 0x563459363200] Invalid DTS: 861520 PTS: 858520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 867520 PTS: 864520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1767900, dts=1770900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1767900, dts=1770900, size=1204[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1773900, dts=1776900, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1773900, dts=1776900, size=945[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1779900, dts=1782900, size=1261[mp4 @ 0x563459363200] Invalid DTS: 879520 PTS: 876520 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1779900, dts=1782900, size=1205[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1785900, dts=1788900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1785900, dts=1788900, size=1162[http @ 0x563459365740] Opening &#x27;http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/fileSequence2.ts&#x27; for reading[mp4 @ 0x563459363200] Invalid DTS: 885520 PTS: 882520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 891520 PTS: 888520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 897520 PTS: 894520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1791900, dts=1794900, size=1391[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1791900, dts=1794900, size=1290[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1797900, dts=1800900, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1797900, dts=1800900, size=1106[mp4 @ 0x563459363200] Invalid DTS: 903520 PTS: 900520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 909520 PTS: 906520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1803900, dts=1806900, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1803900, dts=1806900, size=1072[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1809900, dts=1812900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1809900, dts=1812900, size=1380[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1815900, dts=1818900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1815900, dts=1818900, size=1273[mp4 @ 0x563459363200] Invalid DTS: 915520 PTS: 912520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 921520 PTS: 918520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 927520 PTS: 924520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1821900, dts=1824900, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1821900, dts=1824900, size=1212[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1827900, dts=1831050, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1827900, dts=1831050, size=1324[mp4 @ 0x563459363200] Invalid DTS: 933520 PTS: 930520 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 939670 PTS: 936520 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1840050, dts=1843050, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1840050, dts=1843050, size=1330[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1846050, dts=1849050, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1846050, dts=1849050, size=821[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1852050, dts=1855050, size=1261[mp4 @ 0x563459363200] Invalid DTS: 951670 PTS: 948670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 957670 PTS: 954670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1852050, dts=1855050, size=1326[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1858050, dts=1861050, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1858050, dts=1861050, size=1178[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1864050, dts=1867050, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1864050, dts=1867050, size=917[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1870050, dts=1873050, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1870050, dts=1873050, size=1163[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1876050, dts=1879050, size=1077[mp4 @ 0x563459363200] Invalid DTS: 963670 PTS: 960670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 969670 PTS: 966670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 975670 PTS: 972670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 981670 PTS: 978670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1876050, dts=1879050, size=1102[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1882050, dts=1885050, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1882050, dts=1885050, size=1263[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1888050, dts=1891050, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1888050, dts=1891050, size=1184[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1894050, dts=1897050, size=1077[mp4 @ 0x563459363200] Invalid DTS: 987670 PTS: 984670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 993670 PTS: 990670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 999670 PTS: 996670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1894050, dts=1897050, size=1043[mp4 @ 0x563459363200] Invalid DTS: 1005670 PTS: 1002670 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1900050, dts=1903050, size=1261.7x    [hls @ 0x563459342040] Invalid timestamps stream=0, pts=1900050, dts=1903050, size=1417[mp4 @ 0x563459363200] Invalid DTS: 1011670 PTS: 1008670 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1912050, dts=1915050, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1912050, dts=1915050, size=1122[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1918050, dts=1921050, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1918050, dts=1921050, size=1223[mp4 @ 0x563459363200] Invalid DTS: 1023670 PTS: 1020670 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1924050, dts=1927050, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1924050, dts=1927050, size=1055[mp4 @ 0x563459363200] Invalid DTS: 1029670 PTS: 1026670 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1035670 PTS: 1032670 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1930050, dts=1933050, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1930050, dts=1933050, size=1406[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1936050, dts=1939050, size=893[mp4 @ 0x563459363200] Invalid DTS: 1041670 PTS: 1038670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1936050, dts=1939050, size=870[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1942050, dts=1945050, size=1445[mp4 @ 0x563459363200] Invalid DTS: 1047670 PTS: 1044670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1942050, dts=1945050, size=1299[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1948050, dts=1951050, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1053670 PTS: 1050670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1948050, dts=1951050, size=1198[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1954050, dts=1957050, size=893[mp4 @ 0x563459363200] Invalid DTS: 1059670 PTS: 1056670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1954050, dts=1957050, size=935[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1960050, dts=1963050, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1065670 PTS: 1062670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1960050, dts=1963050, size=1224[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1966050, dts=1969050, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1071670 PTS: 1068670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1966050, dts=1969050, size=1136[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1972050, dts=1975050, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1077670 PTS: 1074670 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1972050, dts=1975050, size=1258[mp4 @ 0x563459363200] Invalid DTS: 1083670 PTS: 1080670 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1984200, dts=1987200, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1984200, dts=1987200, size=1080[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1990200, dts=1993200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1990200, dts=1993200, size=1356[mp4 @ 0x563459363200] Invalid DTS: 1095820 PTS: 1092820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1101820 PTS: 1098820 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=1996200, dts=1999200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=1996200, dts=1999200, size=1264[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2002200, dts=2005200, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1107820 PTS: 1104820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2002200, dts=2005200, size=1231[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2008200, dts=2011200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2008200, dts=2011200, size=1270[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2014200, dts=2017200, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1113820 PTS: 1110820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1119820 PTS: 1116820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2014200, dts=2017200, size=1055[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2020200, dts=2023200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2020200, dts=2023200, size=1366[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2026200, dts=2029200, size=893[mp4 @ 0x563459363200] Invalid DTS: 1125820 PTS: 1122820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2026200, dts=2029200, size=825[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2032200, dts=2035200, size=1445[mp4 @ 0x563459363200] Invalid DTS: 1131820 PTS: 1128820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2032200, dts=2035200, size=1303[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2038200, dts=2041200, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1137820 PTS: 1134820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2038200, dts=2041200, size=1200[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2044200, dts=2047200, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1143820 PTS: 1140820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2044200, dts=2047200, size=913[mp4 @ 0x563459363200] Invalid DTS: 1149820 PTS: 1146820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1155820 PTS: 1152820 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2056200, dts=2059200, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2056200, dts=2059200, size=1193[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2062200, dts=2065200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2062200, dts=2065200, size=1265[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2068200, dts=2071200, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1167820 PTS: 1164820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1173820 PTS: 1170820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2068200, dts=2071200, size=1206[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2074200, dts=2077200, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2074200, dts=2077200, size=1092[mp4 @ 0x563459363200] Invalid DTS: 1179820 PTS: 1176820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1185820 PTS: 1182820 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2080200, dts=2083200, size=1445[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2080200, dts=2083200, size=1435[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2086200, dts=2089200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2086200, dts=2089200, size=1292[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2092200, dts=2095200, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1191820 PTS: 1188820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1197820 PTS: 1194820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2092200, dts=2095200, size=1092[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2098200, dts=2101200, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2098200, dts=2101200, size=1253[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2104200, dts=2107200, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2104200, dts=2107200, size=1021[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2110200, dts=2113200, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1203820 PTS: 1200820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1209820 PTS: 1206820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1215820 PTS: 1212820 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2110200, dts=2113200, size=1391[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2116200, dts=2119200, size=893[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2116200, dts=2119200, size=860[mp4 @ 0x563459363200] Invalid DTS: 1221820 PTS: 1218820 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1227820 PTS: 1224820 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2128200, dts=2131350, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2128200, dts=2131350, size=1199[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2134350, dts=2137350, size=893.56x    [hls @ 0x563459342040] Invalid timestamps stream=0, pts=2134350, dts=2137350, size=944[mp4 @ 0x563459363200] Invalid DTS: 1239970 PTS: 1236820 in output stream 0:0, replacing by guess[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2140350, dts=2143350, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1245970 PTS: 1242970 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2140350, dts=2143350, size=1216[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2146350, dts=2149350, size=157[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2146350, dts=2149350, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1251970 PTS: 1248970 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2146350, dts=2149350, size=1149[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2152350, dts=2155350, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1257970 PTS: 1254970 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2152350, dts=2155350, size=1298[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2158350, dts=2161350, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2158350, dts=2161350, size=1100[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2164350, dts=2167350, size=1077[mp4 @ 0x563459363200] Invalid DTS: 1263970 PTS: 1260970 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2164350, dts=2167350, size=1065[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2170350, dts=2173350, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2170350, dts=2173350, size=1358[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2176350, dts=2179350, size=1261[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2176350, dts=2179350, size=1257[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2182350, dts=2185350, size=1077[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2182350, dts=2185350, size=1202[mpegts @ 0x56345935c4c0] Invalid timestamps stream=0, pts=2188350, dts=2191350, size=1261[mp4 @ 0x563459363200] Invalid DTS: 1269970 PTS: 1266970 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1275970 PTS: 1272970 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1281970 PTS: 1278970 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1287970 PTS: 1284970 in output stream 0:0, replacing by guess[mp4 @ 0x563459363200] Invalid DTS: 1293970 PTS: 1290970 in output stream 0:0, replacing by guess[hls @ 0x563459342040] Invalid timestamps stream=0, pts=2188350, dts=2191350, size=1270[mp4 @ 0x563459363200] Invalid DTS: 1299970 PTS: 1296970 in output stream 0:0, replacing by guessframe=  432 fps=248 q=-1.0 Lsize=    1136kB time=00:00:14.44 bitrate= 644.2kbits/s speed=8.29x    video:1099kB audio:20kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 1.557765%[aac @ 0x5634593649c0] Qavg: 65403.508Exiting normally, received signal 2.\nctrl+c 停止后，ls，可以看到目录下存在1.mp4文件，可以播放文件看看效果\n\n","slug":"其他/vs2017编译FFmpeg","date":"2023-05-11T11:52:25.000Z","categories_index":"音视频编码","tags_index":"FFmpeg","author_index":"阿木大叔"},{"id":"3ab7f0783815eb0913f3bccc1c62e62d","title":"开源项目推荐","content":"Qt开源项目推荐排名不分先后\nQWidgetDemo\n作者：飞扬青云\n项目简介：Qt编写的一些开源的demo，支持Qt4、Qt5、Qt6，支持任意系统，预计会有100多个，一直持续更新完善，代码简洁易懂注释详细，每个都是独立项目，非常适合初学者，代码随意传播使用，拒绝打赏和捐赠，欢迎留言评论！\n项目地址：https://gitee.com/feiyangqingyun/QWidgetDemo\n推荐理由：QWidget入门必备\n\nqt-material-widgets\n作者：laserpants\n项目简介：qt-material-widgets是一款基于 Qt 框架的 UI 组件库，旨在为桌面应用程序提供现代化和美观的 Material Design 风格。它是使用 C++ 和 Qt 开发的，并可以与 Qt 5.x 和 Qt 6.x 版本兼容。该组件库提供了丰富的 UI 控件和样式，包括按钮、复选框、文本输入框、弹出菜单等常见控件。此外，它还提供了多种主题和颜色方案，可帮助用户自定义界面和主题风格。所有的控件和样式都符合 Material Design 设计规范，使得你可以在使用中获得更好的用户体验和视觉效果。qt-material-widgets 的代码是开源的，托管在 GitHub 上，发布的版本包括 .zip 归档文件和源代码。官方网站上也提供了详细的文档和示例，以帮助开发人员初步了解和使用该组件库。如果你使用 Qt 开发桌面应用程序，并想要实现 Material Design 风格的用户界面，可以考虑使用 qt-material-widgets 这个组件库。\n项目地址：https://github.com/laserpants/qt-material-widgets\n推荐理由：Qt界面框架深层次理解 （可惜后面不维护了，但是依然值得学习）\n\nTaoQuick\n作者：武威的涛哥\n项目简介：一套酷炫的QtQuick&#x2F;Qml基础库和示例(a cool QtQuick&#x2F;qml component library and demo)\n项目地址：https://gitee.com/jaredtao/TaoQuick\n推荐理由：QtQuick&#x2F;Qml入门必备\n\nQtAv\n作者：wang-bin\n项目简介：QtAV is a multimedia playback library based on Qt and FFmpeg. It can help you to write a player with less effort than ever before.QtAV has been added to FFmpeg projects page http://ffmpeg.org/projects.htmlQtAV is free software licensed under the term of LGPL v2.1. The player example is licensed under GPL v3. If you use QtAV or its constituent libraries, you must adhere to the terms of the license in question.\n项目地址：https://github.com/wang-bin/QtAV\n推荐理由：Qt实现高性能播放器，整体工程结构值得一看\n\nWeComCopy\n作者：阿木大叔\n项目简介：Qt 模仿企业微信界面 本项目为Qt实现企业微信界面项目，纯界面逻辑，不包含真实业务逻辑。主要用于学习QWidget的使用，包含绘制，布局，信号，事件，重写，多线程，qss等技术使用。\n项目地址：https://gitee.com/hudejie/wecom-copy\n推荐理由：Qt界面入门项目，值得新手学习，并且主页开源多个Qt相关项目，适合新手学习锻炼。主页地址：https://gitee.com/hudejie\n\nC&#x2F;C++开源项目推荐libevent\n作者：Nirvanaliu\n项目简介：libevent是一个轻量级的开源高性能网络库\n项目地址：https://github.com/libevent/libevent\n推荐理由：\n事件驱动（event-driven），高性能;\n轻量级，专注于网络，不如ACE那么臃肿庞大；\n源代码相当精炼、易读；\n跨平台，支持Windows、Linux、BSD和Mac Os；\n支持多种I&#x2F;O多路复用技术， epoll、poll、dev&#x2F;poll、select和kqueue等；\n支持I&#x2F;O，定时器和信号等事件；\n注册事件优先级；\nlibevent已经被广泛的应用，作为底层的网络库；比如memcached、Vomit、Nylon、Netchat等等。\n\n\n\nHP-Socket\n作者：伤神小怪兽\n项目简介：HP-Socket 是一套通用的高性能 TCP&#x2F;UDP&#x2F;HTTP 通信框架，包含服务端组件、客户端组件和Agent组件，广泛适用于各种不同应用场景的 TCP&#x2F;UDP&#x2F;HTTP 通信系统，提供 C&#x2F;C++、C#、Delphi、E（易语言）、Java、Python 等编程语言接口。HP-Socket 对通信层实现完全封装，应用程序不必关注通信层的任何细节；HP-Socket 提供基于事件通知模型的 API 接口，能非常简单高效地整合到新旧应用程序中。\n项目地址：https://gitee.com/ldcsaa/HP-Socket\n推荐理由：高性能socket框架，代码框架及代码规范值得学习\n\n","slug":"开源项目/开源项目推荐","date":"2023-05-08T02:27:52.000Z","categories_index":"开源项目","tags_index":"c++","author_index":"阿木大叔"},{"id":"d2b5059492d6e2887d56c31f82cb8443","title":"【转载】Qt开发经验-飞扬青云","content":"原文地址：https://gitee.com/feiyangqingyun/qtkaifajingyan\n1 开发经验01：001-010\n当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。比如我们可能就写错了一行代码，编译提示几百个错误，你只要把这一行纠正了，其他错误也就没了。\n\n定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。\n1234//异步执行load函数QMetaObject::invokeMethod(this, &quot;load&quot;, Qt::QueuedConnection);//延时10毫秒执行load函数QTimer::singleShot(10, this, SLOT(load()));\n\n默认QtCreator是单线程编译，可能设计之初考虑到尽量不过多占用系统资源，而现在的电脑都是多核心的，默认msvc编译器是多线程编译的不需要手动设置，而对于其他编译器，需要手动设置才行。\n\n\n\n方法一：在每个项目的构建设置中（可以勾选一个 shadow build 的页面地方）的build步骤，make arguments增加一行 -j16 即可，此设置会保存在pro.user文件中，一旦删除就需要重新设置，不建议此方法；\n方法二：在构建套件的环境中增加，工具-&gt;选项-&gt;构建套件(kits)-&gt;选中一个构建套件-&gt;environment-&gt;右侧change按钮-&gt;打开的输入框中填入 MAKEFLAGS&#x3D;-j4 ， 这样就可以不用每次设置多线程编译，只要是应用该构件套件的项目都会加上这个编译参数；\n注意：-j后面接的是电脑的核心数，写多了不会有效果，要自己看下电脑的参数，或者填个-j4就行，毕竟现在电脑4核心应该是最基本的；\n大概从2019年开始的新版本的QtCreator默认已经会根据电脑的核心自动设置多线程编译，比如识别到你的电脑是16核心的就会默认设置-j16参数进行编译；\nQtCreator8版本开始，选项配置菜单从工具移到了编辑菜单中，很多人有点不适应说怎么没有了，其实稍微鼠标划一划找一找就看到了。\n\n\n如果你想顺利用QtCreator部署安卓程序，首先你要在 Android Studio 里面配置成功，编译一个程序能够在手机上或者模拟器中跑起来，把坑全部趟平。\n\n很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了，比如QString、QColor的重载参数极其丰富，很多你做梦都想要的功能就在里面。\n\n可以在pro文件中写上版本号、程序图标、产品名称、版权所有、文件说明等信息（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件。对于早期的Qt4版本你可以手动写rc文件实现。\n12345678910#程序版本VERSION  = 2025.10.01#程序图标RC_ICONS = main.ico#产品名称QMAKE_TARGET_PRODUCT = quc#版权所有QMAKE_TARGET_COPYRIGHT = feiyangqingyun#文件说明QMAKE_TARGET_DESCRIPTION = QQ: 517216493  WX: feiyangqingyun\n\n管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。\n12QMAKE_LFLAGS += /MANIFESTUAC:&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot; #以管理员运行QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,&quot;5.01&quot; #VS2013 在XP运行\n\n运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上一行CONFIG +&#x3D; console，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的。\n1234567TEMPLATE    = appMOC_DIR     = temp/mocRCC_DIR     = temp/rccUI_DIR      = temp/uiOBJECTS_DIR = temp/obj#就是下面这行用来设置运行文件附带调试输出窗口CONFIG      += console\n\n绘制平铺背景QPainter::drawTiledPixmap，绘制圆角矩形QPainter::drawRoundedRect()，而不是QPainter::drawRoundRect()，这两个函数非常容易搞混。\n\n指定控件移除旧的样式。\n123456//移除原有样式style()-&gt;unpolish(ui-&gt;btn);//必须要有下面这行不然还是不会卸载ui-&gt;btn-&gt;setStyleSheet(&quot;&quot;);//重新设置新的该控件的样式。style()-&gt;polish(ui-&gt;btn);\n\n02：011-020\n获取类的属性和方法\n123456789101112131415161718192021222324252627//拿到控件元对象const QMetaObject *metaObject = widget-&gt;metaObject();//所有属性的数量int propertyCount = metaObject-&gt;propertyCount();//propertyOffset是自定义的属性开始的位置int propertyOffset = metaObject-&gt;propertyOffset();//循环取出控件的自定义属性, int i = 0 表示所有属性for (int i = propertyOffset; i &lt; propertyCount; ++i) &#123;    QMetaProperty metaProperty = metaObject-&gt;property(i);    const char *name = metaProperty.name();    const char *type = metaProperty.typeName();    QVariant value = widget-&gt;property(name);    qDebug() &lt;&lt; name &lt;&lt; type &lt;&lt; value;&#125;//所有方法的数量int methodCount = metaObject-&gt;methodCount();//methodOffset是自定义的方法开始的位置int methodOffset = metaObject-&gt;methodOffset();//循环取出控件的自定义方法, int i = 0 表示所有方法for (int i = methodOffset; i &lt; methodCount; ++i) &#123;    QMetaMethod metaMethod = metaObject-&gt;method(i);    const char *name = metaMethod.name();    const char *type = metaMethod.typeName();    qDebug() &lt;&lt; name &lt;&lt; type;&#125;\n\nQt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。\n123456789101112SP_TitleBarMenuButton,SP_TitleBarMinButton,SP_TitleBarMaxButton,SP_TitleBarCloseButton,SP_MessageBoxInformation,SP_MessageBoxWarning,SP_MessageBoxCritical,SP_MessageBoxQuestion,...//下面这样取出来使用就行QPixmap pixmap = this-&gt;style()-&gt;standardPixmap(QStyle::SP_TitleBarMenuButton);ui-&gt;label-&gt;setPixmap(pixmap);\n\n根据操作系统位数判断加载\n1234567win32 &#123;    contains(DEFINES, WIN64) &#123;        DESTDIR = $$PWD/../bin64    &#125; else &#123;         DESTDIR = $$PWD/../bin32    &#125;&#125;\n\nQt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。\n\n可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。\n123456QPushButton *btn = new QPushButton;btn-&gt;resize(30, ui-&gt;lineEdit-&gt;height());QHBoxLayout *layout = new QHBoxLayout(ui-&gt;lineEdit);layout-&gt;setMargin(0);layout-&gt;addStretch();layout-&gt;addWidget(btn);\n\n对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果。\n\n巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。\n123456//查找指定类名objectName的控件QList&lt;QWidget *&gt; widgets = fatherWidget.findChildren&lt;QWidget *&gt;(&quot;widgetname&quot;);//查找所有QPushButtonQList&lt;QPushButton *&gt; allPButtons = fatherWidget.findChildren&lt;QPushButton *&gt;();//查找一级子控件,不然会一直遍历所有子控件QList&lt;QPushButton *&gt; childButtons = fatherWidget.findChildren&lt;QPushButton *&gt;(QString(), Qt::FindDirectChildrenOnly);\n\n巧妙的使用inherits判断是否属于某种类。\n1234QTimer *timer = new QTimer;         // QTimer inherits QObjecttimer-&gt;inherits(&quot;QTimer&quot;);          // returns truetimer-&gt;inherits(&quot;QObject&quot;);         // returns truetimer-&gt;inherits(&quot;QAbstractButton&quot;); // returns false\n\n使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(“name”)取出对应的弱属性的值。\n\n在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。\n\n\n03：021-030\n如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可。\n\n善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。\n123456789QStringList listVideoOpenInterval, listVideoOpenIntervalx;listVideoOpenInterval &lt;&lt; &quot;0.0 秒&quot; &lt;&lt; &quot;0.1 秒&quot; &lt;&lt; &quot;0.3 秒&quot; &lt;&lt; &quot;0.5 秒&quot; &lt;&lt; &quot;1.0 秒&quot; &lt;&lt; &quot;2.0 秒&quot;;listVideoOpenIntervalx &lt;&lt; &quot;0&quot; &lt;&lt; &quot;100&quot; &lt;&lt; &quot;300&quot; &lt;&lt; &quot;500&quot; &lt;&lt; &quot;1000&quot; &lt;&lt; &quot;2000&quot;;for (int i = 0; i &lt; listVideoOpenInterval.count(); ++i) &#123;    ui-&gt;cboxVideoOpenInterval-&gt;addItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i));&#125;//取出对应的值int indexVideoOpenInterval = ui-&gt;cboxVideoOpenInterval-&gt;currentIndex();indexVideoOpenInterval = ui-&gt;cboxVideoOpenInterval-&gt;itemData(indexVideoOpenInterval).toInt();\n\n如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe、translations文件夹、resources文件夹，不然无法正常运行。\n\n在MFC程序或者VB&#x2F;C#等窗体程序中，每个控件都有一个句柄，而且用句柄工具移过去会自动识别，但是在Qt程序中默认Qt是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，在main函数中要做如下设置。\n12345int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    a.setAttribute(Qt::AA_NativeWindows);&#125;\n\nQt编写的Android程序防止程序被关闭。\n1234567#if defined(Q_OS_ANDROID)QAndroidService a(argc, argv);return a.exec()#elseQApplication a(argc, argv);return a.exec();#endif\n\n可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， \n1234*::down-arrow&#123;&#125;*::menu-indicator&#123;&#125;*::up-arrow:disabled&#123;&#125;*::up-arrow:off&#123;&#125;\n\n可以指定位置设置背景图片。\n123456QMainWindow &gt; .QWidget &#123;    background-color: gainsboro;    background-image: url(:/images/xxoo.png);    background-position: top right;    background-repeat: no-repeat&#125;\n\n嵌入式linux运行Qt程序\n1234567//Qt4写法./HelloQt -qws &amp;//Qt5写法 xcb 可以改成 linuxfb eglfs vnc wayland 等,有哪个就用哪个挨个测试./HelloQt --platform xcb./HelloQt --platform linuxfb./HelloQt --platform wayland\n\n如果发现QtCreator中的构建套件不正常了或者坏了（比如不能正确识别环境中的qmake或者编译器、打开项目不能正常生成影子构建目录），请找到两个目录（C:\\Users\\Administrator\\AppData\\Local\\QtProject、C:\\Users\\Administrator\\AppData\\Roaming\\QtProject）删除即可，删除后重新打开QtCreator进行构建套件的配置就行。\n\nQMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer（sudo apt-get install gstreamer1.0-libav ubuntu-restricted-extras），并未完整验证，报错提示 Your GStreamer installation is missing a plug-in，需要命令安装 sudo apt-get install ubuntu-restricted-extras）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）。\n\n\n04：031-040\n判断编译器类型、编译器版本、操作系统。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//GCC编译器#ifdef __GNUC__#if __GNUC__ &gt;= 3   // GCC3.0  以上//MSVC编译器#ifdef _MSC_VER#if _MSC_VER &gt;=1000 // VC++4.0 以上#if _MSC_VER &gt;=1100 // VC++5.0 以上#if _MSC_VER &gt;=1200 // VC++6.0 以上#if _MSC_VER &gt;=1300 // VC2003  以上#if _MSC_VER &gt;=1400 // VC2005  以上#if _MSC_VER &gt;=1500 // VC2008  以上#if _MSC_VER &gt;=1600 // VC2010  以上#if _MSC_VER &gt;=1700 // VC2012  以上#if _MSC_VER &gt;=1800 // VC2013  以上#if _MSC_VER &gt;=1900 // VC2015  以上//Visual Studio版本与MSVC版本号的对应关系MSC    1.0   _MSC_VER == 100MSC    2.0   _MSC_VER == 200MSC    3.0   _MSC_VER == 300MSC    4.0   _MSC_VER == 400MSC    5.0   _MSC_VER == 500MSC    6.0   _MSC_VER == 600MSC    7.0   _MSC_VER == 700MSVC++ 1.0   _MSC_VER == 800MSVC++ 2.0   _MSC_VER == 900MSVC++ 4.0   _MSC_VER == 1000 (Developer Studio 4.0)MSVC++ 4.2   _MSC_VER == 1020 (Developer Studio 4.2)MSVC++ 5.0   _MSC_VER == 1100 (Visual Studio 97 version 5.0)MSVC++ 6.0   _MSC_VER == 1200 (Visual Studio 6.0 version 6.0)MSVC++ 7.0   _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0)MSVC++ 7.1   _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1)MSVC++ 8.0   _MSC_VER == 1400 (Visual Studio 2005 version 8.0)MSVC++ 9.0   _MSC_VER == 1500 (Visual Studio 2008 version 9.0)MSVC++ 10.0  _MSC_VER == 1600 (Visual Studio 2010 version 10.0)MSVC++ 11.0  _MSC_VER == 1700 (Visual Studio 2012 version 11.0)MSVC++ 12.0  _MSC_VER == 1800 (Visual Studio 2013 version 12.0)MSVC++ 14.0  _MSC_VER == 1900 (Visual Studio 2015 version 14.0)MSVC++ 14.1  _MSC_VER == 1910 (Visual Studio 2017 version 15.0)MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3)MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5)MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6)MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7)MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8)MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9)MSVC++ 14.2  _MSC_VER == 1920 (Visual Studio 2019 Version 16.0)MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1)MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2)MSVC++ 14.30 _MSC_VER == 1930 (Visual Studio 2022 Version 17.0)MSVC++ 14.31 _MSC_VER == 1931 (Visual Studio 2022 Version 17.1)MSVC++ 14.32 _MSC_VER == 1932 (Visual Studio 2022 Version 17.2)//Borland C++#ifdef __BORLANDC__//Cygwin#ifdef __CYGWIN__#ifdef __CYGWIN32__//mingw#ifdef __MINGW32__//windows#ifdef _WIN32           //32bit#ifdef _WIN64           //64bit#ifdef _WINDOWS         //图形界面程序#ifdef _CONSOLE         //控制台程序//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了#if (WINVER &gt;= 0x030a)  // Windows 3.1以上#if (WINVER &gt;= 0x0400)  // Windows 95/NT4.0以上#if (WINVER &gt;= 0x0410)  // Windows 98以上#if (WINVER &gt;= 0x0500)  // Windows Me/2000以上#if (WINVER &gt;= 0x0501)  // Windows XP以上#if (WINVER &gt;= 0x0600)  // Windows Vista以上//_WIN32_WINNT 内核版本#if (_WIN32_WINNT &gt;= 0x0500) // Windows 2000以上#if (_WIN32_WINNT &gt;= 0x0501) // Windows XP以上#if (_WIN32_WINNT &gt;= 0x0600) // Windows Vista以上\n\n在pro中判断Qt版本及构建套件位数\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#打印版本信息message(qt version: $$QT_VERSION)#判断当前qt版本号QT_VERSION = $$[QT_VERSION]QT_VERSION = $$split(QT_VERSION, &quot;.&quot;)QT_VER_MAJ = $$member(QT_VERSION, 0)QT_VER_MIN = $$member(QT_VERSION, 1)#下面是表示 Qt5.5及以上版本greaterThan(QT_VER_MAJ, 4) &#123;greaterThan(QT_VER_MIN, 4) &#123;#自己根据需要做一些处理&#125;&#125;#QT_ARCH是Qt5新增的,在Qt4上没效果#打印当前Qt构建套件的信息message($$QT_ARCH)#表示arm平台构建套件contains(QT_ARCH, arm) &#123;&#125;#表示32位的构建套件contains(QT_ARCH, i386) &#123;&#125;#表示64位的构建套件contains(QT_ARCH, x86_64) &#123;&#125;#其实Qt内置了主版本号和子版本号变量#判断当前qt版本号message($$QT_ARCH : $$QT_VERSION -&gt; $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)#下面的含义是如果版本 &lt; 4.8lessThan(QT_MAJOR_VERSION, 5) &#123;lessThan(QT_MINOR_VERSION, 8) &#123;#这里放要做的处理&#125;&#125;#下面的含义是如果版本 &lt; 5.12.0REQ_QT_MAJOR = 5REQ_QT_MINOR = 12REQ_QT_PATCH = 0lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) &#123;#这里放要做的处理&#125;#下面的含义是如果版本 &gt;= 5.5greaterThan(QT_MAJOR_VERSION, 4) &#123;greaterThan(QT_MINOR_VERSION, 4) &#123;#这里放要做的处理&#125;&#125;//代码中判断版本不要太简单#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))//这里放要做的处理#endif//下面表示 &gt;= 5.0.0#if QT_VERSION &gt;= 0x050000...#endif//下面表示 &lt; 5.12.10#if QT_VERSION &lt; 0x050C0A...#endif\n\nQt最小化后恢复界面可能会出现假死冻结现象，加上代码\n12345void showEvent(QShowEvent *e)&#123;    setAttribute(Qt::WA_Mapped);    QWidget::showEvent(e);&#125;\n\n获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆，有一堆玩意在里面。\n\n设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面。\n1234#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,6,0))    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);#endif    QApplication a(argc, argv);\n\n如果运行程序出现 Fault tolerant heap shim applied to current process. This is usually due to previous crashes. 错误。\n\n\n\n第一步：输入命令 regedit 打开注册表；\n第二步：找到节点 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers\\；\n第三步：选中Layers键值，从右侧列表中删除自己的那个程序路径即可。\n\n\nQt内置了QFormLayout表单布局用于自动生成标签+输入框的组合的表单界面，设置布局用的很少，一般用的最多的是横向布局、垂直布局、表格布局。\n\nqml播放视频在linux需要安装 sudo apt-get install libpulse-dev。\n\n可以直接继承QSqlQueryModel实现自定义的QueryModel，比如某一列字体颜色，占位符，其他样式等，重写QVariant CustomSqlModel::data(const QModelIndex &amp;index, int role) const。\n\nQt5以后提供了类QScroller直接将控件滚动。\n1234567891011//禁用横向滚动条ui-&gt;listWidget-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//禁用纵向滚动条ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//设置横向按照像素值为单位滚动ui-&gt;listWidget-&gt;setHorizontalScrollMode(QListWidget::ScrollPerPixel);//设置纵向按照像素值为单位滚动ui-&gt;listWidget-&gt;setVerticalScrollMode(QListWidget::ScrollPerPixel);//设置滚动对象以及滚动方式为鼠标左键拉动滚动QScroller::grabGesture(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);//还有个QScrollerProperties可以设置滚动的一些参数\n\n05：041-050\n如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。\n12QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);db.setDatabaseName(&quot;:memory:&quot;);\n\n清空数据表并重置自增ID，sql &#x3D; truncate table table_name。\n\nQtChart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。\n123#include &lt;QChartView&gt;QT_CHARTS_USE_NAMESPACEclass CustomChart : public QChartView\n\nQPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;}\n\nQLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。\n123456//常规办法ui-&gt;label-&gt;setText(&quot;hello&quot;);//取巧办法ui-&gt;label-&gt;setProperty(&quot;text&quot;, &quot;hello&quot;);//属性大法ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-text:hello;&quot;);\n\n巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行。\n123QEventLoop loop;connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));loop.exec();\n\nQt中也支持多种预定义变量组合判断，去掉生成空的debug和release目录，在pro文件中加一行 CONFIG -&#x3D; debug_and_release。\n123456789101112131415161718192021#if defined(Q_OS_ANDROID) || defined(Q_OS_IOS)#endif#if !defined(Q_OS_ANDROID) &amp;&amp; !defined(Q_OS_IOS)#endif#ifdef Q_OS_WIN//windows系统#else//非windows系统#endif//下面写法编译会报错#ifdef Q_OS_WIN#elif Q_OS_LINUX#endif//正确写法#if defined(Q_OS_WIN)#elif defined(Q_OS_LINUX)#endif\n\n新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model。\n\nQSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。如果数据量很小，也可以采用如下方法：\n1234//主动加载所有数据,不然获取到的行数&lt;=256while(model-&gt;canFetchMore()) &#123;    model-&gt;fetchMore();&#125;\n\n如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，比如自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)，这样会保留一个系统白边框。\n\n\n06：051-060\n在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。\n12QString content = &quot;测试中文&quot;;QString note = content.toUtf8().toPercentEncoding();\n\nQt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。CONFIG +&#x3D; resources_big\n\nQt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。\n\n\n\n方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true);\n方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。\n方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。1234567void Widget::paintEvent(QPaintEvent *)&#123;    QStyleOption option;    option.initFrom(this);    QPainter painter(this);    style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;option, &amp;painter, this);&#125;\n\n\n有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。\n\n在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。\n\n在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方不能立即识别或者要很久（一般至少要30s）才能识别到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。\n123456789int fd = tcpSocket-&gt;socketDescriptor();int keepAlive = 1;      //开启keepalive属性,缺省值:0(关闭)int keepIdle = 5;       //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)int keepInterval = 2;   //探测时发探测包的时间间隔为2秒,缺省值:75(s)int keepCount = 2;      //探测重试的次数,全部超时则认定连接失效,缺省值:9(次)setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&amp;keepAlive, sizeof(keepAlive));setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));\n\n如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。\n\n非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的（后面发现我在刚学Qt的时候也发布了一些demo到网上也是tr包含中文的，当时就狠狠的打了自己一巴掌），tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。\n\n很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。\n\n超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a &#x3D;&#x3D; 123) 要写成 if (123 &#x3D;&#x3D; a)，值在前面，再比如 if (ok &#x3D;&#x3D; true) 要写成 if (ok)，if (ok &#x3D;&#x3D; false) 要写成 if (!ok)等。\n\n\n07：061-070\n很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。\n\n对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多。\n\nQt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。\n\nQt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。\n\n在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。\n1234QRect rect(-radius, -radius, radius * 2, radius * 2);//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形painter-&gt;drawArc(rect, 0, 360 * 16);painter-&gt;drawEllipse(rect);\n\n不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。\n\n很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。\n\n很多控件都带有viewport，比如QTextEdit&#x2F;QTableWidget&#x2F;QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(“background-color:transparent;”);而不是scrollArea-&gt;setStyleSheet(“QScrollArea{background-color:transparent;}”);\n\n有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true);\n\nQt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。\n12345678910QDateTime dateTime;QString dateTime_str = dateTime.currentDateTime().toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);//从字符串转换为毫秒（需完整的年月日时分秒）datetime.fromString(&quot;2011-09-10 12:07:50:541&quot;, &quot;yyyy-MM-dd hh:mm:ss:zzz&quot;).toMSecsSinceEpoch();//从字符串转换为秒（需完整的年月日时分秒）datetime.fromString(&quot;2011-09-10 12:07:50:541&quot;, &quot;yyyy-MM-dd hh:mm:ss:zzz&quot;).toTime_t();//从毫秒转换到年月日时分秒datetime.fromMSecsSinceEpoch(1315193829218).toString(&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;);//从秒转换到年月日时分秒（若有zzz，则为000）datetime.fromTime_t(1315193829).toString(&quot;yyyy-MM-dd hh:mm:ss[:zzz]&quot;);\n\n08：071-080\n在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。\n\n如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。\n123QDialog dialog;dialog.setWindowModality(Qt::WindowModal);dialog.exec();\n\n安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns);\n\n在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。\n\n将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。\n\n心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会一定程度上激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。\n\n在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。\n12345678910//实例化进度条控件QProgressBar *progress = new QProgressBar;//增加widget+布局巧妙实现居中QWidget *widget = new QWidget;QHBoxLayout *layout = new QHBoxLayout;layout-&gt;setSpacing(0);layout-&gt;setMargin(0);layout-&gt;addWidget(progress);widget-&gt;setLayout(layout);ui-&gt;tableWidget-&gt;setCellWidget(0, 0, widget);\n\n很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。\n123//根据背景色自动计算合适的前景色double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;QColor textColor = gray &gt; 0.5 ? Qt::black : Qt::white;\n\n对QTableView、QTableWidget、QTreeView、QTreeWidget禁用列拖动。\n1234567#if (QT_VERSION &lt; QT_VERSION_CHECK(5,0,0))    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setResizeMode(0, QHeaderView::Fixed);    ui-&gt;treeView-&gt;header()-&gt;setResizeMode(0, QHeaderView::Fixed);#else    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Fixed);    ui-&gt;treeView-&gt;header()-&gt;setSectionResizeMode(0, QHeaderView::Fixed);#endif\n\n从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0\n\n\n09：081-090\nQt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。\n123QColor color(255, 0, 0, 100);qDebug() &lt;&lt; color.name() &lt;&lt; color.name(QColor::HexArgb);//输出 #ff0000 #64ff0000\n\nQVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。\n12345if (variant.typeName() == &quot;QColor&quot;) &#123;    QColor color = variant.value&lt;QColor&gt;();    QFont font = variant.value&lt;QFont&gt;();    QString nodeValue = color.name(QColor::HexArgb);&#125;\n\nQt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。\n\nQt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。\n\nQTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。\n\nQt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。Qt5.7以后提供了内置的输入法，可以通过在main函数最前面加上 qputenv(“QT_IM_MODULE”, QByteArray(“qtvirtualkeyboard”)); 来启用。\n\n在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0);\n\nQt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT +&#x3D; gui-private才能使用。\n12345678910111213141516171819202122232425#include &quot;QtGui/private/qzipreader_p.h&quot;#include &quot;QtGui/private/qzipwriter_p.h&quot;QZipReader reader(dirPath);QString path(&quot;&quot;);//解压文件夹到当前目录reader.extractAll(path);//文件夹名称QZipReader::FileInfo fileInfo = reader.entryInfoAt(0);//解压文件QFile file(filePath);file.open(QIODevice::WriteOnly);file.write(reader.fileData(QString::fromLocal8Bit(&quot;%1&quot;).arg(filePath)));file.close();reader.close();QZipWriter *writer = new QZipWriter(dirPath);//添加文件夹writer-&gt;addDirectory(unCompress);//添加文件QFile file(filePath);file.open(QIODevice::ReadOnly);writer-&gt;addFile(data, file.readAll());file.close();writer-&gt;close();\n\n理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。\n\n在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。\n\n\n10：091-100\n数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。\n\n新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。\n12345#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))    void incomingConnection(qintptr handle);#else    void incomingConnection(int handle);#endif\n\nQt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。\n\nQWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。\n123456#if (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))    //下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);    //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);#endif    QApplication a(argc, argv);\n另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素\n1234QRect rect = qApp-&gt;desktop()-&gt;geometry();rect.setY(-1);rect.setHeight(rect.height());this-&gt;setGeometry(rect);\n\nQStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。\n1QStyle::sliderValueFromPosition(minimum(), maximum(), event-&gt;x(), width());\n\n用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。\n123456789101112131415161718//从文件加载英文属性与中文属性对照表QFile file(&quot;:/propertyname.txt&quot;);if (file.open(QFile::ReadOnly)) &#123;    //QTextStream方法读取速度至少快百分之30#if 0    while(!file.atEnd()) &#123;        QString line = file.readLine();        appendName(line);    &#125;#else    QTextStream in(&amp;file);    while (!in.atEnd()) &#123;        QString line = in.readLine();        appendName(line);    &#125;#endif    file.close();&#125;\n\n用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。\n123456789101112131415161718192021222324252627282930void frmMain::initStyle()&#123;    //加载样式表    QString qss;    //QFile file(&quot;:/qss/psblack.css&quot;);    //QFile file(&quot;:/qss/flatwhite.css&quot;);    QFile file(&quot;:/qss/lightblue.css&quot;);    if (file.open(QFile::ReadOnly)) &#123;#if 1        //用QTextStream读取样式文件不用区分文件编码 带bom也行        QStringList list;        QTextStream in(&amp;file);        //in.setCodec(&quot;utf-8&quot;);        while (!in.atEnd()) &#123;            QString line;            in &gt;&gt; line;            list &lt;&lt; line;        &#125;        qss = list.join(&quot;\\n&quot;);#else        //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开        qss = QLatin1String(file.readAll());#endif        QString paletteColor = qss.mid(20, 7);        qApp-&gt;setPalette(QPalette(QColor(paletteColor)));        qApp-&gt;setStyleSheet(qss);        file.close();    &#125;&#125;\n\nQString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。\n1234QString s1, s2;s1 = &quot;666.5567124&quot;;s2.setNum(888.5632123, &#x27;f&#x27;, 7);qDebug() &lt;&lt; qSetRealNumberPrecision(10) &lt;&lt; s1.toDouble() &lt;&lt; s2.toDouble();\n\n用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。\n123456while (it.hasNext()) &#123;    it.next();        if (it.flags() &amp; QScriptValue::SkipInEnumeration)             continue;         qDebug() &lt;&lt; it.name();&#125;\n\nsetPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。\n\n\n11：101-110\n如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免对已经显示区域的重新绘制。\n\n默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(“*{outline:0px;}”);\n\nQt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。\n1234567891011121314151617181920212223242526272829303132333435void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit)&#123;    //奇数偶数行颜色交替    tableView-&gt;setAlternatingRowColors(false);    //垂直表头是否可见    tableView-&gt;verticalHeader()-&gt;setVisible(headVisible);    //选中一行表头是否加粗    tableView-&gt;horizontalHeader()-&gt;setHighlightSections(false);    //最后一行拉伸填充    tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(true);    //行标题最小宽度尺寸    tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0);    //行标题最大高度    tableView-&gt;horizontalHeader()-&gt;setMaximumHeight(rowHeight);    //默认行高    tableView-&gt;verticalHeader()-&gt;setDefaultSectionSize(rowHeight);    //选中时一行整体选中    tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);    //只允许选择单个    tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection);    //表头不可单击#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))    tableView-&gt;horizontalHeader()-&gt;setSectionsClickable(false);#else    tableView-&gt;horizontalHeader()-&gt;setClickable(false);#endif    //鼠标按下即进入编辑模式    if (edit) &#123;        tableView-&gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);    &#125; else &#123;        tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);    &#125;&#125;\n\n在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则。\n12345678910TEMPLATE = subdirs#设置ordered参数以后会依次编译 projA projB projCCONFIG  += orderedSUBDIRS += projASUBDIRS += projBSUBDIRS += projC#还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projAprojB.depends = projAprojC.depends = projAprojD.depends = projC\n\nMSVC编译器的选择说明\n\n\n\n如果是32位的Qt则编译器选择x86开头的\n如果是64位的Qt则编译器选择amd64开头的\n具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构\n一般现在的电脑默认以64位的居多，选择amd64即可\n如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行\n诸葛大佬补充：x86&#x2F;x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。\n\n\n\n\n名称\n说明\n\n\n\nx86\n32&#x2F;64位系统上编译在32&#x2F;64位系统上运行\n\n\nx86_amd64\n32&#x2F;64位系统上编译在64位系统上运行\n\n\nx86_arm\n32&#x2F;64位系统上编译在arm系统上运行\n\n\namd64\n64位系统上编译在64位系统上运行\n\n\namd64_x86\n64位系统上编译在32&#x2F;64位系统上运行\n\n\namd64_arm\n64位系统上编译在arm系统上运行\n\n\n\n很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。\n12QDialog dialog;dialog.setWindowModality(Qt::WindowModal);\n\n很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。\n\n\n\n如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的；\n还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等；\n如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程；\n串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中；\n如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了；\n有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了；\n多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊；\n再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。\n\n\n在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。\n123456//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);//需要在show以后主动激活窗体w-&gt;show();w-&gt;activateWindow();\n\nQString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！\n\nQGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。\n\n\n12：111-120\n在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 &#x2F; 斜杠，而在windows上都是 \\ 两个反斜杠，Qt本身程序内部无论在win还是linux都支持 &#x2F; 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。\n1234567QString path = &quot;C:/temp/test.txt&quot;;path = QDir::toNativeSeparators(path);//输出 C:\\\\temp\\\\test.txtQString path = &quot;C:\\\\temp\\\\test.txt&quot;;path = QDir::toNativeSeparators(path);//输出 C:/temp/test.txt\n\n巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以。\n\n\n\ninvokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。\ninvokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！\n测试下来发现只能执行signals或者slots标识的方法。\n默认可以执行private(protected&#x2F;public) slots下的函数，但是不能执行private(protected&#x2F;public)下的函数。\n毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。\n2021-11-06补充：如果要执行private(protected&#x2F;public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。\n其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected&#x2F;public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。123456789101112131415161718192021222324252627282930//头文件声明信号和槽函数signals:    void sig_test(int type,double value);private slots:    void slot_test(int type, double value);private:    Q_INVOKABLE void fun_test(int type, double value);//构造函数关联信号槽connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));//单击按钮触发信号和槽，这里是同时举例信号槽都可以void MainWindow::on_pushButton_clicked()&#123;    QMetaObject::invokeMethod(this, &quot;sig_test&quot;, Q_ARG(int, 66), Q_ARG(double, 66.66));    QMetaObject::invokeMethod(this, &quot;slot_test&quot;, Q_ARG(int, 88), Q_ARG(double, 88.88));    QMetaObject::invokeMethod(this, &quot;fun_test&quot;, Q_ARG(int, 99), Q_ARG(double, 99.99));&#125;//会打印 66 66.66、88 88.88void MainWindow::slot_test(int type, double value)&#123;    qDebug() &lt;&lt; type &lt;&lt; value;&#125;//会打印 99 99.99void MainWindow::fun_test(int type, double value)&#123;    qDebug() &lt;&lt; type &lt;&lt; value;&#125;\n\n\nQt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。\n\nQt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装（也可以将在线安装好的离线文件打包拷贝到电脑上使用），估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。\n\n有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT +&#x3D; 的方式添加的模块，可以用 contains来判断。\n123456789101112131415qtHaveModule(webenginewidgets) &#123;message(&quot;当前Qt库有找到 webenginewidgets 模块&quot;)&#125;!qtHaveModule(webkit) &#123;message(&quot;当前Qt库没有找到 webkit 模块&quot;)&#125;contains(QT, network) &#123;message(&quot;当前项目已经引入 network 模块&quot;)&#125;!contains(QT, widgets) &#123;message(&quot;当前项目没有引入 widgets 模块&quot;)&#125;\n\nc++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\\，可以用于表示json字符串等场景。\n1234QString s1 = R&quot;(test\\001.jpg)&quot;;s1.replace(&quot;\\\\&quot;, &quot;#&quot;);qDebug()&lt;&lt; s1;//结果 test#001.jpg\n\n安卓上打印信息建议使用 qInfo() 而不是 qDebug() ，qInfo()才有效果。\n\nQt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer);\n\n\n\nQt::PreciseTimer 精确的定时器，尽量保持毫秒精度。\nQt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。\nQt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。\n精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。\n\n\nQGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用。\n\n用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以。\n\n\n13：121-130\nQLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。\n\n\n限制输入只能输入IP地址。\n限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。123456789101112131415161718192021222324252627//正在表达式限制输入QString str = &quot;\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b&quot;;ui-&gt;lineEdit-&gt;setValidator(new QRegExpValidator(QRegExp(str)));//用于占位ui-&gt;lineEdit-&gt;setInputMask(&quot;000.000.000.000&quot;);#if 0//下面代码设置浮点数范围限制失败ui-&gt;lineEdit-&gt;setValidator(new QDoubleValidator(20, 50, 1));#else//下面代码设置浮点数范围限制成功QDoubleValidator *validator = new QDoubleValidator(20, 50, 1);validator-&gt;setNotation(QDoubleValidator::StandardNotation);ui-&gt;lineEdit-&gt;setValidator(validator);#endif//下面代码设置整数范围限制成功ui-&gt;lineEdit-&gt;setValidator(new QIntValidator(10, 120));//其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋//需要来个万能的牛逼的 QRegExpValidator//限制浮点数输入范围为[-180,180]QRegExp regexp(&quot;^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$&quot;);//限制浮点数输入范围为[-90,90]并限定为小数位后4位QRegExp regexp(&quot;^-?(90|[1-8]?\\\\d(\\\\.\\\\d&#123;1,4&#125;)?)$&quot;);QRegExpValidator *validator = new QRegExpValidator(regexp, this);ui-&gt;lineEdit-&gt;setValidator(validator);\n\n\n在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp:&#x2F;&#x2F;58.200.131.2:1935&#x2F;livetv&#x2F;cctv1，会显示成 rtmp:&#x2F;&#x2F;…  ，而在旧版本的Qt中会显示成 rtmp:&#x2F;&#x2F;58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消。\n1234//取消自动换行tableView-&gt;setWordWrap(false);//超出文本不显示省略号tableView-&gt;setTextElideMode(Qt::ElideNone);\n\nQVideoWidget播放视频，可能会遇到画面闪烁的情况，播放视频的窗体需要设置个属性。\n12QVideoWidget *videoWidget = new QVideoWidget;videoWidget-&gt;setAttribute(Qt::WA_OpaquePaintEvent);\n\nQt bug成千上万，这个不用大惊小怪，也基本上遇不到，大部分都是特殊极端情况特定应用场景出现，甚至你会遇到有些是debug可以release报错，有些release可以debug却报错的情况，最神奇的还有先是debug报错，然后release正常，再返回去用debug又正常，需要用release激活一下！学习编程的路本来就是一条坑坑洼洼的路，不断填坑，尽量规避坑！很多时候很多看起来的坑其实是自己没有注意细节导致的。\n\nQt视图中默认排序是按照字符串的ASCII排序的，如果是IP地址的话会出现192.168.1.117排在192.168.1.2前面的情况，如果要规避这种情况，一种做法是取末尾的地址转成整型再比较大小，缺点是跨网段就歇菜了，又会出现192.168.2.65出现在192.168.1.70前面，终极大法是将IP地址转成整型再比较大小。\n12345678910111213141516171819QString QUIHelper::ipv4IntToString(quint32 ip)&#123;    QString result = QString(&quot;%1.%2.%3.%4&quot;).arg((ip &gt;&gt; 24) &amp; 0xFF).arg((ip &gt;&gt; 16) &amp; 0xFF).arg((ip &gt;&gt; 8) &amp; 0xFF).arg(ip &amp; 0xFF);    return result;&#125;quint32 QUIHelper::ipv4StringToInt(const QString &amp;ip)&#123;    int result = 0;    if (isIP(ip)) &#123;        QStringList list = ip.split(&quot;.&quot;);        int ip0 = list.at(0).toInt();        int ip1 = list.at(1).toInt();        int ip2 = list.at(2).toInt();        int ip3 = list.at(3).toInt();        result = ip3 | ip2 &lt;&lt; 8 | ip1 &lt;&lt; 16 | ip0 &lt;&lt; 24;    &#125;    return result;&#125;\n\n在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致。\n\nQt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出。\n12#禁用qdebug打印输出DEFINES += QT_NO_DEBUG_OUTPUT\n\n在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束。\n12345678qDebug() &lt;&lt; &quot;qDebug&quot;;qInfo() &lt;&lt; &quot;qInfo&quot;;qWarning() &lt;&lt; &quot;qWarning&quot;;qCritical() &lt;&lt; &quot;qCritical&quot;;qDebug(&quot;qDebug&quot;);qWarning(&quot;qWarning&quot;);qCritical(&quot;qCritical&quot;);\n\nQt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。\n12345678910111213141516171819#禁用qdebug打印输出DEFINES     += QT_NO_DEBUG_OUTPUT#自定义define变量 可以在整个项目中使用#pro文件可以这样判断 contains(DEFINES, videovlc) &#123;&#125;#代码文件可以这样判断 #ifdef videovlcDEFINES     += videovlc1 videoffmpeg#关闭编译警告提示 眼不见为净CONFIG      += warn_off#指定编译生成的文件到temp目录 分门别类存储MOC_DIR     = temp/mocRCC_DIR     = temp/rccUI_DIR      = temp/uiOBJECTS_DIR = temp/obj#指定编译生成的可执行文件到bin目录DESTDIR     = bin\n\nQt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理。\n123456789101112131415161718192021222324252627282930313233343536373839//主窗体头文件protected:    bool nativeEvent(const QByteArray &amp;eventType, void *message, long *result);#ifdef Q_OS_WIN    bool winEvent(MSG *message, long *result);#endif//主窗体实现函数#ifdef Q_OS_WIN#include &quot;Windows.h&quot;#endifbool frmMain::nativeEvent(const QByteArray &amp;eventType, void *message, long *result)&#123;    if (eventType == &quot;windows_generic_MSG&quot;) &#123;#ifdef Q_OS_WIN        MSG *msg = static_cast&lt;MSG *&gt;(message);        //qDebug() &lt;&lt; TIMEMS &lt;&lt; msg-&gt;message;        if (msg-&gt;wParam == PBT_APMSUSPEND &amp;&amp; msg-&gt;message == WM_POWERBROADCAST) &#123;            //系统休眠的时候自动最小化可以规避程序可能出现的问题            this-&gt;showMinimized();        &#125; else if (msg-&gt;wParam == PBT_APMRESUMEAUTOMATIC) &#123;            //休眠唤醒后自动打开            this-&gt;showNormal();        &#125;#endif    &#125; else if (eventType == &quot;NSEvent&quot;) &#123;#ifdef Q_OS_MACOS#endif    &#125;    return false;&#125;#ifdef Q_OS_WINbool frmMain::winEvent(MSG *message, long *result)&#123;    return nativeEvent(&quot;windows_generic_MSG&quot;, message, result);&#125;#endif\n\nQt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明。\n\n\n\nQMAKE_PRE_LINK    表示编译前执行内容\nQMAKE_POST_LINK   表示编译后执行内容123456789101112srcFile1 = $$PWD/1.txtsrcFile2 = $$PWD/2.txtdstDir = $$PWD/../bin#windows上需要转换路径斜杠 其他系统不需要srcFile1 = $$replace(srcFile1, /, \\\\);srcFile2 = $$replace(srcFile2, /, \\\\);dstDir = $$replace(dstDir, /, \\\\);#编译前执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开QMAKE_PRE_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir#编译后执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开QMAKE_POST_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir\n\n14：131-140\nQt新版本往往会带来一些头文件的更新，比如以前使用QPainter绘制，不需要额外包含QPainterPath头文件，而5.15版本开始就需要显示主动引入#include “qpainterpath.h”才行。\n\nQt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT +&#x3D; core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html。\n\nqDebug输出打印信息，默认会完整打印转义字符，例如：\\  &quot; \\t \\n” 等，所以当你发现你明明设置了转义字符以后打印确还是转义前的字符，这就懵逼了，其实这是qdebug为了方便调试将各种字符都打印输出。无可否认，很多时候，我们极其兴奋的享受着Qt带来的各种轮子各种便利，但是偶尔，稍不留意，这些便利可能也会坑你一把。要做的就是擦亮眼睛，时刻谨慎，一步一个脚印踏踏实实码代码。\n12345QString s1 = R&quot;(\\:device0)&quot;;//TNND居然输出的是 \\\\:device0qDebug() &lt;&lt; s1;//这次终于正确的输出 \\:device0qDebug().noquote() &lt;&lt; s1;\n\n很多人有疑问为何qss对浏览器控件中的网页样式没法控制，其实用屁股想想也知道，那玩意是html css去控制的，和Qt一毛钱关系也没有，根本管不着，如果想要对滚动条样式设置，可以在网页代码中设置样式就行。\n12345&lt;style type=&quot;text/css&quot;&gt;  ::-webkit-scrollbar&#123;width:0.8em;&#125;  ::-webkit-scrollbar-track&#123;background:rgb(241,241,241);&#125;  ::-webkit-scrollbar-thumb&#123;background:rgb(188,188,188);&#125;&lt;/style&gt;\n\nQt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件。\n1234567891011121314151617181920//设置了编码以后配置文件内容为 Company=上海物联网技术研究中心//没有设置编码则配置文件内容为 Company=\\xe4\\xb8\\x8a\\xe6\\xb5\\xb7\\xe7\\x89\\xa9\\xe8\\x81\\x94\\xe7\\xbd\\x91\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe7\\xa0\\x94\\xe7\\xa9\\xb6\\xe4\\xb8\\xad\\xe5\\xbf\\x83void App::readConfig()&#123;    QSettings set(App::ConfigFile, QSettings::IniFormat);    set.setIniCodec(&quot;utf-8&quot;);    set.beginGroup(&quot;AppConfig1&quot;);    App::Company = set.value(&quot;Company&quot;, App::Company).toString();    set.endGroup();&#125;void App::writeConfig()&#123;    QSettings set(App::ConfigFile, QSettings::IniFormat);    set.setIniCodec(&quot;utf-8&quot;);    set.beginGroup(&quot;AppConfig1&quot;);    set.setValue(&quot;Company&quot;, App::Company);    set.endGroup();&#125;\n\n用Qt做安卓开发都会遇到权限的问题，早期的安卓版本可以直接通过 AndroidManifest.xml 配置文件来添加需要的权限，这样在安装app的时候就会提示该app需要哪些权限让用户同意，现在的安卓版本都改成了动态权限，需要在app运行的时候弹出提示让用户确认再有权限，Qt迎合了这种策略内置了动态申请权限的方法 QtAndroid::requestPermissionsSync。\n12345678910111213141516171819202122232425262728//动态设置权限bool checkPermission(const QString &amp;permission)&#123;#ifdef Q_OS_ANDROID#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))    QtAndroid::PermissionResult result = QtAndroid::checkPermission(permission);    if (result == QtAndroid::PermissionResult::Denied) &#123;        QtAndroid::requestPermissionsSync(QStringList() &lt;&lt; permission);        result = QtAndroid::checkPermission(permission);        if (result == QtAndroid::PermissionResult::Denied) &#123;            return false;        &#125;    &#125;#endif#endif    return true;&#125;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);       //请求权限    checkPermission(&quot;android.permission.READ_EXTERNAL_STORAGE&quot;);    checkPermission(&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;);       return a.exec();&#125;\n\nQt重载qDebug输出自定义的信息。\n123456789101112131415struct FunctionInfo &#123;    QString function;    QString name;    QString groupEnabled;    QString action;    QString group;    friend QDebug operator &lt;&lt; (QDebug debug, const FunctionInfo &amp;functionInfo) &#123;        QString info = QString(&quot;功能: %1  名称: %2  启用: %3  方法: %4  分组: %5&quot;)                       .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)                       .arg(functionInfo.action).arg(functionInfo.group);        debug &lt;&lt; info;        return debug;    &#125;&#125;;\n\n对高分屏不同缩放比例的自适应处理方法。\n123456789101112131415161718192021222324252627282930//方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数#if (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    //开启高缩放支持以后图片可能发虚还要开启下面这个属性    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#endif//方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容[Platforms]WindowsArguments = dpiawareness=0//下面这行用来解决Qt高DPI下文字显示有锯齿的问题WindowsArguments = fontengine=freetype//2023-2-2 经过建波（简称JB大佬）亲测两行分开写没有效果，需要逗号分开WindowsArguments = dpiawareness=0, fontengine=freetype//方法3：在main函数最前面设置Qt内部的环境变量qputenv(&quot;QT_AUTO_SCREEN_SCALE_FACTOR&quot;, &quot;1.5&quot;);//方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放qputenv(&quot;QT_ENABLE_HIGHDPI_SCALING&quot;, &quot;1&quot;);QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);//禁用缩放//测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    QApplication::setAttribute(Qt::AA_Use96Dpi);#endif#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);#endif\n\nQTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮。\n123456789101112//对tabWidget设置无切换按钮ui-&gt;tabWidget-&gt;setUsesScrollButtons(false);//对tabBar设置无切换按钮ui-&gt;tabWidget-&gt;tabBar()-&gt;setUsesScrollButtons(false);//对整个系统的选项卡设置无切换按钮QTabBar&#123;qproperty-usesScrollButtons:false;&#125;//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔QTabBar&#123;qproperty-expanding:false;&#125;//设置选项卡关闭按钮可见QTabBar&#123;qproperty-tabsClosable:true;&#125;//还有其他属性参见QTabBar头文件有惊喜//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置\n\nQMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容。\n12//真的是做梦也没想到要这样设置QMainWindow::separator&#123;width:1px;height:1px;margin:1px;padding:1px;background:#FF0000;&#125;\n\n15：141-150\nQImage支持xpm图标，查看Qt内置的QStyle风格的代码中可以发现大量的xpm图标定义，通过代码的形式来产生图标，哇咔咔好牛逼。\n12345678910111213141516171819202122232425static const char * const imgData[] = &#123;    &quot;15 11 6 1&quot;,    &quot;   c None&quot;,    &quot;+  c #979797&quot;,    &quot;@  c #C9C9C9&quot;,    &quot;$  c #C1C1C1&quot;,    &quot;b  c None&quot;,    &quot;d  c None&quot;,    &quot; $++++++++$    &quot;,    &quot;$+bbbbbbbb+$   &quot;,    &quot;+b $$      +$  &quot;,    &quot;+b $@       +$ &quot;,    &quot;+b           +$&quot;,    &quot;+b           d+&quot;,    &quot;+b          d+$&quot;,    &quot;+b $$      d+$ &quot;,    &quot;+b $@     d+$  &quot;,    &quot;$+dddddddd+$   &quot;,    &quot; $++++++++$    &quot;&#125;;//这样就能直接显示一个箭头的图形QImage img(imgData);QLabel lab;lab.setPixmap(QPixmap::fromImage(img));lab.show();\n\n在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文。\n123456789int main(int argc, char *argv[])&#123;    //需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效#if (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))    QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);#endif    QApplication a(argc, argv);    ...&#125;\n\n关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题。\n\n\n\n第一步：代码文件选择用utf8编码带bom。\n第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。\n第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。12345678910111213141516void QUIHelper::setCode()&#123;#if (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))#if _MSC_VER    QTextCodec *codec = QTextCodec::codecForName(&quot;gbk&quot;);#else    QTextCodec *codec = QTextCodec::codecForName(&quot;utf-8&quot;);#endif    QTextCodec::setCodecForLocale(codec);    QTextCodec::setCodecForCStrings(codec);    QTextCodec::setCodecForTr(codec);#else    QTextCodec *codec = QTextCodec::codecForName(&quot;utf-8&quot;);    QTextCodec::setCodecForLocale(codec);#endif&#125;\n\n\n关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论。\n\n\nQt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一；\n是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的；\nmingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容；\n如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了；\n大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容；\n大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。\n本人测试的是widget部分，qml未做测试，不清楚是否机制一样；\n\n\n通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:&#x2F;&#x2F;&#x2F;‘ 开头，是的话则自动读取样式表文件进行设置，无需手动读取。\n1234567891011//以前都是下面的方法QFile file(&quot;:/qss/psblack.css&quot;);if (file.open(QFile::ReadOnly)) &#123;    QString qss = QLatin1String(file.readAll());    qApp-&gt;setStyleSheet(qss);    file.close();&#125;//其实一行代码就行qApp-&gt;setStyleSheet(&quot;file:///:/qss/psblack.css&quot;);//特别说明，只支持qApp-&gt;setStyleSheet 不支持其他比如widget-&gt;setStyleSheet\n\nQt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。\n1234567891011121314151617181920212223242526//打印子类类名集合void printObjectChild(const QObject *obj, int spaceCount)&#123;    qDebug() &lt;&lt; QString(&quot;%1%2 : %3&quot;)             .arg(&quot;&quot;, spaceCount)             .arg(obj-&gt;metaObject()-&gt;className())             .arg(obj-&gt;objectName());    QObjectList childs = obj-&gt;children();    foreach (QObject *child, childs) &#123;        printObjectChild(child, spaceCount + 2);    &#125;&#125;//拿到对话框进行设置和美化QFileDialog *fileDialog = new QFileDialog(this);fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, true);QLabel *lookinLabel = fileDialog-&gt;findChild&lt;QLabel*&gt;(&quot;lookInLabel&quot;);lookinLabel-&gt;setText(QString::fromLocal8Bit(&quot;文件目录：&quot;));lookinLabel-&gt;setStyleSheet(&quot;color:red;&quot;);//设置日期框默认值为空QLineEdit *edit = ui-&gt;dateEdit-&gt;findChild&lt;QLineEdit *&gt;(&quot;qt_spinbox_lineedit&quot;);if (!edit-&gt;text().isEmpty()) &#123;    edit-&gt;clear();&#125;\n\nQt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理。\n12345QFileDialog *fileDialog = new QFileDialog(this);//不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, true);qDebug() &lt;&lt; fileDialog-&gt;findChildren&lt;QLabel *&gt;();//打印输出 QLabel(0x17e2ff68, name=&quot;lookInLabel&quot;), QLabel(0x17e35f88, name=&quot;fileNameLabel&quot;), QLabel(0x17e35e68, name=&quot;fileTypeLabel&quot;)\n\nQtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息。\n\n\n\n菜单-&gt;工具-&gt;选项-&gt;文本编辑器-&gt;右侧tab页面片段(snippets)；\n组选择C++, 可以看到这里面已经内置了不少定义比如foreach，可以依葫芦画瓢；\n添加一个片段, 比如名字是fun, 触发种类是这个片段的简单描述；\n当我们在代码文件中键入fun时, 会自动弹出智能提醒, 选择我们的代码片段回车, 自动填充代码；\n按tab可以在变量间切换, 输入完成后回车, 完成编辑；12345678910/**  * @brief $name$  * @param $param$  * @author feiyangqingyun  * @date $date$  */$ret$ $name$($param$)&#123;    $$&#125;\n\n\nQt5时代对信号槽运行机制据说有了很大的改进。\n\n\n在Qt5之前，connect一般都只能这么写connect(sender, SIGNAL(signalFunc()), receiver, SLOT(receiveFunc()))，就是说在connect的时候，必须把信号用宏SIGNAL包裹起来，把槽函数用宏SLOT包裹起来，这样才能被Qt的Moc机制识别；\n在编译的时候即使信号或槽不存在或者参数不正确也不会报错，但是在执行的时候无效，会打印提示，对于C++这种静态语言来说，这是不友好的，不利于调试；\n但是Qt5之后更加推荐”取地址的写法”，采用这种写法，如果编译的时候信号或槽不存在是无法编译通过的，相当于编译时检查，不容易出错；\n如果没有历史遗留问题需要兼容Qt4的话，还是推荐用新写法，有类型检查更严格，而且支持的写法多样非常灵活；\n一些简单的处理逻辑强烈推荐直接lambda表达式直接处理完；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic: MainWindow(QWidget *parent = 0);    ~MainWindow();private:    Ui::MainWindow *ui;private:    void test_fun();private slots:    void test_slot();&#125;;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    //早期写法,通用Qt所有版本,只支持定义了slots关键字的函数    //connect(ui-&gt;pushButton, SIGNAL(clicked()), this, SLOT(test_fun()));    connect(ui-&gt;pushButton, SIGNAL(clicked()), this, SLOT(test_slot()));    //新写法,支持Qt5及后期所有版本,支持所有函数,无需定义slots关键字也行    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, this, &amp;MainWindow::test_fun);    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, this, &amp;MainWindow::test_slot);    //另类写法,支持lambda表达式,直接执行代码    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [this] &#123;test_fun();&#125;);    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [this] &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot;;    &#125;);    //lambda带参数    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [&amp;] (bool isCheck) &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot; &lt;&lt; isCheck;    &#125;);    //头文件 signals:void sig_test(int i);    connect(this, &amp;MainWindow::sig_test, [] (int i) &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot; &lt;&lt; i;    &#125;);    emit sig_test(5);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::test_fun()&#123;    qDebug() &lt;&lt; &quot;test_fun&quot;;&#125;void MainWindow::test_slot()&#123;    qDebug() &lt;&lt; &quot;test_slot&quot;;&#125;\n\n\nQt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件。\n\n\n斗气：qss内容写得到处都是，哪里需要就写在哪里，各种控件调用 setStyleSheet方法传入样式表内容，或者直接对应控件鼠标右键弹出菜单选择改变样式表填入内容；\n斗者：qss内容放在文件，读取文件内容设置样式表，程序发布的时候带上qss文件；\n斗师：qss文件作为资源文件放到qrc文件，直接编译到可执行文件中，防止篡改；\n斗灵：在qss文件中自定义一些标志充当变量使用，读取以后替换对应的变量为颜色值，类似动态换肤；\n斗王：放在文件容易被篡改，集成到可执行文件不够灵活，一旦样式表更新需要重新编译文件，如何做到既能只更新样式表文件，又不需要重新编译可执行文件，又能防止被篡改：采用rcc命令将资源文件编译生成二进制，只需要替换该二进制文件即可；\n斗皇：继承qstyle类自己实现完成所有样式接口，统一整体风格，大名鼎鼎的UOS系统默认规则就是如此，不允许用样式表，全部painter绘制；\n\n16：151-160\n当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。\n12345//Qt中使用二进制资源文件方法如下//将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc//在应用程序中注册资源，一般在main函数启动后就注册QResource::registerResource(qApp-&gt;applicationDirPath() + &quot;/main.rcc&quot;);\n\n关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。\n123456789101112131415161718//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget//下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFontQFont font;font.setPixelSize(20);this-&gt;setFont(font);this-&gt;setStyleSheet(&quot;&#123;font:26px;&#125;&quot;);this-&gt;setStyleSheet(&quot;QWidget&#123;font:26px;&#125;&quot;);this-&gt;setStyleSheet(&quot;Widget&#123;font:26px;&#125;&quot;);//下面才是通过样式表设置整个控件+子控件的字体this-&gt;setStyleSheet(&quot;font:26px;&quot;);this-&gt;setStyleSheet(&quot;*&#123;font:26px;&#125;&quot;);this-&gt;setStyleSheet(&quot;QWidget&gt;*&#123;font:26px;&#125;&quot;);this-&gt;setStyleSheet(&quot;Widget&gt;*&#123;font:26px;&#125;&quot;);//下面设置全局字体qApp-&gt;setFont(font);\n\nQt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888。\n1234567891011121314151617181920//pixel      函数获取像素点的颜色 setPixel      函数设置像素点的颜色 此函数任意Qt版本都有//pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有//pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换QImage image(&quot;1.png&quot;);image = image.convertToFormat(QImage::Format_ARGB32);int width = image.width();int height = image.height();//遍历图像的每一个像素for (int x = 0; x &lt; width; ++x) &#123;    for (int y = 0; y &lt; height; ++y) &#123;        QString name = image.pixelColor(x, y).name();        //将白色以外的颜色全部替换成红色        if (name != &quot;#ffffff&quot;) &#123;            image.setPixelColor(x, y, Qt::red);        &#125;    &#125;&#125;//保存文件image.save(&quot;2.png&quot;);\n\n在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论。\n\n\n\nQt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源；\n速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显；\n几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计；\n其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败；\nsqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够；\n数据库支持友好度大致是 sqlite &gt; postgresql &gt; mysql &gt; odbc ;\n如果采用的odbc数据源模式连接数据库，只需要设置数据库名称为对应新建的数据源名字，然后设置用户名和密码就行，不需要设置主机名称和端口，因为数据源那边已经设置过的，这里只需要再次验证用户信息就行。\nODBC数据源分32&#x2F;64位之分，在数据源管理器中，如果添加的数据源对应平台显示的只有32或者只有64位，那你的Qt程序也只能是对应位数的才能连接成功。如果显示的是64位，你用32位的程序去连接会失败。\n32位的Qt程序，带对应32位的libmysql动态库，可以访问32&#x2F;64位的mysql数据库，64位的也是一样可以访问32&#x2F;64位的mysql数据库，只需要带上对应位数的动态库就行。查看mysql是32位还是64位命令 mysql.exe -V。\n在mysql驱动可用且正常的情况下，如果还是提示Driver not loaded Driver not loaded，则很可能是拷贝的libmysql动态库版本不对或者位数不对导致的。\n以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的；\n\n\nQt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。\n123456789101112131415161718192021222324252627282930313233//早期处理办法 先初始化随机数种子然后取随机数qsrand(QTime::currentTime().msec());//取 0-10 之间的随机数qrand() % 10;//取 0-1 之间的浮点数qrand() / double(RAND_MAX);//新版处理办法 支持5.10以后的所有版本包括qt6QRandomGenerator::global()-&gt;bounded(10);      //生成一个0和10之间的整数QRandomGenerator::global()-&gt;bounded(10.123);  //生成一个0和10.123之间的浮点数QRandomGenerator::global()-&gt;bounded(10, 15);  //生成一个10和15之间的整数//兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数srand(QTime::currentTime().msec());rand() % 10;rand() / double(RAND_MAX);//通用公式 a是起始值,n是整数的范围int value = a + rand() % n;//(min, max)的随机数int value = min + 1 + (rand() % (max - min - 1));//(min, max]的随机数int value = min + 1 + (rand() % (max - min + 0));//[min, max)的随机数int value = min + 0 + (rand() % (max - min + 0));//[min, max]的随机数int value = min + 0 + (rand() % (max - min + 1));//如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。//取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。//切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大srand((long long)currentThreadId());qrand((long long)currentThreadId());\n\nQt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下。\n12345678void frmMain::on_btnMenu_Max_clicked()&#123;    ......    //最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下        QEvent event(QEvent::Leave);    QApplication::sendEvent(ui-&gt;btnMenu_Max, &amp;event);    &#125;\n\n项目中启用c++11语法支持。\n12greaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11\n\nQt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多。\n1ui-&gt;textEdit-&gt;setUndoRedoEnabled(false);\n\n其他几点常规小经验，本人在这几个地方摔跤过很多次。\n\n\n\n有返回值的函数，一定要主动return返回值，有部分编译器在没有返回值的情况下也能正常编译通过，但是运行的时候会出问题，得不到想要的结果，因为没有return对应的值。\n定义的局部变量，主动给定个初始值，是个必须养成的好习惯，不然编译器给的初始值很可能不是你想要的，比如int变量默认0，有时候随机变成一个很大的数值，bool变量的初始值不同编译器不同值，有些是true有些是false，主动给一个初始值更可靠。\n某些函数参数很多，而且后期可能还会修改和增加，这就导致了源头修改以后，关联信号槽的地方也要修改，参数类型和位置必须保持完全一致，对应槽函数处理也要修改等，改动的工作量非常大而且极不友好，所以对于非固定参数的函数，建议用结构体，这样非常容易增加其他的参数，而且不用修改信号槽关联和信号槽函数定义等，比如学生信息表、商品信息表作为参数传输，最佳方案就是结构体。\n\n\nQTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充，12345678910111213141516171819202122232425262728293031//方法1：字符串空格填充ui-&gt;tabWidget-&gt;addTab(httpClient1, &quot;测    试&quot;);ui-&gt;tabWidget-&gt;addTab(httpClient1, &quot;人员管理&quot;);ui-&gt;tabWidget-&gt;addTab(httpClient1, &quot;系统设置&quot;);//方法2：识别尺寸改变事件自动设置最小宽度void MainWindow::resizeEvent(QResizeEvent *e)&#123;    int count = ui-&gt;tabWidget-&gt;tabBar()-&gt;count();    int width = this-&gt;width() - 30;    QString qss = QString(&quot;QTabBar::tab&#123;min-width:%1px;&#125;&quot;).arg(width / count);    this-&gt;setStyleSheet(qss);&#125;//方法3：设置全局样式，不同选项卡个数的设置不同的宽度QStringList list;list &lt;&lt; QString(&quot;QTabWidget[tabCount=\\&quot;2\\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;).arg(100);list &lt;&lt; QString(&quot;QTabWidget[tabCount=\\&quot;3\\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;).arg(70);qApp-&gt;setStyleSheet(list.join(&quot;&quot;));//设置了tabCount弱属性自动去找对应的宽度设置ui-&gt;tabWidget-&gt;setProperty(&quot;tabCount&quot;, 2);ui-&gt;tabWidget-&gt;setProperty(&quot;tabCount&quot;, 3);//方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置//Qt4的tabBar()是propected的，所以建议还是通过样式表设置ui-&gt;tabWidget-&gt;tabBar()-&gt;setDocumentMode(true);ui-&gt;tabWidget-&gt;tabBar()-&gt;setExpanding(true);//样式表一步到位不用每个都单独设置QString(&quot;QTabBar&#123;qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;&#125;&quot;);//在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。//5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。\n\n17：161-170\n经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条。\n\nQt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法。\n12345678910//增加一个无边框属性setWindowFlags(windowFlags() | Qt::FramelessWindowHint);//移除无边框属性setWindowFlags(windowFlags() &amp; ~Qt::FramelessWindowHint);//下面是5.9以后新增的方法//增加一个无边框属性到窗体属性链表setWindowFlag(Qt::FramelessWindowHint, true);//从窗体属性链表中移除无边框属性setWindowFlag(Qt::FramelessWindowHint, false);\n\n如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸。\n12setMinimumSize(0, 0);setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);\n\nQt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()。\n123456789101112131415161718192021222324//在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出if (qApp-&gt;mouseButtons() == Qt::RightButton) &#123;    videoMenu-&gt;exec(QCursor::pos());&#125;//全局剪切板qApp-&gt;clipboard();//顶层控件对象集合qApp-&gt;topLevelWidgets()//当前焦点所在控件qApp-&gt;focusWidget()//当前平台名称qApp-&gt;platformName()//调用系统蜂鸣器qApp-&gt;beep()//打印当前Qt版本信息qApp-&gt;aboutQt()//设置全局的鼠标样式qApp-&gt;setOverrideCursor()//不使用系统的标准颜色字体等QGuiApplication::setDesktopSettingsAware(bool on);QApplication app(argc, argv);//更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。\n\nQt对区分不同的编译器也做了非常细致的处理。\n123456789101112131415161718192021222324#pro文件可以这样判断msvc &#123;//要做的处理&#125;mingw &#123;//要做的处理&#125;//代码中可以这样判断#ifdef Q_CC_MINGW//mingw编译器#elif Q_CC_MSVC//msvc编译器#endif//判断编译器和编译器版本#if defined Q_CC_MSVC &amp;&amp; _MSC_VER &lt; 1300#if defined(Q_CC_GNU) &amp;&amp; (__GNUC__ &lt; 4)//代码中判断ARM平台#ifdef QT_ARCH_ARM//多个条件判断#if defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)\n\n有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法。\n1234567891011121314//方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。disconnect(ui-&gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));for (int i = 0; i &lt;= 100; i++) &#123;    ui-&gt;cbox-&gt;addItem(QString::number(i));&#125;connect(ui-&gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));//方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。//如果需要指定某个信号进行断开那就只能用 disconnect 来处理。ui-&gt;cbox-&gt;blockSignals(true);for (int i = 0; i &lt;= 100; i++) &#123;    ui-&gt;cbox-&gt;addItem(QString::number(i));&#125;ui-&gt;cbox-&gt;blockSignals(false);\n\n项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2。\n123456789//方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。HEADERS += *.hSOURCES += *.cpp//方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。include($$PWD/ui/ui.pri)//还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹INCLUDEPATH += $$PWD/ui//加上上面这行，在使用头文件的时候可以直接 include &quot;form.h&quot;，没有加则需要 include &quot;ui/form.h&quot;。\n\n在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农民工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的。\n123456789101112131415161718192021222324252627282930//tcp客户端QTcpSocket *socket = new QTcpSocket(this);//断开所有连接和操作socket-&gt;abort();//绑定网卡和端口socket-&gt;bind(QHostAddress(&quot;192.168.1.2&quot;), 6005);//连接服务器socket-&gt;connectToHost(&quot;192.168.1.3&quot;, 6000);//打印通信用的本地绑定地址和端口qDebug() &lt;&lt; socket-&gt;localAddress() &lt;&lt; socket-&gt;localPort();//打印通信服务器对方的地址和端口qDebug() &lt;&lt; socket-&gt;peerAddress() &lt;&lt; socket-&gt;peerPort() &lt;&lt; socket-&gt;peerName();//udp客户端QUdpSocket *socket = new QUdpSocket(this);//绑定网卡和端口,没有绑定过才需要绑定//采用端口是否一样来判断是为了方便可以直接动态绑定切换端口if (socket-&gt;localPort() != 6005) &#123;    socket-&gt;abort();    socket-&gt;bind(QHostAddress(&quot;192.168.1.2&quot;), 6005);&#125;//指定地址和端口发送数据socket-&gt;writeDatagram(buffer, QHostAddress(&quot;192.168.1.3&quot;), 6000);//上面是Qt5可以使用bind，Qt4中的QTcpSocket的对应接口是protected的没法直接使用，需要继承类重新实现把接口放出来。//Qt4中的QUdpSocket有bind函数是开放的，奇怪了，为何Qt4中独独QTcpSocket不开放。TcpSocket *socket = new TcpSocket(this);socket-&gt;setLocalAddress(QHostAddress(&quot;192.168.1.2&quot;));socket-&gt;setLocalPort(6005);\n\n关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯。\n\n\n\ntcp对网卡1监听了端口6000，还可以对网卡2监听端口6000。\ntcp对网卡1监听了端口6000，udp对网卡1还可以继续监听端口6000。\ntcp对网卡1监听了端口6000，在网卡1上其他tcp只能监听6000以外的端口。\nudp协议也是上面的逻辑。\n\n\n开源的图表控件QCustomPlot很经典，作者至少是八星斗圣级别，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点。\n\n\n可以将XY轴对调，然后形成横向的效果，无论是曲线图还是柱状图，分组图、堆积图等，都支持这个特性。\n不需要的提示图例可以调用 legend-&gt;removeItem 进行移除。\n两条曲线可以调用 setChannelFillGraph 设置合并为一个面积区域。\n可以关闭抗锯齿 setAntialiased 加快绘制速度。\n可以设置不同的线条样式（setLineStyle）、数据样式（setScatterStyle）。\n坐标轴的箭头样式可更换 setUpperEnding。\n可以用 QCPBarsGroup 实现柱状分组图，这个类在官方demo中没有，所以非常容易忽略。\nV2.0开始支持数据排序设置，默认是交给QCustomPlot排序，也可以设置setData第三个参数为true表示已经排序过，这样可以绘制往回走的曲线。\n频繁绘制数据可以设置排队绘制参数 replot(QCustomPlot::rpQueuedReplot)，可以避免重复的replot和提高性能。如果不开启很可能绘制出错。\n可以将多个plot图表合并到一个QCustomPlot控件中，极大提升绘制效率，而不是实例化多个QCustomPlot控件。合并后也是分开对应不同的坐标轴不同位置排列显示，和多个QCustomPlot控件效果一样并且极大提升性能。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//对调XY轴，在最前面设置QCPAxis *yAxis = customPlot-&gt;yAxis;QCPAxis *xAxis = customPlot-&gt;xAxis;customPlot-&gt;xAxis = yAxis;customPlot-&gt;yAxis = xAxis;//移除图例customPlot-&gt;legend-&gt;removeItem(1);//合并两个曲线画布形成封闭区域customPlot-&gt;graph(0)-&gt;setChannelFillGraph(customPlot-&gt;graph(1));//关闭抗锯齿以及设置拖动的时候不启用抗锯齿customPlot-&gt;setNoAntialiasingOnDrag(true);customPlot-&gt;graph()-&gt;setAntialiased(false);customPlot-&gt;graph()-&gt;setAntialiasedFill(false);customPlot-&gt;graph()-&gt;setAntialiasedScatters(false);//设置快速绘制可以大大加快画笔宽度大于1的线条customPlot-&gt;setPlottingHint(QCP::phFastPolylines);//多种设置数据的方法customPlot-&gt;graph(0)-&gt;setData();customPlot-&gt;graph(0)-&gt;data()-&gt;set();//设置不同的线条样式、数据样式customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle::ssDot);customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(shapes.at(i), 10));//还可以设置为图片或者自定义形状customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(QPixmap(&quot;./sun.png&quot;)));QPainterPath customScatterPath;for (int i = 0; i &lt; 3; ++i) &#123;    customScatterPath.cubicTo(qCos(2 * M_PI * i / 3.0) * 9, qSin(2 * M_PI * i / 3.0) * 9, qCos(2 * M_PI * (i + 0.9) / 3.0) * 9, qSin(2 * M_PI * (i + 0.9) / 3.0) * 9, 0, 0);&#125;customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, 0), QColor(40, 70, 255, 50), 10));//更换坐标轴的箭头样式customPlot-&gt;xAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);customPlot-&gt;yAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);//设置背景图片customPlot-&gt;axisRect()-&gt;setBackground(QPixmap(&quot;./solarpanels.jpg&quot;));//画布也可以设置背景图片customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QPixmap(&quot;./balboa.jpg&quot;)));//整体可以设置填充颜色或者图片customPlot-&gt;setBackground(QBrush(gradient));//设置零点线条颜色customPlot-&gt;xAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);//控制是否鼠标滚轮缩放拖动等交互形式customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);//柱状分组图QCPBarsGroup *group = new QCPBarsGroup(customPlot);QList&lt;QCPBars*&gt; bars;bars &lt;&lt; fossil &lt;&lt; nuclear &lt;&lt; regen;foreach (QCPBars *bar, bars) &#123;    //设置柱状图的宽度大小    bar-&gt;setWidth(bar-&gt;width() / bars.size());    group-&gt;append(bar);&#125;//设置分组之间的间隔group-&gt;setSpacing(2);//绘制往回走的曲线QVector&lt;double&gt; keys, values;keys &lt;&lt; 0 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 4 &lt;&lt; 3;values &lt;&lt; 5 &lt;&lt; 4 &lt;&lt; 6 &lt;&lt; 7 &lt;&lt; 7 &lt;&lt; 6 &lt;&lt; 5 &lt;&lt; 4;customPlot-&gt;graph(0)-&gt;setData(keys, values, true);//频繁绘制数据开启排队绘制可以提高性能customPlot-&gt;replot(QCustomPlot::rpQueuedReplot);QCPAxis *axis = customPlot-&gt;xAxis;double lower = axis-&gt;range().lower;double upper = axis-&gt;range().upper;double origin = (upper - lower) / 2;//设置刻度线按照设置优先而不是可读性优先axis-&gt;ticker()-&gt;setTickStepStrategy(QCPAxisTicker::tssMeetTickCount);//设置原点值为范围值的中心点axis-&gt;ticker()-&gt;setTickOrigin(origin);//下面演示如何在一个控件中多个不同的曲线对应不同坐标轴//拿到图表布局对象QCPLayoutGrid *layout = customPlot-&gt;plotLayout();//实例化坐标轴区域QCPAxisRect *axisRect = new QCPAxisRect(customPlot);//拿到XY坐标轴对象QCPAxis *xAxis = axisRect-&gt;axis(QCPAxis::atBottom);QCPAxis *yAxis = axisRect-&gt;axis(QCPAxis::atLeft);//将坐标轴指定行列位置添加到布局中layout-&gt;addElement(i, 0, axisRect);//添加对应的画布到指定坐标轴QCPGraph *graph = customPlot-&gt;addGraph(xAxis, yAxis);\n\n18：171-180\n在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理。\n12345678910111213141516171819202122232425QString fileName = &quot;c:/测试目录/1.txt&quot;;//如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据const char *name = fileName.toLocal8Bit().constData();//如果设置过了下面两句则需要主动转码QTextCodec *codec = QTextCodec::codecForName(&quot;utf-8&quot;);QTextCodec::setCodecForLocale(codec);QTextCodec *code = QTextCodec::codecForName(&quot;gbk&quot;);const char *name = code-&gt;fromUnicode(fileName).constData();//推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码//切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit//有时候可能还有下面这种情况#ifdef Q_OS_WIN#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)    QTextCodec *code = QTextCodec::codecForName(&quot;utf-8&quot;);#else    QTextCodec *code = QTextCodec::codecForName(&quot;gbk&quot;);#endif    const char *name = code-&gt;fromUnicode(fileName).constData();#else    const char *name = fileName.toUtf8().constData();#endif\n\n在查阅和学习Qt源码的过程中，发现了一些趋势和改变。\n\n\n\n数据类型这块尽量用Qt内部的数据类型，哪怕是重定义过的比如quint8其实unsigned char，qreal就是double，以前翻看源码的时候可能还有些是double，现在慢慢改成了qreal。\n循环结构用 for(;;) 替代 while(1)，因为转成汇编指令后 for(;;) 只有一条指令而 while(1) 确有4条，指令少不占用寄存器而且不用跳转，理论上速度要更快。\n其实Qt中就重定义了 forever 关键字表示 for(;;) ，我的乖乖，想的真周到。\n自动c++11以及后续的标准都支持auto万能数据类型，发现Qt的源码中也慢慢的改成了auto，这样加快了编写代码的效率，不用自己去指定数据类型而是让编译器自己推导数据类型。而且其实也不影响编译器编译的速度，因为无论指定和没有指定数据类型，编译器都要推导右侧的数据类型进行判断。不过有个缺点就是影响了阅读代码的成本，很多时候需要自己去理解推导。\n\n\n\nQt中设置或者打开加载本地文件需要用到QUrl类，本地文件建议加上 file:&#x2F;&#x2F;&#x2F; 前缀。\n123456QString url = &quot;file:///c:/1.html&quot;;//浏览器控件打开本地网页文件webView-&gt;setUrl(QUrl(url));//打开本地网页文件，下面两种方法都可以QDesktopServices::openUrl(QUrl::fromLocalFile(url));QDesktopServices::openUrl(QUrl(url, QUrl::TolerantMode));\n\n在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。\n1234567891011121314151617181920212223242526//局部的事件循环,不卡主界面QEventLoop eventLoop;//设置超时 5.15开始自带了超时时间函数 默认30秒#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,15,0))manager-&gt;setTransferTimeout(timeout);#elseQTimer timer;connect(&amp;timer, SIGNAL(timeout()), &amp;eventLoop, SLOT(quit()));timer.setSingleShot(true);timer.start(timeout);#endifQNetworkReply *reply = manager-&gt;get(QNetworkRequest(QUrl(url)));connect(reply, SIGNAL(finished()), &amp;eventLoop, SLOT(quit()));eventLoop.exec();if (reply-&gt;bytesAvailable() &gt; 0 &amp;&amp; reply-&gt;error() == QNetworkReply::NoError) &#123;    //读取所有数据保存成文件    QByteArray data = reply-&gt;readAll();    QFile file(dirName + fileName);    if (file.open(QFile::WriteOnly | QFile::Truncate)) &#123;        file.write(data);        file.close();    &#125;&#125;\n\nQt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick&#x2F;qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。\n1234567891011121314151617181920212223242526272829303132333435//如果是控制台程序则下面的QApplication换成QCoreApplication//如果是quick/qml程序则下面的QApplication换成QGuiApplicationint main(int argc, char *argv[])&#123;    //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard    qputenv(&quot;QT_IM_MODULE&quot;, QByteArray(&quot;qtvirtualkeyboard&quot;));        //设置不应用操作系统设置比如字体    QApplication::setDesktopSettingsAware(false);#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    //设置高分屏缩放舍入策略    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);#endif#if (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))    //设置启用高分屏缩放支持    //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    //设置启用高分屏图片支持    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#endif#if (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))    //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL    //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速    //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2    //QApplication::setAttribute(Qt::AA_UseOpenGLES);    //设置opengl共享上下文    QApplication::setAttribute(Qt::AA_ShareOpenGLContexts);#endif    QApplication a(argc, argv);    QWidget w;    w.show();    return a.exec();&#125;\n\nQCamera中获取设备的配置参数比如支持的分辨率集合等，需要先调用load后才能正确获取，或者关联stateChanged信号中判断状态是否是ActiveState，然后再读取。\n1234567891011121314151617181920212223242526272829303132333435//方法1：调用load后获取camera = new QCamera(this);//先需要载入才能获取到对应参数camera-&gt;load();//输出当前设备支持的分辨率QList&lt;QSize&gt; sizes = camera-&gt;supportedViewfinderResolutions();emit resolutions(sizes);//重新设置分辨率QCameraViewfinderSettings set;set.setResolution(cameraWidth, cameraHeight);camera-&gt;setViewfinderSettings(set);//获取完成后卸载camera-&gt;unload();//方法2：通过事件信号获取camera = new QCamera(this);connect(camera, SIGNAL(stateChanged(QCamera::State)), this, SLOT(stateChanged(QCamera::State)));void CameraThread::stateChanged(QCamera::State state)&#123;    if (state == QCamera::ActiveState) &#123;        //输出当前设备支持的分辨率        QList&lt;QSize&gt; sizes = camera-&gt;supportedViewfinderResolutions();        emit resolutions(sizes);        //重新设置分辨率        QCameraViewfinderSettings set;        set.setResolution(cameraWidth, cameraHeight);        camera-&gt;setViewfinderSettings(set);    &#125;&#125;//QCamera没有指定设备名称的时候则采用默认的摄像机camera = new QCamera(this);//cameraName = @device:pnp:\\\\\\\\?\\\\usb#vid_046d&amp;pid_0825&amp;mi_00#6&amp;212eebd3&amp;0&amp;0000#&#123;65e8773d-8f56-11d0-a3b9-00a0c9223196&#125;\\\\global//可以通过设备描述符来查找设备名称(唯一标识)camera = new QCamera(cameraName.toUtf8(), this);\n\n很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用。\n123456789void Widget::showEvent(QShowEvent *)&#123;    //这里为了演示代码方便直接写的static，如果new多个窗体则需要定义在头文件中。    static bool isLoad = false;    if (!isLoad) &#123;        isLoad = true;        //执行对应的处理    &#125;&#125;\n\nQt获取当前所用的Qt版本、编译器、位数等信息。\n12345678910111213141516171819202122232425262728293031323334353637//详细的Qt版本+编译器+位数QString compilerString = &quot;&lt;unknown&gt;&quot;;&#123;#if defined(Q_CC_CLANG)    QString isAppleString;#if defined(__apple_build_version__)    isAppleString = QLatin1String(&quot; (Apple)&quot;);#endif    compilerString = QLatin1String(&quot;Clang &quot;) + QString::number(__clang_major__) + QLatin1Char(&#x27;.&#x27;) + QString::number(__clang_minor__) + isAppleString;#elif defined(Q_CC_GNU)    compilerString = QLatin1String(&quot;GCC &quot;) + QLatin1String(__VERSION__);#elif defined(Q_CC_MSVC)    if (_MSC_VER &gt; 1999) &#123;        compilerString = QLatin1String(&quot;MSVC &lt;unknown&gt;&quot;);    &#125; else if (_MSC_VER &gt;= 1930) &#123;        compilerString = QLatin1String(&quot;MSVC 2022&quot;);    &#125; else if (_MSC_VER &gt;= 1920) &#123;        compilerString = QLatin1String(&quot;MSVC 2019&quot;);    &#125; else if (_MSC_VER &gt;= 1910) &#123;        compilerString = QLatin1String(&quot;MSVC 2017&quot;);    &#125; else if (_MSC_VER &gt;= 1900) &#123;        compilerString = QLatin1String(&quot;MSVC 2015&quot;);    &#125; else if (_MSC_VER &gt;= 1800) &#123;        compilerString = QLatin1String(&quot;MSVC 2013&quot;);    &#125; else if (_MSC_VER &gt;= 1700) &#123;        compilerString = QLatin1String(&quot;MSVC 2012&quot;);    &#125; else if (_MSC_VER &gt;= 1600) &#123;        compilerString = QLatin1String(&quot;MSVC 2010&quot;);    &#125; else &#123;        compilerString = QLatin1String(&quot;MSVC &lt;old&gt;&quot;);    &#125;#endif&#125;//拓展知识 查看 QSysInfo 类下面有很多好东西// qVersion() = QT_VERSION_STRQString version = QString(&quot;%1 %2 %3&quot;).arg(qVersion()).arg(compilerString).arg(QString::number(QSysInfo::WordSize));\n\nQDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd &#x3D; 周二 Tue  dddd &#x3D; 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换。\n12345678910111213141516171819202122232425//格式化输出受到本地操作系统语言的影响//英文操作系统//这样获取到的是Mon到Sun，英文星期的3个字母的缩写。QDateTime::currentDateTime().toString(&quot;ddd&quot;);//这样获取到的是Monday到Sunday，英文星期完整单词。QDateTime::currentDateTime().toString(&quot;dddd&quot;);//中文操作系统//这样获取到的是周一到周日。QDateTime::currentDateTime().toString(&quot;ddd&quot;);//这样获取到的是星期一到星期日。QDateTime::currentDateTime().toString(&quot;dddd&quot;);//主动指定语言转换//如果没有指定本地语言则默认采用系统的语言环境。QLocale locale;//QLocale locale = QLocale::Chinese;//QLocale locale = QLocale::English;//QLocale locale = QLocale::Japanese;//下面永远输出中文的周一到周日locale.toString(QDateTime::currentDateTime(), &quot;ddd&quot;);//下面永远输出中文的星期一到星期日locale.toString(QDateTime::currentDateTime(), &quot;dddd&quot;);\n\nQSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实例化数据库表模型QSqlTableModel *model = new QSqlTableModel(this);//指定表名model-&gt;setTable(&quot;table&quot;);//设置列排序model-&gt;setSort(0, Qt::AscendingOrder);//设置提交模式model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);//立即查询一次model-&gt;select();//将数据库表模型设置到表格上ui-&gt;tableView-&gt;setModel(model);//测试发现过滤条件中除了可以带where语句还可以带排序及limit等model-&gt;setFilter(&quot;1=1 order by id desc limit 100&quot;);//如果在过滤条件中设置了排序语句则不可以再使用setSort方法//下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。model-&gt;setSort(0, Qt::AscendingOrder);model-&gt;setFilter(&quot;1=1 order by id desc limit 100&quot;);//通过setFilter设置单纯的where语句可以不用加1=1model-&gt;setFilter(&quot;name=&#x27;张三&#x27;&quot;);//如果还有其他语句比如排序或者limit等则需要最前面加上1=1//下面表示按照id升序排序，查询结果显示第5-15条记录。model-&gt;setFilter(&quot;1=1 order by id asc limit 5,10&quot;);//多个条件用and连接//建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。model-&gt;setFilter(&quot;1=1 and name=&#x27;张三&#x27; and result&gt;=70;&quot;);//下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。model-&gt;setFilter(&quot;1=1 and name=&#x27;张三&#x27; order by id desc limit 10,100;&quot;);//在第3行开始添加一条记录model-&gt;insertRow(2);//立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。model-&gt;setData(model-&gt;index(2, 0), 100);model-&gt;setData(model-&gt;index(2, 1), &quot;张三&quot;);//提交更新model-&gt;submitAll();//删除第4行model-&gt;removeRow(3);model-&gt;submitAll();//总之有增删改操作后都需要调用model-&gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。//撤销更改model-&gt;revertAll();\n\n19：181-190\nQt天生就是linux的，从linux开始发展起来的，所以不少Qt程序员经常的开发环境是linux，比如常用的ubuntu等系统，整理了一点常用的linux命令。\n\n\n\n\n命令\n功能\n\n\n\nsudo -s\n切换到管理员，如果是 sudo -i 切换后会改变当前目录。\n\n\napt install g++\n安装软件包（要管理员权限），另一个派系的是 yum install。\n\n\ncd &#x2F;home\n进入home目录。\n\n\nls\n罗列当前所在目录所有目录和文件。\n\n\nifconfig\n查看网卡信息包括IP地址，windows上是 ipconfig。\n\n\ntar -zxvf bin.tar.gz\n解压文件到当前目录。\n\n\ntar -jxvf bin.tar.xz\n解压文件到当前目录。\n\n\ntar -zxvf bin.tar.gz -C &#x2F;home\n解压文件到&#x2F;home目录，记住是大写的C。\n\n\ntar -zcvf bin.tar.gz bin\n将bin目录压缩成tar.gz格式文件（压缩比一般）。\n\n\ntar -jcvf bin.tar.xz bin\n将bin目录压缩成tar.xz格式文件（压缩比高，推荐）。\n\n\ntar -…\nj z 表示不同的压缩方法，x表示解压，c表示压缩。\n\n\ngedit 1.txt\n用记事本打开文本文件。\n\n\nvim 1.txt\n用vim打开文件，很多时候可以缩写用vi。\n\n\n.&#x2F;configure  make -j4  make install\n通用编译源码命令，第一步.&#x2F;configure执行配置脚本，第二步make -j4启用多线程编译，第三步make install安装编译好的文件。\n\n\n.&#x2F;configure -prefix &#x2F;home&#x2F;liu&#x2F;Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc\nQt通用编译命令。\n\n\n.&#x2F;configure -static -release -fontconfig -system-freetype -qt-xcb -qt-sql-sqlite -qt-zlib -qt-libpng -qt-libjpeg -nomake tests -nomake examples -prefix &#x2F;home&#x2F;liu&#x2F;qt&#x2F;Qt5.6.3\nQt静态带中文。\n\n\n.&#x2F;configure -prefix &#x2F;home&#x2F;liu&#x2F;Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d\n精简编译命令。\n\n\n.&#x2F;configure –prefix&#x3D;host –enable-static –disable-shared –disable-doc\nffmpeg编译命令。\n\n\n\nQt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。//如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。//切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。//日志重定向一般就三种处理//1: 输出到日志文件比如txt文本文件。//2: 存储到数据库，可以分类存储，以便相关人员查询分析。//3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。//日志重定向#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))void Log(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)#elsevoid Log(QtMsgType type, const char *msg)#endif&#123;    //加锁,防止多线程中qdebug太频繁导致崩溃    static QMutex mutex;    QMutexLocker locker(&amp;mutex);    QString content;    //这里可以根据不同的类型加上不同的头部用于区分    switch (type) &#123;        case QtDebugMsg:            content = QString(&quot;%1&quot;).arg(msg);            break;        case QtWarningMsg:            content = QString(&quot;%1&quot;).arg(msg);            break;        case QtCriticalMsg:            content = QString(&quot;%1&quot;).arg(msg);            break;        case QtFatalMsg:            content = QString(&quot;%1&quot;).arg(msg);            break;    &#125;    //加上打印代码所在代码文件、行号、函数名#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    if (SaveLog::Instance()-&gt;getUseContext()) &#123;        int line = context.line;        QString file = context.file;        QString function = context.function;        if (line &gt; 0) &#123;            content = QString(&quot;行号: %1  文件: %2  函数: %3\\n%4&quot;).arg(line).arg(file).arg(function).arg(content);        &#125;    &#125;#endif    //将内容传给函数进行处理    SaveLog::Instance()-&gt;save(content);&#125;//安装日志钩子,输出调试信息到文件,便于调试void SaveLog::start()&#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    qInstallMessageHandler(Log);#else    qInstallMsgHandler(Log);#endif&#125;//卸载日志钩子void SaveLog::stop()&#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    qInstallMessageHandler(0);#else    qInstallMsgHandler(0);#endif&#125;\n\n自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记。\n\n\n\n代码格式：capture mutable -&gt;return-type {statement}\n[capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。\n(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。\nmutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。\n-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -&gt; 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。\n{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。\n\n捕捉列表有以下几种形式：\n\n[var]表示值传递方式捕捉变量var。\n[&#x3D;]表示值传递方式捕捉所有父作用域的变量（包括this）。\n[&amp;var]表示引用传递捕捉变量var。\n[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）。\n[this]表示值传递方式捕捉当前的this指针。\n\n1234567891011121314151617181920212223MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    //按钮单击不带参数    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot;;    &#125;);    //按钮单击带参数    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] (bool isCheck) &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot; &lt;&lt; isCheck;    &#125;);    //自定义信号带参数    connect(this, &amp;MainWindow::sig_test, [] (int i, int j) &#123;        qDebug() &lt;&lt; &quot;hello lambda&quot; &lt;&lt; i &lt;&lt; j;    &#125;);    emit sig_test(5, 8);&#125;\n\n\n由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4&#x2F;Qt5&#x2F;Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include “qglobal.h”不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中。\n1234567//至少要包含 qglobal.h，理论上Qt所有的类都包含了这个头文件，所以你引入Qt的其他头文件也行比如 qobject.h#include &quot;qglobal.h&quot;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))#include &quot;qscreen.h&quot;#else#include &quot;qdesktopwidget.h&quot;#endif\n\n在使用QString转换到char *或者const char *的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对。\n\n\n\n转换前QString的内容无关中文还是英文，要出问题都一样。\n转换中QByteArray无关具体类型，toUtf8、toLatin1、toLocal8Bit、toStdString等方法，要出问题都一样。\n转换后无关char *还是const char *，要出问题都一样。\n出问题的随机性的，概率出现，理论上debug的概率更大。\n根据酷码大佬分析可能的原因(不确定)是msvc为了方便调试，debug会在内存释放后做填充，release则不会。1234567QString text = &quot;xxxxx&quot;;//下面这样转换很可能会有问题char *data = text.toUtf8().data();//分两步转换肯定不会有问题QByteArray buffer = text.toUtf8();char *data = buffer.data();const char *data = buffer.constData();\n\n\n关于是使用QList还是QVector的问题，一直是众多Qter的选择问题，主要是这两个玩意提供的的接口函数基本一致，比如插入、删除、取值等。\n\n\n大多数情况下可以用QList。像append、prepend、insert这种操作，通常QList比QVector快的多。\nQList是基于index标签存储它的元素项在内存中，比那种依赖iterator迭代的更快捷，而且你的代码也更少。\n如果你需要一个真正的连接着的list，且需要保证一个固定插入耗时。那就用迭代器，而不是标签。使用QLinkedList()。\n如果你需要开辟连续的内存空间存储，或者你的元素远比一个指针大，这时你需要避免个别插入操作，出现堆栈溢出，这时候用QVector。\n如果更在意取值的速度则用QVector，QCustomPlot用的就是QVector，需要频繁大量的取出数据进行绘制。\n如果更在意更新数据（添加、删除等）的速度则用QList（对应操作是[]&#x3D;值），但是因为QChart主要用的是QList访问数据（对应操作是at()），也是导致大数据量卡顿的原因之一，一直被诟病。\n曲线图表这类的基本上绝大部分时间都是在访问数据，拿到设置好的数据进行绘制。\n总之：QList更新（插入、追加等）数据速度快，QVector取数据速度快。\n在数据量很小的情况下两者几乎没啥性能区别。\n貌似Qt6对这两个类合并了（选择困难症的Qter解放了），QVector&#x3D;QList即QVector是QList的别名，可能底层改了代码以便发挥两者的优势。\n\n\n关于mouseTracking鼠标追踪和tabletTracking平板追踪的几点官方说明。\n\n\nmouseTracking属性用于保存是否启用鼠标跟踪，缺省情况是不启用的。\n没启用的情况下，对应部件只接收在鼠标移动同时至少一个鼠标按键按下时的鼠标移动事件。\n启用鼠标跟踪的情况下，任何鼠标移动事件部件都会接收。\n部件方法hasMouseTracking()用于返回当前是否启用鼠标跟踪。\nsetMouseTracking(bool enable)用于设置是否启用鼠标跟踪。\n与鼠标跟踪相关的函数主要是mouseMoveEvent()。\ntabletTracking属性保存是否启用部件的平板跟踪，缺省是不起用的。\n没有启用平板跟踪的情况下，部件仅接收触控笔与平板接触或至少有个触控笔按键按下时的触控笔移动事件。\n如果部件启用了平板跟踪功能，部件能接收触控笔靠近但未真正接触平板时的触控笔移动事件。\n这可以用于监视操作位置以及部件的辅助操作功能（如旋转和倾斜），并为图形界面提供这些操作的信息接口。\n部件方法hasTabletTracking()用于返回当前是否启用平板跟踪。\nsetTabletTracking(bool enable)用于设置是否启用平板跟踪。\n与平板跟踪相关的函数主要是tabletEvent()。\n\n\n关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。\n1234567//每次调用 clearContents 都会自动清理之前的itemui-&gt;tableWidget-&gt;clearContents();for (int i = 0; i &lt; count; ++i) &#123;    ui-&gt;tableWidget-&gt;setItem(i, 0, new QTableWidgetItem(&quot;aaa&quot;));    ui-&gt;tableWidget-&gt;setItem(i, 1, new QTableWidgetItem(&quot;bbb&quot;));    ui-&gt;tableWidget-&gt;setCellWidget(i, 2, new QPushButton(&quot;ccc&quot;));&#125;\n\n对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行。\n12345678910111213141516171819202122232425262728QCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator&#123;width:13px;height:13px;&#125;QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked&#123;image:url(:/qss/flatwhite/checkbox_unchecked.png);&#125;QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled&#123;image:url(:/qss/flatwhite/checkbox_unchecked_disable.png);&#125;QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked&#123;image:url(:/qss/flatwhite/checkbox_checked.png);&#125;QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled&#123;image:url(:/qss/flatwhite/checkbox_checked_disable.png);&#125;QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate&#123;image:url(:/qss/flatwhite/checkbox_parcial.png);&#125;QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled&#123;image:url(:/qss/flatwhite/checkbox_parcial_disable.png);&#125;\n\n关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void frmSimple::initForm()&#123;    //实例化数据模型    model = new QStandardItemModel(this);    //设置行数列数    row = 100;    column = 10;    //设置列名列宽    for (int i = 0; i &lt; column; ++i) &#123;        columnNames &lt;&lt; QString(&quot;列%1&quot;).arg(i + 1);        columnWidths &lt;&lt; 60;    &#125;&#125;void frmSimple::on_btnLoad1_clicked()&#123;    //先设置数据模型,否则 setColumnWidth 不起作用    ui-&gt;tableView-&gt;setModel(model);    //设置列数及列标题和列宽    model-&gt;setColumnCount(column);    //简便方法设置列标题集合    model-&gt;setHorizontalHeaderLabels(columnNames);    for (int i = 0; i &lt; column; ++i) &#123;        ui-&gt;tableView-&gt;setColumnWidth(i, columnWidths.at(i));    &#125;    //循环添加行数据    QDateTime now = QDateTime::currentDateTime();    model-&gt;setRowCount(row);    for (int i = 0; i &lt; row; ++i) &#123;        for (int j = 0; j &lt; column; ++j) &#123;            QStandardItem *item = new QStandardItem;            //最后一列显示时间区别开来            if (j == column - 1) &#123;                item-&gt;setText(now.addSecs(i).toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));            &#125; else &#123;                item-&gt;setText(QString(&quot;%1_%2&quot;).arg(i + 1).arg(j + 1));            &#125;            model-&gt;setItem(i, j, item);        &#125;    &#125;&#125;void frmSimple::on_btnLoad2_clicked()&#123;    //设置列标题和列数及列宽    ui-&gt;tableWidget-&gt;setColumnCount(column);    //简便方法设置列标题集合    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(columnNames);    for (int i = 0; i &lt; column; ++i) &#123;        ui-&gt;tableWidget-&gt;setColumnWidth(i, columnWidths.at(i));    &#125;    //添加数据    QDateTime now = QDateTime::currentDateTime();    ui-&gt;tableWidget-&gt;setRowCount(row);    for (int i = 0; i &lt; row; ++i) &#123;        for (int j = 0; j &lt; column; ++j) &#123;            QTableWidgetItem *item = new QTableWidgetItem;            //最后一列显示时间区别开来            if (j == column - 1) &#123;                item-&gt;setText(now.addSecs(i).toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));            &#125; else &#123;                item-&gt;setText(QString(&quot;%1_%2&quot;).arg(i + 1).arg(j + 1));            &#125;            ui-&gt;tableWidget-&gt;setItem(i, j, item);        &#125;    &#125;&#125;\n\n20：191-200\n关于QList队列的处理中，我们最常用的就是调用append函数添加item，往前插入item很多人第一印象就是调用insert(0,xxx)来插入，其实QList完全提供了往前追加item的函数prepend、push_front。\n123456789101112131415161718QStringList list;list &lt;&lt; &quot;aaa&quot; &lt;&lt; &quot;bbb&quot; &lt;&lt; &quot;ccc&quot;;//往后追加 等价于 appendlist.push_back(&quot;ddd&quot;);//往前追加 等价于 prependlist.push_front(&quot;xxx&quot;);//往后追加list.append(&quot;ddd&quot;);//往前追加list.prepend(&quot;xxx&quot;);//指定第一个位置插入 等价于 prependlist.insert(0, &quot;xxx&quot;);//输出 QList(&quot;xxx&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;)qDebug() &lt;&lt; list;\n\nQt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。\n1234567891011//qwindowdefs.htypedef QList&lt;QWidget *&gt; QWidgetList;typedef QList&lt;QWindow *&gt; QWindowList;typedef QHash&lt;WId, QWidget *&gt; QWidgetMapper;typedef QSet&lt;QWidget *&gt; QWidgetSet;//qmetatype.htypedef QList&lt;QVariant&gt; QVariantList;typedef QMap&lt;QString, QVariant&gt; QVariantMap;typedef QHash&lt;QString, QVariant&gt; QVariantHash;typedef QList&lt;QByteArray&gt; QByteArrayList;\n\nQt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值。\n\nQt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放。\n12345678910111213141516171819202122//永远不应用高分屏及缩放int main(int argc, char *argv[])&#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    QApplication::setAttribute(Qt::AA_Use96Dpi);#endif#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);#endif    QApplication a(argc, argv);    ....    return a.exec();&#125;//自动应用高分屏及缩放//方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。//新建qt.conf文件放到可执行文件同一目录[Platforms]WindowsArguments = dpiawareness=0//有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。\n\n关于QSS要注意的坑。\n\n\n\nqss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。\nqss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。\n有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-&gt;setStyleSheet() 来设置。\nqss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大群每周都有人问，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。\nqss整体来说还是可以的，解析速度性能在Qt5高版本后期比Qt4好很多，尤其是修复了不少qss中的解析绘制BUG。尽管有这样那样的BUG，怀着包容的心对待它。\nqss官方学习地址1：http://47.100.39.100/qtwidgets/stylesheet-reference.html\nqss官方学习地址2：http://47.100.39.100/qtwidgets/stylesheet-examples.html\n\n\n关于Qt延时的几种方法。\n123456789101112131415161718192021222324void QUIHelperCore::sleep(int msec)&#123;    if (msec &lt;= 0) &#123;        return;    &#125;#if 1    //非阻塞方式延时,现在很多人推荐的方法    QEventLoop loop;    QTimer::singleShot(msec, &amp;loop, SLOT(quit()));    loop.exec();#else#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    //阻塞方式延时,如果在主线程会卡住主界面    QThread::msleep(msec);#else    //非阻塞方式延时,不会卡住主界面,据说可能有问题    QTime endTime = QTime::currentTime().addMSecs(msec);    while (QTime::currentTime() &lt; endTime) &#123;        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);    &#125;#endif#endif&#125;\n\n随着国产化的兴起，各种国产系统和国产数据库等逐渐进入开发者的世界，罗列几个要点。\n\n\n\n中标麒麟neokylin基于centos。\n银河麒麟kylin早期版本比如V2基于freebsd，新版本V4、V10基于ubuntu。\n优麒麟ubuntukylin就是ubuntu的汉化版本，加了点农历控件啥的。\ndeepin基于debian。\nuos基于deepin或者说是deepin的商业分支。\nubuntu基于debian。\nlinux界主要分两种发行版本，debian（ubuntu、deepin、uos、银河麒麟kylin等）和redhat（fedora、centos、中标麒麟neokylin、中兴新支点newstart等），分别对应apt-get和yum安装命令。绝大部分的linux系统都基于或者衍生自这两种发行版本。\n理论上基于同一种系统内核的，在其上编译的程序可以换到另外的系统运行，前提是编译器版本一致，比如都是gcc4.9，在ubuntu14.04 64位用gcc4.9编译的Qt程序，是能够在uos 64位上运行的。\n高版本编译器的系统一般能够兼容低版本的，比如你用gcc4.9编译的程序是能够在gcc7.0上运行，反过来不行。\n意味着如果你想尽可能兼容更多的系统，尽量用低版本的编译器编译你的程序，当然要你的程序代码语法支持，比如c++11就要从gcc4.7开始才支持，如果你的代码用了c++11则必须至少选择gcc4.7版本及以上。\n用Qt编写linux程序为了发布后的可执行文件可以兼容各种linux系统，只要在这两种内核（debian、redhat）的系统上用低版本的编译器比如gcc4.7编译qt程序发布即可。\n2022-01-27补充：根据Qt官方安装包（关于对话框），发现基于redhat和gcc4.9（后面Qt5.14&#x2F;5.15带的qtc采用gcc5.3）编译器发布的，通用各种linux系统（亲测ubuntu各个版本、fedora、centos、deepin、uos、银河麒麟kylin、中标麒麟neokylin、中兴新支点newstart等），自己按照这个版本也亲测打包发布了，亲测可用，我擦，redhat系统的也可以在debian系统跑。\n2022-02-10补充：debian上静态编译的程序也可以在redhat系统跑，可能静态编译去掉了很多依赖吧。\n2022-03-01补充：低调大佬补充，如果没有特定的依赖关系，高版本的编译器编译的程序也可以在低版本编译器的系统运行，比如alpine Linux下用gcc11&#x2F;clang13编译生成的可执行二进制，依然可以在cenos5&#x2F;ubuntu10上运行。并不是编译器版本的问题，也不是C++11特性的问题，这个问题涉及到太多，内核版本、gnu libc、ABI兼容等等，两句话说不清。\n按照QtCreator软件采用的编译器环境规则，一般来说就是低版本的可以在高版本运行，比如Qt5可以在ubuntu14&#x2F;16&#x2F;18&#x2F;20运行，但是高版本编译器编译的就无法在低版本编译器系统运行，会提示缺少GLBC、LIBCXX、symbol xxxxxx等，比如Qt6可以在ubuntu20运行而无法在ubuntu18&#x2F;16&#x2F;14等运行。\n在uos上做开发，建议采用系统自带的Qt库环境开发，以及命令行安装开发环境，不建议使用Qt官方的安装包搭建环境，因为uos的Qt是魔改过的，用Qt官方的标准安装包的环境开发出来的程序，打包发布很可能会有依赖问题而无法运行，而用系统自带的就不存在这个问题。\n国产人大金仓数据库用的是postgresql数据库改的，意味着你在Qt中用postgresql数据库插件也是能够连接到人大金仓数据库的。\n以上未必完全正确，欢迎各位指正。\n\n\n纵观Qt的发展历史，也几乎经历着合久必分、分久必合的逻辑，比如最开始QPushButton等UI控件类都是在QtGui模块中，后面越发臃肿不方便管理和升级迭代，又分离出一个QtWidgets模块；到Qt6又将QList和QVector合并了成了一个类，搞得像分久必合；而且一些数学函数以及封装的c++标准函数库的方法，逐渐放弃了Qt自己的封装改用c++标准函数库，从开始的分到现在的合统一。\n\nQt一直在持续升级迭代，尽管新增加的代码质量明显不如诺基亚时代，但最起码有行动，慢慢完善。目前主要的升级改善在qml模块，底层也有完善，毕竟无论是widget还是qml都是公用一套底层逻辑类，底层基础一定要扎实稳固，个人这几年一直对比测试过不同Qt版本（从旧版本到新版本）很多类和函数的性能，发现官网列出来的新版本对应类和方法的性能提升改善，确实没有说谎，至于提升了多少这块有没有吹牛逼那就不清楚。\n\n\n\nbase64算法性能提升很大。\nQStringList等凡是使用了QList相关的类，性能提升巨大。\n对比测试大概从5.12版本开始QStringList和QMap性能相当。\n早期版本QStringList如果查找的值先插入则时间越短，QMap则没有这个区别。12345678910111213141516171819202122232425262728293031QStringList list1, list2;QMap&lt;QString, QString&gt; map;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    for (int i = 0; i &lt; 100000; ++i) &#123;        QString s1 = QString(&quot;%1&quot;).arg(i);        QString s2 = QString(&quot;A%1&quot;).arg(i);        list1 &lt;&lt; s1;        list2 &lt;&lt; s2;        map.insert(s1, s2);    &#125;&#125;void MainWindow::on_pushButton_clicked()&#123;    QElapsedTimer time;    time.start();    qDebug() &lt;&lt; &quot;111&quot; &lt;&lt; time.nsecsElapsed() &lt;&lt; list2.at(list1.indexOf(&quot;9999&quot;));&#125;void MainWindow::on_pushButton_2_clicked()&#123;    QElapsedTimer time;    time.start();    qDebug() &lt;&lt; &quot;222&quot; &lt;&lt; time.nsecsElapsed() &lt;&lt; map.value(&quot;9999&quot;);&#125;\n\n\n关于QtCreator中三种不同编译版本 debug、release、profile 的区别。\n\n\ndebug调试模式，编译后的可执行文件很大，带了很多调试符号信息等，方便开发阶段调试的时候进入具体的堆栈查看值。会打开所有的断言，运行阶段性能差速度慢，可能会有卡顿感觉。\nrelease发布模式，编译后的可执行文件很小，不带任何调试符号信息，一般用于打包发布程序。由于经过了各种优化，会关闭所有断言，运行阶段性能最好，如果有卡顿那肯定是你的程序问题。\nprofile概述模式，编译后的可执行文件比debug小很多比release大一点，带有部分调试符号信息，在debug和release之间取一个平衡，兼顾性能和调试，性能更优但是又方便调试。\n使用Qt5.7版本对应三种模式编译的空白窗体程序大小：debug（1319kb）、release（24kb）、profile（90kb）。\ndebug链接的库是带d结尾的，release和profile链接的库是不带d结尾的，很多人以为profile链接的是带d结尾的其实是错误的。\n新的Qt在线安装程序在安装的时候，可以勾选是否安装debug调试库（对应lib目录下一堆带d结尾的文件），以前的版本是默认都安装，现在可选安装以便减少体积。\n无论是否安装了debug调试库，你都可以选择debug模式生成对应debug的文件，这个不知道怎么做到的。\n无论是哪种模式，都可以在程序中开启日志钩子输出日志信息，方便收集运行阶段的各种信息反馈给开发人员查看问题。\n最初的开发工具一般是具有debug和release两种模式，随着用户需求的增加和场景的需要，部分开发工具衍生出了profile模式，更有甚者比如flutter还有第四种test模式。\n\n21：201-210\n编译生成debug版本动态库，文件末尾自动加上d结尾。\n12345CONFIG(debug, debug|release) &#123;    win32:      TARGET = $$join(TARGET,,,d)    mac:        TARGET = $$join(TARGET,,,_debug)    unix:!mac:  TARGET = $$join(TARGET,,,d)&#125;\n\nQtCreator中pro项目文件格式说明。\n\n\n\n\n\n名称\n说明\n\n\n\nQT +&#x3D; core gui\n添加本项目中需要的模块，影响后面代码文件include的时候自动弹出下拉选择，如果pro文件没有引入该模块则无法自动语法提示，一般打包发布的时候对应动态库文件比如 Qt5Core.dll。\n\n\nTARGET &#x3D; xxx\n生成最后目标文件的名字，可以是可执行文件或者库文件。\n\n\nTEMPLATE &#x3D; app\n项目程序的生成模式，默认是app表示生成可执行文件程序，如果是动态库项目就是 TEMPLATE &#x3D; lib。\n\n\nCONFIG +&#x3D; qaxcontainer\n引入一些配置，在Qt4的时候还用来引入一些模块，其中有部分改成了QT +&#x3D; 方式引入，比如Qt5引入本地activex控件支持改成了QT +&#x3D; qaxcontainer。\n\n\nDEFINES +&#x3D; xxx\n项目中自定义的一些定义，可以在代码文件中识别，通常用来定义一些不同平台的处理，根据项目需要自己定义任何标识。\n\n\nHEADERS +&#x3D; head.h\n项目中用到的头文件，一般拓展名是.h，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。\n\n\nSOURCES +&#x3D; main.cpp\n项目中用到的实现文件，一般拓展名是.cpp，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。\n\n\nFORMS +&#x3D; Form.ui\n项目中用到的UI文件，一般拓展名是.ui，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。\n\n\nRESOURCES +&#x3D; main.qrc\n项目中用到的资源文件，可以多个，写代码使用对应资源文件中的文件时候务必记得资源文件中的前缀。\n\n\nLIBS +&#x3D; -L$$PWD&#x2F; -lavformat -lavcodec\n项目中编译时候链接依赖的库，一般是 .lib .a .dylib 文件，可以写在一行，省略文件名的lib打头部分，也可以分多行绝对路径和全名称。\n\n\nDESTDIR +&#x3D; $$PWD&#x2F;bin\n目标生成路径，$$PWD表示当前目录，一般建议生成的最终文件重定向到另外目录存放，好找，不然一堆临时文件在里面有时候文件太多好难找。\n\n\nINCLUDEPATH +&#x3D; $$PWD&#x2F;include\n工程需要的头文件，指定整个目录，写代码的时候找到的话会自动下拉。\n\n\nDEPENDPATH +&#x3D;\n工程的依赖路径，用的比较少，一般涉及到引入链接库的时候可能需要。\n\n\ninclude($$PWD&#x2F;3rd.pri)\n引入pri模块文件，pri最大的好处就是分目录管理文件，通用的轮子模块可以放到一个目录下，然后用pri统一管理，可以给多个项目公用。\n\n\n官方详细地址https://doc.qt.io/qt-5/qmake-variable-reference.html\n\n如果发现之前编译正常，突然之间再编译就一直死循环的样子，停留在一行提示并疯狂不停的打印，或者提示文件时间在未来，这说明你很可能改过开发环境的时间（比如测试某个授权文件失效），导致有修改过文件的保存时间在未来，你只需要将时间调整回来，将最后更新时间不正确的代码文件重新保存下就行。Qt的增量编译是根据文件的最后修改时间来判定的，最后的修改时间比上一次的修改时间还要新则认为该文件被修改过，需要重新编译该文件。\n\nQt的构建套件一般是在安装Qt开发环境的时候自动设置的，当然也可以手动设置，手动设置的时候千万要注意编译器和Qt库必须一致，否则该构建套件是有问题的，千万不能乱设置，尤其是对构建套件命名的时候最好标明qt版本和编译器版本，最好也要一致，不要说名称叫msvc而编译器选择的确是mingw，这样尽管能正常使用该构建套件，但是会造成一种误解，还以为该套件是msvc的，其实里面是mingw的。有个qter说他的qt坏了，死活编译失败，远程一看，尼玛，构建套件名称写的qt_msvc2019 编译器选择的msvc2015（他电脑只安装了vs2015），qt库选择的mingw！差点狂扇自己八个耳光，太离谱了！\n\n当你编译Qt程序发现编译通不过提示报错，而且报错提示在Qt的头文件的时候，不要去尝试着修改Qt头文件来编译通过，那样没用的，你使用的Qt的库是已经根据原始的头文件编译好的。如果报错提示在编译生成的临时的moc等文件，你也不要尝试去修改他，那个是临时文件，这次你改好了也许编译通过了，你重新编一下又覆盖了还是旧的错误。总之你要从源头（你的代码）找问题。\n\n有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。\n1234567891011121314QString text = &quot;测试分散对齐内容&quot;;//计算当前文本在当前字体下占用的宽度QFont font = ui-&gt;label-&gt;font();int textWidth = ui-&gt;label-&gt;fontMetrics().width(text);//显示文本的区域宽度=标签的宽度-两边的边距int width = ui-&gt;label-&gt;width() - 12;//需要-1相当于中间有几个间隔int count = text.count() - 1;//计算每个间距多少qreal space = qreal(width - textWidth) / count;//设置固定间距font.setLetterSpacing(QFont::AbsoluteSpacing, space);ui-&gt;label-&gt;setFont(font);ui-&gt;label-&gt;setText(text);\n\n随着需求的不断增加，程序不断变大，用到的动态库也越来越多，到了发布程序的时候你会发现和可执行文件同一目录下文件数量真多，此时可能会考虑如何将一些库文件分门别类的存放，这样方便管理。\n\n\n\nQt提供的设置动态库路径的方法setLibraryPaths是用来搜索插件动态库的，而不是程序直接依赖的动态库。\n很多人以为这个可以设置Qt的库或者程序中依赖的第三方库的路径，其实想想也知道，因为程序依赖这个库，找不到的话根本跑不起来，程序跑不起来怎么应用执行这个代码呢？\nQt默认是可用通过setLibraryPaths的方式设置Qt插件的动态库目录位置，比如数据库插件sqldrivers，因为这些库文件是真正在Qt程序跑起来以后通过插件形式去加载的。\n还可以通过qt.conf文件设置 Plugins&#x3D;”config” 指定所有插件在可执行文件下的config目录下。\n要想设置程序直接依赖的动态库在其他目录，找遍全宇宙也只有一个办法，那就是设置环境变量，除此别无他法。\n至于如何设置环境变量方式很多，比如手动在电脑上设置，或者搞个批处理文件执行命令行，在程序安装的时候自动执行，或者程序打包目录下用户手动运行这个批处理。\n大神补充：设置插件的目录还可以通过在main函数最前面写 qputenv(“PATH”, QString(“%1;%2”).arg(qgetenv(“PATH”), pluginFileInfo.path()).toLocal8Bit()); 来实现。\n网友补充：最终找插件的路径其实就是这个 QT_PLUGIN_PATH 环境变量。\n\n\n进度条控件如果设置的垂直方向，就算你设置了文本可见，会发现根本看不到进度文本，经过多方百折不挠的试探，以及和酷码大佬深入的探讨，发现只要设置下border样式（border:1px solid #ff0000、border:none、border-style:solid、border-radius:0px 任意一种）就行，就可以把文本显示出来，这TM就不知道Qt为什么总是不统一规则，这个BUG通用于任何版本，这个可能是因为边框的solid样式冲突了导致无法继续绘制，确切的说这必须是BUG，这个锅Qt必须背。\n\n我们在使用QFileDialog::getOpenFileName、QFileDialog::getExistingDirectory等方法时，有时候会发现首次打开很卡，尤其是在默认目录很多文件的时候，此时你可以考虑设置这些函数最末尾的参数为QFileDialog::DontUseNativeDialog，表示不采用本地系统对话框，这样的话会采用Qt的对话框，速度快很多，估计系统的对话框在打开的时候会做很多初始化加载处理。\n12QFileDialog::getOpenFileName(this, &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, QFileDialog::DontUseNativeDialog);QFileDialog::getExistingDirectory(this, &quot;&quot;, &quot;&quot;, QFileDialog::DontUseNativeDialog);\n\n滑块控件QSlider，如果设置的垂直样式，其进度颜色和剩余颜色，刚好和横向样式的颜色相反的，不确定这个是否是Qt的BUG，Qt456都是这个现象。\n123456789101112131415161718192021222324252627282930313233343536373839QSlider::groove:horizontal&#123;height:8px;background:#FF0000;&#125;QSlider::add-page:horizontal&#123;height:8px;background:#FF0000;&#125;QSlider::sub-page:horizontal&#123;height:8px;background:#00FF00;&#125;QSlider::handle:horizontal&#123;width:10px;background:#0000FF;&#125;QSlider::groove:vertical&#123;width:8px;background:#FF0000;&#125;QSlider::add-page:vertical&#123;width:8px;background:#00FF00;&#125;QSlider::sub-page:vertical&#123;width:8px;background:#FF0000;&#125;QSlider::handle:vertical&#123;height:10px;background:#0000FF;&#125;\n\n22：211-220\nQMainWindow 在对停靠窗体进行排列的时候，有些不常用的设置容易遗忘，建议将 QMainWindow 的头文件函数过一遍一目了然。详细介绍各种停靠参数文章参见 https://zhuanlan.zhihu.com/p/388544168。\n12345678910//设置允许各种嵌套比如上下排列左右排列非常灵活//此设置会和下面的 setDockOptions 中的参数覆盖所以要注意顺序//this-&gt;setDockNestingEnabled(true);//设置停靠参数,不允许重叠,只允许拖动和嵌套this-&gt;setDockOptions(AnimatedDocks | AllowNestedDocks);//将底部左侧作为左侧区域，底部右侧作为右侧区域，否则底部区域会填充拉伸this-&gt;setCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea);this-&gt;setCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea);\n\n当我们在对QModelIndex取数据的时候，常规的角色的数据（QVariant类型支持to的比如toString、toInt、toDouble等）可以很方便的取出来，特定的数据类型需要用的万能取值模板函数 T value() 取出来。\n12345678910//显示文本QString text = index.data(Qt::DisplayRole).toString();//文本对齐int align = index.data(Qt::TextAlignmentRole).toInt();//文字字体QFont font = index.data(Qt::FontRole).value&lt;QFont&gt;();//前景色QColor color = index.data(Qt::ForegroundRole).value&lt;QColor&gt;();//背景色QColor color = index.data(Qt::BackgroundRole).value&lt;QColor&gt;();\n\n很多人以为拖曳只要在dropEvent事件就可以了，其实不行的，没有效果的，需要先在dragEnterEvent事件中执行event-&gt;accept()才行，不然根本没有效果，很多人尤其是初学者都挂在这里，我就是在这里摔了一跤，好疼！\n1234567891011121314void frmMain::dropEvent(QDropEvent *event)&#123;    QList&lt;QUrl&gt; urls = event-&gt;mimeData()-&gt;urls();&#125;void frmMain::dragEnterEvent(QDragEnterEvent *event)&#123;    if(event-&gt;mimeData()-&gt;hasFormat(&quot;application/x-qabstractitemmodeldatalist&quot;)) &#123;        event-&gt;setDropAction(Qt::MoveAction);        event-&gt;accept();    &#125; else &#123;        event-&gt;ignore();    &#125;&#125;\n\nQt5.6以后内置的是webengine浏览器内核，如果需要做web交互的话必须用到 qwebchannel.js 这个文件，此文件是Qt官方提供的，所以不建议去改动其中的源码，要注意的是，由于官方对webengine的支持在不断更新，所以官方提供的对应Qt版本的 qwebchannel.js 文件也不同，意味着你要用对应提供的版本的 qwebchannel.js 文件才ok，该文件默认在 C:\\Qt\\Qt5.12.11\\Examples\\Qt-5.12.11\\webchannel\\shared 目录下。经过几十个Qt版本的测试发现，用高版本的 qwebchannel.js 放到低版本运行不行，低版本放到高版本可以，为了万无一失还是建议直接用对应版本的。\n\n对于QString去除空格，有多种场景，可能需要去除左侧、右侧、所有等位置的空格。\n123456789101112131415161718192021222324252627282930313233343536373839404142//字符串去空格 -1=移除左侧空格 0=移除所有空格 1=移除右侧空格 2=移除首尾空格 3=首尾清除中间留一个空格QString QUIHelperData::trimmed(const QString &amp;text, int type)&#123;    QString temp = text;    QString pattern;    if (type == -1) &#123;        pattern = &quot;^ +\\\\s*&quot;;    &#125; else if (type == 0) &#123;        pattern = &quot;\\\\s&quot;;        //temp.replace(&quot; &quot;, &quot;&quot;);    &#125; else if (type == 1) &#123;        pattern = &quot;\\\\s* +$&quot;;    &#125; else if (type == 2) &#123;        temp = temp.trimmed();    &#125; else if (type == 3) &#123;        temp = temp.simplified();    &#125;    //调用正则表达式移除空格    if (!pattern.isEmpty()) &#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))        temp.remove(QRegularExpression(pattern));#else        temp.remove(QRegExp(pattern));#endif    &#125;    return temp;&#125;//测试代码QString text = &quot;  a  b  c d  &quot;;//结果：a  b  c d  QUIHelper::trimmed(text, -1);//结果：abcd  QUIHelper::trimmed(text, 0);//结果：  a  b  c dQUIHelper::trimmed(text, 1);//结果：a  b  c dQUIHelper::trimmed(text, 2);//结果：a b c dQUIHelper::trimmed(text, 3);\n\nQt的网络库支持udp广播搜索和组播搜索，其中组播搜索可以跨网段搜索，有时候你会发现失灵，此时你可以尝试把本地的虚拟机的网卡禁用试试，估计就好了。还有就是在本地开启了代理啥的，先关掉试试。近期在使用tcpsocket连接的时候，发现在Qt4和Qt5中正常的程序，到了Qt6中就不行了，报错提示 The proxy type is invalid for this operation ，原来是本地设置了代理导致的，可能在Qt6以前会默认跳过去不处理。\n12345678//也可以通过代码设置跳过代理#include &lt;QNetworkProxy&gt;QNetworkProxyFactory::setUseSystemConfiguration(false);//下面这样每次设置也可以tcpSocket-&gt;setProxy(QNetworkProxy::NoProxy);//查阅到文章 https://www.cnblogs.com/cppskill/p/11730452.html//从5.8开始socket默认代理类型是DefaultProxy而不是NoProxy，不知道出于什么考虑。\n\n关于交叉编译，对于初学者来说是个极难跨过去的砍（一旦跨过去了，以后遇到需要交叉编译的时候都是顺水推舟、信手拈来。），因为需要搭建交叉编译环境，好在现在厂家提供的板子基本上都是测试好的环境，尤其是提供的编译器，不用自己再去折腾，按照官方手册来基本上不会有啥的的问题。\n\n\n\n在linux系统上编译ffmpeg和qt都是非常简单的事情，初学者也会，前提只要本地的gcc g++编译器正常。\n任何编译器包括嵌入式编译器，为了确保环境正常，你可以先查看对应的编译器版本是否ok，g++ -v  arm-linux-g++ -v。\n交叉编译器查看版本 &#x2F;opt&#x2F;FriendlyARM&#x2F;toolschain&#x2F;4.5.1&#x2F;bin&#x2F;arm-linux-g++ -v 。\n编译器位数和操作系统位数有关，一般32位的编译器要在32位的系统上做交叉编译，虽然32位也可以在安装依赖后，在64位系统做交叉编译，但是个人不建议，可能会出问题。64位的编译器只能在64位的系统。\n设置了环境变量则可以省略掉长长的路径，直接打可执行文件名称即可，没有设置环境变量则需要打完整路径。\n设置环境变量只是为了编译的时候让自动寻找编译器，其实也完全可以不用设置环境变量，使用绝对路径指定编译器位置即可。\n在linux上编译，无论是ffmpeg还是qt还是其他，都是通用的步骤，第一步：.&#x2F;configure  第二步：make  第三步：make install 。\n至于具体configure后面有哪些参数，参照对应源码包的手册就行，搜索也一大堆。当然你用默认的就不带任何参数一般也可以，自动采用默认参数进行编译。\n交叉编译ffmpeg命令：.&#x2F;configure –prefix&#x3D;host –enable-static –disable-shared –disable-doc –cross-prefix&#x3D;&#x2F;opt&#x2F;FriendlyARM&#x2F;toolschain&#x2F;4.5.1&#x2F;bin&#x2F;arm-linux- –arch&#x3D;arm –target-os&#x3D;linux\n交叉编译qt前提：修改mkspecs&#x2F;qws&#x2F;linux-arm-g++下面的qmake.conf，如果没有设置环境变量则设置对应编译器的绝对路径，并将编译器的名字改成你需要的。\n比如修改gcc编译器：QMAKE_CC &#x3D; &#x2F;opt&#x2F;FriendlyARM&#x2F;toolschain&#x2F;4.5.1&#x2F;bin&#x2F;arm-linux-gcc\n交叉编译qt4.8.5命令：.&#x2F;configure -prefix host -embedded arm -xplatform qws&#x2F;linux-arm-g++ -release -opensource -confirm-license -qt-sql-sqlite -qt-gfx-linuxfb -plugin-sql-sqlit -no-qt3support -no-phonon -no-svg -no-webkit -no-javascript-jit -no-script -no-scripttools -no-declarative -no-declarative-debug -qt-zlib -no-gif -qt-libtiff -qt-libpng -no-libmng -qt-libjpeg -no-rpath -no-pch -no-3dnow -no-avx -no-neon -no-openssl -no-nis -no-cups -no-dbus -little-endian -qt-freetype -no-opengl -no-glib -nomake demos -nomake examples -nomake docs -nomake tools\n交叉编译qt5.9.8命令：.&#x2F;configure -prefix host -xplatform linux-arm-g++ -recheck-all -opensource -confirm-license -optimized-qmake -release -no-separate-debug-info -strip -shared -static -c++std c++1z -no-sse2 -pch -compile-examples -gui -widgets -no-dbus -no-openssl -no-cups -no-opengl -linuxfb -qt-zlib -qt-libpng -qt-libjpeg -qt-freetype\n综上所述交叉编译和常规的编译就一个区别，需要手动指定交叉编译器路径。ffmpeg是通过–cross-prefix&#x3D;指定，qt比较庞大是通过更改配置文件最后通过-xplatform指定配置文件名称。\nQt6的编译比较繁琐，默认用cmake编译，在linux上先用cmake3.19以上版本的源码，用make编译生成cmake，然后再用cmake编译qt生成qmake，最后调用qmake来编译你的qt项目。\n编译Qt其实只是想用其中的库，至于demo、doc、tool、example等统统不用，费时费力。所以强烈建议编译的时候去掉，大大加快编译速度。\n编译建议用普通用户编译即可，包括解压源码，因为这样编译出来的库普通用户就能用，如果是root管理员编译的则以后都需要管理员权限才行。\n很多系统都提供了直接鼠标右键解压，其实也是可以的，就是速度慢，建议用命令行解压和删除目录。\nQt的编译参数每个版本都可能有出入，毕竟一直在更新代码，甚至有些分类描述变了，比如之前-qt-xcb到了5.15改成了-xcb，之前-qt-sql-sqlite改成了-qt-sqlite，一定要看源码下的readme，里面约定了编译环境要求的最低版本，后面qt5开始具体的配置参数有哪些放到了qtbase目录下的config说明。\n编译完成使用如果遇到提示 GL&#x2F;gl.h 错误，需要安装 apt install libgl1-mesa-dev libglu1-mesa-dev  或者 yum install mesa-libGL-devel mesa-libGLU-devel 。\n编译参数说明可参考 https://blog.csdn.net/xi_gua_gua&#x2F;article&#x2F;details&#x2F;53413930。\n\n\n在Qt中设置图片有时候会发现不成功，很可能是因为文件的拓展名不正确导致的，比如jpg的图片拓展名是png，bmp的图片拓展名改成了jpg，QImage、QPixmap传入文件路径加载图片，是通过拓展名去调用对应的图片解析算法，比较傻，但是速度快，不用经过分析具体内部是何种图片格式。如果想要不管拓展名都能保证加载成功，则必须读取图片文件数据加载的方式处理。\n1234567891011121314151617181920212223//可以是资源文件中的图片也可以是本地文件QString fileName = &quot;:/test.png&quot;;//此方式按照拓展名来区分具体格式不准确//如果拓展名不正确就无法加载成功ui-&gt;label-&gt;setPixmap(QPixmap(fileName));//通过直接读取图片数据加载保证成功QFile file(fileName);file.open(QIODevice::ReadOnly);QByteArray data = file.readAll();//通过 QImage 处理QImage img;img.loadFromData(data);//下面这种方式也行//QImage img = QImage::fromData(data);ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img));//通过 QPixmap 处理QPixmap pix;pix.loadFromData(data);ui-&gt;label-&gt;setPixmap(pix);\n\n总结几个Qt版本的冷知识。\n\n\n\nQt4.8.7是Qt4的终结版本，是Qt4系列版本中最稳定最经典的（很多嵌入式板子还是用Qt4.8），其实该版本是和Qt5.5差不多时间发布的。参考链接 https://www.qt.io/blog/2015/05/26/qt-4-8-7-released https://blog.qt.io/blog/2015/07/01/qt-5-5-released/\nQt5.6.3最最后支持xp系统的长期支持版本，Qt5.7.0是最后支持xp系统的非长期支持版本（有可能有极少数函数不支持，个人没遇到过）。\nQt5.12.3是最后提供mysql数据库插件的版本，往后的版本需要自行编译对应的mysql数据库插件，官方安装包不再提供。\nQt5.12.5是最后样式表性能最高的版本，经过酷码大佬查阅代码发现此后版本的样式表源码中为了修复一个bug做了循环嵌套设置，导致性能急剧下降，界面越多性能暴降10倍以上。\nQt5.14.2是最后提供二进制安装包的版本，后面的版本都需要在线安装。\nQt5.15系列是最后支持win7的版本，后面的Qt6系列版本需要更改源码编译才能支持win7，这对于小白来说难于上青天。\nQt6.0&#x2F;6.1版本其实也是支持win7的，但是因为缺失太多模块，而且BUG成山，大佬说了狗都不用，所以使用此版本没意义。\nQt6不支持win7，是说开发阶段和运行阶段都不支持，无论开发阶段还是运行阶段你都需要Qt的库，只要是Qt的库不支持，到哪里也不支持。\n新版的qtc7由于采用Qt6编译，所以也只能在win10及以上运行，意味着你要用新的qtc7+Qt5做开发也必须用win10及以上。\n欢迎各位补充，比如哪个版本以后商用需要收费之类的，貌似用Qt4，在不更改Qt本身源码，动态库发布程序，法律风险小一些？\n\n\nQt官方除了Qt库一直在升级外，对应的集成开发环境也在更新升级，一般会选用最新的Qt库编译新版本，要注意的是，有些人安装的旧版本的qtc，加载比较高版本的Qt库，很容易出现报错提示 Project ERROR: Cannot run compiler ‘g++’. Maybe you forgot to setup the environment? 之类的，一般是版本跨度过大，比如用Qt5.5附带的qtc加载Qt5.9的库，导致有些环境识别不到，可能是qtc在新版本中对某些识别处理规则有变动。所以一般建议可以用新的qtc加载旧的Qt库，不建议旧的qtc加载新的Qt库。\n\n23：221-230\n在对表格数据模型操作的时候，经常遇到一种场景就是，删除某条记录后，希望重新选中某一行。QTableView、QTableWidget本身就支持多选全选等操作，比如批量删除可以多选。\n1234567891011121314151617181920212223242526//拿到表格数据模型QAbstractItemModel *model = ui-&gt;tableView-&gt;model();//主动定位到第三行ui-&gt;tableView-&gt;setCurrentIndex(model-&gt;index(3, 0));//主动定位到最后一行ui-&gt;tableView-&gt;setCurrentIndex(model-&gt;index(model-&gt;rowCount() - 1, 0));//设置选择模式支持多选，其他几个枚举值自行查阅文档。ui-&gt;tableView-&gt;setSelectionMode(QAbstractItemView::MultiSelection);//选择全部ui-&gt;tableView-&gt;selectAll();//取消所有选中ui-&gt;tableView-&gt;clearSelection();//选中行，注意如果该行选中则执行后取消选中，如此往复。这个设计很巧妙，掌声。ui-&gt;tableView-&gt;selectRow(row);//选中列，注意如果该列选中则执行后取消选中，如此往复。这个设计很巧妙，掌声。ui-&gt;tableView-&gt;selectColumn(column);//获取选中行的内容QItemSelectionModel *selections = ui-&gt;tableView-&gt;selectionModel();QModelIndexList selected = selections-&gt;selectedIndexes();foreach (QModelIndex index, selected) &#123;    qDebug() &lt;&lt; index.row() &lt;&lt; index.column() &lt;&lt; index.data();   &#125;\n\n在读取文本文件的时候，有时候会发现读取出来的中文乱码，这个时候就需要识别文件编码格式，然后主动设置对应的编码去读取就不会乱码。\n123456789101112131415161718192021222324252627282930313233//检查文件编码 0=ANSI 1=UTF-16LE 2=UTF-16BE 3=UTF-8 4=UTF-8BOMint DataCsv::findCode(const QString &amp;fileName)&#123;    //假定默认编码utf8    int code = 3;    QFile file(fileName);    if (file.open(QIODevice::ReadOnly)) &#123;        //读取3字节用于判断        QByteArray buffer = file.read(3);        quint8 b1 = buffer.at(0);        quint8 b2 = buffer.at(1);        quint8 b3 = buffer.at(2);        if (b1 == 0xFF &amp;&amp; b2 == 0xFE) &#123;            code = 1;        &#125; else if (b1 == 0xFE &amp;&amp; b2 == 0xFF) &#123;            code = 2;        &#125; else if (b1 == 0xEF &amp;&amp; b2 == 0xBB &amp;&amp; b3 == 0xBF) &#123;            code = 4;        &#125; else &#123;            //尝试用utf8转换,如果可用字符数大于0,则表示是ansi编码            QTextCodec::ConverterState state;            QTextCodec *codec = QTextCodec::codecForName(&quot;utf-8&quot;);            codec-&gt;toUnicode(buffer.constData(), buffer.size(), &amp;state);            if (state.invalidChars &gt; 0) &#123;                code = 0;            &#125;        &#125;        file.close();    &#125;    return code;&#125;\n\n在连接远程数据库进行查询数据的时候，有时候会发现很慢，尤其是表数据量越多越慢，本地的话同等数据量快很多，可以尝试开启只前进属性，query.setForwardOnly(true);这样的话只会缓存一次的数据，大大提高远程数据库的查询效率，据说可以提高几十倍百倍的速度。当然前提是对查询的数据之前向前取数据的需求，如果还要往后取数据或者在数据模型QSqlQueryModel中使用，则不能开启此属性。原因在每次利用QSqlQuery获取下一条记录时，若不开启isForwardOnly属性（很遗憾默认就是不开启），则每次都开辟新的内存空间，来存储已经访问及未访问的记录，这样，每次都会浪费好多存储空间。\n\nQt中的painter绘制非常灵活强大，接口丰富，但是对于很多初学者来说还是有一定的难度，尤其是各种奇奇怪怪的复杂格式，而这些格式用html确很好描述，比如控制行间距、字符间距等，此时可以用QTextDocument传入html格式内容交给QPainter绘制，非常完美、简单、强大，包括一些数学公式啥的。\n12345678910void Form::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);    QTextDocument doc;    doc.setHtml(html);    //设置文本宽度    doc.setTextWidth(200);    //指定绘制区域    doc.drawContents(&amp;painter, QRect(0, 0, 200, 70));&#125;\n\nQt中样式表对选中颜色和悬停颜色是有优先级的，根据对操作系统默认样式的观察，当处于选中状态+悬停状态的时候，默认取悬停状态，也就是鼠标移动到选中的列表item上，颜色取悬停状态颜色。而Qt中如果两种颜色都设置了，根据设置的顺序来，取最后的为准，如果最后设置的选中状态颜色，则当item处于选中状态+悬停状态的时候，取选中状态颜色而不是悬停状态颜色，切记！\n12345678910//下面这样设置则当鼠标停留在选中的item上时背景颜色=#00FF00QTableView::item:selected&#123;background:#FF0000;&#125;QTableView::item:hover&#123;background:#00FF00;&#125;//下面这样设置则当鼠标停留在选中的item上时背景颜色=#FF0000QTableView::item:hover&#123;background:#00FF00;&#125;QTableView::item:selected&#123;background:#FF0000;&#125;//左上角样式很容易忽略QTableCornerButton:section&#123;background:#FF0000;&#125;\n\nqtc开发工具内置了不少的函数，可以很方便的进行一些判断和处理。\n12345//最小版本要求!minQtVersion(5, 15, 2) &#123;    message(&quot;Cannot build Qt Installer Framework with Qt version $$&#123;QT_VERSION&#125;.&quot;)    error(&quot;Use at least Qt 5.15.2.&quot;)&#125;\n\n有时候文本框中的内容过长，而文本框默认光标在尾部，所以要主动设置下将光标移到最前面\n12345//三种方法都可以ui-&gt;lineEdit-&gt;setSelection(0, 0);ui-&gt;lineEdit-&gt;setCursorPosition(0);//样式表方式&quot;QLineEdit&#123;qproperty-cursorPosition:0;&#125;\n\n关于Qt浏览器模块的几点说明。\n\n\n\nQt5.6以前用的是webkit，Qt5.6版本以后分两种情况，一种是mingw编译器（windows系统）对应的Qt库不再提供浏览器模块。\nQt5.6以后的版本在linux系统和mac等系统，都不存在没有浏览器控件的情况，都使用的是webengine。\n仅仅是windows上的mingw编译器的Qt版本没有，其他系统其实都有的。很多人在这个地方都有疑问，都以为只有msvc编译器有浏览器控件，其实确切的说是在windows上msvc的Qt库带浏览器控件。\n安装Qt的时候webengine模块默认不勾选，需要主动勾选才会安装。\n也不是所有的msvc的Qt版本都有webengine浏览器模块，哪怕你勾选了也没用，有些版本官方并没有编译，需要自行编译。需要到对应的Qt安装目录查看是否有 Qt5WebEngine.dll 文件。\n如果仅仅是为了弥补mingw版本缺失浏览器模块的遗憾，推荐用miniblink。\n如果为了统一兼容各种版本和系统，推荐用cef。\n如果没有历史包袱，推荐用webengine，与Qt的集成度高。\nwebkit和miniblink默认都不支持gpu，webengine默认走gpu。\nqwebengine默认不支持MP4，需要自己重新编译。\n\n\n关于编译数据库插件的几个经验总结。\n\n\n安装对应的数据库，安装后会有include头文件和lib链接库文件，这是基本的前提，编译数据库插件必须要有这两个东西。务必注意，32位的Qt必须安装32位的数据库才能正常编译成功，位数要一致。\n准备好数据库插件源码，比如qt-everywhere-src-5.14.2\\qtbase\\src\\plugins\\sqldrivers\\mysql，可以在安装Qt的时候勾选src，或者后期直接官网重新下载源码解压出来。\n打开你要编译的数据库插件源码，比如mysql就打开mysql.pro，oracle就打开oci.pro。\n在pro中注释掉一行 #QMAKE_USE +&#x3D; mysql，如果是oci项目则是#QMAKE_USE +&#x3D; oci。\nqsqldriverbase.pri文件中注释掉 #include(..shadowed(..PWD)&#x2F;qtsqldrivers-config.pri)。\nmysql.pro文件内容下面加上如下代码。123path = C:/Qt/mysql-5.7.30-winx64INCLUDEPATH += $$path/includewin32:LIBS += -L$$path/lib -llibmysql\noci.pro文件内容下面加上如下代码。123path = C:/app/Administrator/product/11.2.0/client_1INCLUDEPATH += $$path/oci/includewin32:LIBS += -L$$path/oci/lib/msvc -loci\npsql.pro文件内容下面加上如下代码。123path = &quot;C:/Program Files/PostgreSQL/13&quot;INCLUDEPATH += $$path/includewin32:LIBS += -L$$path/lib -llibpq\n以上写法同时支持mingw和msvc，其他系统编译过程也是类似。编译完成后默认会在你当前源码所在盘符的根目录下，会出现plugins目录，里面sqldrivers目录下就是对应编译生成好的插件动态库。\n默认oracle的插件驱动代码是按照oracle12的函数写的，如果链接的是oracle11，则需要改动两行代码才能编译成功。打开qsql_oci.cpp文件大概在1559行代码左右，有个OCIBindByPos2函数改成OCIBindByPos，下面还有一行bindColumn.lengths改成(ub2*)bindColumn.lengths。\n\n\n关于Qt数据库开发的一些冷知识。\n\n\nQt即支持库的形式直接和数据库通信，也支持ODBC数据源的形式和各种数据库通信，这样就涵盖了所有的情况。\nQt数据库程序打包发布，所有前提：注意区分32&#x2F;64位，你的程序是32位的就必须带上32位的库，64位的必须带上64位的库，这点Qt的库也是这个要求。mysql发布最简单，带上一个mysql的动态库文件就行（windows上的是libmysql.dll），非常简单。sqlserver不用带，因为是微软的亲儿子，一般操作系统自带。postgres需要带上libpq.dll、libintl-8.dll、libiconv-2.dll、libeay32.dll、ssleay32.dll这几个文件就行。oracle需要带上oci.dll、oraociei11.dll（这个文件很大有130MB+），如果不行建议直接安装个oracle client客户端软件，然后对应bin目录设置到环境变量就好。\n打包发布后测试下来，发现32位的程序也可以正常连接64位的mysql，64位的程序也可以正常连接32位的mysql，因此判断只要和程序的库的位数一致就行（编译的时候也是这个规则，32位的Qt程序编译数据库插件也要用32位的数据库链接库。），不需要和具体的数据库的位数一致，测试过mysql、sqlserver、postgresql数据库都是类似规则。\n大量测试对比下来，通过odbc数据源的方式和直连数据库的方式批量插入大量数据记录，直连方式速度更快，约5%左右，所以建议尽量采用此方式，是在没有此方式的环境才采用odbc数据源的方式，Qt默认自带odbc数据库插件。\n不同数据库在执行sql脚本的时候，会自动将表名或者字段名转成大写或小写，mysql会将表名转成小写、postgresql会将表名和字段名转成小写、oracle会将表名和字段名转成大写。这就导致使用QSqlTableModel调用setTable设置数据库表名的时候，一定要和数据库中的表名一致，区分大小写，所以就是在对postgresql和oracle数据库的时候一定要注意，本人就是在这里卡了很久，差点要把这巨大的屎盆扣在Qt的BUG上。123456789101112void DbHelper::bindTable(const QString &amp;dbType, QSqlTableModel *model, const QString &amp;table)&#123;    //postgresql全部小写,oracle全部大写,这两个数据库严格区分表名字段名的大小写卧槽    QString flag = dbType.toUpper();    if (flag == &quot;POSTGRESQL&quot;) &#123;        model-&gt;setTable(table.toLower());    &#125; else if (flag == &quot;ORACLE&quot;) &#123;        model-&gt;setTable(table.toUpper());    &#125; else &#123;        model-&gt;setTable(table);    &#125;&#125;\nQt支持不指定数据库名打开数据库，因为有时候是要在连接数据库服务器后，执行sql语句创建数据库。数据库都还没存在怎么连接呢，测试发现sqlite、mysql、sqlserver、postgresql都支持这个特性。在删除和创建数据库的前提是该数据库没有被其他程序占用，比如其他程序已经打开了该数据库则会执行失败。这里我就折磨过很多次，为什么执行失败呢？后面发现第三方数据库工具已经打开了该数据库，把工具关掉就ok了。12345678910111213141516171819QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);//database.setDatabaseName(&quot;dbtool&quot;);database.setHostName(&quot;127.0.0.1&quot;);database.setPort(3306);database.setUserName(&quot;root&quot;);database.setPassword(&quot;root&quot;);if (database.open()) &#123;    QSqlQuery query(database);    qDebug() &lt;&lt; &quot;删除数据库&quot; &lt;&lt; query.exec(&quot;drop database dbtool&quot;);    qDebug() &lt;&lt; &quot;创建数据库&quot; &lt;&lt; query.exec(&quot;create database dbtool&quot;);    if (query.exec(&quot;select * from userinfo&quot;)) &#123;        while (query.next()) &#123;            qDebug() &lt;&lt; &quot;查询数据库&quot; &lt;&lt; query.value(0);        &#125;    &#125;&#125; else &#123;     qDebug() &lt;&lt; &quot;打开数据库&quot; &lt;&lt; database.lastError().text();&#125;\n用QSqlQueryModel+QTableView显示数据，int类型的数据，如果超过100万，会变成科学计数显示，这就很恼火了，肯定不是自己想要的结果。找遍网络搜索，终于找到一个同样问题的哥们，需要对这一列加个空的委托就行。后面发现空委托也不行，超过1000万条又屌样了，需要终极大法重载数据模型显示。123456789101112131415ui-&gt;tableView-&gt;setItemDelegateForColumn(0, new QItemDelegate);//下面是终极大法QVariant SqlQueryModel::data(const QModelIndex &amp;index, int role) const&#123;    QVariant value = QSqlQueryModel::data(index, role);    //超过100万的数值会被科学计数显示需要这里转成字符串显示    if (role == Qt::DisplayRole) &#123;        int result = value.toInt();        if (result &gt;= 1000000) &#123;            value = QString::number(result);        &#125;    &#125;    return value&#125;\nmysql数据库有多种数据库引擎，其中MyIsam不支持数据库事务，默认一般是这个引擎，所以当你使用Qt中的transaction方法后commit提交时候，会发现不成功，其实事实上又是成功的，去数据库里面查看对应的结果又是正确的。有两个办法，第一就是将数据库引擎改成InnoDB，第二就是在提交后做个错误判断 if (database.commit() || !database.lastError().isValid()) ，错误不可用也说明是成功的。\n如果采用odbc数据源通信，则只需设置数据库名称setDatabaseName、设置用户名称setUserName、设置用户密码setPassword这三个参数即可，因为数据源配置的时候就已经设置好对应的主机地址和端口以及关联的数据库名称，所以在用odbc数据源通信的时候只需要再次验证用户信息即可。这里特别要注意的是setDatabaseName设置数据库名称要填写数据源配置的名称。\n经过大量的对比测试，包括插入、删除、批量、查询、分页等操作，千万量级数据，在Qt数据库部分响应速度这块，友好度排名依次是 sqlite &gt; postgresql &gt; oracle &gt; mysql &gt; odbc 。千万量级以上是 postgresql &gt; oracle &gt; mysql &gt; sqlite &gt; odbc 。亿级别以上是 oracle &gt; postgresql &gt; 其他。以上测试均建立在初学者水平基础上，至于分库分表、联合查询、缓存、内存数据库等各种高级知识点没用上。\nmysql主要有两个版本，mysql5.7和mysql8，官方说是8比5要快很多，个人测试下来，5.7比8要快很多，无论是查询，还是批量插入数据，不知道为何，网上搜索的也是这个结果（https://www.coder4.com/archives/7596），大家都说8慢了很多。\nmysql有个分支叫mariadb，比mysql更纯正，据说各方面都吊打mysql（https://blog.csdn.net/x275920/article/details/123847792），个人对比测试下来也是确实批量插入和查询性能要好不少，并且完全兼容mysql，甚至库文件直接重命名也可以直接使用，比如将libmariadb.dll改成libmysql.dll可以直接使用，而且体积还小了八倍，这个好，发布的时候又少了好几兆。\n如果是Qt+mysql程序，发布的时候带的库版本要和插件对应数据库版本一致，否则可能没有数据库事务特性，database.driver()-&gt;hasFeature(QSqlDriver::Transactions)为假。\nQSqlTableModel封装的非常好，并不会一次性加载所有数据，而是随着滚动条的拉动加载需要的数据，测试一亿条的表，速度非常快，和几千条的表速度一样。\n在连接网络数据库的时候，如果你本地网络设置了代理，比如使用了代理上github等网站，就会发现Qt的数据库程序连不上，你需要设置下不使用本地代理设置 QNetworkProxyFactory::setUseSystemConfiguration(false) 。这个地方如果不仔细会找问题找到你怀疑人生。\n\n24：231-240\n关于c++中继承多态virtual和override的几点总结。\n\n\n子类可以直接使用基类中的protected下的变量和函数。\n基类函数没加virtual，子类有相同函数，实现的是覆盖。用基类指针调用时，调用到的是基类的函数；用子类指针调用时，调用到的是子类的函数。\n基类函数加了virtual，子类有相同函数，实现的是重写。用基类指针或子类指针调用时，调用到的都是子类的函数。\n函数加上override，强制要求子类相同函数需要是虚函数，而且必须重新实现，否则会编译报错。\n子类的virtual可加可不加，建议加override不加virtual。\n基类中的纯虚函数（virtual void play() &#x3D; 0;）在基类中无需在cpp中实现，但是必须在子类实现，否则编译报错。\n继承多态最大的好处就是提炼共性，将通用的变量和方法信号等，全部放在基类，子类负责实现自己需要的特殊的部分即可。\n\n\n关于 QTableView、QTableWidget 悬停整行选中效果，网上大多数都是针对 QTableWidget 的实现，针对 QTableView 的也都是通过委托或者重新painter实现。\n\n\n前提：设置选中单元格自动选中整行，tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);\n安装事件过滤器，识别到当前坐标处的数据模型，然后设置当前模型为鼠标悬停处的模型即可。这个取巧的办法可以节省大量的工作。\n无论 QTableView、QTableWidget 都用此方法都可以。\n\n\nQt中如何避免和第三方的signals、slots等关键字冲突。\n\n\n第一步：在pro中加上 CONFIG +&#x3D; no_keywords 。\n第二步：项目中之前所有的 signals 改成 Q_SIGNALS，slots 改成 Q_SLOTS 等。\n第三步：彻底重新编译项目，这样就关键字不冲突了。\n\n\npro中区分不同的操作系统及硬件平台。\n123456789101112131415win32 &#123;&#125;unix &#123;&#125;//Qt5可以直接用 linux&#123;&#125; Qt4切记需要用 unix:!maxc&#123;&#125;unix:!maxc&#123;&#125;linux &#123;&#125;maxc &#123;&#125;android &#123;&#125;wasm &#123;&#125;//表示64位平台contains(QT_ARCH, x86_64) &#123;&#125;//表示arm平台contains(QT_ARCH, arm) || contains(QT_ARCH, arm64) &#123;&#125;//万能办法直接切换到套件打印下 QT_ARCH 看下什么字符message($$QT_ARCH)\n\n在显示视频画面位置的时候，一般会有三种机制作为参考，自动模式(超过则等比例缩放否则原图)、普通模式(任何尺寸都等比例缩放)、填充模式(任何尺寸都拉伸填充)。Qt中图片类QImage都提供了缩放策略的参数设置，比如Qt::KeepAspectRatio表示等比例缩放，但很多时候我们需要的是设置控件的大小，其实QSize类就提供了对应的方法scale专门解决这个问题，这个方法很容易被忽视。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//缩放显示模式enum ScaleMode &#123;    //自动模式(超过则等比例缩放否则原图)    ScaleMode_auto = 0,    //普通模式(任何尺寸都等比例缩放)    ScaleMode_normal = 1,    //填充模式(任何尺寸都拉伸填充)    ScaleMode_fill = 2&#125;;//传入图片尺寸和窗体区域及边框大小返回居中区域static QRect getCenterRect(const QSize &amp;imageSize, const QRect &amp;widgetRect, int borderWidth = 2, const ScaleMode &amp;scaleMode = ScaleMode_auto)&#123;    QSize newSize = imageSize;    QSize widgetSize = widgetRect.size() - QSize(borderWidth * 2, borderWidth * 2);    if (scaleMode == ScaleMode_auto) &#123;        if (newSize.width() &gt; widgetSize.width() || newSize.height() &gt; widgetSize.height()) &#123;            newSize.scale(widgetSize, Qt::KeepAspectRatio);        &#125;    &#125; else if (scaleMode == ScaleMode_normal) &#123;        newSize.scale(widgetSize, Qt::KeepAspectRatio);    &#125; else &#123;        newSize = widgetSize;    &#125;    int x = widgetRect.center().x() - newSize.width() / 2;    int y = widgetRect.center().y() - newSize.height() / 2;    return QRect(x, y, newSize.width(), newSize.height());&#125;//传入图片尺寸和窗体尺寸及缩放策略返回合适尺寸的图片static void getScaledImage(QImage &amp;image, const QSize &amp;widgetSize, const ScaleMode &amp;scaleMode = ScaleMode_auto, bool fast = true)&#123;    Qt::TransformationMode mode = fast ? Qt::FastTransformation : Qt::SmoothTransformation;    if (scaleMode == ScaleMode_auto) &#123;        if (image.width() &gt; widgetSize.width() || image.height() &gt; widgetSize.height()) &#123;            image = image.scaled(widgetSize, Qt::KeepAspectRatio, mode);        &#125;    &#125; else if (scaleMode == ScaleMode_normal) &#123;        image = image.scaled(widgetSize, Qt::KeepAspectRatio, mode);    &#125; else &#123;        image = image.scaled(widgetSize, Qt::IgnoreAspectRatio, mode);    &#125;&#125;\n\n关于在头文件中定义函数使用static关键字的血的教训。\n\n\n\n有时候我们需要将一些常用函数写在一个文件中供很多地方调用，如果写的是 int doxxx{} 这种，在你多个地方引用的时候，肯定会编译报错提示 “重复定义” 的错误。\n此时你需要在函数前面加上static关键字，变成 static int doxxx{} 这种，能够正常编译和运行，以为一切万事大吉，还是我太年轻。\n如果仅仅是一个类中在使用，或者函数中没有静态变量，也不会出问题，问题就在static修饰的函数在每个引入头文件的时候都会拷贝一份，导致函数里面的static静态变量会重复初始化，这样就不正确了。\n为了解决这个问题，终极办法就是在外面套个类，所有的函数和变量放到类中，完美，再也不会睡不着了，真香。\n关于C&#x2F;C++ 中的static关键字，建议大家参考这篇文章写得 https://zhuanlan.zhihu.com/p/37439983，醍醐灌顶。12345678910111213141516171819//文件名 test.h//下面这个函数 编译报错提示 “重复定义”void test() &#123;&#125;//下面4个函数在每个引入头文件的时候都会被拷贝一份static void test1() &#123;&#125;inline void test2() &#123;&#125;static inline void test3() &#123;&#125;inline static void test4() &#123;&#125;//保证没问题的写法class tt &#123;    void test() &#123;&#125;    static void test1() &#123;&#125;    inline void test2() &#123;&#125;    static inline void test3() &#123;&#125;    inline static void test4() &#123;&#125;&#125;\n\n\n在数据库查询中，一般会建立索引以便加快查询速度，比如常用的条件字段作为索引字段。但是有些时候如果查询语句没写好，就算where中有索引字段也会引起全表扫描，也就是说根本没用上索引，这点要积极的避免。\n\n\n模糊查询like，全模糊 like ‘%…%’ 和左模糊 like ‘%…’ 无法直接使用索引，右模糊查询 like ‘…%’ 会使用索引。\n查询条件中含有is null的select语句执行慢，is not null 时永远不会使用索引，一般数据量大的表不要用is null查询。\n不等于操作符 &lt;&gt; 和 !&#x3D; 会限制索引，引起全表扫描，即使比较的字段上有索引。\nwhere子句中比较的两个条件，一个有索引，一个没索引，使用or则会引起全表扫描。\nselect count(*) from table 这样不带任何条件的count会引起全表扫描。\nin 和 not in 也要慎用，否则会导致全表扫描，能用 between 就不要用 in。\n用 &gt;&#x3D; 替代 &gt;，比如 高效写法：select * from table where id &gt;&#x3D; 4，低效写法：select * from table where id &gt; 3。\n如果表数据量很小，比如就几千行，请忽略上述警告，加不加索引问题不大，甚至某些时候加索引反而大大增加了数据库文件的体积，影响更新数据库的速度。\n\n\n由于Qt在不断的更新换代，各种组件轮子也在增加、拆分、调整等，所以我们在编写项目的时候，如果有版本兼容的问题，就需要在pro项目文件和代码文件中做对应的判断处理。根据多年的经验总结，一个万能的办法就是在pro中增加一个DEFINES标识，然后根据这个DEFINES标识引入对应模块，最后在代码中通过#ifdef判断标识执行对应代码。经过这样倒腾几下你的代码可以在低版本和高版本编译运行。\n12345678910111213141516171819202122//pro pri 文件//下面表示主版本&gt;4子版本&gt;6 即版本&gt;=5.7greaterThan(QT_MAJOR_VERSION, 4) &#123;greaterThan(QT_MINOR_VERSION, 6) &#123;DEFINES += qchart&#125;&#125;//由于Qt6的发布以及以后Qt7、Qt8等，光有上面这个判断是不够的的//下面表示Qt主版本&gt;5 即版本&gt;=6.0greaterThan(QT_MAJOR_VERSION, 5) &#123;DEFINES += qchart&#125;//判断有定义则导入对应模块contains(DEFINES, qchart) &#123;QT += charts&#125;//代码文件#ifdef qchart//要执行的代码#endif\n\n在使用QChart图表控件的时候，你会发现默认的边距好大，很多时候我们希望能显示更多的信息，紧凑型的界面，所以需要设置边距。\n123456//设置背景区域圆角角度chart-&gt;setBackgroundRoundness(0);//设置内边界边距chart-&gt;setMargins(QMargins(0, 0, 0, 0));//设置外边界边距chart-&gt;layout()-&gt;setContentsMargins(0, 0, 0, 0);\n\nQt内置了数据压缩和解压的功能，如果遇到图片、音频数据、文件等转base64传输这种，采用qCompress压缩后大概可以节省30%的数据传输量，压缩性能可观。前提是双方都是Qt程序，因为收到数据的时候还要用qUncompress解压出来，成对出现的。\n12345678//发送的时候压缩下数据QByteArray buffer = &quot;...&quot;;buffer = qCompress(buffer);socket-&gt;write(buffer);//收到数据后务必记得先解压再使用QByteArray data = socket-&gt;readAll();data = qUncompress(data);\n\n25：241-250\nQString类是我个人认为Qt所有类中的精华，封装的无可挑剔。内置了各种进制数据的转换，比如将数据转成10进制、16进制显示，或者将10进制、16进制数据转成字符串显示。这里很容易忽略的一点就是，很多人以为就是支持2进制、10进制、16进制之类的，其实不是的，里面实现了 2-36 之间的任意进制转换，可以自行翻阅源码查看实现。\n123456789101112char data[2];data[0] = 0x10;data[1] = 25;//输出 2进制显示 &quot;10000&quot; &quot;11001&quot;qDebug() &lt;&lt; &quot;2进制显示&quot; &lt;&lt; QString::number(data[0], 2) &lt;&lt; QString::number(data[1], 2);//输出 5进制显示 &quot;31&quot; &quot;100&quot;qDebug() &lt;&lt; &quot;5进制显示&quot; &lt;&lt; QString::number(data[0], 5) &lt;&lt; QString::number(data[1], 5);//输出 10进制显示 &quot;16&quot; &quot;25&quot;qDebug() &lt;&lt; &quot;10进制显示&quot; &lt;&lt; QString::number(data[0]) &lt;&lt; QString::number(data[1]);//输出 16进制显示 &quot;10&quot; &quot;19&quot;qDebug() &lt;&lt; &quot;16进制显示&quot; &lt;&lt; QString::number(data[0], 16) &lt;&lt; QString::number(data[1], 16);\n\nQtSql模块封装了各种数据库操作，使得Qt操作各种数据库非常的简单，支持各种各样的数据库，最基础的ODBC方式也支持连接到各种数据库。有个很容易忽视的要点就是在连接sqlserver数据库的时候，你会发现第三方的数据库工具也没有配置数据库，但是可以连接成功，而在Qt中的常规数据库连接写法却不行，那是因为你代码写错了，要用另外一种写法。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//连接sqlite数据库QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);//只需要指定数据库文件的绝对路径即可database.setDatabaseName(&quot;d:/test.db&quot;);//连接mysql数据库QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);database.setDatabaseName(&quot;test&quot;);database.setHostName(&quot;127.0.0.1&quot;);database.setPort(3306);database.setUserName(&quot;root&quot;);database.setPassword(&quot;root&quot;);//连接到sqlserver数据库//方式一通过odbc数据源，前提是必须配置好数据源。QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QODBC&quot;);database.setDatabaseName(&quot;数据源名称&quot;);database.setUserName(&quot;sa&quot;);database.setPassword(&quot;123456&quot;);//方式二通过驱动字符串，无需配置数据源。设置数据库名称就带了主机地址端口和用户信息所有后面这些设置不需要，强烈建议推荐此方法。QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QODBC&quot;);QStringList list;list &lt;&lt; QString(&quot;DRIVER=&#123;%1&#125;&quot;).arg(&quot;SQL SERVER&quot;);list &lt;&lt; QString(&quot;SERVER=%1,%2&quot;).arg(&quot;127.0.0.1&quot;).arg(1433);list &lt;&lt; QString(&quot;DATABASE=%1&quot;).arg(&quot;test&quot;);list &lt;&lt; QString(&quot;UID=%1&quot;).arg(&quot;sa&quot;);list &lt;&lt; QString(&quot;PWD=%1&quot;).arg(&quot;123456&quot;);database.setDatabaseName(list.join(&quot;;&quot;));//连接到postgresql数据库QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QPSQL&quot;);database.setDatabaseName(&quot;test&quot;);database.setHostName(&quot;127.0.0.1&quot;);database.setPort(5432);database.setUserName(&quot;postgres&quot;);database.setPassword(&quot;123456&quot;);//连接到oracle数据库QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QOCI&quot;);database.setDatabaseName(&quot;test&quot;);database.setHostName(&quot;127.0.0.1&quot;);database.setPort(1521);database.setUserName(&quot;system&quot;);database.setPassword(&quot;123456&quot;);//连接到人大金仓kingbase数据库（内核就是postgresql）QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QPSQL&quot;);database.setDatabaseName(&quot;test&quot;);database.setHostName(&quot;127.0.0.1&quot;);database.setPort(54321);database.setUserName(&quot;SYSTEM&quot;);database.setPassword(&quot;123456&quot;);//通过odbc数据源连接到各种数据库，前提是必须配置好数据源，只需要设置数据库名称为数据源的名称，填写用户名和密码就行，其他的主机地址和端口不需要。QSqlDatabase database = QSqlDatabase::addDatabase(&quot;QODBC&quot;);database.setDatabaseName(&quot;数据源名称&quot;);database.setUserName(&quot;system&quot;);database.setPassword(&quot;123456&quot;);\n\n如果信号槽关联函数 connect(obj, SIGNAL(), this, SLOT()); 执行多次则会重复关联（意味着会执行多次），而取消信号槽关联函数 disconnect(obj, SIGNAL(), this, SLOT()); 只需要执行一次就可以将之前关联的（哪怕是重复关联过）全部清除。很多初学者会遇到为什么点一下居然执行多次的原因就在这里，很可能代码中写了 on_objName_clicked(); 这种Qt内置自动生成关联的槽函数，然后自己又在代码中调用 connect 绑定了一次，导致重复绑定。提个建议：其实Qt可以过滤下如果是完全一样的绑定则认为是一个而不是多个。\n123456//为了保证永远只有一个关联可以在关联前面执行一次取消关联disconnect(obj, SIGNAL(), this, SLOT());connect(obj, SIGNAL(), this, SLOT());//经过群里大佬提示，原来connect第五个参数填 UniqueConnection 就可以避免这个问题，按照官方文档说明这个参数会过滤重复的信号。connect(obj, SIGNAL(), this, SLOT(), Qt::UniqueConnection);\n\n通过对Qt自带Examples的源码研究你会发现，越往后的版本，越喜欢用智能指针QScopedPointer来定义对象，这样有个好处就是用的地方只管new就行，一直new下去，不用担心资源释放问题，智能指针会给你在合适的时机释放，相当于可以少些一行代码 xxx-&gt;deleteLater(); ，而且避免不必要的麻烦，不然很多地方你要判断 if (!xxx) 看下对象是否ok。\n12345678910QWidget *widget;//用的地方先newwidget = new QWidget;//用完释放对象widget-&gt;deleteLater();      //智能指针写法QScopedPointer&lt;QWidget&gt; widget;//只管new尽管new不用管释放widget.reset(new QWidget);\n\n如果控件中存在布局，在调用setLayout重新设置布局的时候，会提示 QWidget::setLayout: Attempting to set QLayout … 之类的信息，说是已经存在了布局，需要删除之前的布局才能重新设置布局，按道理Qt推荐的是调用 layout()-&gt;deleteLater() 方法去删除对象，更安全，但是在这里不起作用，你需要用 delete layout() 来删除，着实奇怪。\n\n在编写类中有时候需要对变量进行赋值和取值，这时候一般用 setxxx、getxxx 之类的函数进行处理，而且往往里面就一行代码，这时候你可能会思考为何不直接将变量改成public暴露出来使用，还可以省两个函数几行代码。其实用set get这样处理主要还是为了拓展性，比如后期如果需要对赋值进行过滤处理，或者该变量只允许读写中的一个，如果之前是直接使用的变量外，则使用的地方都要去修改规则，反而变得很糟糕。 参考文章 https://blog.csdn.net/ChineseSoftware/article/details/122923485 。\n\n关于如何快速结束线程，调用terminate暴力结束容易出问题。一般来说我们都是采用标志位来结束线程，但是如果执行过程中的函数很耗时，或者在run中msleep休息的时间过久，容易导致要很长一段时间才能正确停止，此时可以考虑一个策略就是分割线程执行体，如果是函数体耗时可以在耗时的函数体中增加停止标志位的判断，使其快速跳出；如果是延时时间过久可以将延时时间拆分成多个小的时间轮片，每个小的休息间隔都判断停止标志位，这样也可以大大加快线程正常退出的速度而不用等待太久。\n123456789101112131415161718192021222324252627282930313233void Thread::run()&#123;    while (!stopped) &#123;        doTask();        //下面这个延时太久导致退出很慢        //msleep(3000);        //特意每次做个小延时每次都去判断标志位等可以大大加快关闭速度        int count = 0;        while (!stopped) &#123;            msleep(100);            count++;            //如果到了30次=30*100=3000毫秒也跳出            if (count == 30) &#123;                break;            &#125;        &#125;      &#125;         stopped = false;    &#125;void Thread::doTask()&#123;    while(1) &#123;        if (stopped) &#123;            return;        &#125;        doTask1();        doTask2();    &#125;    &#125;\n\nQt中如果指定了同一个父类窗体，则控件都会覆盖在该父类窗体中，这就需要设置窗口小部件覆盖遮挡与层叠顺序。\n1234567891011121314//Qt对有共同父类窗体的控件优化到了极致，下面生成了1000个widget才新增不到3mb的内存。for (int i = 0; i &lt; 1000; ++i) &#123;    QWidget *w = new QWidget(this);    w-&gt;setGeometry(0, 0, 100, 100);    w-&gt;show();&#125;QWidget *w1, *w2, *w3;//将w1控件移到最前面相当于在该父窗体中置顶w1-&gt;raise();//将w1控件移到最后面相当于在该父窗体中置底w1-&gt;lower();//将w1控件移到w2控件下面w1-&gt;stackUnder(w2);\n\n当我们关闭窗体的时候，按道理来说都会执行对应窗体的析构函数 ~MainWindow() 之类的，这是理想状态，当你的窗体还弹出了子窗体，就算你关闭了主窗体，会发现子窗体依然在，而且根本没有去析构主窗体，对应的子窗体也没有设置 setParent ，通常情况下，我们都是希望关闭了主窗体，对应子窗体自动关闭，这个时候怎么办呢？你需要重载 closeEvent 拿到关闭消息，主动去把子窗体释放。\n1234567891011121314151617181920212223242526272829303132333435363738394041class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent = 0);    ~MainWindow();protected:    void closeEvent(QCloseEvent *);private slots:    void on_pushButton_clicked();private:    Ui::MainWindow *ui;    QLabel *lab;&#125;;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    lab = new QLabel;    lab-&gt;resize(400, 300);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::closeEvent(QCloseEvent *)&#123;    //先把子窗体释放    lab-&gt;deleteLater();&#125;void MainWindow::on_pushButton_clicked()&#123;    lab-&gt;show();&#125;\n\n关于Qt中 sendEvent 和 postEvent 主动模拟发送鼠标键盘事件的几点说明。\n\n\n\nsendEvent是阻塞式，代码会立即执行，支持栈空间和堆空间事件对象的发送（局部对象和new分配的对象）。\npostEvent是非阻塞式，会发送到事件队列中等待处理，只支持栈堆空间事件对象的发送（new分配的对象）。\nnew分配的事件对象被处理后，会由Qt内部自动摧毁，不用担心。\n短时间内密集频繁的调用，推荐用postEvent，放入事件队列非常安全。否则用sendEvent很容易导致崩溃。123456789101112131415//下面这个会立即执行QResizeEvent event(size(), size());QApplication::sendEvent(this, &amp;event);//下面这个会立即执行QResizeEvent *event = new QResizeEvent(size(), size());QApplication::sendEvent(this, event);//下面这个不会报错但是也不会执行因为事件对象是局部变量QResizeEvent event(size(), size());QApplication::postEvent(this, &amp;event);//下面的方式非常安全QResizeEvent *event = new QResizeEvent(size(), size());QApplication::postEvent(this, event);\n\n26：251-260\n今天在一个头文件中，发现 #ifdef Q_OS_WIN #ifdef Q_CC_MSVC 之类的都失效了，搞得差点怀疑人生了。经历过之前类似的教训后，排查原来是没有提前引入 qglobal.h 头文件导致的。切记如果要使用Qt的东西，哪怕是最基础的标识宏定义 Q_OS_WIN 之类的，都要保证该前面至少包含了 qglobal.h ，否则都是失败的。很多人和我一样天真的以为编译器会自动处理。\n123456789101112//必须要先引入这个头文件#include &quot;qglobal.h&quot;#ifdef Q_OS_WIN...#else...#endif#ifdef Q_CC_MSVC#pragma execution_character_set(&quot;utf-8&quot;)#endif\n\n有一个场景经常遇到，那就是在符合某个条件下，延时一段时间去执行一段代码，如果短时间内触发多次又不需要频繁执行，只需要执行一次就行。如果选择用QTimer::singleShot无法终止已经触发的，这个时候就要主动实例化一个单次定时器，每次调用前都停止之前的（只要是还没执行都会取消），完美解决。\n1234567891011//QTimer::singleShot(1000, thread, SLOT(xxx()));static QTimer *timer = NULL;if (!timer) &#123;    timer = new QTimer;    QObject::connect(timer, SIGNAL(timeout()), thread, SLOT(xxx()));    timer-&gt;setSingleShot(true);    timer-&gt;setInterval(1000);&#125;timer-&gt;stop();timer-&gt;start();\n\n有时候我们发现控件设置透明后背景变成黑色，你可以尝试设置透明度值1而不是完全透明0，这样看起来是透明的但是又保留了窗体的特性。如果想要不应用系统阴影边框可以设置属性 w.setWindowFlags(w.windowFlags() | Qt::NoDropShadowWindowHint); \n\nQt中的事件过滤器相当于万能大法（终极秘密武器），尤其是对整个应用程序安装事件过滤器，则可以拿到所有的事件。比如可以拿到系统标题栏鼠标按下松开，对所有需要移动的无边框窗体统一拦截进行移动处理。个人建议不到万不得已不建议使用，有一定性能损耗，毕竟这个是从最初源头拦截事件，意味着所有的事件都会到这里过一遍。如果你在收到对应事件后还做了一定耗时的处理，很容易就卡主了UI主线程。\n1234567891011121314151617181920212223242526272829303132333435363738void AppInit::start()&#123;    qApp-&gt;installEventFilter(this);&#125;bool AppInit::eventFilter(QObject *watched, QEvent *event)&#123;    if (event-&gt;type() == QEvent::NonClientAreaMouseButtonPress) &#123;        qDebug() &lt;&lt; &quot;系统标题栏按下&quot;;    &#125; else if (event-&gt;type() == QEvent::NonClientAreaMouseButtonRelease) &#123;        qDebug() &lt;&lt; &quot;系统标题栏松开&quot;;    &#125;        QWidget *w = (QWidget *)watched;    if (!w-&gt;property(&quot;canMove&quot;).toBool()) &#123;        return QObject::eventFilter(watched, event);    &#125;    static QPoint mousePoint;    static bool mousePressed = false;    QMouseEvent *mouseEvent = static_cast&lt;QMouseEvent *&gt;(event);    if (mouseEvent-&gt;type() == QEvent::MouseButtonPress) &#123;        if (mouseEvent-&gt;button() == Qt::LeftButton) &#123;            mousePressed = true;            mousePoint = mouseEvent-&gt;globalPos() - w-&gt;pos();        &#125;    &#125; else if (mouseEvent-&gt;type() == QEvent::MouseButtonRelease) &#123;        mousePressed = false;    &#125; else if (mouseEvent-&gt;type() == QEvent::MouseMove) &#123;        if (mousePressed) &#123;            w-&gt;move(mouseEvent-&gt;globalPos() - mousePoint);            return true;        &#125;    &#125;    return QObject::eventFilter(watched, event);&#125;\n\nlinux上可执行文件默认从系统环境变量查找动态库，而windows上默认是从可执行文件所在目录查找，所以有时候为了统一，希望动态库就指定放在可执行文件同一目录下或者相对目录比如lib文件夹，这就需要编译的时候做特殊设置，在pro项目文件中指定rpath（也可以用命令或者第三方工具进行设置），指定好以后默认先从指定的rpath查找动态库是否在，不在然后再去环境变量中的路径查找。\n12345linux &#123;QMAKE_LFLAGS += &quot;-Wl,-rpath,\\&#x27;\\$$ORIGIN\\&#x27;&quot;QMAKE_LFLAGS += &quot;-Wl,-rpath,\\&#x27;\\$$ORIGIN/lib\\&#x27;&quot;QMAKE_LFLAGS += &quot;-Wl,-rpath,\\&#x27;\\$$ORIGIN/../lib\\&#x27;&quot;&#125;\n\n默认QDialog窗体右下角有个拉伸尺寸的手柄，通过它可以对窗体拉伸大小，这个控件很容易被遗忘但是又经常可以看到，他的名字叫QSizeGrip，可以通过setSizeGripEnabled来启用或者禁用，也可以用qss对外观进行设置。\n12345QSizeGrip &#123;\timage:url(:/image/sizegrip.png);\twidth:10px;\theight:10px;&#125;\n\n在有些没有opengl环境的Qt开发中，比如一些嵌入式板子为了节省资源没有编译opengl所以不会有opengl相关的头文件，在编译项目过程中可能遇到提示 GLES3&#x2F;gl3.h: No such file or directory，尽管你的项目中也没有用到opengl的任何东西，那是因为你包含了一个大模块 #include  ，而这个大模块中包含了 #include “qopenglwidget.h” ，你需要做的是在引入大模块前面加一行。\n1234//下面两个定义看具体需求调整#define QT_NO_OPENGL#define QT_NO_OPENGL_ES_3#include &lt;QtWidgets&gt;\n\n可以通过设置过滤机制，将代码中的部分打印类别屏蔽掉，比如只保留qdebug打印的信息，也可以将Qt内部类的警告信息屏蔽，只保留自己程序写的打印信息。\n123456789101112131415161718192021//代码写在main函数最前面int main(int argc, char *argv[])&#123;\tQLoggingCategory::setFilterRules(&quot;*.critical=false&quot;);\tQApplication a(argc, argv);&#125;//下面表示将所有的debug打印信息屏蔽QLoggingCategory::setFilterRules(&quot;*.debug=false&quot;);//下面最终打印 222qDebug() &lt;&lt; &quot;111&quot;;qInfo() &lt;&lt; &quot;222&quot;;//下面表示将所有的打印信息屏蔽QLoggingCategory::setFilterRules(&quot;*=false&quot;);//下面可以将所有警告提示屏蔽(Qt内部类中出现的警告信息都用的这个qErrnoWarning对应的就是critical)QLoggingCategory::setFilterRules(&quot;*.critical=false&quot;);//支持多个规则写法(有部分警告信息用的qWarning所以也要加进去)QLoggingCategory::setFilterRules(&quot;*.critical=false\\n*.warning=false&quot;);\n\n官方的Qt安装包基本上都带了各种高级模块比如浏览器模块webengine以及多媒体模块q，有些嵌入式的环境或者厂家提供好的Qt环境，未必有这些模块，需要单独打命令安装。\n123456//如果找不到音频输入输出设备需要执行下面这个命令sudo apt-get install libqt5multimedia5-plugins//安装浏览器模块sudo apt-get install libqt5web*//也可以一次性安装所有sudo apt-get install libqt5*\n\n项目大了以后，经常需要将某些类做成单例类，在整个项目中唯一存在，供多个地方使用，如果一个就一个类需要写成单例模式，那直接写在那个类中即可，如果类多了的话，会发现都是一些重复的定义代码，此时可以考虑用个宏定义，传入类名即可，代码量虽然少了可能绩效低了，但是水平提升了。\n12345678910111213141516171819202122232425262728293031323334353637383940#ifndef QUISINGLETON_H#define QUISINGLETON_H#include &lt;QScopedPointer&gt;#include &lt;QMutex&gt;#define SINGLETON_DECL(Class) \\    public: \\        static Class *Instance(); \\    private: \\        Q_DISABLE_COPY(Class) \\        static QScopedPointer&lt;Class&gt; self;#define SINGLETON_IMPL(Class) \\    QScopedPointer&lt;Class&gt; Class::self; \\    Class *Class::Instance() &#123; \\        if (self.isNull()) &#123; \\            static QMutex mutex; \\            QMutexLocker locker(&amp;mutex); \\            if (self.isNull()) &#123; \\                self.reset(new Class); \\            &#125; \\        &#125; \\        return self.data(); \\    &#125;#endif // QUISINGLETON_H//使用的时候在头文件和实现文件各加一行代码即可#include &quot;quisingleton.h&quot;class Form : public QWidget&#123;    Q_OBJECT SINGLETON_DECL(Form)&#125;SINGLETON_IMPL(Form)Form::Form(QWidget *parent) : QWidget(parent), ui(new Ui::Form)&#123;    ui-&gt;setupUi(this);&#125;\n\n27：261-270\n代码中判断当前Qt库是32位还是64位，用QSysInfo::WordSize&#x3D;32&#x2F;64。\n\nQTreeView控件设置左侧branch 图标大小，无法通过qss设置，万能大法查看源码得知控制宽度最后取决于indentation参数，indentation的默认值根据系统环境不同而不同，比如1080P分辨率下是20，你要放大可以通过 setIndentation(30) 来设置。\n\n在对选项卡控件QTabWidget设置样式表的时候，很多人希望能做成类似浏览器或者资源管理器中上面选项卡的样子，就是选中的tab上边左右两边有加粗线条，底部空白的和面板形成一体，有很多方法，方法一就是把底边宽度为0，方法二将底边颜色设置成和面板颜色一样，方法三将tab的底边边距设置成边框的负数（margin-bottom:-3px），这样看起来就是和面板融为一体了。\n123456//下面几种分别对应选项卡不同位置的效果//注意Qt5.12版本后tabbar选项卡左右反过来的QTabWidget::pane:top&#123;top:-1px;&#125;QTabWidget::pane:bottom&#123;bottom:-1px;&#125;QTabWidget::pane:left&#123;right:-1px;&#125;QTabWidget::pane:right&#123;left:-1px;&#125;\n\n在linux上编译动态库文件，可能会生成一堆软连接文件（图标上有个小箭头&#x2F;libuntitled.so&#x2F;libuntitled.so.1&#x2F;libuntitled.so.1.0libuntitled.so.1.0.0），很多时候看起来很烦，习惯了windows上就生成一个文件，你只需要在你的pro或者pri中加上一行 CONFIG +&#x3D; plugin 即可，这样只会生成一个libuntitled.so文件。2023-4-2补充：还可以使用 CONFIG +&#x3D; unversioned_libname unversioned_soname 来实现，unversioned_libname用来去掉lib的各个版本号，unversioned_soname用来去掉链接里的版本号（不加这个的话尽管生成的是libuntitled.so，但是链接编译的时候还会报错提示依赖带版本号的）。具体文章可以参考 https://blog.csdn.net/gongjianbo1992/article/details/129889588 。\n\n关于Qt在线安装过程中出现报错提示：下载“http://mirrors.aliyun.com...“时出现网络错误 的解决方法，打开命令行运行安装程序，比如C:\\Users\\Administrator&gt;D:\\Qt\\Qt6\\MaintenanceTool.exe，后面主动加上参数 –mirror https://mirrors.aliyun.com/qt，完整命令行是 C:\\Users\\Administrator&gt;D:\\Qt\\Qt6\\MaintenanceTool.exe –mirror https://mirrors.aliyun.com/qt，回车运行即可。同理也可以换成国内其他的镜像地址。\n\n从Qt6.4版本开始多媒体模块提供了ffmpeg作为后端解码使用（6.5版本默认就是ffmpeg），可以通过设置环境变量来更改使用哪种后端解码，在main函数的第一行 qputenv(“QT_MEDIA_BACKEND”, “ffmpeg”); 目前已知的问题是如果选用ffmpeg则暂时不支持中文目录以及中文名称，如果一定要支持中文则需要改成windows。\n12345678910//设置后端解码为ffmpeg/所有系统都支持qputenv(&quot;QT_MEDIA_BACKEND&quot;, &quot;ffmpeg&quot;);//windows系统专用qputenv(&quot;QT_MEDIA_BACKEND&quot;, &quot;windows&quot;);//linux系统专用qputenv(&quot;QT_MEDIA_BACKEND&quot;, &quot;gstreamer&quot;);//mac系统专用qputenv(&quot;QT_MEDIA_BACKEND&quot;, &quot;darwin&quot;);//android系统专用qputenv(&quot;QT_MEDIA_BACKEND&quot;, &quot;android&quot;);\n\n2 升级到Qt600：直观总结\n增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。\n把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。\n把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。\n跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。\n对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。\n有参数类型的变化，比如 long * 到 qintptr * 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。\n源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。\n我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。\n强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2.2版本开始正式迁移。\n\n01：01-10\n万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。PS：如果本身就是Qt6新增的功能函数则此方法无效\n\nQt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。\n1234567891011//pro文件引入模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgetsgreaterThan(QT_MAJOR_VERSION, 5): QT += core5compat//代码中引入头文件#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))#include &lt;QtWidgets&gt;#endif#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))#include &lt;QtCore5Compat&gt;#endif\n\n默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。\n123#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);#endif\n\n原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。\n\nQColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。\n\nQFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。\n\nQPalette调色板枚举值，Foreground &#x3D; WindowText, Background &#x3D; Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。\n\nQWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。\n\nsvg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT +&#x3D; svgwidgets ，同理opengl模块拆分出来了openglwidgets。\n\nqlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。\n\n\n02：11-20\n之前 QChar c &#x3D; 0xf105 全部要改成强制转换 QChar c &#x3D; (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。\n\nqSort等一些函数用回c++的 std::sort 。\n12345#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    std::sort(ipv4s.begin(), ipv4s.end());#else    qSort(ipv4s);#endif\n\nQt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。\n\nQMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。\n\nQTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。\n\nQApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。\n123456789#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))#include &quot;qscreen.h&quot;#define deskGeometry qApp-&gt;primaryScreen()-&gt;geometry()#define deskGeometry2 qApp-&gt;primaryScreen()-&gt;availableGeometry()#else#include &quot;qdesktopwidget.h&quot;#define deskGeometry qApp-&gt;desktop()-&gt;geometry()#define deskGeometry2 qApp-&gt;desktop()-&gt;availableGeometry()#endif\n\n获取当前屏幕索引以及尺寸需要分别处理。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//获取当前屏幕索引int QUIHelper::getScreenIndex()&#123;    //需要对多个屏幕进行处理    int screenIndex = 0;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    int screenCount = qApp-&gt;screens().count();#else    int screenCount = qApp-&gt;desktop()-&gt;screenCount();#endif    if (screenCount &gt; 1) &#123;        //找到当前鼠标所在屏幕        QPoint pos = QCursor::pos();        for (int i = 0; i &lt; screenCount; ++i) &#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))            if (qApp-&gt;screens().at(i)-&gt;geometry().contains(pos)) &#123;#else            if (qApp-&gt;desktop()-&gt;screenGeometry(i).contains(pos)) &#123;#endif                screenIndex = i;                break;            &#125;        &#125;    &#125;    return screenIndex;&#125;//获取当前屏幕尺寸区域QRect QUIHelper::getScreenRect(bool available)&#123;    QRect rect;    int screenIndex = QUIHelper::getScreenIndex();    if (available) &#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))        rect = qApp-&gt;screens().at(screenIndex)-&gt;availableGeometry();#else        rect = qApp-&gt;desktop()-&gt;availableGeometry(screenIndex);#endif    &#125; else &#123;#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))        rect = qApp-&gt;screens().at(screenIndex)-&gt;geometry();#else        rect = qApp-&gt;desktop()-&gt;screenGeometry(screenIndex);#endif    &#125;    return rect;&#125;\n\nQRegExp类移到了core5compat模块，需要主动引入头文件 #include 。\n1234567891011121314    //设置限制只能输入数字+小数位    QString pattern = &quot;^-?[0-9]+([.]&#123;1&#125;[0-9]+)&#123;0,1&#125;$&quot;;    //设置IP地址校验过滤    QString pattern = &quot;(2[0-5]&#123;2&#125;|2[0-4][0-9]|1?[0-9]&#123;1,2&#125;)&quot;;    //确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    QRegularExpression regExp(pattern);    QRegularExpressionValidator *validator = new QRegularExpressionValidator(regExp, this);#else    QRegExp regExp(pattern);    QRegExpValidator *validator = new QRegExpValidator(regExp, this);#endif    lineEdit-&gt;setValidator(validator);\n\nQWheelEvent构造参数和对应的计算方位函数变了。\n123456789101112131415161718//模拟鼠标滚轮#if (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))QWheelEvent wheelEvent(QPoint(0, 0), -scal, Qt::LeftButton, Qt::NoModifier);#elseQWheelEvent wheelEvent(QPointF(0, 0), QPointF(0, 0), QPoint(0, 0), QPoint(0, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, false);#endifQApplication::sendEvent(widget, &amp;wheelEvent);//鼠标滚轮直接修改值QWheelEvent *whellEvent = (QWheelEvent *)event;//滚动的角度,*8就是鼠标滚动的距离#if (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))int degrees = whellEvent-&gt;delta() / 8;#elseint degrees = whellEvent-&gt;angleDelta().x() / 8;#endif//滚动的步数,*15就是鼠标滚动的角度int steps = degrees / 15;\n\nqVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。\n\n\n03：21-30\nQStyleOption的init改成了initFrom。\n\nQVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。\n\nQStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。\n\nQFont的 resolve 的一个重载函数换成了 resolveMask。\n\nQSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。\n\nqcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。\n\nqtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。\n\nQByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。\n\nQDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。\n\nQLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。\n\n\n04：31-40\nQTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。\n\nqtnetwork模块中（TCP&#x2F;UDP相关的socket）的错误信号error换成了errorOccurred，就改了个名字，注意websocket那块居然没统一改过来依然是叫error。\n12345678910#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    connect(udpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error()));    connect(tcpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error()));#else    connect(udpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error()));    connect(tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error()));#endif//特别注意websocket中依然还是用errorconnect(webSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error()));\n\nXmlPatterns模块木有了，全部用xml模块重新解析。\n\nnativeEvent的参数类型变了。\n12345#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))bool nativeEvent(const QByteArray &amp;eventType, void *message, qintptr *result);#elsebool nativeEvent(const QByteArray &amp;eventType, void *message, long *result);#endif\n\nQButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。\n123456    QButtonGroup *btnGroup = new QButtonGroup(this);#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    connect(btnGroup, SIGNAL(idClicked(int)), ui-&gt;xstackWidget, SLOT(setCurrentIndex(int)));#else    connect(btnGroup, SIGNAL(buttonClicked(int)), ui-&gt;xstackWidget, SLOT(setCurrentIndex(int)));#endif\n\nQWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-&gt;settings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-&gt;settings();因为Qt6去除了N多过度封装的函数。\n12345#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    QWebEngineSettings *webSetting = QWebEngineProfile::defaultProfile()-&gt;settings();#else    QWebEngineSettings *webSetting = QWebEngineSettings::defaultSettings();#endif\n\nQt6将enterEvent的参数QEvent改成了QEnterEvent也不打个招呼。这种改变编译也不会提示的。\n12345678910111213#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))    void enterEvent(QEnterEvent *);#else    void enterEvent(QEvent *);#endif//后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。//这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。//下面是父类函数virtual void enterEvent(QEvent *event);//子类建议加上overridevoid enterEvent(QEvent *event) override;\n\nQt6中多个类进行了合并，比如现在QVector就成了QList的别名，意味着这两个类是同一个类没有任何区别，可能Qt内部对两种的优点都集中在一起，并尽量重写算法或者其他处理规避缺点。同理QStringList现在也成了 QList&lt;QString&gt; 的别名，是同一个类，没有单独的类。\n\n在Qt4时代默认QWidget构造函数父类是0，到了Qt5变成了Q_NULLPTR，到了Qt6居然用的是默认的c++标准中的nullptr而不是Qt自定义定义的Q_NULLPTR（同样的还有Q_DECL_OVERRIDE换成了用override等），可能是为了彻底抛弃历史包袱拥抱未来。\n12345678910111213//下面依次是Qt4/5/6的写法MainWindow(QWidget *parent = 0);MainWindow(QWidget *parent = Q_NULLPTR);MainWindow(QWidget *parent = nullptr);//查阅Qt源码查看Q_NULLPTR原来是根据编译器定义来选择#ifdef Q_COMPILER_NULLPTR# define Q_NULLPTR         nullptr#else# define Q_NULLPTR         NULL#endif//Qt高版本兼容低版本写法比如Qt5/6都支持 *parent = 0 这种写法。\n\n对于委托的进度条样式QStyleOptionProgressBar类的属性，在Qt4的时候不能设置横向还是垂直样式，默认横向样式，要设置orientation需要用另外的QStyleOptionProgressBarV2。从Qt5开始新增了orientation和bottomToTop属性设置。在Qt6的时候彻底移除了orientation属性，只有bottomToTop属性，而且默认进度是垂直的，很操蛋，理论上默认应该是横向的才对，绝大部分进度条场景都是横向的。这个时候怎么办呢，原来现在的处理逻辑改了，默认垂直的，如果要设置横向的直接设置 styleOption.state |&#x3D; QStyle::State_Horizontal 这种方式设置才行，而Qt6以前默认方向是通过 orientation 值取得，这个State_Horizontal从Qt4就一直有，Qt6以后要主动设置下才是横向的就是。\n\n\n05：41-50\nQt6.2版本开始增加了对多媒体模块的支持，但是在mingw编译器下还是有问题，直到6.2.2才修复这个问题，官网解释是因为mingw编译器版本不支持，到6.2.2采用了新的mingw900_64，这个编译器版本才支持。所以理论上推荐从6.2.2开始使用新的Qt6。\n\nQTextStream中的setCodec方法改成了setEncoding，参数变了，功能更强大。\n12345678QTextStream stream(&amp;file);#if (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))stream.setCodec(&quot;utf-8&quot;);stream.setCodec(&quot;gbk&quot;);#elsestream.setEncoding(QStringConverter::Utf8);stream.setEncoding(QStringConverter::System);#endif\n\nQModelIndex的查找子节点child函数去掉了，但是查找父节点parent函数保留，查阅代码得知之前的child函数就是封装的model-&gt;index(row, column, QModelIndex)函数。\n1234567//下面两个函数等价 如果要兼容Qt456则用下面这个方法QModelIndex index = indexParent.child(i, 0);QModelIndex index = model-&gt;index(i, 0, indexParent);//下面两个函数等价 如果要兼容Qt456则用下面这个方法QModelIndex indexChild = index.child(i, 0);QModelIndex indexChild = model-&gt;index(i, 0, index);\n\n之前QPixmap类中的静态函数grabWindow和grabWidget彻底废弃了，改成了用QApplication::primaryScreen()-&gt;grabWindow，其实这个从Qt5开始就建议用这个。\n12345#if (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))    QPixmap pixmap = QApplication::primaryScreen()-&gt;grabWindow(widget-&gt;winId());#else    QPixmap pixmap = QPixmap::grabWidget(widget-&gt;winId());#endif\n\nQProcess中的start方法以前直接支持传入完整的命令，到了Qt6严格要求必须拆分后面的参数。\n12345//Qt6以前支持执行完整命令QProcess p;p.start(&quot;wmic cpu get Name&quot;);//Qt6需要改成下面的方法，此方法也兼容Qt4、5、6p.start(&quot;wmic&quot;, QStringList() &lt;&lt; &quot;cpu&quot; &lt;&lt; &quot;get&quot; &lt;&lt; &quot;Name&quot;);\n\n在qss中对属性的枚举值写法到了Qt6换成了数值表示（需要翻阅枚举值的定义找到对应的值），这个改动挺大，切记需要切换过来，而且这种写法不兼容Qt5。\n123456789//Qt4/5 通过样式表设置标签右上角对齐ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-alignment:AlignRight;&quot;);//Qt4/5 通过样式表设置标签居中对齐ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-alignment:AlignHCenter|AlignVCenter;&quot;);//Qt6 通过样式表设置标签右上角对齐 翻阅 AlignRight 的枚举值=2ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-alignment:2;&quot;);//Qt6 通过样式表设置标签居中对齐 翻阅 AlignHCenter|AlignVCenter 的枚举值=0x04|0x80=0x84=132ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-alignment:132;&quot;);\n\nQt6中多媒体模块的类做了巨大调整改动，有些是类名的变化，比如音频输出（也叫播放）之前是 QAudioOutput 现在是 QAudioSink ，音频输入（也叫录音）之前是 QAudioInput 现在是 QAudioSource ，默认音频输入输出设备集合之前是 QAudioDeviceInfo::defaultInputDevice()、QAudioDeviceInfo::defaultOutputDevice()，现在是 QMediaDevices::defaultAudioInput()、QMediaDevices::defaultAudioOutput()。感觉这个名字改的没有以前贴切。\n12345678910111213141516#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,2,0))#define AudioInput QAudioSource#define AudioOutput QAudioSink#else#define AudioInput QAudioInput#define AudioOutput QAudioOutput#endif//使用的时候只需要new就行AudioInput *input = new AudioInput(format, this);#if (QT_VERSION &gt;= QT_VERSION_CHECK(6,2,0))#define QAudioInput QAudioSource#define QAudioOutput QAudioSink#endif//使用的时候只需要new就行QAudioInput *input = new QAudioInput(format, this);\n\nQt6开始默认用cmake，所以现在新版的qtcreator在新建项目的时候默认选择的就是cmake，很多初学者首次用的时候会发现，怎么突然之间生成的项目，结构都不一样，突然之间懵逼了，所以要在新建项目的过程中选择qmake，选择一次以后就默认qmake了。\n\nQt6.4开始对应类QString&#x2F;QByteArray的count函数废弃了，改用size&#x2F;length函数，估计可能描述更准确吧。\n\nQt6.4.1新增了N多BUG，强烈不建议使用，比如QAudioSink播放声音没有声音 https://bugreports.qt.io/browse/QTBUG-108383，DPI缩放严重变形 https://bugreports.qt.io/browse/QTBUG-108593。这些BUG在6.4.0&#x2F;6.5.0是不存在的，KPI害死人啊。\n\nQt6.5版本开始取消了QVariant的默认构造函数，之前return QVariant() 现在必须改成 QVariant(QVariant::Invalid) 才不会有警告提示。通过打印值发现QVariant()本身就&#x3D;QVariant(QVariant::Invalid)，所以统一写成QVariant(QVariant::Invalid)兼容Qt456。\n\n\n3 Qt安卓经验01：01-05\npro中引入安卓拓展模块 QT +&#x3D; androidextras 。\npro中指定安卓打包目录 ANDROID_PACKAGE_SOURCE_DIR &#x3D; $$PWD&#x2F;android 指定引入安卓特定目录比如程序图标、变量、颜色、java代码文件、jar库文件等。\n\n\nAndroidManifest.xml 每个程序唯一的一个全局配置文件，里面xml格式的数据，标明支持的安卓版本、图标位置、横屏竖屏、权限等。这个文件是最关键的，如果没有这个文件则Qt会默认生成一个。\nandroid&#x2F;res&#x2F;drawable-hdpi drawable-xxxhdpi 等目录下存放的是应用程序图标。\nandroid&#x2F;res&#x2F;layout 目录下存放的布局文件。\nandroid&#x2F;res&#x2F;values&#x2F;libs.xml 存储的一些变量值。\nandroid&#x2F;libs 目录下存放的jar库文件。\nandroid&#x2F;src 目录下存放的java代码文件，可以是根据包名建立的一层层子目录，也可以直接在src目录下。\n其他目录自行搜索安卓目录规范。\n后面的说明统一用的android目录举例，其实你可以改成任意目录，比如你的代码目录下是xxoo存放的安卓相关的打包文件，你就写成 ANDROID_PACKAGE_SOURCE_DIR &#x3D; $$PWD&#x2F;xxoo 。\n\n\njava类名必须和文件名完全一致，区分大小写。\njava类必须在android&#x2F;src目录下不然不会打包到apk文件，可以是子目录比如 android&#x2F;src&#x2F;com&#x2F;qt 。\nQt代码中的QAndroidJniObject指定传入的java包名，必须严格和java文件package完全一致，不然程序执行到此处会因为找不到而崩溃。\n\n\nandroid&#x2F;scr&#x2F;MainActivity.java 顶部 没有 package 则代码中必须是 QAndroidJniObject javaClass(“MainActivity”);\nandroid&#x2F;scr&#x2F;MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com&#x2F;qandroid&#x2F;MainActivity”);\nandroid&#x2F;scr&#x2F;com&#x2F;example&#x2F;MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com&#x2F;qandroid&#x2F;MainActivity”);\nandroid&#x2F;scr&#x2F;com&#x2F;example&#x2F;MainActivity.java 顶部 package com.example.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com&#x2F;qandroid&#x2F;example&#x2F;MainActivity”);\n总之这个包名是和代码中的package后面一段吻合，而不是目录路径。为了统一管理方便查找文件，建议包名和目录路径一致。\n\n02：06-10\nQt只能干Qt内部类的事情，做一些简单的UI交互还是非常方便，如果涉及到底层操作，还是需要熟悉java会如虎添翼，一般的做法就是写好java文件调试好，提供静态方法给Qt调用，这样通过QAndroidJniObject这个万能胶水可以做到Qt程序调用java中的函数并拿到执行结果，也可以接收java中的函数。\npro中通过 OTHER_FILES +&#x3D; android&#x2F;AndroidManifest.xml OTHER_FILES +&#x3D; android&#x2F;src&#x2F;JniMessenger.java 引入文件其实对整个程序的编译打包没有任何影响，就是为了方便在QtCreator中查看和编辑。\n在Qt中与安卓的java文件交互都是用万能的QAndroidJniObject，可以执行java类中的普通函数、静态函数，可以传类对象jclass、类名className、方法methodName、参数，也可以拿到执行结果返回值。 (I)V括号中的是参数类型，括号后面的是返回值类型，void返回值对应V，由于String在java中不是数据类型而是类，所以要用Ljava&#x2F;lang&#x2F;String;表示，其他类作为参数也是这样处理。\n\n\n调用实例方法：callMethod、callObjectMethod。\n调用静态方法：callStaticMethod、callStaticObjectMethod。\n不带Object的函数名用来执行无返回值或者常规返回值int、float等的方法。\n如果返回值是String或者类则需要用带Object的函数名来执行，返回QAndroidJniObject类型再转换处理拿到结果，比如toString拿到字符串。\n\n\n各种参数和返回值示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.qt;import org.qt.QtAndroidData;public class QtAndroidTest&#123;    //需要通过实例来调用 测试发现不论 private public 或者不写都可以调用 我擦    private void printText()    &#123;        System.out.println(&quot;printText&quot;);    &#125;    public static void printMsg()    &#123;        System.out.println(&quot;printMsg&quot;);    &#125;    public static void printValue(int value)    &#123;        System.out.println(&quot;printValue:&quot; + value);    &#125;    public static void setValue(float value1, double value2, char value3)    &#123;        System.out.println(&quot;value1:&quot; + value1 + &quot; value2:&quot; + value2 + &quot; value3:&quot; + value3);    &#125;    public static int getValue()    &#123;        return 65536;    &#125;    public static int getValue(int value)    &#123;        return value + 1;    &#125;    public static void setMsg(String message)    &#123;        System.out.println(&quot;setMsg:&quot; + message);    &#125;    public static String getMsg()    &#123;        return &quot;hello from java&quot;;    &#125;    public static void setText(int value1, float value2, boolean value3, String message)    &#123;        System.out.println(&quot;value1:&quot; + value1 + &quot; value2:&quot; + value2 + &quot; value3:&quot; + value3 + &quot; message:&quot; + message);    &#125;    public static String getText(int value1, float value2, boolean value3, String message)    &#123;        //同时演示触发静态函数发给Qt        QtAndroidData.receiveData(&quot;message&quot;, &quot;你好啊 java&quot;);        //下面两种办法都可以拼字符串        return &quot;value1:&quot; + value1 + &quot; value2:&quot; + value2 + &quot; value3:&quot; + value3 + &quot; message:&quot; + message;        //return &quot;value1:&quot; + String.valueOf(value1) + &quot; value2:&quot; + String.valueOf(value2) + &quot; value3:&quot; + String.valueOf(value3) + &quot; message:&quot; + message;    &#125;&#125;\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &quot;androidtest.h&quot;//java类对应的包名+类名#define className &quot;org/qt/QtAndroidTest&quot;void AndroidTest::test()&#123;    jint a = 12;    jint b = 4;    //可以直接调用java内置类中的方法    jint max = QAndroidJniObject::callStaticMethod&lt;jint&gt;(&quot;java/lang/Math&quot;, &quot;max&quot;, &quot;(II)I&quot;, a, b);    //jclass javaMathClass = &quot;java/lang/Math&quot;;    jdouble value = QAndroidJniObject::callStaticMethod&lt;jdouble&gt;(&quot;java/lang/Math&quot;, &quot;random&quot;);    qDebug() &lt;&lt; &quot;111&quot; &lt;&lt; max &lt;&lt; value;&#125;void AndroidTest::printText()&#123;    QAndroidJniEnvironment env;    jclass clazz = env.findClass(className);    QAndroidJniObject obj(clazz);    obj.callMethod&lt;void&gt;(&quot;printText&quot;);&#125;void AndroidTest::printMsg()&#123;#if 0    //查看源码得知不传入jclass类的函数中内部会自动根据类名查找jclass    QAndroidJniEnvironment env;    jclass clazz = env.findClass(className);    QAndroidJniObject::callStaticMethod&lt;void&gt;(clazz, &quot;printMsg&quot;);#else    //没有参数和返回值可以忽略第三个参数    QAndroidJniObject::callStaticMethod&lt;void&gt;(className, &quot;printMsg&quot;);    //QAndroidJniObject::callStaticMethod&lt;void&gt;(classNameTest, &quot;printMsg&quot;, &quot;()V&quot;);#endif&#125;void AndroidTest::printValue(int value)&#123;    QAndroidJniObject::callStaticMethod&lt;jint&gt;(className, &quot;printValue&quot;, &quot;(I)I&quot;, (jint)value);&#125;void AndroidTest::setValue(float value1, double value2, char value3)&#123;    QAndroidJniObject::callStaticMethod&lt;void&gt;(className, &quot;setValue&quot;, &quot;(FDC)V&quot;, (jfloat)value1, (jdouble)value2, (jchar)value3);&#125;int AndroidTest::getValue(int value)&#123;    //java类中有两个 getValue 函数 一个需要传参数    //jint result = QAndroidJniObject::callStaticMethod&lt;jint&gt;(className, &quot;getValue&quot;);    jint result = QAndroidJniObject::callStaticMethod&lt;jint&gt;(className, &quot;getValue&quot;, &quot;(I)I&quot;, (jint)value);    return result;&#125;void AndroidTest::setMsg(const QString &amp;msg)&#123;    QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg);    QAndroidJniObject::callStaticMethod&lt;void&gt;(className, &quot;setMsg&quot;, &quot;(Ljava/lang/String;)V&quot;, jmsg.object&lt;jstring&gt;());&#125;QString AndroidTest::getMsg()&#123;    QAndroidJniObject result = QAndroidJniObject::callStaticObjectMethod(className, &quot;getMsg&quot;, &quot;()Ljava/lang/String;&quot;);    return result.toString();&#125;void AndroidTest::setText(int value1, float value2, bool value3, const QString &amp;msg)&#123;    QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg);    QAndroidJniObject::callStaticMethod&lt;void&gt;(className, &quot;setText&quot;, &quot;(IFZLjava/lang/String;)V&quot;, (jint)value1, (jfloat)value2, (jboolean)value3, jmsg.object&lt;jstring&gt;());&#125;QString AndroidTest::getText(int value1, float value2, bool value3, const QString &amp;msg)&#123;    QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg);    QAndroidJniObject result = QAndroidJniObject::callStaticObjectMethod(className, &quot;getText&quot;, &quot;(IFZLjava/lang/String;)Ljava/lang/String;&quot;, (jint)value1, (jfloat)value2, (jboolean)value3, jmsg.object&lt;jstring&gt;());    return result.toString();&#125;\n\n\n在原生Android开发中，不同页面会定义不同的Activity。但使用Qt Quick、Flutter等采用Direct UI方式实现的第三方开发框架则只定义了一个Activity。里面不同页面实际都是使用OpenGL等直接绘制的。https://blog.csdn.net/LCSENs/article/details/100182235\n\n03：11-15\n安卓中一个界面窗体对应一个Activity，多个界面就有多个Activity，而在Qt安卓程序中，Qt这边只有一个Activity那就是QtActivity（包名全路径 org.qtproject.qt5.android.bindings.QtActivity），这个QtActivity是固定的写好的，整个Qt程序都是在这个QtActivity界面中。你打开AndroidManifest.xml文件可以看到对应节点有个name&#x3D;org.qtproject.qt5.android.bindings.QtActivity，所以如果要让Qt程序能够更方便通畅的与对应的java类进行交互（需要上下文传递Activity的，比如震动，消息提示等），建议新建一个java类，继承自QtActivity即可，这样相当于默认Qt启动的就是你java类中定义的Activity，可以很好的控制和交互。\n\n由于AndroidManifest.xml文件每个程序都可能不一样，为了做成通用的组件，这就要求可能不能带上AndroidManifest.xml文件，这样的话每个Qt安卓程序都启动默认内置的Activity，如果依赖Activity上下文的执行函数需要传入Qt的Activity才行，这里切记Qt的Activity包名是 Lorg&#x2F;qtproject&#x2F;qt5&#x2F;android&#x2F;bindings&#x2F;QtActivity; 之前顺手想当然的写的 Landroid&#x2F;app&#x2F;Activity; 发现死活不行，原来是包名错了。\n\n一个Qt安卓程序中可以有多个Java类，包括继承自Activity的类（这样的Activity可以通过QtAndroid::startActivity函数来调用），但是只能有一个通过AndroidManifest.xml文件指定的Activity，不指定会默认一个。如果java类中不需要拿到Qt的Activity进行处理的，可以不需要继承任何Activity，比如全部是运算的静态函数。\n\n在java类中如果上面没有主动引入包名，则下面需要写全路径，引入了则不需要全路径可以直接用（包括枚举值都可以直接写，比如 VIBRATOR_SERVICE 这种枚举值引入了包名后不需要写android.content.Context.VIBRATOR_SERVICE），建议引入包名，比如上面写了 import org.qtproject.qt5.android.bindings.QtActivity; 则下面继承类可以直接写 public class QtAndroidActivity extends QtActivity，如果没有引入则需要写成 public class QtAndroidActivity extends org.qtproject.qt5.android.bindings.QtActivity 。\n\n建议搭配 android studio 工具开发，因为在 android studio 中写代码都有自动语法提示，包名会提示自动引入，可以查看有那些函数方法等，还可以校验代码是否正确，而如果在QtCreator中手写有时候可能会写错，尤其是某个字母写错，当然这种错误是编译通不过的，会提示错误在哪行。\n\n\n04：16-20\n用Qt做安卓开发最大难点两个，第一个就是传参数这些奇奇怪怪的字符（Ljava&#x2F;lang&#x2F;String;）啥意思，如何对应，这也不是Qt故意为难初学者啥的，因为这套定义机制是安卓系统底层要求的，系统层面定义的一套规范，其实这个在帮助文档中写的很清楚，都有数据类型对照表，用熟悉了几次就很简单了。第二个难点就是用java写对应的类，如果是会安卓开发的人来说那不要太简单，尤其是搜索那么方便一大堆，没有搞过安卓开发的人来说就需要学习下，这个没有捷径，只是希望Qt能够尽可能最大化的封装一些可以直接使用的类，比如后期版本就提供了权限申请的类 QtAndroid::requestPermissionsSync 之类的，用起来就非常的爽，不用自己写个java类调来调去的。\n\n理论上来说按照Qt提供的万能大法类QAndroidJniObject，可以不用写java类也能执行各种处理，拿到安卓库中的属性和执行方法，就是写起来太绕太费劲，在java类中一行代码，这里起码三行，所以终极大法就是熟悉安卓开发，直接封装好java类进行调用。\n\n测试发现GetStringUTFChars方法对应的数据字符串中不能带有temp字样，否则解析有问题，不知什么原因。\n\n数据类型参数和返回值类型必须完全一致，否则执行会提示找不到对应的函数，有返回值一定要写上返回值。\n\njar文件对包名的命名没有要求，只要放在android&#x2F;libs目录下即可，安卓底层是通过包名去查找，而不是通过文件名，你甚至可以将原来的包名重新改成也可以正常使用，比如classes.jar改成test.jar也能正常使用。\n\n\n05：21-25\n关于权限设置，在早期的安卓版本，所有权限都写在全局配置文件AndroidManifest.xml中，这种叫安装时权限，就是安装的时候告诉安卓系统当前app需要哪些权限。大概从安卓6开始，部分权限需要动态申请，这种叫动态权限，这种申请到的权限也可以动态撤销，就是要求程序再次执行代码去向系统申请权限，比如拍照、存储读写等。也不是所有的权限都改成了动态申请，意味着兼容安卓6以上的系统你既要在AndroidManifest.xml中写上要求的权限，也要通过checkPermission申请你需要的权限。\n\nandroid studio 新建并生产jar包步骤。\n\n\n\n第一步：文件（File）-》新建（new）-》项目（new project）-》空白窗体（empty activity）。\n第二步：刚才新建好的项目鼠标右键新建（new）-》模块（new module）-》安卓库（android library）。\n说明：如果选择的不是安卓库（android library）而是java库（Java Library），则直接编译出来的就是jar文件，默认包名 com.example.lib.MyClass。推荐选择java库，编译后不用去一堆文件中找jar文件。\n第三步：写好库名字，根据项目需要选择好最低sdk版本-》完成。\n第四步：在刚才新建好的库项目mylibrary，依次找到子节点src&#x2F;main&#x2F;java&#x2F;com.example.mylibrary上鼠标右键新建-》class类。切记是这个节点不是java节点或者其他节点。\n第五步：写好你的类方法函数等。123456package com.example.mylibrary;public class Test &#123;    public static int add(int a, int b) &#123;        return a + b;    &#125;&#125;\n第六步：选中库项目mylibrary，菜单执行编译（build）-》编译库（make module xxx）。\n第七步：此时在mylibrary&#x2F;build目录下有outputs目录和intermediates目录，其中outputs&#x2F;aar目录下是生成的Android库项目的二进制归档文件，包含所有资源，class以及res资源文件全部包含。有时候我们仅仅需要jar文件，只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。需要到intermediates&#x2F;aar_main_jar&#x2F;debug目录下，可以看到classes.jar，将这个拷贝出来使用即可。当然你也可以对刚才的aar文件用解压缩软件解压出来也能看到classes.jar，是同一个文件。\n其他：调用jar包非常简单，只需要将jar文件放在你的项目的libs目录下即可，对应的包名和函数一般jar包提供者会提供，没有提供的话，可以在android studio中新建空白项目，切换到project视图，找到libs目录，鼠标右键最下面作为包动态库添加到项目，导入包完成以后会自动在libs目录列出，双击刚刚导入的包然后就自动列出对应的类和函数。\n\n\nQt安卓使用jar包步骤。\n\n\n第一步：将classes.jar放到android&#x2F;libs目录下，为啥是这个目录？因为这是安卓的规则约定，这个目录就是放库文件，放在这个目录下的文件会自动打包编译到apk文件中。\n第二步：调用jar文件之前，前提是你知道jar文件中的函数详细信息，这个一般jar提供者会提供好手册，如果代码没有混肴的话，你可以在android studio中双击打开查阅具体的函数。\n第三步：如果jar文件中的函数简单，直接拿到结果不需要绕来绕去，可以直接写Qt类来调用；如果还是很复杂，建议再去新建java类处理完再交给Qt，当然也可以让jar的作者尽可能封装函数的时候就做好，尽量提供最简单的接口返回需要的数据。比如返回图片数据可以做成jar内部存储好图片，然后返回图片路径即可，不然有些数据转换也挺烦。\n第四步：编写最终的调用函数。12345678int AndroidJar::add(int a, int b)&#123;#ifdef Q_OS_ANDROID    const char *className = &quot;com/example/mylibrary/Test&quot;;    jint result = QAndroidJniObject::callStaticMethod&lt;jint&gt;(className, &quot;add&quot;, &quot;(II)I&quot;, (jint)a, (jint)b);    return result;#endif&#125;\n\n\nQt6中对安卓支持部分做了大的改动，目前还不完善，如果是不涉及到与java交互的纯Qt项目，可以正常移植，涉及到的暂时不建议移植到Qt6，等所有类完善了再说。\n\n\n移除了安卓插件androidextras，将其中部分功能类移到core模块中，不需要额外引入。\n类名发生了变化，比如QAndroidJniObject改成了QJniObject、QAndroidJniEnvironment改成了QJniEnvironment，可能是为了统一移动开发平台类，弱化安卓的影响。\n对应的安卓jdk要用jdk11而不是jdk1.8，Qt5.15两个都支持，建议就统一用jdk11。\n对应封装的java类包名去掉了qt5标识，org.qtproject.qt5.android.bindings.QtActivity改成了org.qtproject.qt.android.bindings.QtActivity、org.qtproject.qt5.android.bindings.QtApplication改成了org.qtproject.qt.android.bindings.QtApplication。\n对安卓最低sdk有要求，所以建议在配置AndroidManifest.xml文件的时候不要带上最低版本要求。\n对AndroidManifest.xml文件内容有要求，之前Qt5安卓的不能在Qt6安卓下使用，具体内容参见示例下的文件。\n对应示例demo在 C:\\Qt\\Examples\\Qt-6.3.0\\corelib\\platform 目录下，之前是 C:\\Qt\\Examples\\Qt-5.15.2\\androidextras ，目前就一个示例，可能因为其他类还没有移植好。\nQt6中安卓模块介绍在这里 https://doc.qt.io/qt-6/qtandroidprivate.html\n\n\n如果想要安卓全屏遮挡住顶部状态栏，可以在main函数中将show改成showFullScreen即可，当然也可以采用java的方式在onCreate函数中加一行 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\n06：25-30\n横竖屏切换的识别，在Qt中会同时反映到resizeEvent事件中，你可以在这个是尺寸变化后读取下当前屏幕是横屏还是竖屏，然后界面上做出调整，比如上下排列改成左右排列。\n\n由于不同Qt版本对应的安卓配置文件 AndroidManifest.xml 内容格式不一样，高版本和低版本模板格式互不兼容，所以建议使用自己的Qt版本创建的 AndroidManifest.xml 文件，创建好以后如果使用的是自己重新定义的java文件的启动窗体则需要将 AndroidManifest.xml 文件中的 android:name&#x3D;”org.qtproject.qt5.android.bindings.QtActivity” 换掉就行。\n\n如果自己用android studio编译的jar文件放到Qt项目的libs目录下，导致编译通不过，提示 com.android.dx.cf.iface.ParseException: bad class file magic 之类的，那是因为jdk版本不一致导致的，你可能需要在android studio项目中找到模块编jdk版本设置的地方降低版本，比如你用的ndk是r14，则需要选择jdk1.6或者jdk1.7。一般来说高版本兼容低版本，因为ndk版本太低无法兼容jdk1.8。后面发现如果直接新建的是java库（Java Library）则不存在这个问题，如果选择的是安卓库（android library）就可能有这个问题。\n\n安卓项目配置文件是固定的名字 AndroidManifest.xml ，改成其他名字就不认识，不要想当然改成其他名字导致无法正常识别。\n\nAndroidManifest.xml文件中的package&#x3D;”org.qtproject.example”是包名，也是整个apk程序的内部唯一标识，如果多个apk这个包名一样，则会覆盖，所以一定要注意不同的程序记得把这个包名改成你自己的。这个包名也决定了java文件中需要使用资源文件时候的引入包名 import org.qtproject.example.R; 如果包名不一样则编译都通不过。\n\n\n4 Qt设计模式读《c++ Qt设计模式》书籍整理的一点经验。此书和官方的《C++ GUI Qt4编程》一起的。\n\n通常而言，好的做法是在包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。\n12345678#include &quot;frminput2019.h&quot;#include &quot;ui_frminput2019.h&quot;#include &quot;qdatetime.h&quot;#include &quot;qdebug.h&quot;#include &quot;input2019.h&quot;#include &quot;inputnumber.h&quot;\n\n一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。\n12345678910//不推荐写法for (int i = 0; i &lt; 100; ++i) &#123;    ...&#125;//推荐下面的写法const int count = 100;for (int i = 0; i &lt; count; ++i) &#123;    ...&#125;\n\n内存管理使程序员获得了强大的能力，但是，“权力越大，责任越大”。\n\n只要有可能，就应当使用列表而不是数组，比如应该使用 QList 代替 int [] ，在c++中数组被看成是“邪恶的”。\n\n在利用Qt编写程序的过程中，因为Qt的父子所有权继承关系，很少会用到智能指针，因为需要调用delete的情况很少。任何时候只要我们需要调用delete，或者是需要将某个指针设定为0时，应该考虑使用一个智能指针。\n\n实际上，我们不能完全确定使用多线程就一定能够真正改善程序的性能，例如，如果增加使用线程的数量，使他与系统可用的内核数量成正比，这样做或许还会降低程序的性能，因为所获得的收益会因线程竞争的剧增而消失殆尽。有时候，单线程中最有效的算法在多线程中却不一定有效。因此，如果真的是想改进程序的性能，理想的做法是，使用不同的实现方法，并与他们的性能进行比较后加以分类，当然测试对比的前提是使用完全相同的硬件和软件配置环境。\n\n在源代码中关于文件路径，使用 &#x2F; 会更方便一些，因为无论是在何种平台上，Qt都能理解他，不需要对他进行转换。但是，当我们想为用户显示路径时，最好还是根据应用程序所在平台的正确形式来显示他。\n\n当我们有很多项数据需要处理时，比如成千上万或者更多，那么为每个处理都创建一个线程可能导致大量的开销，这样来依次处理数据或许更快些。一种解决办法就是创建少量的辅助线程，并让每个线程只处理一组数据。\n\n\n\n5 Qt大佬专区5.1 酷码大佬微信：Kuma-NPC\n\n关于Qt事件传递的一个说明：\n\n\n通常写win32程序，鼠标消息应该是直接发给指定窗口句柄的，指定窗口没有处理就会转化成透传消息，交给父窗口处理。你在一个普通文字label上点击，父窗口也能收到鼠标事件。\nQt应该是所有消息都发给了顶层窗口，所以事件分发逻辑是自己处理，主窗口收到鼠标事件然后Qt自己分发给指定子控件，QEvent会有ignore或者accept表示自己处理了没有，例如鼠标点击事件，事件分发器发现没有被处理，数据重新计算然后分发给父窗口。这样父窗口收到的事件坐标就是基于自己窗口内的。用eventFilter就需要自己计算坐标。\n再比如，当使用QDialog，放一个QLineEdit并设置焦点，按Esc时QDialog也会自动关闭，本质上就是因为QLineEdit并不处理Esc的按键事件，透传给了QDialog。\n\n5.2 小豆君\n无论你是学Qt，Java，Python或其它，都需要明白一个道理：摒弃掉你的好奇心，千万不要去追求第三方类或工具是怎么实现的，这往往会让你收效甚微，其实，你只需要熟练掌握它的接口，知道类的目的即可，不可犯面向过程的毛病，刨根问底。记住，你的目标是让其它工具为你服务，你要踩在巨人的肩膀上创造世界。\n\nQt真正的核心：元对象系统、属性系统、对象模型、对象树、信号槽。往死里啃这五大特性，在你的项目中，逐渐的设法加入这些特性，多多练习使用它们，长此以往你会收获意想不到的效果。\n\n一边请教别人，一边多多重构，其实编码这条路虽然有人给你指路，但真正走下去的是你自己，当你真正走完时，你的编码水平一定会有非常大的提升。也许别人1000行的代码，在你这里几十行就搞定了，这也正事Qt的魅力。\n\n在阅读Qt的帮助文档时，要静下心来，不要放过每一句，记住在文档中没有废话，尤其是每段的开头。\n\n\n6 其他经验\nQt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！\n\n在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。\n\nQt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。\n\nQt在开发阶段不支持中文目录（运行阶段可以，比如打包发布的程序放到中文目录运行是ok的），切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，Qt项目源码也必须是英文目录，否则很可能不正常，建议尽量用默认的安装位置。\n\n如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。\n\nQt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.15，最高的新版本比如5.15.2。强烈不建议使用4.7以前和5.0到5.3之间的版本（Qt6.0到Qt6.2之间、不含6.2的版本也不建议，很多模块还没有集成），太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。如果没有历史包袱建议用5.15.2，目前新推出的6.0版本也强烈不建议使用，官方还在整合当中，好多类和模块暂时没有整合，需要等到6.2.2版本再用。考虑到qss性能以及自带mysql驱动的因素，最终Qt5选用5.12.3，Qt4选用4.8.7，Qt6选用6.5.x。\n\nQt和msvc编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017、Qt5.15+VS2019、Qt6.2+VS2019，按照这些搭配来，基本上常用的模块都会有，比如webengine模块，如果选用的Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的，如果一定要用msvc2015不想换msvc2017则只能选择Qt5.9+msvc2015套件，或者自行源码重新编译（这个难度超大，初学者绕过）。\n\nQt默认有对应VS版本，在下载对应VS插件的时候心里要有个数，官方默认提供的是原配的插件，如果想要Qt4.8+VS2015的插件，需要自行编译。一般来说是Qt4.8原配VS2010，Qt5.6原配VS2013，Qt5.9原配VS2015，Qt5.12原配VS2017，Qt5.15原配VS2019，切记：原配最好。\n\n用Qt做开发机器建议用win10，尤其是2021年以后新发布的Qt版本，比如Qt5.12.12、Qt5.15.2、Qt6.2.2等，因为很可能自带的QtCreator用的最新的版本，Qt6开始不再支持win7，或者由于其他的原因，对win7的支持不友好，会出现奇奇怪怪的问题等，所以又是没得选必须用win10。建议各位拥抱新时代的变化，这世上唯一不变的只有变化。\n\n新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。从Qt5.15开始不再提供离线安装包，意味着必须使用在线安装器安装Qt的后续版本，必须填写用户信息，没得选。\n\n终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人其他语言其他领域很可能做过！\n\n如果Qt能从下面几个方面努力，相信会更有发展前景。\n\n\n\nQWidget支持CSS3，具有诸多的牛逼的效果，目前支持的是CSS2。\nQWidget支持GPU绘制，可选切换CPU或者GPU，提升绘制效率，利用现在强大的硬件。\nQml无缝支持js，可以利用现在各种js轮子，指数级提升qml的项目范围。\n支持将程序转成web运行，比如转成cgi之类的程序，目前Qt for WebAssembly很鸡肋，功能极其有限，sql&#x2F;network&#x2F;本地访问等都不支持，首次加载速度超慢，大部分Qt类还不支持。\n\n\nQt自从4.7以后引入的QML。从此以后，Qt开发就分成了两种流派，一者使用原来的C++ 语言进行开发，另外一种使用QML语言进行开发。这下搞得嘞，经常吵吵不亦乐乎，在Qt界从此就有两大阵营产生激烈的纷争，那就是选用qml还是widget好，大量初学者也会问这个问题，有以下几点总结。\n\n\nwidget属于传统界面开发，和VB&#x2F;VC&#x2F;Delphi等拖曳控件开发类似，走CPU绘制，能最大化的兼容现有的硬件和过去的相对偏低性能的硬件。\nqml属于新时代的产物，大概从2010年开始，和flutter&#x2F;Electron等web开发框架及移动开发框架类似，为了适应各种移动端开发及动画流畅性触摸丝滑体验、充分利用和“榨干”现在的GPU性能，把CPU留出来给用户最大化发挥。\n硬件性能越好，GPU越是强劲，qml的综合性能越是完爆widget，反之对比也是指数级的。除了极其省成本的嵌入式硬件领域或者国产CPU等，其他领域的硬件性能都是暴增。\nwidget主要集中在金融、军工、安防、航天、船舶、教育等领域，qml主要集中在汽车仪表、车机、直播等领域。\n目前国内widget多于qml，国外可能偏向qml，这个不难看出，流行的移动端开发框架都是国外开发者居多。\n可预见的十年内，这两者将长期并存，官方基本不再更新widget而是主推qml，意味着将来对qml的性能优化只增不减，未来趋势是qml。\n没有编程经验的新手qml学习成本更低，而从VB&#x2F;VC等传统软件开发转过来的从业者更适合学习widget。\n有的时候不禁要问，既生widget何生qml，学习成本和选择又多了，其实这正是和这个世界的哲学一样：世界是简单的又是复杂的。为了适应各种需求和满足需要。\n总之，无论qml还是widget，和找老婆一样，适合自己的就是最好的，自己擅长哪个就用哪个。\n如果还不知道擅长哪个，有空就两个都学，学习过程中自己就会有切身感受和对比，能者多劳多多益善。能够顺利的最快的完成老板的任务给老板赚钱才是王道。\n网友补充：如果你的软件最终是手指操作的多，就用qml，如果是鼠标操作的多，就选择widget。\n\n\n写程序过程中发现问题，比如有些问题是极端特殊情况下出现，最好找到问题的根源，有时候肯定多多少少会怀疑是不是Qt本身的问题，怀疑是对的，但是99.9%的问题最终证实下来还是自己的代码写的不够好导致的，如果为了赶时间老板催的急，实在不行再用重启或者复位大法，比如搞个定时器、线程、网络通信啥的去检测程序是否正常，程序中某个模块或者功能是否正常，不正常就复位程序或者重启程序，在嵌入式上还可以更暴力一点就是系统重启和断电重启。\n\n写程序过程中尤其要注意32位的库和64位的库互不兼容，比如32位的程序引用64位的库，64位的程序引用32位的库，都是编译通不过的，而在windows64位系统中是能够运行32位程序的，因为64位的系统提供了32位的运行环境，一般目录在Program Files(x86)，32位的程序在64位的环境中最终引用的还是32位的库。关于如何判断自己的Qt库是多少位，有个误区就是很多人要么看成了QtCreator的关于信息中列出的位数，要么以为自己是64位的系统就认为是64位的Qt，最终要在Qt构建套件中查看具体位数，大概从Qt5.14开始基本上很少提供32位的库，尤其是Qt6.0以后基本上默认就是只有64位的库了，这也是顺应时代潮流，毕竟不久的将来（个人预计2030年以前）基本上32位的系统占比不超过1%，放心大胆的用64位的库吧，抛弃烦人的32位以及XP系统。\n\n关于程序中动态和静态的一点个人理解：\n\n\n\n在Qt程序中，分动态库版本的Qt和静态库版本的Qt。\n官方默认提供的二进制包就是动态库版本的Qt，如果自行编译则编译的时候对应参数 -shared。\n静态库版本的Qt需要自行编译，编译的时候对应参数 -static，（理论上无论商业非商业使用Qt静态库需要收费，因为静态编译后都看不到Qt的相关库文件）。\n使用动态库的Qt支持编译生成动态库和静态库（CONFIG +&#x3D; staticlib）的程序。\n使用动态库的Qt程序支持动态库的引用（引用的时候 LIB +&#x3D; ，运行的时候需要动态库文件比如 .dll .so 文件支持）。\n使用动态库的Qt程序支持静态库的引用（引用的时候 LIB +&#x3D; ，运行的时候无需库文件支持，可以理解为该文件已经和可执行文件合二为一，缺点是可执行文件体积变大）。\n通过生成文件的个数和大小可以发现，静态库相当于把运行时需要的文件也一并合并到一个文件了，而动态库是拆分成两个文件，一个用于编译，一个用于运行。\n上述动态库的规则也通用于静态库。\n此规则应该是通用于其他语言框架。\n很多人有个误区包括几年前的我，以为要用Qt编写静态库就必须用静态的Qt库，其实动态库的Qt也可以编写静态的库，只是该库不会生成动态库文件。\n如果要将Qt程序编译成静态的可执行文件（单个文件无依赖），前提是所用的Qt库必须静态的。\n\n\n后期的Qt版本，大致从5.15开始，就不在提供离线版本下载，需要自行通过在线安装器安装，由于默认服务器在国外，很多人反映下载的时候很慢，或者选择晚上的时候下载要快很多，为了解决这个烦人的问题，不至于时间都浪费在没有意义的等待上，有个极其简单的方法可以将速度提升几万倍，甚至冲坏你的硬盘。先下载 Fiddler5（尽量选择中文版本不然小白看不懂），双击打开程序后（可能win10自带的杀毒软件会报毒删除，临时停用杀毒软件或者恢复可信任文件即可），在底部的输入栏中输入 urlreplace download.qt.io mirrors.ustc.edu.cn&#x2F;qtproject&#x2F; 回车应用，然后再去打开安装器在线安装，世界突然变得非常美好。\n\nQt绝对是个非常牛逼的项目，源码非常庞大，而且分模块设计，对于有足够精力的可以花时间学习源码中的具体实现，如果时间不多，个人推荐看 QObject、QWidget、QPainter、QString、QColor、QList、QVariant、QAbstractButton、QAbstractItemModel、qnamespace.h（整个Qt中所有的全局的枚举值）、这些类的源码即可，看看他们有哪些方法和属性，对自己的编程会有莫大的帮助。\n\n最后一条：珍爱生命，远离编程。祝大家头发浓密，睡眠良好，情绪稳定，财富自由！\n\n\n7 杂七杂八7.1 推荐开源主页\n\n\n名称\n网址\n\n\n\nQt&#x2F;C++学习高级群\n751439350\n\n\nQtWidget开源demo集合\nhttps://gitee.com/feiyangqingyun/QWidgetDemo\n\n\nQtQuick&#x2F;Qml开源demo集合\nhttps://gitee.com/jaredtao/TaoQuick\n\n\nQtQuick&#x2F;Qml开源demo集合\nhttps://gitee.com/zhengtianzuo/QtQuickExamples\n\n\n7.2 推荐网站主页\n\n\n名称\n网址\n\n\n\nqtcn\nhttp://www.qtcn.org\n\n\n豆子的空间\nhttps://www.devbean.net\n\n\nyafeilinux\nhttp://www.qter.org\n\n\nfeiyangqingyun\nhttps://blog.csdn.net/feiyangqingyun\n\n\nQt作品大全\nhttps://qtchina.blog.csdn.net/article/details/97565652\n\n\n龚建波\nhttps://gongjianbo1992.blog.csdn.net/\n\n\n乌托邦2号\nhttp://blog.csdn.net/taiyang1987912\n\n\nforuok\nhttp://blog.csdn.net/foruok\n\n\njason\nhttp://blog.csdn.net/wsj18808050\n\n\n朝十晚八\nhttp://www.cnblogs.com/swarmbees\n\n\nBIG_C_GOD\nhttp://blog.csdn.net/big_c_god\n\n\n公孙二狗\nhttps://qtdebug.com/qtbook\n\n\n雨田哥\nhttps://blog.csdn.net/ly305750665\n\n\n郑天佐\nhttps://blog.csdn.net/zhengtianzuo06\n\n\n寒山-居士\nhttps://blog.csdn.net/esonpo\n\n\n前行中小猪\nhttp://blog.csdn.net/goforwardtostep\n\n\n涛哥的知乎专栏\nhttps://zhuanlan.zhihu.com/TaoQt\n\n\nQt君\nhttps://blog.csdn.net/nicai_xiaoqinxi\n\n\n7.3 推荐学习网站\n\n\n名称\n网址\n\n\n\nQt老外视频教程\nhttp://space.bilibili.com/2592237/#!&#x2F;index\n\n\nQt维基补充文档\nhttps://wiki.qt.io/Main\n\n\nQt源码查看网站\nhttps://code.woboq.org/qt5\n\n\nQt官方下载地址\nhttps://download.qt.io\n\n\nQt官方下载新地址\nhttps://download.qt.io/new_archive&#x2F;qt&#x2F;\n\n\nQt国内镜像下载地址\nhttps://mirrors.cloud.tencent.com/qt\n\n\nQt安装包下载地址\nhttp://qthub.com/download/\n\n\nQt最新版二进制包\nhttps://build-qt.fsu0413.me/\n\n\nQt版本更新内容\nhttps://doc-snapshots.qt.io/qt6-6.2/whatsnew62.html\n\n\nQt中qmake变量说明\nhttps://doc.qt.io/qt-5/qmake-variable-reference.html\n\n\nQt入门最简单教程\nhttp://c.biancheng.net/qt/\n\n\nqss学习地址1\nhttp://47.100.39.100/qtwidgets/stylesheet-reference.html\n\n\nqss学习地址2\nhttp://47.100.39.100/qtwidgets/stylesheet-examples.html\n\n\nqss学习地址3\nhttps://doc.qt.io/qt-6/qstyle.html\n\n\n精美图表控件QWT\nhttp://qwt.sourceforge.net/\n\n\n精美图表控件QCustomPlot\nhttps://www.qcustomplot.com/\n\n\n免费图标下载\nhttp://www.easyicon.net/\n\n\n图形字体下载\nhttps://www.iconfont.cn/\n\n\n漂亮界面网站\nhttps://www.ui.cn/\n\n\n微信公众号\n官方公众号：Qt软件  亮哥公众号：高效程序员\n\n\n8 书籍推荐\nC++入门书籍推荐《C++ primer plus》，进阶书籍推荐《C++ primer》。\nQt入门书籍推荐霍亚飞的《Qt Creator快速入门》，Qt进阶书籍推荐官方的《C++ GUI Qt4编程》，qml书籍推荐《Qt5编程入门》，Qt电子书强烈推荐《Qt5.10 GUI完全参考手册》。\n强烈推荐程序员自我提升、修养、规划系列书《走出软件作坊》《大话程序员》《程序员的成长课》《解忧程序员》，受益匪浅，受益终生！\n\n","slug":"转载/Qt/Qt开发经验","date":"2023-05-08T02:27:52.000Z","categories_index":"转载","tags_index":"Qt,c++","author_index":"阿木大叔"},{"id":"01d9802911dc5e780502cf79cbe9f782","title":"Qt实现日历行程软件","content":"DailyAssist📚简介本项目为Qt实现日历行程软件。\n\n日历显示、增加&#x2F;删除行程\n增加删除定时任务，支持关机，重启，锁屏，注销等操作\n支持动态多语言\n支持切换布局\n支持启动密码设置\n支持开机自启动\n动态切换效果\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上msvc编译器都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\nsqlite\n存储数据库\n\n\n🗺️软件展示 \n\n日历行程\n新建日程\n定时提醒\n新建提醒\n系统设置\n英文界面\n布局2\n布局3\n图形密码\n英文界面\n日历行程\n定时提醒\n系统设置\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现日历行程软件","date":"2023-05-04T11:44:09.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"bfad628bb7933d4e69a2d0dc8ebc5a5c","title":"QtAv编译-windows平台","content":"\n简介\nQtAV是基于Qt和FFmpeg的多媒体播放库。它可以帮助您以前所未有的精力编写播放器。\n\nQtAV强大的功能\nQtAV可以满足您的最大需求\n\n硬件解码支持：DXVA2，VAAPI，VDA &#x2F; VideoToolbox，CedarX，CUDA（第一个播放器在Linux上支持CUDA吗？）\nOpenGL和ES2支持几乎所有格式，包括Hi10P视频（第一个播放器&#x2F;库在ES2中支持10bit？VLC，XBMC，mplayer现在不支持）\n实时预览\nRGB和YUV格式的视频捕获\nOSD和自定义过滤器\nlibavfilter中的过滤器，例如stero3d，模糊\n字幕轨道选择。动态更改FFmpeg和libass引擎\n逐帧播放\n播放速度控制\n各种流：区域设置文件，http，rtsp等以及您的自定义流\n音频通道，轨道和外部音频轨道\n播放时动态更改渲染引擎。\n动态更改视频解码器\n1个播放器的多个视频输出\n视频均衡器（软件和OpenGL）：亮度，对比度，饱和度，色相\nQML支持。大多数播放API与QtMultimedia模块兼容\n兼容性：QtAV可以同时使用Qt4和Qt5，FFmpeg（&gt; &#x3D; 1.0）和Libav（&gt; &#x3D; 9.0）来构建。建议使用最新的FFmpeg版本。\n\n\n\n编译准备作者目前所使用的的环境为Qt5.9.3 + vs2015编译器\n下载FFmpeg直接下载官方提供的开发库下载地址：    - https://ffmpeg.zeranoe.com/builds/win64/dev/ffmpeg-3.4.2-win64-dev.zip    - https://ffmpeg.zeranoe.com/builds/win64/shared/ffmpeg-3.4.2-win64-shared.zip\n使用QtAv提供的开发库（推荐）txt- 文件名：QtAV-depends-windows-x86+x64.7z\n- http://sourceforge.net/projects/qtav/files/depends/QtAV-depends-windows-x86+x64.7z/download\n- 本教程采用此种方式编译QtAv自行编译FFmpegtxt- 自行编译比较麻烦，感兴趣的可以自行尝试，这里不再赘述下载QtAv源码txt- 访问QtAv github地址：https://github.com/wang-bin/QtAV/\n- 可以使用git clone或者直接下载源代码配置环境\n进入QtAv代码根目录\n创建ffmpeg&#x2F;win目录\n解压上面下载的FFmpeg依赖库：QtAV-depends-windows-x86+x64.7z，解压到上面创建ffmpeg&#x2F;win目录\n目录结构如下\n修改QtAv&#x2F;.qmake.conf文件\n在最后加上下面两行，即设置FFmpeg的动态库路径及头文件路径12INCLUDEPATH += $$PWD/ffmpeg/win/includeLIBS +=  -L$$PWD/ffmpeg/win/lib\n完整文件如下123456789101112131415161718QTAV_MAJOR_VERSION = 1QTAV_MINOR_VERSION = 13QTAV_PATCH_VERSION = 0QTAV_VERSION = $$&#123;QTAV_MAJOR_VERSION&#125;.$$&#123;QTAV_MINOR_VERSION&#125;.$$&#123;QTAV_PATCH_VERSION&#125;#MODULE_VERSION = $$QTAV_VERSION# set runpath instead of rpath for gcc for elf targets. Qt&gt;=5.5CONFIG *= enable_new_dtags# OSX10.6 is not supported in Qt5.4macx:isEqual(QT_MAJOR_VERSION,5):greaterThan(QT_MINOR_VERSION, 3): CONFIG *= c++11android: CONFIG*=c++11QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.8QMAKE_IOS_DEPLOYMENT_TARGET = 6.0# 阿木大叔INCLUDEPATH += $$PWD/ffmpeg/win/includeLIBS +=  -L$$PWD/ffmpeg/win/lib\n\n开始编译\n使用QtCreator打开QtAv.pro文件\n进行编译即可\n\n运行&amp;测试\n将QtAV\\ffmpeg\\win\\bin下面的所有dll文件拷贝到QtAV\\bin目录\n选择simpleplayer项目，点击运行即可\n可以看见一个简易的视频播放器就出现了，可以去播放测试了\n\n使用QtAv动态库\n在QtAV\\lib_win_x86目录下有生成的QmlAV.dll及QmlAV.lib，QtAVWidgets1.lib，QtAVWidgets1.lib，这四个文件即我们需要的动态库文件\nQtAV\\src\\QtAV和QtAV\\widgets\\QtAVWidgets两个目录为上面两个动态库的头文件\n有了上面这些文件，你就可以集成到自己的程序里，开发自己的播放器了，具体开发过程这里就不再说明了，有机会可以再写一篇教程，具体可以看官方示例就行\n\n","slug":"Qt/进阶教程/QtAv编译-windows","date":"2022-11-02T05:57:29.000Z","categories_index":"Qt入门指南,QtAv使用教程","tags_index":"Qt,QtAv","author_index":"阿木大叔"},{"id":"e715a1b3be6463ce11c263a306ec455e","title":"Qt编译报错 Parse error at “std“的解决办法","content":"\n正文\nQt编译时出现如下报错\n\n\n&#x2F;usr&#x2F;local&#x2F;Qt-5.10.0&#x2F;bin&#x2F;moc -DLINUX -DQT_DEPRECATED_WARNINGS -DQT_NO_DEBUG -DQT_NETWORK_LIB -DQT_CORE_LIB –include .&#x2F;moc_predefs.h -I&#x2F;usr&#x2F;local&#x2F;Qt-5.10.0&#x2F;mkspecs&#x2F;linux-g++ -I&#x2F;root&#x2F;hz3000v2.5&#x2F;trunk&#x2F;source&#x2F;dts&#x2F;debug_info_srv -I&#x2F;root&#x2F;hz3000v2.5&#x2F;trunk&#x2F;source&#x2F;dts&#x2F;common -I&#x2F;root&#x2F;hz3000v2.5&#x2F;trunk&#x2F;include&#x2F;hnstd -I&#x2F;root&#x2F;hz3000v2.5&#x2F;trunk&#x2F;include&#x2F;boost_include -I&#x2F;root&#x2F;hz3000v2.5&#x2F;trunk&#x2F;source&#x2F;dts&#x2F;debug_info_srv -I&#x2F;usr&#x2F;local&#x2F;Qt-5.10.0&#x2F;include -I&#x2F;usr&#x2F;local&#x2F;Qt-5.10.0&#x2F;include&#x2F;QtNetwork -I&#x2F;usr&#x2F;local&#x2F;Qt-5.10.0&#x2F;include&#x2F;QtCore -I&#x2F;usr&#x2F;include&#x2F;c++&#x2F;4.9 -I&#x2F;usr&#x2F;include&#x2F;i386-linux-gnu&#x2F;c++&#x2F;4.9 -I&#x2F;usr&#x2F;include&#x2F;c++&#x2F;4.9&#x2F;backward -I&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i586-linux-gnu&#x2F;4.9&#x2F;include -I&#x2F;usr&#x2F;local&#x2F;include -I&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;i586-linux-gnu&#x2F;4.9&#x2F;include-fixed -I&#x2F;usr&#x2F;include&#x2F;i386-linux-gnu -I&#x2F;usr&#x2F;include tcp_server.h -o moc_tcp_server.cppusr&#x2F;include&#x2F;c++&#x2F;4.9&#x2F;bits&#x2F;stl_relops.:67: Parse error at “std”Makefile:579: recipe for target ‘moc_tcp_server.cpp’ failedmake: *** [moc_tcp_server.cpp] Error 1\n\n解决方案于是，一通google之后发现，qmake会在工程目录下生成.qmake.stash，删掉这个文件，重新qmake myproject.pro，会重新生成这个文件\n\nqmake myproject.proInfo: creating stash file &#x2F;root&#x2F;myproject&#x2F;.qmake.stash\n\n","slug":"Qt/进阶教程/国产化系统Qt编译报错01","date":"2022-11-02T05:42:51.000Z","categories_index":"Qt入门指南,国产化操作系统","tags_index":"Qt,国产化","author_index":"阿木大叔"},{"id":"a6c3990ea6d4db0cb6f4530662b613f2","title":"VUE前端解决web升级后需要手动刷新浏览器问题","content":"问题描述\nvue项目后端升级新的index.html及相应js&#x2F;css后，前端已打开web是不感知的，所以在不刷新浏览器的情况下，前端的index.html是不会主动更新，从而造成前后端不一致的问题。\n\n前端方案\nweb每次编译时自动生成一个版本号，并且写入的配置文件中\n每次打包配置文件一起发布\nweb在需要的地方检测服务器上的配置文件和当前web的版本号是否一致，若不一致则主动刷新一下界面，或者提示用户刷新等\n\n具体步骤\n修改vue.config.js, 生成版本号，并注入项目中\n\n修改vue.config.js, 生成配置文件，version.json\n\n完整代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const path = require(&#x27;path&#x27;)Date.prototype.Format = function (fmt) &#123;    var o = &#123;        &quot;M+&quot;: this.getMonth() + 1,  // 月份        &quot;d+&quot;: this.getDate(),       // 日        &quot;h+&quot;: this.getHours(),      // 小时        &quot;m+&quot;: this.getMinutes(),    // 分        &quot;s+&quot;: this.getSeconds(),    // 秒        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), // 季度        &quot;S&quot;: this.getMilliseconds() // 毫秒    &#125;;    if (/(y+)/.test(fmt))        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));    for (var k in o)        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));        return fmt;&#125;let myVersion = new Date().Format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;);module.exports = &#123;    chainWebpack: config =&gt; &#123;        config.resolve.alias        .set(&#x27;vue-i18n&#x27;, &#x27;vue-i18n/dist/vue-i18n.cjs.js&#x27;)        .set(&#x27;@&#x27;, path.join(__dirname,&#x27;src&#x27;))        config.plugin(&#x27;define&#x27;)        .tap(args =&gt; &#123;             args[0][&#x27;process.env&#x27;].API_CONFIG = JSON.stringify(&#123;                WEB_VERSION: myVersion  //自定义配置web版本号            &#125;)            return args        &#125;)    &#125;&#125;// 导入fs模块const fs = require(&#x27;fs&#x27;)// 调用writeFile()写入内容，如果写入路径的文件找不到，路径正确会自动创建文件// 注意：writeFile()不会自动创建路径// 判断是否写入成功let ver = &#123;    version: myVersion&#125;fs.writeFile(__dirname + &#x27;/public/version.json&#x27;, JSON.stringify(ver), &#x27;utf-8&#x27;, function(err) &#123;    if (err) &#123;        return console.log(&#x27;写入文件失败&#x27;, err.message)    &#125; else &#123;        console.log(&#x27;写入成功&#x27;)    &#125;&#125;)\n\n在需要的地方请求配置文件，并校验\n12345678910async function checkWebVersion() &#123;    const ver = await request.get(`/version.json?t=$&#123;new Date().getTime()&#125;`);    console.log(ver);    let serverVersion = ver.version;    let localWebVersion = process.env.API_CONFIG.WEB_VERSION;    if (localWebVersion &amp;&amp; serverVersion != localWebVersion) &#123;        window.location.reload();        return;    &#125;&#125;\n\n此处为示例，可根据需求修改\n原理上就是获取一下服务器上的web版本号，注意后面加上时间戳\n然后对比当前web版本和服务器上web版本的却别\n若有区别则刷新界面，重新加载web\n此段代码可以加到axio的发送拦截器中，每条请求都校验一次，也可以增加定时器，间隔一定时间去检测，具体根据实际业务来处理\n\n\n\n","slug":"WEB/VUE前端解决web升级后需要手动刷新浏览器问题","date":"2022-11-01T08:52:25.000Z","categories_index":"前端框架","tags_index":"vue","author_index":"阿木大叔"},{"id":"cb8a46bc06540e3038f7697e934b72dc","title":"TCP四次挥手","content":"\n四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用 close() 函数，当两端都调用了该函数，四次挥手也就完成了。\n\n\n客户端和服务器断开连接 -&gt; 单向断开\n服务器和客户端断开连接 -&gt; 单向断开\n进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作。\n\n\n\n\n在 Tcp 协议中，比较重要的字段有：\n源端口：表示发送端端口号，字段长 16 位，2 个字节\n\n目的端口：表示接收端端口号，字段长 16 位，2 个字节\n\n序号（sequence number）：字段长 32 位，占 4 个字节，序号的范围为 [0，4284967296]。\n\n由于 TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号  首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。  序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了 0  确认序号（acknowledgement number）：占 32 位（4 字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为 N，序号为 S，则表明到序号 N-S 为止的所有数据字节都已经被正确地接收到了。\n\n\n8 个标志位（Flag）:\n\nCWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；\nECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.；\nURG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；\nACK：该位设为 1，确认应答的字段有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设为 1；\nPSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；\nRST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；\nSYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；\nFIN：该位设为 1，表示今后不再有数据发送，希望断开连接。\n\n\n窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。\n\n\n\n\n\n标志位\n解释\n\n\n\nSYN\nsynchronous建立联机\n\n\nACK\nacknowledgement 确认\n\n\nPSH\npush传送\n\n\nPSH\npush传送\n\n\nURG\nurgent紧急\n\n\nRST\nreset重置\n\n\nFIN\nfinish结束\n\n\nseq\nSequence number(顺序号码)\n\n\nack\nAcknowledge number(确认号码)\n\n\nTCP四次挥手具体过程如下：1234567sequenceDiagram    participant Client    participant Server    Client-&gt;&gt;Server: FIN,Seq=x,Ack=y    Server--&gt;&gt;Client: ACK,Ack=y+1,Seq=z    Server-&gt;&gt;Client: FIN,Seq=w,Ack=y+1    Client--&gt;&gt;Server: ACK,Ack=w+1,Seq=x+1\n\n第一次握手：\n客户端：客户端向服务器端发起连接请求将报文中的 SYN 字段置为 1，生成随机序号 x，seq&#x3D;x\n服务器端：接收客户端发送的请求数据，解析 tcp 协议，校验 SYN 标志位是否为 1，并得到序号 x\n\n第一次挥手:\n主动断开连接的一方：发送断开连接的请求\n将 tcp 协议中 FIN 标志位设置为 1，表示请求断开连接\n发送序号 x 给对端，seq&#x3D;x，基于这个序号用于客户端数据校验的计算\n\n\n被动断开连接的一方：接收请求数据，并解析 TCP 协议\n校验 FIN 标志位是否为 1\n收到了序号 x，基于这个数据计算回复的确认序号 ack 的值\n\n\n\n第二次挥手:\n被动断开连接的一方：回复数据\n同意了对方断开连接的请求，将 ACK 标志位设置为 1\n回复 ack&#x3D;x+1，表示成功接受了客户端发送的一个字节数据\n向客户端发送序号 seq&#x3D;y，基于这个序号用于服务器端数据校验的计算\n\n\n主动断开连接的一方：接收回复数据，并解析 TCP 协议\n校验 ACK 标志位，如果为 1 表示断开连接的请求对方已经同意了\n校验 ack 确认发送的数据服务器是否收到了，发送的数据 &#x3D; ack - x &#x3D; x + 1 -x &#x3D; 1\n\n\n\n第三次挥手:\n被动断开连接的一方：将 tcp 协议中 FIN 标志位设置为 1，表示请求断开连接\n主动断开连接的一方：接收请求数据，并解析 TCP 协议，校验 FIN 标志位是否为 1\n\n第四次挥手:\n主动断开连接的一方：回复数据\n将 tcp 协议中 ACK 对应的标志位设置为 1，表示同意了断开连接的请求\nack&#x3D;y+1，表示服务器发送给客户端的一个字节客户端接收到了\n序号 seq&#x3D;h，此时的 h 应该等于 x+1，也就是第三次挥手时服务器回复的确认序号 ack 的值\n\n\n被动断开连接的一方：收到回复的 ACK, 此时双向连接双向断开，通信的两端没有任何关系了\n\nwirshark抓包分析TCP四次挥手过程，此抓包为服务端主动断开连接\n\n第一次挥手\n\nFIN请求，即服务端请求断开连接，可以看到seq&#x3D;1， 这里的ASK标志，及ask&#x3D;1说明断开的时候对之前收到的报文段进行确认  \n\n\n第二次挥手\n\n[ACK]请求，即客户端同意断开连接，ACK说明客户端已经同意了服务端的请求  \n\n\n第三次挥手\n\nFIN请求，即客户端请求断开连接，可以看到seq&#x3D;1， 这里的ASK标志，及ask&#x3D;2说明断开的时候对之前收到的报文段进行确认过来的seq+1)  \n\n\n第四次挥手\n\n[ACK]请求，即服务端同意断开连接，ACK说明服务端已经同意了客户端的请求  \n\n\n\n总结\nTCP四次挥手可以由任意一方发起\n\n发起方先发送FIN标志来请求断开连接，然后接收方回复ASK来确认关闭连接\n接着接收方发送FIN来请求断开连接，然后发起方回复ASK来确认关闭连接\n\n\n","slug":"其他/TCP四次挥手","date":"2022-11-01T06:59:51.000Z","categories_index":"网络相关","tags_index":"tcp,socket","author_index":"阿木大叔"},{"id":"178906d428a0d6cc1b23477e81172dad","title":"TCP三次握手","content":"\nTCP 协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手，对于程序猿来说只需要在客户端调用 connect() 函数，三次握手就自动进行了。先通过下图看一下 TCP 协议的格式，然后再介绍三次握手的具体流程。\n\n\n在 Tcp 协议中，比较重要的字段有：\n源端口：表示发送端端口号，字段长 16 位，2 个字节\n\n目的端口：表示接收端端口号，字段长 16 位，2 个字节\n\n序号（sequence number）：字段长 32 位，占 4 个字节，序号的范围为 [0，4284967296]。\n\n由于 TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号  首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。  序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了 0  确认序号（acknowledgement number）：占 32 位（4 字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为 N，序号为 S，则表明到序号 N-S 为止的所有数据字节都已经被正确地接收到了。\n\n\n8 个标志位（Flag）:\n\nCWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；\nECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.；\nURG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；\nACK：该位设为 1，确认应答的字段有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设为 1；\nPSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；\nRST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；\nSYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；\nFIN：该位设为 1，表示今后不再有数据发送，希望断开连接。\n\n\n窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。\n\n\n\n\n\n标志位\n解释\n\n\n\nSYN\nsynchronous建立联机\n\n\nACK\nacknowledgement 确认\n\n\nPSH\npush传送\n\n\nPSH\npush传送\n\n\nURG\nurgent紧急\n\n\nRST\nreset重置\n\n\nFIN\nfinish结束\n\n\nseq\nSequence number(顺序号码)\n\n\nack\nAcknowledge number(确认号码)\n\n\n三次握手具体过程如下：\n第一次握手：\n客户端：客户端向服务器端发起连接请求将报文中的 SYN 字段置为 1，生成随机序号 x，seq&#x3D;x\n服务器端：接收客户端发送的请求数据，解析 tcp 协议，校验 SYN 标志位是否为 1，并得到序号 x\n\n第二次握手：\n服务器端：给客户端回复数据\n回复 ACK, 将 tcp 协议 ACK 对应的标志位设置为 1，表示同意了客户端建立连接的请求\n回复了 ack&#x3D;x+1, 这是确认序号\nx: 客户端生成的随机序号\n1: 客户端给服务器发送的数据的量，SYN 标志位存储到某一个字节中，因此按照一个字节计算，表示客户端给服务器发送的 1 个字节服务器收到了。\n\n\n将 tcp 协议中的 SYN 对应的标志位设置为 1, 服务器向客户端发起了连接请求\n服务器端生成了一个随机序号 y, 发送给了客户端\n\n\n客户端：接收回复的数据，并解析 tcp 协议\n校验 ACK 标志位，为 1 表示服务器接收了客户端的连接请求\n数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下：\n发送的数据的量 &#x3D; 使用服务器回复的确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;x+1-x\n校验 SYN 标志位，为 1 表示服务器请求和客户端建立连接\n得到服务器生成的随机序号: y\n\n\n\n第三次握手：\n客户端：发送数据给服务器\n将 tcp 协议中 ACK 标志位设置为 1，表示同意了服务器的连接请求\n给服务器回复了一个确认序号 ack &#x3D; y+1\ny：服务器端生成的随机序号\n1：服务器给客户端发送的数据量，服务器给客户端发送了 ACK 和 SYN, 都存储在这一个字节中\n\n\n发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq &#x3D; x+1\n\n\n服务器端：接收数据，并解析 tcp 协议\n查看 ACK 对应的标志位是否为 1, 如果是 1 代表，客户端同意了服务器的连接请求\n数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下：\n给客户端发送的数据量 &#x3D; 确认序号 - 服务器生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;y+1-y\n得到客户端发送的序号：x+1\n\n\n\nwirshark抓包分析\n服务端监听9999\n\n上图为TCP三次握手过程\n\n第一次握手\n\nSYN请求，即客户端请求建立连接，可以看到SYN&#x3D;1,seq&#x3D;0  \n\n\n第二次握手\n\n[SYN,ACK]请求，ACK说明服务端已经同意了客户端的请求，SYN说明服务端请求建立连接，可以看到ACK&#x3D;1,SYN&#x3D;1,seq&#x3D;0,ack&#x3D;1 (ack为确认序号，值为客户端发送过来的seq+1；这里的seq为服务端随机生成的序号)  \n\n\n第三次握手\n\n[ACK]请求，ACK说明客户端已经同意了服务端的请求，可以看到ACK&#x3D;1,seq&#x3D;0,ack&#x3D;1 (ack为确认序号，值为服务端户端发送过来的seq+1)  \n\n\n\n","slug":"其他/TCP三次握手","date":"2022-11-01T02:29:52.000Z","categories_index":"网络相关","tags_index":"tcp,socket","author_index":"阿木大叔"},{"id":"e314d67fa76866251074a4c5605dc64d","title":"基于QtAv及ffmpeg开发的视频播放器","content":"基于QtAv及ffmpeg开发的视频播放器主要功能：\n本地媒体文件播放，支持切换上一个下一个文件，暂停&#x2F;恢复，快放&#x2F;慢放，音量控制\n全屏&#x2F;取消全屏\n播放列表，列表缩略图\n播放进度，进度条展示缩略图\n在线电视台列表，支持打开.m3u文件，加载在线视频源列表\n支持多画面播放，支持1,4,6,8,9,16,25,36,49,64画面风格\n支持开启或关闭GPU加速\n支持抓拍\n支持改变画面比例\n支持查看视频媒体信息\n\n\n体验地址：https://gitee.com/hudejie/QtDemoExe/tree/master/HSYPlayer\n\n界面展示主界面\n播放界面\n播放列表\n在线电视台\n多画面播放\n播放界面\n全屏\nGPU加速&amp;抓拍\n画面风格切换\n播放列表缩略图\n进度条缩略图\n快放&amp;慢放\n音量控制\n媒体信息\n","slug":"Qt/作品展/基于QtAv及ffmpeg开发的视频播放器","date":"2022-10-31T11:37:32.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"3fa7b6b4e7b63ef887d3676dae872298","title":"第一个Qt项目","content":"\n写在前面\n相关博文\n个人博客首页\n注：学习交流使用！\n\n\n正文\nQt [1]  是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C&#x2F;C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP,它提供给应用程序开发者建立艺术级的图形用户界面所需的所有功能。基本上，Qt 同 X Window 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。 – 百度百科\n\n新建项目\n选择新建项目\n\n选择Qt Widgets Application\n\n选择项目名称及项目路径\n\n选择构建套件，即采用那种编译器，windows一般有MiniGw以及msvc，Linux下一般为GCC\n\n选择创建的主窗口类名及继承的类型，可以为QMainWindow，QDialog，QWidget\n\n可以选择需不需要创建ui文件，ui文件即可使用Qt Ui工具直接编辑界面，前期可以使用此种\n\n创建完成的项目\n\n\n编译运行\n使用左下角三个按钮即可编译运行项目，分别为运行，调试，编译\n\n运行完成界面\n\n\n简单展示Hello World\n双击mainwindow.ui文件，打开设计模式\n\n拖动一个label到界面，然后双击可修改文字内容\n\n编译，运行完成界面\n\n至此第一个Qt程序创建完成，恭喜你已经迈出了第一步，接下来一起学习Qt的各种高级用法吧。\n\n\n\n交个朋友\nGitee首页\n\n\n版权声明：本文为「阿木大叔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n","slug":"Qt/基础教程/第一个Qt项目","date":"2022-10-28T08:09:33.000Z","categories_index":"Qt入门指南","tags_index":"Qt","author_index":"阿木大叔"},{"id":"61b7d43740d88aadb9a85687e42c152b","title":"libcurl编译及使用","content":"","slug":"其他/libcurl编译及使用","date":"2022-10-28T03:31:25.000Z","categories_index":"","tags_index":"","author_index":"阿木大叔"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"当下，Markdown 是一种广泛使用的轻量级标记语言，用于在Web中书写文档，同时应用于许多不同的场景。它旨在简化发布文本内容的过程，并减少在撰写文档时的格式转换的需要。Markdown 优点很多，包括易学易用、易于掌握和交流、跨平台可用性等等。\nMarkdown 核心语法\n标题：通过使用 # 符号即可创建标题，例如：\n\n1234# 一级标题## 二级标题### 三级标题...\n\n\n斜体和加粗：可以使用 * 或 _ 符号将文本包裹起来实现，例如：\n\n12*斜体* 或者 _斜体_**加粗** 或者 __加粗__\n\n\n引用：可以使用 &gt; 符号引用文本，例如：\n\n1&gt; 这是引用的文本。\n\n\n列表：可以通过符号 *, -, + 来创建无序列表，也可以使用数字来创建有序列表。例如：\n\n1234- 无序列表项1- 无序列表项21. 有序列表项12. 有序列表项2\n\n\n链接和图片：可以使用 [] 和 () 来创建链接和图片。例如：\n\n12[链接文字](链接地址)![图片描述](图片地址)\n\n\n代码块：可以用 &#96;&#96;&#96; 包裹一段代码创建代码块，例如：\n\n123​```javascriptconsole.log(&#x27;Hello, world!&#x27;);​```\n\nMarkdown 扩展语法除了核心语法，Markdown 还有一些扩展语法来丰富文本格式。\n\n表格：可以使用竖线 | 和连字符 - 来创建表格，例如：\n\n1234| 姓名 | 年龄 || ---- | ---- || 张三 | 20   || 李四 | 22   |\n\n\n分割线：使用3个或3个以上的-、*、_可以创建分割线。\n\n1---\n\n\n脚注：可以使用[^]来创建脚注，例如：\n\n12这是一个脚注[^1][^1]: 这是脚注的文本。\n\n\n删除线：可以使用 ~~ 标记划掉的文本，例如：\n\n1~~删除的文本~~\n\n以上就是常用的 Markdown 语法和扩展语法，掌握这些基础知识后就可以开始书写 Markdown 文档啦！\n","slug":"其他/Markdown语法","date":"2022-10-04T03:34:06.000Z","categories_index":"其他教程","tags_index":"Markdown","author_index":"阿木大叔"},{"id":"f8bc6db07820d29668bd8d1363592c13","title":"Qt开发加解密软件","content":"Qt开发加解密软件Qt开发的极简的，跨平台的文件，文件夹加密工具，采用AES-256加密算法。界面模仿的Encrypto，采用极简风格，有兴趣的可以试一下。\n   前言例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。\n\n一、FileEncrypter是什么？FileEncrypter是一个免费的，极简的，跨平台的文件，文件夹加密工具，支持Windows，Linux等系统。使用该工具可以轻松的对文件，文件夹进行加密生成一个新的文件，获取到加密文件之后，使用对应的密码即可对文件进行解密，并查看文件内容。\nEncrypto应用程序使用AES-256加密，允许您向其他人发送非常私人的消息和文件。该工具最初是为苹果设备开发的，但该软件在Mac和Windows设备上运行良好。创建此应用程序是为了帮助人们在发送文件之前对其进行加密，但您不必将文件发送到任何地方。你可以很容易地加密你的文件并把它们留在你的计算机上。\nFileEncrypter加密后除了本身密码解密外，无任何其他方式能解密，所以请牢记密码，如忘记密码，可参考加密时填写的提示信息。\n二、使用步骤1.界面展示详情见CSDN博客\n\n总结例如：以上就是今天要讲的内容，本文仅仅简单介绍了FileEncrypter的使用，有兴趣的可以私聊我。\n更多开源项目见CSDN\n","slug":"Qt/作品展/Qt开发加解密软件","date":"2022-06-20T08:40:04.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"9f7b90ca802128164406072bd8f29e21","title":"什么是QWebEngineView和QWebChannel？","content":"当您准备开发一个现代化的Web应用程序时，QWebEngineView和QWebChannel是两个重要的Qt组件。这篇博客将会给您介绍它们的用途，以及如何在您的Qt代码中使用它们。\nQWebEngineView是什么？QWebEngineView是一个基于Chromium引擎的Qt组件，用于呈现和交互Web页面。当您需要在Qt应用程序中嵌入Web内容时，QWebEngineView会很有用。它提供了一些便利的方法来加载、导航和操作Web页面，比如：\n12QWebEngineView *view = new QWebEngineView(this);view-&gt;load(QUrl(&quot;https://www.example.com&quot;));\n\n以上代码创建了一个QWebEngineView对象，并通过load方法将其载入指定的URL。如果您希望捕获Web页面的截图或输出HTML源代码等操作，QWebEngineView也提供了相应的API实现。\nQWebChannel是什么？QWebChannel是另一个Qt组件，它提供了一种简单的机制来在Web页面和Qt应用程序之间进行通信。在使用QWebChannel时，您可以从JavaScript代码中调用Qt对象的方法，或者通过Qt对象接收来自Web页面的事件和数据。\n为了使用QWebChannel，您需要执行以下步骤：\n\n将一个QWebChannel对象附加到QWebEngineView上。\n在Qt代码中声明一个QObject派生类，并使用QWebChannel::registerObject方法将其注册到QWebChannel对象中。\n在Web页面中，使用qt.webChannelTransport对象来连接到QWebChannel，并通过qt.webChannel.objects数组访问已注册的Qt对象。\n\n以下是一个简单的代码示例，展示了如何在Qt应用程序和Web页面之间交换数据：\nmain.cpp\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QObject&gt;#include &lt;QWebEngineView&gt;#include &lt;QWebChannel&gt;class MyObject : public QObject&#123;    Q_OBJECTpublic slots:    void onMessage(const QString &amp;message)    &#123;        qDebug() &lt;&lt; &quot;Received message from web page:&quot; &lt;&lt; message;    &#125;&#125;;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    // 创建QWebEngineView对象并添加到主窗口中    QWebEngineView *view = new QWebEngineView();    view-&gt;setUrl(QUrl(&quot;qrc:///index.html&quot;));    // 创建QWebChannel对象并附加到QWebEngineView对象上    QWebChannel *channel = new QWebChannel(view);    view-&gt;page()-&gt;setWebChannel(channel);    // 在Qt代码中创建MyObject对象，并将其注册到QWebChannel对象中    MyObject myObject;    channel-&gt;registerObject(QStringLiteral(&quot;myObject&quot;), &amp;myObject);    view-&gt;show();    return app.exec();&#125;#include &quot;main.moc&quot;\n\nindex.html\n1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;QWebChannel Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;QWebChannel Example&lt;/h1&gt;    &lt;button onclick=&quot;sendMessage()&quot;&gt;Send Message to Qt&lt;/button&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;qrc:///qtwebchannel/qwebchannel.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 连接到QWebChannel并获取已注册的Qt对象        var webChannel = new QWebChannel(qt.webChannelTransport, function(channel) &#123;            var myObject = channel.objects.myObject;            // 在点击按钮时调用MyObject对象的onMessage方法            function sendMessage() &#123;                myObject.onMessage(&quot;Hello from Web&quot;);            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n在这个例子中，我们创建了一个名为MyObject的QObject派生类，并将其注册到了一个名为myObject的对象名上。Web页面中的JavaScript代码使用qt.webChannelTransport连接到了QWebChannel，然后通过qt.webChannel.objects.myObject访问了已注册的Qt对象。当点击按钮时，Web页面上的JavaScript调用了myObject.onMessage(&quot;Hello from Web&quot;)，这个调用会触发Qt对象中的onMessage方法，并输出一条消息到控制台。\n在QWebEngineView中使用QWebChannel在上面的例子中，我们演示了如何使用QWebChannel在Qt应用程序和Web页面之间交换数据。现在，让我们看看如何在QWebEngineView中使用QWebChannel来控制Web页面的行为。\n首先，我们需要创建一个新的QObject派生类，以便将其注册到QWebChannel中：\n1234567891011class WebController : public QObject&#123;    Q_OBJECTpublic slots:    void setButtonStyle(const QString &amp;style);    void setLabelStyle(const QString &amp;style);private:    QWebEnginePage *m_page;&#125;;\n\n这里，我们声明了两个槽函数：setButtonStyle和setLabelStyle。这些槽函数将通过QWebChannel暴露给Web页面的JavaScript代码。我们还添加了一个指向QWebEnginePage对象的指针，这样我们就可以从槽函数中直接操作Web页面了。\n我们的下一步是将这个新对象注册到QWebChannel中：\n1234QWebChannel *channel = new QWebChannel(view-&gt;page());WebController *controller = new WebController();controller-&gt;setPage(view-&gt;page());channel-&gt;registerObject(QStringLiteral(&quot;webController&quot;), controller);\n\n在这个例子中，我们将WebController对象注册为webController对象，然后将其附加到了QWebChannel对象中。\n现在，我们需要在Web页面中添加一些JavaScript代码来连接到QWebChannel，并使用webController对象。这里是一个例子：\n12345new QWebChannel(qt.webChannelTransport, function (channel) &#123;    var webController = channel.objects.webController;    webController.setButtonStyle(&quot;background-color: blue; color: white;&quot;);    webController.setLabelStyle(&quot;font-weight: bold;&quot;);&#125;);\n\n在这个例子中，我们在QWebChannel对象上创建了一个新的JavaScript对象，并通过channel.objects.webController访问了已经注册的WebController对象。然后，我们调用了setButtonStyle和setLabelStyle槽函数，从而改变了Web页面上的按钮和标签样式。\n结论在这篇博客中，我们介绍了Qt框架中两个非常有用的组件：QWebEngineView和QWebChannel。QWebEngineView可以帮助您将Web内容嵌入到您的Qt应用程序中，而QWebChannel则允许您在Qt代码和Web页面之间交换数据。这些组件非常容易使用，而且可以帮助您构建出更加现代化、功能更加强大的Qt应用程序。\n除了上述提到的基本使用方法，QWebEngineView和QWebChannel还有许多其他使用技巧和注意事项。下面是一些需要特别注意的问题：\n\n在Qt5.6及更高版本中，QWebChannel已经被移动到了QtWebChannel库中。因此，在使用QWebChannel时，需要在.pro文件中添加QT += webchannel。\n\n建议不要将QWebEngineView对象和QWebChannel对象的生命周期直接绑定在某个特定的QWidget或QObject对象上。如果必须这样做，请确保在销毁父对象之前先销毁QWebEngineView和QWebChannel对象。\n\n可以考虑使用JavaScript Promise API来管理复杂的异步操作。例如，在加载Web页面时，我们可以使用Promise API来等待页面加载完成后再执行后续操作。\n\n如果Web页面需要与外部服务进行交互（例如通过AJAX请求数据），则可以使用Qt框架中提供的网络API来实现。\n\n如果需要在Web页面中使用一些第三方JavaScript库（例如jQuery、React等），则可以将这些库作为静态资源打包到Qt应用程序中，并使用qrc: URL来引用。\n\n\n总而言之，QWebEngineView和QWebChannel为开发人员提供了强大而灵活的工具来构建现代化的Qt应用程序。无论您是想要嵌入Web内容，还是需要在Qt代码和Web页面之间交换数据，QWebEngineView和QWebChannel都可以帮助您轻松实现。\n完整代码示例最后，这里是一个完整的代码示例，演示了如何在Qt应用程序中使用QWebEngineView和QWebChannel。这个例子包含了三个文件：\n\nmain.cpp：应用程序入口，创建主窗口并加载Web页面。\nwebcontroller.h和webcontroller.cpp：定义了WebController类，它是我们向QWebChannel注册的QObject派生类。\n\nmain.cpp\n1234567891011121314151617181920212223242526#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QObject&gt;#include &lt;QWebEngineView&gt;#include &lt;QWebChannel&gt;#include &quot;webcontroller.h&quot;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    // 创建QWebEngineView对象并添加到主窗口中    QWebEngineView *view = new QWebEngineView();    view-&gt;setUrl(QUrl(&quot;qrc:///index.html&quot;));    // 创建QWebChannel对象并附加到QWebEngineView对象上    QWebChannel *channel = new QWebChannel(view-&gt;page());    WebController *controller = new WebController();    controller-&gt;setPage(view-&gt;page());    channel-&gt;registerObject(QStringLiteral(&quot;webController&quot;), controller);    view-&gt;page()-&gt;setWebChannel(channel);    view-&gt;show();    return app.exec();&#125;\n\nwebcontroller.h\n12345678910111213141516171819#ifndef WEBCONTROLLER_H#define WEBCONTROLLER_H#include &lt;QObject&gt;#include &lt;QWebEnginePage&gt;class WebController : public QObject&#123;    Q_OBJECTpublic slots:    void setButtonStyle(const QString &amp;style);    void setLabelStyle(const QString &amp;style);private:    QWebEnginePage *m_page;&#125;;#endif // WEBCONTROLLER_H\n\nwebcontroller.cpp\n12345678910111213141516#include &quot;webcontroller.h&quot;void WebController::setButtonStyle(const QString &amp;style)&#123;    m_page-&gt;runJavaScript(QString(&quot;document.getElementById(&#x27;myButton&#x27;).style=&#x27;%1&#x27;&quot;).arg(style));&#125;void WebController::setLabelStyle(const QString &amp;style)&#123;    m_page-&gt;runJavaScript(QString(&quot;document.getElementById(&#x27;myLabel&#x27;).style=&#x27;%1&#x27;&quot;).arg(style));&#125;void WebController::setPage(QWebEnginePage *page)&#123;    m_page = page;&#125;\n\nindex.html\n12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;QWebChannel Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;QWebChannel Example&lt;/h1&gt;    &lt;button id=&quot;myButton&quot; onclick=&quot;sendMessage()&quot;&gt;Send Message to Qt&lt;/button&gt;    &lt;br&gt;&lt;br&gt;    &lt;label id=&quot;myLabel&quot;&gt;This is a label&lt;/label&gt;    &lt;br&gt;&lt;br&gt;    &lt;input type=&quot;text&quot; id=&quot;myInput&quot;&gt;    &lt;br&gt;&lt;br&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;qrc:///qtwebchannel/qwebchannel.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 连接到QWebChannel并获取已注册的Qt对象        new QWebChannel(qt.webChannelTransport, function (channel) &#123;            var webController = channel.objects.webController;            webController.setButtonStyle(&quot;background-color: blue; color: white;&quot;);            webController.setLabelStyle(&quot;font-weight: bold;&quot;);            // 当点击按钮时，调用MyObject对象的onMessage方法            function sendMessage() &#123;                var inputValue = document.getElementById(&quot;myInput&quot;).value;                alert(&quot;You entered: &quot; + inputValue);            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n在这个例子中，我们创建了一个简单的Web页面，其中包含一个按钮、一个标签和一个文本框。当用户点击按钮时，JavaScript代码会通过QWebChannel对象调用setButtonStyle和setLabelStyle方法，从而改变按钮和标签的样式。同时，JavaScript代码还会弹出一个对话框，显示用户在文本框中输入的内容。\n总之，QWebEngineView和QWebChannel是非常有用的Qt组件，它们可以帮助您构建出现代化、功能丰富的Qt应用程序，让您的应用程序更加灵活、可扩展。\n参考资料如果您想了解更多关于QWebEngineView和QWebChannel的信息，可以参考以下官方文档：\n\nQt WebEngine\nQt WebChannel\n\n此外，以下是一些其他有用的资源：\n\nQWebEngineView实现Qt与Web的交互\nUsing QWebChannel to expose C++ objects to JavaScript\nCreating a simple browser with QtWebEngine\nIntegrating HTML and QML Using the Qt WebEngine\n\n通过这些资料，您可以深入了解如何在Qt应用程序中使用QWebEngineView和QWebChannel，并学习如何构建出现代化、功能丰富的Qt应用程序。\n总结在本篇博客中，我们介绍了Qt框架中两个非常有用的组件：QWebEngineView和QWebChannel。QWebEngineView可以帮助您将Web内容嵌入到您的Qt应用程序中，而QWebChannel则允许您在Qt代码和Web页面之间交换数据。\n我们首先演示了如何使用QWebEngineView在Qt应用程序中加载Web页面，并且如何利用JavaScript代码与页面进行交互。然后，我们介绍了如何使用QWebChannel实现Qt代码与Web页面之间的双向通信，从而使得应用程序更加灵活、可扩展。\n最后，我们提供了一个完整的代码示例，演示了如何在Qt应用程序中使用QWebEngineView和QWebChannel。通过这个例子，您可以深入了解QWebEngineView和QWebChannel的使用方法，并学习如何构建出现代化、功能丰富的Qt应用程序。\n希望本篇博客能够对您有所帮助！\n","slug":"Qt/进阶教程/什么是QWebEngineView和QWebChannel？","date":"2021-11-24T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"03e99f8ee62e69d3f5234649fa8dbb9f","title":"Qt 线程池","content":"Qt 线程池Qt 线程池是 Qt 库中用于任务异步执行的工具类，它提供了一种简单方便的方式来管理多线程并发处理。本篇文章将会介绍 Qt 线程池的概念及其使用方法。\n什么是线程池？线程池是一个预先创建好一组线程，将可用线程保存在内存池中，等待来自任务队列的任务请求，一旦有任务到达就会自动分配空闲的线程来执行任务。线程执行完任务后并不会被立即销毁而是重新返回线程池中等待下次任务调度。\n线程池在多线程编程中广泛应用，能够有效控制线程创建和线程销毁的频率，避免由于创建过多线程导致系统资源浪费和运行效率降低的问题。\nQt 线程池的使用引入头文件为了使用 Qt 线程池，需要引入 QtConcurrent/QtConcurrentRun 头文件，实现如下：\n1#include &lt;QtConcurrent/QtConcurrentRun&gt;\n\n创建线程池要使用 Qt 线程池，需要创建一个 QThreadPool 对象。 Qt 线程池默认使用线程数等于 CPU 核心数的两倍，但是你可以自定义线程数。创建线程池的代码如下：\n123QThreadPool *threadPool = QThreadPool::globalInstance();// or QThreadPool *threadPool = new QThreadPool(parent);\n\n定义任务函数需要执行在线程池中的任务必须是静态或全局的，这样才能保证在线程池中正确执行。为了方便演示，下面代码片段中使用 lambda 表达式作为任务函数：\n1234auto task = []()&#123;    QThread::sleep(1); // 模拟耗时操作    qDebug() &lt;&lt; &quot;任务执行完毕&quot;;&#125;;\n\n提交任务将任务提交到线程池中进行处理，使用 QtConcurrent::run() 函数即可。例如，以下代码可将 task 任务提交到线程池中：\n1QtConcurrent::run(threadPool, task);\n\n控制线程池QThreadPool 对象有几个控制线程池行为的属性和方法：\n\nsetMaxThreadCount(int maxThreadCount)：设置线程池最大线程数。\nactiveThreadCount()：返回活跃线程个数。\nreserveThread()：分配一个新的线程，相当于增加一个已有线程的数量。\nreleaseThread()：释放一个线程，相当于减少一个线程的数量。\n\n等待任务完成运行时，任务被提交到线程池中异步执行。想要等待所有的任务执行完成才继续后面的代码执行，可以使用 QThreadPool::waitForDone() 方法：\n1threadPool-&gt;waitForDone();\n\n总结Qt 线程池提供了一种简单方便的方式来执行多线程并发操作，避免由于创建过多线程导致系统资源浪费和运行效率降低的问题。需要注意的是，在进行多线程并发处理时，必须保证代码的线程安全性。希望本文对 Qt 线程池的概念及使用方法有所帮助。\n","slug":"Qt/进阶教程/Qt 线程池","date":"2021-11-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"93a101a48c8aea63429499c894498199","title":"QtCustomPlot 绘制图表","content":"使用 QtCustomPlot 绘制图表介绍QtCustomPlot 是一个基于 Qt 的图表库，用于创建数据可视化图表。它支持多种类型的图表，包括折线图、散点图、柱状图等，并提供了多种自定义选项，以便用户对其外观和行为进行优化。\n在本教程中，我们将向您展示如何使用 QtCustomPlot 来创建一个简单的折线图来可视化数据。\n准备工作在开始之前，请确保已满足以下要求：\n\n安装了 Qt 5 或更高版本。\n下载并安装了 QtCustomPlot 库。\n您可以在此处下载最新版本的库。\n\n\n创建一个新的 Qt 项目，在 .pro 文件中添加以下行以引用 QtCustomPlot 库：1include(path/to/qtcustomplot.pri)\n\n步骤\n定义一个 QCustomPlot 对象，该对象将承载我们的图表。1QCustomPlot *customPlot = new QCustomPlot(this);\n创建一个称为“图形”（graph）的对象，用于在图表中显示数据。1QCPGraph *graph = customPlot-&gt;addGraph();\n将数据添加到图形对象中，以便在图表中显示。123QVector&lt;double&gt; xData, yData;// 添加您的数据到 xData 和 yData 向量中graph-&gt;setData(xData, yData);\n（可选） 设置轴的标签和范围。1234customPlot-&gt;xAxis-&gt;setLabel(&quot;X Axis&quot;);customPlot-&gt;yAxis-&gt;setLabel(&quot;Y Axis&quot;);customPlot-&gt;xAxis-&gt;setRange(0, 10);customPlot-&gt;yAxis-&gt;setRange(0, 100);\n显示图表。1customPlot-&gt;replot();\n\n示例代码完整示例代码如下所示：\n1234567891011121314151617#include &lt;QtCustomPlot/QCustomPlot&gt;QCustomPlot *customPlot = new QCustomPlot(this);QCPGraph *graph = customPlot-&gt;addGraph();QVector&lt;double&gt; xData, yData;// 添加您的数据到 xData 和 yData 向量中graph-&gt;setData(xData, yData);customPlot-&gt;xAxis-&gt;setLabel(&quot;X Axis&quot;);customPlot-&gt;yAxis-&gt;setLabel(&quot;Y Axis&quot;);customPlot-&gt;xAxis-&gt;setRange(0, 10);customPlot-&gt;yAxis-&gt;setRange(0, 100);customPlot-&gt;replot();\n\n以上就是使用 QtCustomPlot 绘制图表的基本步骤，您可以根据需要自定义更多样式和外观选项。\n","slug":"Qt/进阶教程/QtCustomPlot 绘制图表","date":"2021-11-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"de5d17019a62106c24ae84eccced9caf","title":"Qt事件处理机制流程","content":"Qt事件处理机制流程Qt事件处理机制是实现GUI程序的重要组成部分。在Qt中，所有的用户操作（例如鼠标点击、键盘输入等）都会被转换为事件，然后交给相应的对象进行处理。因此，了解Qt事件处理机制对于理解Qt编程至关重要。\n事件处理函数在Qt中，事件处理函数是指重载QObject类的event()函数或QWidget类的paintEvent()函数等一系列事件处理函数。事件处理函数可以接收到Qt各种事件类型，我们可以通过这些函数来处理事件并决定如何响应这些事件。\n在Qt中，每个QObject对象都可以有自己的事件处理函数，例如：\n1234567class MyObject : public QObject&#123;    Q_OBJECTprotected:    bool event(QEvent *event);&#125;;\n\n在上述代码中，MyObject类继承自QObject，并重载了event()函数。当该类接收到事件时，会调用event()函数进行事件处理。\n事件循环Qt事件循环是指一个无限循环，在该循环中，Qt会不断地从操作系统取出事件并将其发送给相应的接收者（即事件处理函数）。Qt事件循环的实现由QCoreApplication类完成。在Qt应用程序中，我们通常需要创建一个QApplication或QGuiApplication对象来初始化Qt事件循环。\n事件循环的代码如下：\n123456while (true) &#123;    if (!QCoreApplication::hasPendingEvents())        QCoreApplication::processEvents(QEventLoop::WaitForMoreEvents);    else        QCoreApplication::processEvents(QEventLoop::AllEvents);&#125;\n\n在上述代码中，QCoreApplication会不断地调用processEvents()函数来处理事件。当有新的事件到达时，该函数会将事件发送给相应的对象进行处理。\n事件过滤器在Qt中，事件过滤器是指通过重载QObject类的eventFilter()函数来实现对事件的拦截和处理。通过事件过滤器，我们可以监视所有QObject对象的事件，并做出相应的响应。\n例如：\n1234567class MyFilter : public QObject&#123;    Q_OBJECTpublic:    bool eventFilter(QObject *obj, QEvent *event);&#125;;\n\n在上述代码中，MyFilter类继承自QObject，并重载了eventFilter()函数。当一个QObject对象接收到事件时，会首先将事件发送给MyFilter对象进行处理。如果MyFilter对象需要拦截该事件，则返回true，否则返回false，让该事件被传递到原本的事件处理函数进行处理。\n事件分发在Qt事件处理机制中，事件分发是指将事件分发给相应的接收者进行处理。通过事件分发，我们可以保证每个事件都能正确地被处理。\n在Qt中，事件分发由QCoreApplication::sendEvent()函数完成。该函数负责将事件分发给相应的接收者（即事件处理函数）进行处理。如果事件处理函数返回true，则说明该事件已被处理；否则，该事件会被传递给父对象进行处理。\n流程图下面是一个使用mermaid语法绘制的Qt事件处理机制流程图：\n12345678graph LRA[事件] --&gt; B&#123;事件分发&#125;B --&gt; C1[事件过滤器1]B --&gt; C2[事件过滤器2]B --&gt; C3[事件过滤器3]C1 --&gt; D1[事件处理函数1]C2 --&gt; D2[事件处理函数2]C3 --&gt; D3[事件处理函数3]\n\n在上述流程图中，事件首先通过事件分发器（即B节点）进行分发。然后，事件可能会被传递给一系列事件过滤器（即C1、C2和C3节点），这些事件过滤器可以拦截并处理事件。最终，事件会被传递给对应的事件处理函数（即D1、D2和D3节点）进行处理。\n总结Qt事件处理机制是一种高效而可靠的机制，它能够确保GUI程序能够正确地响应用户的操作。通过了解Qt事件处理机制的流程，我们可以更好地理解Qt编程，同时也能够更加灵活地控制程序的行为。\n以上是关于Qt事件处理机制流程的详细介绍，如有不足之处，欢迎指正。\n","slug":"Qt/进阶教程/Qt事件处理机制流程","date":"2021-11-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"5b703c364468afe9449fdcd6becdc305","title":"Qt内置宏及其含义","content":"Qt内置宏及其含义当您开始使用Qt编程时，会发现在Qt代码中频繁出现了各种奇怪的宏定义。它们是用于执行不同功能的特殊指令。在Qt中有许多这样的宏定义。在本篇教程中，我们将深入探讨这些宏的含义和用法。\nQ_OBJECTQ_OBJECT 是一个非常重要的宏。它必须出现在 Qt 类声明的私有部分中。该宏告诉 Qt 元对象编译器在 MOC (Meta-Object Compiler) 中为该类生成元对象。这使得信号和槽、元数据等特性得以使用。例如：\n12345678910111213class MyWidget : public QWidget&#123;    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);signals:    void buttonClicked();private slots:    void handleButton();&#125;;\n\n注意：如果您使用的 IDE 不支持自动运行 MOC，您需要确保在每次更改包含 Q_OBJECT 的头文件之后手动运行 MOC。\nQ_PROPERTYQ_PROPERTY 宏用于声明属性。它与访问器方法一起使用，以便更方便地查询和设置属性值。例如：\n123456789101112131415161718192021222324252627282930class MyWidget : public QWidget&#123;    Q_OBJECT    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)public:    explicit MyWidget(QWidget *parent = nullptr);    QString text() const;    void setText(const QString &amp;text);signals:    void textChanged();private:    QString m_text;&#125;;QString MyWidget::text() const&#123;    return m_text;&#125;void MyWidget::setText(const QString &amp;text)&#123;    if (text != m_text) &#123;        m_text = text;        emit textChanged();    &#125;&#125;\n\n此示例中声明了一个具有 text 属性的 MyWidget 类。使用 Q_PROPERTY 声明为只读或读&#x2F;写属性。设置器方法应该在修改属性时发出对应的信号。\nQ_SIGNALS 和 Q_SLOTSQ_SIGNALS 和 Q_SLOTS 宏分别用于声明信号和槽。这使得编译器能够在元对象中注册它们以进行运行时调用。例如：\n12345678910111213class MyWidget : public QWidget&#123;    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);signals:    void buttonClicked();private slots:    void handleButton();&#125;;\n\n在此示例中，MyWidget 的 buttonClicked() 信号和 handleButton() 槽被声明为 Q_SIGNALS 和 Q_SLOTS。\nQ_EMITQ_EMIT 宏用于发射信号。\n12345void MyWidget::handleButton()&#123;    // do something    Q_EMIT buttonClicked();&#125;\n\nQT_VERSION_CHECKQT_VERSION_CHECK(major, minor, patch) 用于在预处理期间检查 Qt 库版本。\n12345#if QT_VERSION_CHECK(5, 14, 0)// code for Qt 5.14.0 and later#else// code for earlier versions of Qt#endif\n\nQ_DECL_OVERRIDE 和 Q_DECL_FINALQ_DECL_OVERRIDE 和 Q_DECL_FINAL 宏分别用于覆盖和禁止覆盖虚函数。\n1234567891011class MyWidget : public QWidget&#123;    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr) &#123;&#125;    virtual void paintEvent(QPaintEvent *event) Q_DECL_OVERRIDE;    virtual void mousePressEvent(QMouseEvent *event) Q_DECL_FINAL;&#125;;\n\nQ_DISABLE_COPY 和 Q_DISABLE_MOVEQ_DISABLE_COPY 和 Q_DISABLE_MOVE 宏用于禁用类的默认拷贝构造函数和移动构造函数。这是为了防止代码复制和意外使用不安全的拷贝和移动函数。\n12345678class MyWidget : public QWidget&#123;    Q_DISABLE_COPY(MyWidget)    Q_DISABLE_MOVE(MyWidget)public:    explicit MyWidget(QWidget *parent = nullptr);&#125;;\n\n以上是常用的 Qt 内置宏，它们可以使 Qt 编程更加简洁和高效。希望本篇教程能够对您有所帮助！\n","slug":"Qt/进阶教程/Qt内置宏及其含义","date":"2021-11-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"cb41401ee69235767505fab37433a483","title":"什么是Qt pro文件？","content":"什么是Qt pro文件？Qt pro文件是QT项目管理器使用的配置文件。它们在Qt创建时自动生成，并且包含有关工程的信息，如源文件、库和编译选项等。\n如何创建Qt pro文件？可以使用Qt Creator创建交互式工程向导来创建一个新项目并自动生成pro文件。也可以手动创建pro文件并将其添加到Qt Creator项目中。 \npro文件的基本语法结构1234567891011CONFIG += &lt;配置选项&gt;TARGET = &lt;目标名&gt;TEMPLATE = &lt;模板&gt;&lt;其他变量&gt;SOURCES += &lt;源文件列表&gt;HEADERS += &lt;头文件列表&gt;FORMS += &lt;表单文件列表&gt;RESOURCES += &lt;资源文件列表&gt;LIBS += &lt;链接库列表&gt;\n\n其中，CONFIG 指定一系列的配置选项，例如设置编译类型：debug 或 release；TEMPLATE 指定使用什么样的构建模板，例如 app 或 lib； TARGET 是生成的最终目标（可执行文件，静态&#x2F;共享库）的名称；SOURCES、HEADERS、FORMS 和RESOURCES 分别指定源文件、头文件、表单和资源文件的列表；LIBS 定义所需的库文件。 \nQt pro文件示例123456789101112131415161718192021# 配置debug/release下的编译选项 CONFIG += debug_and_release# 指定生成的目标为可执行文件TEMPLATE = app# 定义可执行文件名 TARGET = myapp# 声明源文件目录 SOURCES += main.cpp \\           mywindow.cpp# 声明头文件目录HEADERS += mywindow.h # 配置Qt库（示例中使用了 Widgets） QT += widgets# 添加外部库 LIBS += -lmylib\n\n以上示例将生成一个名为 myapp 的可执行文件，包含 main.cpp 和 mywindow.cpp 文件。其中所需的头文件 mywindow.h 将被包含在编译中。该应用程序将链接到名为 mylib 的外部库，并且它将使用 Qt 库中的一个库（widgets）。 \n这是一个简单的Qt pro文件的例子，开发者可以根据需要和实际情况进行修改和扩展。\n","slug":"Qt/进阶教程/什么是Qt pro文件？","date":"2021-10-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"b5f40241243dd23db9b5a3b73e4d29d8","title":"在Qt中使用渐变色","content":"在Qt中使用渐变色Qt是一个跨平台开发框架，在图形用户界面（GUI）设计中非常常用。渐变色能够为GUI添加视觉效果并提高用户体验。本文将介绍在Qt中如何使用渐变色。\n安装和设置在Qt中使用渐变色需要在项目文件中添加 QT += widgets，这样才能使用QPainter等相关API绘制渐变色。\n垂直渐变首先，让我们看看如何绘制一条垂直的渐变色。\n1234567QLinearGradient gradient(0, 0, 0, height());gradient.setColorAt(0, Qt::white);gradient.setColorAt(1, Qt::black);QPainter painter(this);painter.setBrush(gradient);painter.drawRect(rect());\n\n上述代码创建了一个从顶部到底部渐变的QLinearGradient对象，然后通过setColorAt()函数设置颜色。最后，将该渐变对象设为画刷(setBrush())并用drawRect()函数绘制出来。\n水平渐变下面，我们来看看如何绘制水平方向上的渐变色：\n1234567QLinearGradient gradient(0, 0, width(), 0);gradient.setColorAt(0, Qt::white);gradient.setColorAt(1, Qt::black);QPainter painter(this);painter.setBrush(gradient);painter.drawRect(rect());\n\n与垂直渐变相似，只需要将QLinearGradient对象中的起点和终点改为(0, 0)和(width(), 0)即可。\n辐射渐变除了线性渐变外，Qt还支持辐射渐变。相对于线性渐变，辐射渐变通常用于绘制圆形的渐变色填充效果。\n1234567QRadialGradient gradient(QPointF(width()/2, height()/2), qMax(width(), height())/2);gradient.setColorAt(0, Qt::white);gradient.setColorAt(1, Qt::black);QPainter painter(this);painter.setBrush(gradient);painter.drawEllipse(rect());\n\n上述代码创建了一个从中心到各个角的渐变的QRadialGradient对象，并使用setColorAt()函数设置颜色。最后，将该渐变对象设为画刷并在屏幕上用drawEllipse()函数绘制出来。\n总结在Qt中使用渐变色非常简单。通过上述示例代码，您可以快速了解如何在Qt中使用垂直、水平和辐射渐变。使用渐变色不仅能够很好地提升用户体验，还可以为GUI设计增添一些华丽的动态效果。\n","slug":"Qt/进阶教程/在Qt中使用渐变色","date":"2021-10-22T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"5c952a910652e5178fb110ec12dbdb02","title":"使用Qt开发自定义委托的表格控件","content":"使用Qt开发自定义委托的表格控件在Qt中，可以使用自定义委托（QStyledItemDelegate）来实现自定义的表格控件，这个机制可以让开发者完全掌握表格单元格UI的显示方式和用户交互方式。\n步骤一：设置表格模型在创建表格前，需要先创建一个表格模型来存储数据。Qt中提供了QAbstractTableModel对象，其派生类可用于创建各种类型的表格模型，如列表、树状等，这里我们以一个简单的列表为例。\n12345678910111213class CustomTableModel : public QAbstractTableModel &#123;    Q_OBJECTpublic:    explicit CustomTableModel(QObject *parent = nullptr);    int rowCount(const QModelIndex &amp;parent) const override;    int columnCount(const QModelIndex &amp;parent) const override;    QVariant data(const QModelIndex &amp;index, int role) const override;    bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role) override;private:    QList&lt;QString&gt; m_dataList;&#125;;\n\n以上代码定义了一个CustomTableModel类，为了展示文章重点在委托上，具体实现略去。\n步骤二：自定义委托自定义委托是实现表格控件的核心，而Qt中提供了QStyledItemDelegate对象作为实现基类，开发者通过继承直接派生此类并实现其中的四个虚函数以完成自定义：paint()、createEditor()、setEditorData() 和 setModelData()。\n例如，以绘制自定义委托为例：\n1234567class ColorDelegate : public QStyledItemDelegate &#123;public:    explicit ColorDelegate(QObject *parent = nullptr);private:    void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override;&#125;;\n\n通过paint()方法，可以实现对单元格的绘制方式，以下是一个简单的例子：\n12345678910void ColorDelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const&#123;    painter-&gt;save();    painter-&gt;setRenderHint(QPainter::Antialiasing);    painter-&gt;setPen(Qt::NoPen);    painter-&gt;setBrush(QColor(&quot;#FF0000&quot;));    painter-&gt;drawRect(option.rect);    painter-&gt;restore();&#125;\n\n上述代码的作用是：将单元格绘制成红色矩形。\n步骤三：设置委托一旦创建了自定义委托对象以后，需要将委托对象设置到表格控件中，从而绑定自定义单元格的显示方式和用户交互方式。\n在Qt中，通过表格模型的setItemDelegate()方法即可将自定义委托设置到表格中：\n1ui-&gt;tableView-&gt;setItemDelegate(new ColorDelegate(this));\n\n以上代码将刚刚创建的红色单元格样式代理設置给表格。\n总结使用自定义委托来实现表格控件可以让开发者完全掌握单元格UI的显示方式和用户交互方式。在具体实现过程中，需要了解表格模型和委托类的具体用法，并重载QStyledItemDelegate的四个虚函数。\n","slug":"Qt/进阶教程/使用Qt开发自定义委托的表格控件","date":"2021-10-20T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"e00bfb303760f43313b1eb86fecbfba9","title":"QStyle的介绍","content":"QStyle的介绍QStyle是Qt中一个用于自定义GUI外观的类，可以通过重写实现各种控件的显示效果。不同的Widget类有不同的默认样式，而通过QStyle，开发人员可以自定义整个应用程序，包括大小、颜色、字体和各种原始矢量图标。\n基本用法样式设置通过调用QWidget或QApplication上的setStyle()函数选择特定的样式。\n123QApplication a(argc, argv);QStyle* myStyle = new MyCustomStyle();a.setStyle(myStyle);\n\n自定义样式通过继承QStyle并实现其中的虚函数来实现GUI控件和窗口部件的自定义渲染样式。\n以下是一个简单的样式子类定义示例：\n12345678910111213141516171819202122class CustomStyle : public QStyle&#123;public:    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,                        QPainter *painter, const QWidget *widget) const override;&#125;;void CustomStyle::drawPrimitive(PrimitiveElement element, const QStyleOption *option,                                QPainter *painter, const QWidget *widget) const&#123;    switch (element) &#123;        case PE_FrameFocusRect: &#123;            QPen pen(Qt::blue, 2, Qt::SolidLine, Qt::SquareCap, Qt::MiterJoin);            painter-&gt;setPen(pen);            painter-&gt;drawRect(option-&gt;rect.adjusted(0, 0, -1, -1));            break;        &#125;        default:            QStyle::drawPrimitive(element, option, painter, widget);            break;    &#125;&#125;\n\n常用函数QStyle提供了许多常见的方法以便对GUI控件进行设置和管理，例如：\n\npolish()：初始化QStyle对象（根据主题文件等优化样式）。\nunpolish()：撤销QStyle对象的初始化。\ndrawControl()：为指定的GUI控件绘制样式。\nstyleHint()：检索指定GUI样式的提示信息。\npixelMetric()：检查特定的像素度量值。\n\n例如，以下代码演示如何将原生风格的按钮改成红色背景：\n12345678910111213141516171819202122232425class RedButtonStyle : public QProxyStyle&#123;public:    QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const override    &#123;        if (element == SE_PushButtonContents)            return option-&gt;rect;        else            return QProxyStyle::subElementRect(element, option, widget);    &#125;    void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const override    &#123;        if (element == PE_PanelButtonCommand) &#123;            QBrush brush(QColor(Qt::red));            painter-&gt;fillRect(option-&gt;rect, brush);        &#125;        else &#123;            QProxyStyle::drawPrimitive(element, option, painter, widget);        &#125;    &#125;&#125;;QPushButton* redButton = new QPushButton(&quot;Red Button&quot;);redButton-&gt;setStyle(new RedButtonStyle);\n\n结论总之，QStyle可以帮助Qt应用程序自定义外观风格并实现各种控件的渲染效果。QStyle允许开发人员自定义窗口部件和控件的样式以及大小、颜色、字体和矢量图标等属性。在实际应用中，需要根据具体的需求选择合适的方法继承并重写对应的函数，自定义Qt应用程序的外观和视觉效果。\n","slug":"Qt/进阶教程/QStyle的介绍","date":"2021-10-18T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"9e97b4c65e3bc73c141685e2a659e85b","title":"QMetaObject::invokeMethod()的介绍","content":"QMetaObject::invokeMethod()的介绍在Qt框架中，QMetaObject类提供了一些反射机制可以实现类似于Java反射机制的功能。其中一个函数就是QMetaObject::invokeMethod()，它可以通过字符串调用对象的方法，同时支持异步执行和跨线程操作等特性。\n使用方法QMetaObject::invokeMethod()方法有多个重载，最常用的格式如下：\n12345678910111213bool QMetaObject::invokeMethod(QObject *obj, const char *method,        Qt::ConnectionType type = Qt::AutoConnection,        QGenericReturnArgument ret = QGenericReturnArgument(),        QGenericArgument val0 = QGenericArgument(),        QGenericArgument val1 = QGenericArgument(),        QGenericArgument val2 = QGenericArgument(),        QGenericArgument val3 = QGenericArgument(),        QGenericArgument val4 = QGenericArgument(),        QGenericArgument val5 = QGenericArgument(),        QGenericArgument val6 = QGenericArgument(),        QGenericArgument val7 = QGenericArgument(),        QGenericArgument val8 = QGenericArgument(),        QGenericArgument val9 = QGenericArgument());\n\n\nobj：要调用方法的QObject对象指针。\nmethod：需要调用的方法名字符串。\ntype：连接类型，决定调用方法的线程以及调用形式。其值可以是Qt::DirectConnection（同步直接调用）、Qt::QueuedConnection（异步排队调用）和Qt::AutoConnection（根据线程自动选择同步直接调用或异步排队调用）。\nret：返回值类型。可以使用QGenericReturnArgument分别传入不同的返回类型，通常为void。\nval0～val9：可选的十个参数值，根据需要传递。\n\n使用示例下面是一个使用QMetaObject::invokeMethod()来调用另一个对象函数的例子：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;QThread&gt;#include &lt;QDebug&gt;class MyWorker : public QObject&#123;    Q_OBJECTpublic:    explicit MyWorker(QObject *parent = nullptr) : QObject(parent) &#123;&#125;signals:    void finished();    void progressMade(int value);public slots:    void doWork()    &#123;        for (int i = 0; i &lt;= 100; ++i) &#123;            emit progressMade(i);            QThread::msleep(50);        &#125;        emit finished();    &#125;&#125;;class MyObject : public QObject&#123;    Q_OBJECTpublic:    explicit MyObject(QObject *parent = nullptr) : QObject(parent) &#123;&#125;public slots:    void onWorkerFinished()    &#123;        qDebug() &lt;&lt; &quot;Worker finished.&quot;;    &#125;    void onWorkerProgressMade(int value)    &#123;        qDebug() &lt;&lt; &quot;Progress made:&quot; &lt;&lt; value;    &#125;&#125;;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    MyWorker worker;    MyObject obj;    QObject::connect(&amp;worker, &amp;MyWorker::finished,                     &amp;a, &amp;QCoreApplication::quit);    QObject::connect(&amp;worker, &amp;MyWorker::progressMade,                     &amp;obj, &quot;onWorkerProgressMade&quot;);    QMetaObject::invokeMethod(&amp;worker, &quot;doWork&quot;);    return a.exec();&#125;\n\n在这个例子中，我们定义了一个MyWorker类和一个MyObject类。其中MyWorker类是一个计时器类，通过发射信号告诉外部工作进度情况。另一方面，MyObject类提供了两个槽函数onWorkerFinished()和onWorkerProgressMade()，用于处理MyWorker类的信号。\n在main函数中，我们首先创建了worker和obj对象，然后使用&amp;worker, &quot;doWork&quot;这种方式（即字符串调用）来调用MyWorker类中的doWork()方法，实现异步操作并执行worker对象的计时器操作。\n注意事项\n方法名字符串必须与槽函数名或者信号名字匹配。\n只有公共槽函数才能使用该方法调用，无法调用私有、保护槽函数及任何静态函数。\n参数根据调用的函数需要自行配置，使用过程中需要注意参数顺序和数据类型。\n调用时需要保证目标对象已经完成构造，并且处于合法状态。\n\n结论总之，QMetaObject::invokeMethod()函数是一个非常方便的反射调用方法，可以让我们避免在跨线程信号连接中频繁考虑线程安全问题，简化代码流程，带来更好的编程体验。\n","slug":"Qt/进阶教程/invokeMethod的介绍","date":"2021-10-18T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"ce4d369535f0325ae64c13ca955fe4c5","title":"使用Qt实现HTTP中GET、POST、PUT、DELETE","content":"使用Qt实现HTTP中GET、POST、PUT、DELETE在现代的应用程序中，网络连接已成为不可或缺的一部分。这就意味着您必须编写代码来执行各种请求和响应操作。本文将向您展示如何使用Qt库来实现HTTP中GET、POST、PUT、DELETE等基本请求，并解释每个请求行动背后的重要细节和选项。\n前置条件首先，确保您的项目已正确链接Qt网络模块并包含它所需的头文件：\n123#include &lt;QNetworkAccessManager&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;\n\nGET请求GET请求是最常见的HTTP请求类型之一。此请求类型从服务器请求指定的资源，没有请求正文，仅有URL和请求头。\n以下是一个简单的使用Qt的GET请求的示例：\n1234567891011121314151617void performGetRequest(QUrl url)&#123;    QNetworkAccessManager manager;    QNetworkRequest request(url);    QNetworkReply* reply = manager.get(request);    connect(reply, &amp;QNetworkReply::finished, [reply]()&#123;        if (reply-&gt;error() != QNetworkReply::NoError) &#123;            qDebug() &lt;&lt; &quot;Error in performing get request: &quot; &lt;&lt; reply-&gt;errorString();            reply-&gt;deleteLater();            return;        &#125;        QByteArray data = reply-&gt;readAll();        qDebug() &lt;&lt; &quot;Received data: &quot; &lt;&lt; data;        reply-&gt;deleteLater();    &#125;);&#125;\n\n我们首先创建一个QNetworkAccessManager对象，然后创建一个QNetworkRequest，然后使用get()函数执行GET请求。我们使用finished()信号和一个lambda表达式来读取响应数据并清理资源。\nPOST请求POST请求是向Web服务器提交信息的常见方法。与GET请求不同，POST包含请求正文，并且通常用于将表单数据提交到服务器。下面是一个简单使用Qt中POST请求的示例：\n1234567891011121314151617181920212223242526void performPostRequest(QUrl url, QVariantMap data)&#123;    QNetworkAccessManager manager;    QNetworkRequest request(url);    request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/x-www-form-urlencoded&quot;);    QByteArray postData;    for (auto key : data.keys()) &#123;        postData.append(key.toLatin1()).append(&quot;=&quot;).append(data[key].toByteArray()).append(&quot;&amp;&quot;);    &#125;    if (postData.endsWith(&quot;&amp;&quot;)) &#123;        postData.chop(1);    &#125;    QNetworkReply* reply = manager.post(request, postData);    connect(reply, &amp;QNetworkReply::finished, [reply]()&#123;        if (reply-&gt;error() != QNetworkReply::NoError) &#123;            qDebug() &lt;&lt; &quot;Error in performing post request: &quot; &lt;&lt; reply-&gt;errorString();            reply-&gt;deleteLater();            return;        &#125;        QByteArray data = reply-&gt;readAll();        qDebug() &lt;&lt; &quot;Received data: &quot; &lt;&lt; data;        reply-&gt;deleteLater();    &#125;);&#125;\n\n在这里，我们创建了一个QNetworkRequest并为其设置一些HTTP标头，然后将数据映射到post请求正文中，最后使用post()函数执行POST请求。同样，使用finished()信号和一个lambda表达式来处理响应数据。\nPUT请求PUT请求主要用于更新服务器上的资源，可以用于创建新资源。与POST类似，PUT请求包含一个请求正文。下面是如何在Qt中执行PUT请求的示例：\n1234567891011121314151617181920212223void performPutRequest(QUrl url, QByteArray data)&#123;    QNetworkAccessManager manager;    QNetworkRequest request(url);    QBuffer *buffer = new QBuffer;    buffer-&gt;setData(data);    request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/octet-stream&quot;);    QNetworkReply* reply = manager.put(request, buffer);    connect(reply, &amp;QNetworkReply::finished, [reply, buffer]()&#123;        if (reply-&gt;error() != QNetworkReply::NoError) &#123;            qDebug() &lt;&lt; &quot;Error in performing put request: &quot; &lt;&lt; reply-&gt;errorString();            reply-&gt;deleteLater();            buffer-&gt;deleteLater();            return;        &#125;        QByteArray responseData = reply-&gt;readAll();        qDebug() &lt;&lt; &quot;Received data: &quot; &lt;&lt; responseData;        reply-&gt;deleteLater();        buffer-&gt;deleteLater();    &#125;);&#125;\n\n在这里，我们创建了一个指向QBuffer对象的指针，它用于传递数据主体和管理内存。可选地，我们可以设置一些HTTP标头。\nDELETE请求DELETE请求用于删除服务器上的资源，通常用于删除文件或恢复从数据库删除的条目。以下是如何使用Qt执行DELETE请求的示例：\n1234567891011121314151617void performDeleteRequest(QUrl url)&#123;    QNetworkAccessManager manager;    QNetworkRequest request(url);    QNetworkReply* reply = manager.deleteResource(request);    connect(reply, &amp;QNetworkReply::finished, [reply]()&#123;        if (reply-&gt;error() != QNetworkReply::NoError) &#123;            qDebug() &lt;&lt; &quot;Error in performing delete request: &quot; &lt;&lt; reply-&gt;errorString();            reply-&gt;deleteLater();            return;        &#125;        QByteArray responseData = reply-&gt;readAll();        qDebug() &lt;&lt; &quot;Deleted data: &quot; &lt;&lt; responseData;        reply-&gt;deleteLater();    &#125;&#125;\n\n我们首先创建一个QNetworkAccessManager对象，然后创建一个QNetworkRequest，然后使用deleteResource()函数执行GET请求。我们使用finished()信号和一个lambda表达式来读取响应数据并清理资源。\n","slug":"Qt/进阶教程/使用Qt实现HTTP中GET、POST、PUT、DELETE","date":"2021-10-18T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"ff14916e39f6b95778b03aff03b57cd4","title":"使用Qt进行文件读写操作","content":"使用Qt进行文件读写操作在现代应用程序中，处理文件读写操作是一项非常常见的任务。Qt提供了许多工具来轻松地读写文件。在本文中，我们将介绍如何使用Qt编写文件读写代码。\nQFile类QFile是Qt中用于文件读写的核心类之一。要使用它进行读写操作，需要通过创建一个QFile对象来打开文件。例如，要打开一个名为example.txt的文本文件，并将其读入到一个QByteArray中，可以使用以下代码：\n12345678910111213141516171819202122#include &lt;QFile&gt;#include &lt;QDebug&gt;int main()&#123;    const QString fileName = &quot;example.txt&quot;;    QFile file(fileName);    if (!file.open(QIODevice::ReadOnly)) &#123;        qDebug() &lt;&lt; &quot;Failed to open file:&quot; &lt;&lt; fileName;        return -1;    &#125;    QByteArray content = file.readAll();    qDebug() &lt;&lt; &quot;Content of file:&quot; &lt;&lt; fileName &lt;&lt; &quot;:&quot; &lt;&lt; endl &lt;&lt; content;    file.close();    return 0;&#125;\n\n要将数据写入文件，可以使用open函数来以写入模式打开文件，然后可以调用write函数，传入要包含在文件中的字节的指针和字节数：\n12345678910111213141516171819202122#include &lt;QFile&gt;#include &lt;QDebug&gt;int main()&#123;    const QString fileName = &quot;example.txt&quot;;    QFile file(fileName);    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123;        qDebug() &lt;&lt; &quot;Failed to open file:&quot; &lt;&lt; fileName;        return -1;    &#125;    QByteArray content = &quot;Hello, world!&quot;;    file.write(content);    file.close();    return 0;&#125;\n\nQTextStream类QTextStream是Qt中用于文本文件读写的另一个核心类。它可以使用不同的编码，包括UTF-8、UTF-16等。例如，要将内容保存为UTF-8编码的文本文件，可以使用以下代码：\n123456789101112131415161718192021222324#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QDebug&gt;int main()&#123;    const QString fileName = &quot;example.txt&quot;;    QFile file(fileName);    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123;        qDebug() &lt;&lt; &quot;Failed to open file:&quot; &lt;&lt; fileName;        return -1;    &#125;    QTextStream out(&amp;file);    out.setCodec(&quot;UTF-8&quot;);    out &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    file.close();    return 0;&#125;\n\n读取UTF-8编码的文本文件同样简单：\n1234567891011121314151617181920212223242526#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QDebug&gt;int main()&#123;    const QString fileName = &quot;example.txt&quot;;    QFile file(fileName);    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) &#123;        qDebug() &lt;&lt; &quot;Failed to open file:&quot; &lt;&lt; fileName;        return -1;    &#125;    QTextStream in(&amp;file);    in.setCodec(&quot;UTF-8&quot;);    QString content = in.readAll();    qDebug() &lt;&lt; &quot;Content of file:&quot; &lt;&lt; fileName &lt;&lt; &quot;:&quot; &lt;&lt; endl &lt;&lt; content;    file.close();    return 0;&#125;\n\n结论在Qt中，文件读写操作非常简单。通过使用QFile和QTextStream类，可以轻松地读写各种类型的文件。\n","slug":"Qt/进阶教程/使用Qt进行文件读写操作","date":"2021-10-18T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"c11d7ff241d9d77db46fba39f11f66e8","title":"使用Qt实现JSON数据的解析和构建","content":"使用Qt实现JSON数据的解析和构建介绍在现代应用程序中，处理JSON数据是一项非常常见的任务。Qt提供了许多工具来轻松地对JSON数据进行解析和构建。在本文中，我们将介绍如何使用Qt框架的QJsonDocument类来解析和构建JSON数据。\n解析JSON数据要解析JSON数据，在Qt中使用QJsonDocument类。下面是一个示例JSON文件：\n123456789101112&#123;    &quot;name&quot;: &quot;John Smith&quot;,    &quot;age&quot;: 30,    &quot;isMarried&quot;: true,    &quot;hobbies&quot;: [&quot;music&quot;, &quot;sports&quot;, &quot;reading&quot;],    &quot;address&quot;: &#123;        &quot;street&quot;: &quot;123 Main St&quot;,        &quot;city&quot;: &quot;Anytown&quot;,        &quot;state&quot;: &quot;CA&quot;,        &quot;zip&quot;: &quot;12345&quot;    &#125;&#125;\n\n使用QJsonDocument类，可以将这些数据解析为一个QJsonObject对象，如下所示：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QJsonDocument&gt;int main(int argc, char **argv)&#123;    QString filename = &quot;example.json&quot;;    QFile file(filename);    if (!file.open(QIODevice::ReadOnly)) &#123;        qWarning() &lt;&lt; &quot;Failed to open file:&quot; &lt;&lt; filename;        return -1;    &#125;    QByteArray data = file.readAll();    QJsonParseError error;    QJsonDocument doc = QJsonDocument::fromJson(data, &amp;error);    if (doc.isNull()) &#123;        qWarning() &lt;&lt; &quot;Failed to parse JSON:&quot; &lt;&lt; error.errorString();        return -1;    &#125;    QJsonObject obj = doc.object();    // Access the data in the object    QString name = obj.value(&quot;name&quot;).toString();    int age = obj.value(&quot;age&quot;).toInt();    QJsonArray hobbies = obj.value(&quot;hobbies&quot;).toArray();    foreach (const QJsonValue &amp; v, hobbies) &#123;        qDebug() &lt;&lt; v.toString();    &#125;    return 0;&#125;\n\n这个例子打开example.json文件，并将其读取到一个QByteArray中。然后，使用QJsonDocument::fromJson()方法将数据解析为一个QJsonDocument对象。如果解析成功，可以调用QJsonDocument::object()方法以获取其中的QJsonObject。\n任何在QJsonObject中存储的值都可以使用QJsonValue类型访问。因此，可以通过调用QJsonObject::value()找到JSON值，并使用相应的QJsonValue::to*()方法获取它。\n构建JSON数据要构建JSON数据，请使用QJsonDocument和其支持的类。假设我们要创建与前面提到的JSON数据结构类似的对象。下面是如何使用QJsonObject和QJsonArray类来构建它：\n123456789101112131415161718192021222324252627282930313233#include &lt;QDebug&gt;#include &lt;QJsonDocument&gt;#include &lt;QJsonObject&gt;#include &lt;QJsonArray&gt;int main(int argc, char **argv)&#123;    QJsonObject obj;    obj.insert(&quot;name&quot;, &quot;John Smith&quot;);    obj.insert(&quot;age&quot;, 30);    obj.insert(&quot;isMarried&quot;, true);    QJsonArray hobbies;    hobbies.append(&quot;music&quot;);    hobbies.append(&quot;sports&quot;);    hobbies.append(&quot;reading&quot;);    obj.insert(&quot;hobbies&quot;, hobbies);    QJsonObject address;    address.insert(&quot;street&quot;, &quot;123 Main St&quot;);    address.insert(&quot;city&quot;, &quot;Anytown&quot;);    address.insert(&quot;state&quot;, &quot;CA&quot;);    address.insert(&quot;zip&quot;, &quot;12345&quot;);    obj.insert(&quot;address&quot;, address);    QJsonDocument doc(obj);    qDebug() &lt;&lt; doc.toJson();    return 0;&#125;\n\n在此例中，我们首先创建了一个QJsonObject，并将一些键值对添加到对象中。然后，创建一个QJsonArray，并将其添加到对象中。最后，我们还创建一个嵌套的QJsonObject并将其添加到主对象中。\n要将QJsonObject转换为JSON字符串，请使用QJsonDocument::toJson()方法。此方法返回包含对象数据的QByteArray。\n结论在Qt中，处理JSON数据非常简单。使用QJsonDocument和支持的类可以轻松地解析和构建JSON数据。\n","slug":"Qt/进阶教程/使用Qt实现JSON数据的解析和构建","date":"2021-10-14T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"6be795b38460ae66925a200f50747cea","title":"QDebug：Qt中的调试工具","content":"QDebug：Qt中的调试工具在开发Qt应用程序时，我们需要一种可靠的方法来检查代码和排除错误。QPlainTextEdit是一个用于输出调试信息的基本方法，但Qt框架还提供了一个更强大且易于使用的调试工具：QDebug。在本文中，我们将详细介绍QDebug类的功能和应用场景。\n使用QDebug输出调试信息QDebug是Qt中用于输出调试信息的强大工具，可以输出各种类型的数据，例如字符串、数字和对象等。为了使用QDebug，我们需要包含其头文件并使用qDebug()宏来输出调试信息。\n例如，以下代码展示了如何使用QDebug输出“Hello, World!”：\n123456#include &lt;QDebug&gt;int main() &#123;    qDebug() &lt;&lt; &quot;Hello, World!&quot;;    return 0;&#125;\n\n在这个例子中，我们包含QDebug头文件并调用qDebug()宏来输出一个简单的字符串。“&lt;&lt;”符号用于在qDebug()宏中分隔多个参数，可以输出任何类型的数据，而无需使用其他特定的格式说明符。\n输出Qt数据类型除了常规数据类型，QDebug还支持输出Qt特定的数据类型，例如QString、QByteArray和QVariant等。这些数据类型不仅可以帮助我们更容易地跟踪反馈到应用程序的数据，还提供了更高的灵活性和可读性。\n以下代码展示了如何使用QDebug输出一个QString：\n12345678#include &lt;QDebug&gt;#include &lt;QString&gt;int main() &#123;    QString data = &quot;Hello, World!&quot;;    qDebug() &lt;&lt; &quot;Outputting string using QDebug:&quot; &lt;&lt; data;    return 0;&#125;\n\n在这个例子中，我们包含QString头文件，并创建了一个名为“data”的字符串。然后，我们使用qDebug()宏并将其与字符串“Outputting string using QDebug:”和名为“data”的QString一起使用，以避免输出多行文本。\n使用QDebug观察对象状态除了以上应用场景之外，QDebug还可以帮助我们跟踪对象的状态和调试错误。当对象在运行时出现问题时，我们可以使用QDebug快速定位和解决问题。\n以下代码展示了如何使用QDebug跟踪QWidget对象的状态：\n12345678910111213#include &lt;QDebug&gt;#include &lt;QWidget&gt;int main() &#123;    QWidget widget;    widget.setGeometry(100, 100, 400, 300);    widget.show();    qDebug() &lt;&lt; &quot;Widget visibility&quot; &lt;&lt; widget.isVisible();    qDebug() &lt;&lt; &quot;Widget size&quot; &lt;&lt; widget.size();    return 0;&#125;\n\n在这个例子中，我们创建了一个QWidget实例，并设置其大小和位置，接着使用qDebug()宏打印widget isVisible() 和 size() 的状态。\n输出调试信息到文件最后，QDebug还支持将调试信息输出到文件而不是控制台。这对于在需要长时间记录输出时非常有用，或者我们需要在控制台之外查看和分析输出。\n以下代码展示了如何将调试信息输出到文件：\n1234567891011121314#include &lt;QDebug&gt;#include &lt;QFile&gt;int main() &#123;    QFile file(&quot;output.txt&quot;);    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))        return 1;    QTextStream out(&amp;file);    out &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    qDebug().noquote().nospace() &lt;&lt; &quot;Outputted to a file:&quot; &lt;&lt; file.fileName();    return 0;&#125;\n\n在这个例子中，我们首先创建了一个新的名为“output.txt”的文件，并打开它以便于写入文本（注意QIODevice::Text标记）。然后，我们使用QTextStream类代替QDebug来输出一些信息。“&lt;&lt;”符号用于在输出消息之间分离多个参数。最后，我们使用qDebug()宏将输出文件名称打印到控制台。\n结论QDebug是一个非常方便的调试工具，在Qt应用程序中使用它可以轻松地追踪对象状态、输出调试信息及定位问题等。通过使用QDebug，我们可以更快速地测试和调试代码，增加我们的工作效率和准确性。\n","slug":"Qt/基础教程/QDebug：Qt中的调试工具","date":"2021-10-12T03:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"84bd6b5d625d0beb31de3b6ad48960fe","title":"QFont中setPointSize和setPixelSize的作用和区别","content":"QFont中setPointSize和setPixelSize的作用和区别在Qt应用程序中，字体往往是UI设计中非常重要的一个因素。QFont类是Qt框架中表示字体的核心类，它提供了许多方法来指定字体外观和大小等属性。其中，setPointSize()和setPixelSize()是QFont中我们最常见也非常实用的两个方法之一，本文将给出它们的作用和区别。\nsetPointSize()setPointSize()方法是QFont类的方法之一，它可以设置字体的点数大小。字号通常参数是数字(N)，其默认值为（11）。\n当我们调用setPointSize()方法时，QFont将点数大小与每英寸点数分辨率结合计算出每个字符的高度。 在这种情况下，如果QFontMetrics返回像素数，则会将该字段转换为点数大小。\n示例代码如下：\n12QFont font(&quot;Times&quot;, 11);font.setPointSize(14);       // 将字体点数大小设置为 14\n\n在上述示例中，我们创建了一个名为“font”的新字体对象，并使用它的setPointSize()方法将点数大小设置为14。这就意味着此字体的所有字符都将具有14个点的高度。\nsetPixelSize()setPixelSize()方法是QFont类的另一个方法，它可以设置字体的像素大小。\n当使用setPixelSize()方法时，字体的大小将以像素为单位而不是点数来测量。注意：大小实际上仍然被视为点值——QFontMetrics基于其当前分辨率将其转换为像素。\n示例代码如下：\n12QFont font(&quot;Times&quot;, 11);font.setPixelSize(18);       // 将字体像素大小设置为 18\n\n在上述示例中，我们创建了一个名为“font”的新字体对象，并使用它的setPixelSize()方法将像素大小设置为18。这意味着，在至少可能的QFontMetrics（即与屏幕分辨率相同的值），此字体对象的每个字符将具有18个像素高度。\n区别我们可以看到，setPointSize()和setPixelSize()都提供了一种设置字体大小的方法。主要区别在于它们使用的单位不同：setPointSize()方法使用点数作为单位，而setPixelSize()方法使用像素作为单位。因此，不同分辨率下的字体实际显示效果也会有所不同。\n通常情况下，为了更好的UI效果，建议优先考虑使用setPixelSize()方法来设置字体大小，以确保字体在不同设备上显示效果的一致性。但是需要注意的是，使用像素单位设置字体大小可能导致文字在高分辨率设备上显示得过小或过大，因此我们需要根据具体需求进行选择。\n结论在Qt应用程序中，字体往往是UI设计中非常重要的一个因素。setPointSize()和setPixelSize()方法是QFont类中最基本、实用的设置字体大小的方法之一。它们的区别在于使用的单位和实际显示效果会有所不同，因此在选择时需要结合具体需求进行选择。\n","slug":"Qt/基础教程/QFont中setPointSize和setPixelSize的作用和区别","date":"2021-10-05T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"41f212302bde8d9f69f32b4fddb39ad0","title":"Qt中使用TCP服务端及客户端","content":"Qt中使用TCP服务端及客户端TCP（Transmission Control Protocol）是一种可靠、高度优化的互联网通信协议，广泛用于各类网络应用程序中。在这篇博客中，我们将介绍如何在Qt中使用TCP服务端及客户端。\n使用Qt创建TCP服务器要使用Qt创建TCP服务器，需要完成以下步骤：\n步骤1：创建QTcpServer对象1QTcpServer *server = new QTcpServer(this);\n\n步骤2：监听连接请求在开始监听之前，您需要使用listen()方法指定服务端口号并监听来自特定IP地址的连接请求。\n12345if (!server-&gt;listen(QHostAddress::Any, 12345))&#123;    qDebug() &lt;&lt; &quot;Failed to start server&quot;;    return;&#125;\n\n步骤3：处理新连接请求每当一个新连接请求到达服务器时，QTcpServer将通过发射newConnection()信号来提示您。您可以使用accept()方法来接受该连接，并创建一个新的QTcpSocket对象以进行收发消息。\n12345678910111213void MyTcpServer::newConnection()&#123;    QTcpSocket *socket = server-&gt;nextPendingConnection();    connect(socket, SIGNAL(readyRead()), this, SLOT(readData()));    connect(socket, SIGNAL(disconnected()), socket, SLOT(deleteLater()));&#125;void MyTcpServer::readData()&#123;    QTcpSocket *socket = static_cast&lt;QTcpSocket *&gt;(sender());    QByteArray data = socket-&gt;readAll();    // 处理接收到的数据&#125;\n\n步骤4：发送数据使用QTcpSocket的write()方法将您的数据发送到连接的客户端。\n1socket-&gt;write(&quot;Hello world&quot;);\n\n使用Qt创建TCP客户端要使用Qt创建TCP客户端，需要完成以下步骤：\n步骤1：创建QTcpSocket对象1QTcpSocket *m_socket = new QTcpSocket(this);\n\n步骤2：连接到服务器使用connectToHost()方法将socket连接到目标主机和端口。连接成功后，QTcpSocket将发送connected()信号。\n1m_socket-&gt;connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 12345);\n\n步骤3：发送和接收数据使用write()方法向服务器发送数据，并通过readyRead()信号处理接收到的数据。\n12345678910void MyTcpClient::sendData(QString data)&#123;    m_socket-&gt;write(data.toUtf8().constData());&#125;void MyTcpClient::readData()&#123;    QString data = m_socket-&gt;readAll();    // 处理接收到的数据&#125;\n\n总结在Qt中使用TCP服务端及客户端是一种可靠、高效的方法来进行网络通信。QTcpServer和QTcpSocket类提供了一个面向对象的解决方案，使得您能够轻松地开发出各种类型的网络应用程序。\n然而，请注意因多种原因（例如网络中断、远程主机关闭连接等）导致的时延和异常情况，并确保在代码中处理这些情况以确保应用程序的稳定性。\n","slug":"Qt/基础教程/Qt中使用TCP服务端及客户端","date":"2021-10-05T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"5b80ee9c26ef869c27c39383e381d5b4","title":"Qt中的时区","content":"Qt中的时区在处理日期和时间的应用程序中，时区相关的问题一直是一个重要的问题。在Qt中，提供了一套完善的时区支持，能够轻松地处理时区相关的功能。\nQt中的时区概述在Qt中，时区由QTimeZone类来表示。它提供了一种跨平台方式，以标准时间表示特定地区的时间偏移量。这对于在不同的时区中确定时间（如UTC）尤其有用。下面是一段示例代码，演示如何创建一个QTimeZone对象：\n1QTimeZone timeZone = QTimeZone(&quot;Asia/Shanghai&quot;);\n\nQDateTime类也可以与QTimeZone配合使用，在使用时也会自动考虑时区。下面是一个简单的示例代码：\n123QDateTime time = QDateTime::currentDateTime();time.setTimeZone(QTimeZone(&quot;Asia/Shanghai&quot;));QString timeString = time.toString(Qt::ISODate);\n\nQt中的时区转换在Qt中，QDateTime类提供了一种方便的方式来从世界标准时间（UTC）转换为特定时区中的本地时间。可以使用toLocalTime()方法将UTC转换为本地时间，也可以使用toUTC()方法将本地时间转换为UTC。以下是一个示例用法：\n12345QDateTime utcTime = QDateTime::currentDateTimeUtc();QDateTime localTime = utcTime.toLocalTime();qDebug() &lt;&lt; &quot;UTC time: &quot; &lt;&lt; utcTime.toString(Qt::ISODate);qDebug() &lt;&lt; &quot;Local time: &quot; &lt;&lt; localTime.toString(Qt::ISODate);\n\nQt中的时区数据库Qt中的时区数据库是一个内置的、跨平台的时区数据库（又称为定位服务），它将地理位置映射到最近的市&#x2F;区域以及相关的时区规则。QTimeZone类使用该数据库来识别时区。\n如果您要在应用程序中使用时区功能，请确保使用最新的时区数据库，因为公历和政治事件会产生深远的影响，导致时区信息随时间而变化。您可以使用Qt提供的tzdata更新程序来更新时区数据库。下面是一些示例代码来更新时区数据库：\n1234#include &lt;QTimeZone&gt;#include &lt;QTimeZonePrivate&gt;QTimeZonePrivate::instance()-&gt;updateZoneInfo(QDir(&quot;/usr/share/zoneinfo&quot;));\n\n结论通过Qt中提供的完整时区支持，我们可以轻松地处理时区相关的功能。QTimeZone类提供了一个可靠的方式来表示不同地区的时间偏移量，并且QDateTime类可以自动考虑时区来进行转换。当使用时区功能时，请确保使用最新版本的时区数据库以确保准确性。\n","slug":"Qt/基础教程/Qt中的时区","date":"2021-10-05T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"8bf3e6aeb6e1a58dc6ced323d0a34c0b","title":"Qt布局中的 setStretch() 方法","content":"Qt布局中的 setStretch() 方法在Qt程序开发中，我们经常使用QLayout类来管理和自动布置控件。使用QLayout可以帮助组织UI界面，并确保控件可以自动调整大小以适应不同大小的屏幕，使用户获得更好的体验。setLayout()方法是将QLayout与QWidget关联，并且实现图形界面布局的主要方法之一。其中，setStretch()方法则是QBoxLayout及其子类布局独有的方法，具有非常重要的作用。\nsetStretch() 方法示例例如，当您创建一个水平排列的按钮列表时，您可能需要在窗口宽度修改时调整按钮的大小，并同时保持按钮之间的间隔始终保持一定大小（例如5个像素）。针对这种情况，我们通常会使用QHBoxLayout类并使用setStretch()方法来实现这一点。\n以下是一个示例代码：\n12345678910111213141516171819// 创建3个QPushButtonQPushButton *button1 = new QPushButton(&quot;Button 1&quot;);QPushButton *button2 = new QPushButton(&quot;Button 2&quot;);QPushButton *button3 = new QPushButton(&quot;Button 3&quot;);// 创建QHBoxLayout并添加QPushButtonQHBoxLayout *layout = new QHBoxLayout;layout-&gt;addWidget(button1);layout-&gt;addWidget(button2);layout-&gt;addWidget(button3);// 设置每个添加的Widget在布局中所占的比例layout-&gt;setStretchFactor(button1, 1);layout-&gt;setStretchFactor(button2, 1);layout-&gt;setStretchFactor(button3, 1);// 将QHBoxLayout关联到QWidgetQWidget *widget = new QWidget;widget-&gt;setLayout(layout);\n\n在这个示例中，我们使用QHBoxLayout创建了一个水平按钮列表，并使用布局的setStretchFactor()方法将按钮之间的间距设置为具有相同宽度比例。具体地说，我们使用layout-&gt;setStretchFactor(button1, 1)、layout-&gt;setStretchFactor(button2, 1)和layout-&gt;setStretchFactor(button3, 1)将每个按钮的拉伸系数设置为1。这样，当父窗口宽度发生变化时，我们可以通过修改拉伸因子来控制每个按钮的大小。在本例中，如果添加第四个按钮，则可以按增加此按钮后任意数量的按钮贡献其按列的可用空间。\nsetStretch() 方法解释setStretch()方法指定了包含在该布局中的行或列所占据的窗口部件在该行或该列中所被拉伸的比例。在QBoxLayout中，每个QLayoutItem对象都有一个特定的拉伸系数。QBoxLayout 中默认情况下，每个项的拉伸系数设置为零（0）。当用户调整窗口大小时，会以各个widget的等比例缩放来改变窗口大小，也就是说每一列中的所有组件宽度的和等于列的宽度。\n在本示例中，三个窗口部件的拉伸参数均设置为1，表示QHBoxLayout 应该将其尽可能平均地分配到布局中的区域中。因此，每个窗口部件获得相等的控制权并将占据布局的相等比例。\n结论setStretch() 方法是QBoxLayout 和其派生类 的一个非常有用的方法，通过它我们可以控制所包含控件在布局中所占的空间比例，以实现在不同窗口大小下布局的自适应性。这对于开发高度动态的UI界面，尤其是需要同时考虑大、中、小屏幕尺寸时非常有用。\n","slug":"Qt/基础教程/Qt布局中的 setStretch() 方法","date":"2021-10-05T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"d22eb85de16f2f58ec69f569b2b4a75b","title":"Qt多线程详解","content":"Qt多线程详解Qt是一个支持多线程、跨平台的C++框架，旨在帮助开发人员以安全和简单的方式处理并发任务。在这篇博客中，我们将介绍Qt中的多线程概念及其用法。\n什么是Qt多线程在计算机科学中，一个线程可以被看作一个轻量级的、可执行的单独进程中的一部分。与传统的单线程程序相比，多线程程序可以同时执行多个任务，并利用现代CPU的多核性能。\n在Qt中，多线程是通过QThread类来实现的。QThread类提供了一种使用线程的通用方法，可以方便地处理各种多线程应用场景。\n如何在Qt中使用多线程使用QObject类及其派生的类，如QWidget和QCoreApplication，可以使线程间通信更容易。其中，最常见的方法是使用信号和槽机制，在不同的线程之间发送信号和接收槽。\n使用多线程的基本步骤如下：\n步骤1：创建一个自定义线程类您需要继承QThread类或使用QObject类自己创建线程的子类。\n123456class MyThread : public QThread&#123;    Q_OBJECT    public:    void run() override;\n\n在您自己编写的run()函数内定义线程的任务。\n步骤2：实例化新线程在主线程中声明MyThread thread实例，并显示运行它：\n12MyThread thread;thread.start();\n\n步骤3：连接信号和槽多线程程序的关键就是线程之间的通信。通过使用信号（QThread::finished()）将工作线程信号与接收该信号的对象的槽（deleteLater()）连接，可以确保在工作完成后删除工作线程。以下是部分示例代码：\n1connect(&amp;thread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);\n\n步骤4：处理线程停止时的异常为了确保在线程停止时应用程序的稳定性，我们需要在线程停止时处理异常。例如，在MyThread类中可以添加以下代码：\n12345678void MyThread::stop()&#123;    mutex.lock();        stopped = true;    mutex.unlock();&#125;if (stopped) break;\n\n注意：您需要根据您的代码适当地添加互斥锁protects来保护共享数据。\nQt多线程的最佳实践\n避免在GUI线程上进行大量计算。\n确保进程、线程之间的通信由Qt处理，而不是直接访问或更改变量。\n尽可能使用队列来管理线程池，避免过度使用资源。\n需要在不同的线程中保护共享数据。\n\n总结Qt多线程提供了一种强大的机制来处理并发任务。使用信号和槽机制，您可以轻松地实现各种线程间通信，并通过QObject类来更加容易地管理线程池及其任务。\n在实际应用程序中，确保根据Qt多线程最佳实践来设计代码，会使您写出高效、稳定并且易于维护的程序。\n","slug":"Qt/基础教程/Qt多线程详解","date":"2021-10-04T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"c0af7e63ff6c9262bf89de2022bf6b45","title":"QString的介绍","content":"QString的介绍QString是Qt中处理字符串最常用的类之一，提供了丰富的字符串操作和转换方法。相比原生C++中的std::string，QString可以方便地处理Unicode字符，支持动态长度和自动内存管理等功能。\n基本用法创建和赋值通过直接传入字符串或者字符串指针来创建一个QString对象：\n123QString str1 = &quot;hello world&quot;;const char *str2 = &quot;hello qt&quot;;QString str3(str2);\n\n还可以通过复制构造函数或者赋值操作来创建新的字符串：\n123QString str4(str1);QString str5 = str2;str4 = str5;\n\n常用函数QString提供了很多常见的字符串操作函数。\n\nsize() 或 length()：获取字符串长度\ntoUpper() 和 toLower()：转换大小写\ntrimmed()：去掉前后空格\nsplit()：切割字符串为列表\nreplace()：替换字符串中的子串\nstartsWith(), contains() 和 endsWith()：在字符串中查找子串\n\n例如：\n1234QString myString(&quot;  Hello, world!   &quot;);qDebug() &lt;&lt; &quot;String length: &quot; &lt;&lt; myString.length(); // 输出 &quot;String length: 16&quot;qDebug() &lt;&lt; &quot;Trimmed string: &quot; &lt;&lt; myString.trimmed(); // 输出 &quot;Trimmed string: Hello, world!&quot;\n\n转换函数QString也提供了一些便于字符串转换的函数。比如，如果需要将QString对象转换成字符数组或者字符串指针，可以使用toUtf8()、toLatin1()和toLocal8Bit()等函数。\n123QString myString(&quot;Hello, world!&quot;);qDebug() &lt;&lt; myString.toUtf8().constData(); // 输出 &quot;Hello, world!&quot;\n\n同样，也可以通过fromUtf8()、fromLatin1()和fromLocal8Bit()等函数将std::string转换成QString对象。\n12345std::string myStdString = &quot;Hello, Qt!&quot;;QString myString = QString::fromUtf8(myStdString.c_str());qDebug() &lt;&lt; myString; // 输出 &quot;Hello, Qt!&quot;\n\n需要注意的是，如果在进行跨平台开发时，需要谨慎选择字符编码方式来确保与目标平台的兼容性。\n性能考虑由于QString类似于动态数组，它可以自动分配所需大小的内存。这种自动管理的特点会导致每次修改字符串都需要分配和释放内存，从而影响了其性能表现。\n为了减少频繁的内存分配和释放，可以尽量避免使用toUpper()、toLower()等函数，因为它们会改变字符串内容并创建新的QString对象。\n另外，当只需要读取字符串时，可以使用QStringView类，这个类不会创建新的字符串对象，而是直接引用原始的QString对象，提高了程序的性能。\n结论总之，QString是Qt框架中强大且易于使用的字符串类之一，提供了许多方便实用的方法和操作。在适当的情况下，可以使用QStringView类来优化程序性能。对于涉及到字符编码的情况需要特别注意。在实际应用中，根据具体需求选择各种不同的QString函数和转换策略来满足开发需求。\n","slug":"Qt/基础教程/QString的介绍","date":"2021-10-04T06:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"0e349ef346a818a9b65cc579b534d135","title":"Qt信号槽机制详解","content":"Qt信号槽机制详解Qt信号槽机制是一种用于处理应用程序中事件与方法交互的解决方案。通过这个机制，一个对象的行为可以影响到另外一个对象，从而促进事件流的自动化管理，提高程序的效率和可读性。\n在这篇博客中，我们将探讨Qt信号槽机制的用法、规则和最佳实践。\n什么是Qt信号槽机制在Qt中，信号（signal）和槽（slot）是两个任务不同但非常密切相关的概念。简单地说，一个信号是指触发程序某个操作的事件，而一个槽是指被调用的程序或方法。\n使用Qt信号槽机制，您可以将信号与槽连接起来，使得一个事件可以触发其他操作。这样，当一个对象发出信号时，可以唤醒响应的槽，并执行槽中的操作。\n在实际开发中，大多数信号都是以某些特定事件的形式出现的，如鼠标点击、按键事件等。每种事件都有它们自己对应的信号。\nQt信号槽机制的用法步骤1：创建信号在Qt中，信号是使用signals关键字定义的特殊函数。在下面的示例中，我们将定义一个名为click()的信号：\n12signals:    void click();\n\n请注意，信号函数通常不包含任何实现代码。\n步骤2：连接信号和槽在使用信号和槽之前，需要先将它们进行连接。对于普通C++函数，我们可以像下面这样连接它们：\n1connect(sender, SIGNAL(click()), receiver, SLOT(handleClick()));\n\n在上述示例中，connect()方法用于将sender对象的click()信号连接到receiver对象的handleClick()槽。如果sender对象发出了click()信号，receiver对象的handleClick()槽就会被调用。\n请注意，使用新的信号槽语法连接信号和槽如下：\n1connect(sender, &amp;Sender::click, receiver, &amp;Receiver::handleClick);\n\n步骤3：发出信号当要触发一个事件时，发送对象必须在其某些操作中使用emit关键字来触发其信号。以下是一个示例： \n1234void Button::mousePressEvent(QMouseEvent *event)&#123;    emit click();&#125;\n\n在以上示例中，当鼠标按下时，Button对象将发射click()信号。\n步骤4：接收信号并执行槽一旦接收对象接收到信号，就会自动调用槽函数。以下是槽函数的示例：\n12345public slots:    void handleClick()    &#123;        qDebug() &lt;&lt; &quot;Button clicked!&quot;;    &#125;\n\n在以上示例中，当接收到信号时，将打印一条消息。\nQt信号槽机制的规则和最佳实践\n使用signals和slots关键字声明信号和槽。\n连接信号和槽时，确保参数类型总是匹配。\n对于单个信号，可以连接多个槽。\n接收对象将按连接顺序执行其槽函数。\n断开连接时，请注意确保准确的参数匹配。\n在UI控件上使用信号和槽时，请在构造函数中进行连接。\n尽可能避免使用队列连接来防止内存泄漏。\n\n总结Qt信号槽机制为程序员提供了一个灵活而强大的事件管理框架。通过连接信号和槽，我们可以使程序代码更加模块化、易于维护和扩展。使用Qt信号槽机制时，请确保遵循规则和最佳实践，以使您的代码清晰、高效且具有可读性。\n","slug":"Qt/基础教程/Qt信号槽机制详解","date":"2021-10-04T06:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"3ebafc97fc88a959250cd7b15e946c06","title":"Qt状态机使用","content":"Qt状态机使用在本篇博客中，我们将探讨Qt状态机的用法以及如何在应用程序中使用它们。状态机可以简化复杂应用程序的开发流程，并且让代码更具可读性和易维护性。\n什么是Qt状态机Qt状态机是一种被称为QStateMachine的类，它可以用来管理应用程序的状态。状态机有助于将应用程序分解为互相独立、可重复的状态。状态由事件驱动，可以响应输入、发出输出并采取自适应操作。\n在Qt中，状态机非常广泛地应用于UI界面设计中。它们可用于管理UI元素的变化、控件之间的交互以及处理用户的操作。在开始使用状态机之前，请先确保已经深入了解了Qt信号与槽连接机制。\n如何创建Qt状态机使用Qt状态机，需要完成以下几个步骤：\n步骤1：定义状态变量首先，我们需要定义表示应用程序可能处于的状态变量。在这里，我们创建了两个状态变量：Idle和Working：\n1234enum State &#123;    Idle,    Working&#125;;\n\n步骤2：创建状态机对象接下来，我们需要创建一个QStateMachine的实例，该实例将负责管理应用程序的状态：\n1QStateMachine machine;\n\n一旦我们创建了一个QStateMachine实例，我们就可以在其中添加所有可能的状态。在这里，我们将定义两个状态：Idle和Working：\n12345QState *idle = new QState();QState *working = new QState();machine.addState(idle);machine.addState(working);\n\n步骤3：指定状态转换一旦我们定义了状态，我们需要将它们连接起来以构建状态机。在该示例中，我们添加了一个从Idle到Working的转换：\n1idle-&gt;addTransition(&amp;button, &amp;QPushButton::clicked, working);\n\n在这个转换中，当用户单击按钮时，从Idle到Working状态转换会启动。\n步骤4：指定进入&#x2F;退出动作除了在此之前涉及的功能之外，还可以在状态转换中定义进入&#x2F;退出操作。这些操作可以设置为执行特定任务或更改UI元素的值等功能。在这里，我们将打印文本消息以确定状态变化。\n1234567QObject::connect(idle, &amp;QState::entered, []()&#123;    qDebug() &lt;&lt; &quot;Now in Idle state&quot;;&#125;);QObject::connect(working, &amp;QState::entered, []()&#123;    qDebug() &lt;&lt; &quot;Now in Working state&quot;;&#125;);\n\n完成以上步骤后，已经成功创建了一个使用Qt状态机的应用程序！通过不同状态的转换，应用程序可以响应用户事件并根据需要执行相应动作。\n总结总而言之，Qt状态机是一种很好的方式来管理应用程序的状态，并且在UI设计中广泛应用。通过分解复杂问题并确保按照有序的、可读的方法处理它们，可以简化应用程序的开发流程并增强其可维护性。\n在实际的应用程序中，使用 Qt 状态机可能比上面提供的示例更为复杂，因此建议阅读 Qt 官方文档以了解更多信息。\n","slug":"Qt/基础教程/Qt状态机使用","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"9cd29aa7149344790a81ff29803e94e3","title":"使用Qt开发一个搜索框","content":"使用Qt开发一个搜索框在许多应用程序中，我们需要提供一个搜索框来让用户快速查找内容。在本文中，我们将介绍如何使用Qt创建一个简单的内嵌式搜索框和搜索按钮，并演示如何获取用户输入和执行搜索操作。\n创建搜索框和搜索按钮首先，我们需要创建一个QWidget部件，并将其布局为水平布局。然后，我们可以向该布局添加一个QLineEdit对象和一个QPushButton对象，以创建搜索框和搜索按钮。\n12345678QWidget *searchWidget = new QWidget();QHBoxLayout *layout = new QHBoxLayout(searchWidget);QLineEdit *lineEdit = new QLineEdit();QPushButton *searchButton = new QPushButton(&quot;Search&quot;);layout-&gt;addWidget(lineEdit);layout-&gt;addWidget(searchButton);\n\n获取用户输入并执行搜索操作为了获取用户在搜索框中输入的文本，我们需要连接QLineEdit的textChanged()信号，并将其发送到一个槽函数。在该函数中，我们可以获取文本并存储它，以备搜索时使用。\n123456connect(lineEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onSearchTextChanged);void MyClass::onSearchTextChanged(const QString &amp;text)&#123;    m_searchText = text;&#125;\n\n要执行搜索操作，我们只需将QPushButton的clicked()信号连接到一个槽函数即可。在该函数中，我们可以使用存储的搜索文本执行搜索操作。\n123456connect(searchButton, &amp;QPushButton::clicked, this, &amp;MyClass::onSearchClicked);void MyClass::onSearchClicked()&#123;    // 执行搜索操作&#125;\n\n完整代码示例下面是一个完整的代码示例，用于演示如何创建一个内嵌式搜索框和搜索按钮，并获取用户输入和执行搜索操作：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QHBoxLayout&gt;#include &lt;QLineEdit&gt;#include &lt;QPushButton&gt;#include &lt;QDebug&gt;class MyClass : public QWidget&#123;    Q_OBJECTpublic:    MyClass(QWidget *parent = nullptr) : QWidget(parent)    &#123;        // 创建搜索框和搜索按钮        QWidget *searchWidget = new QWidget();        QHBoxLayout *layout = new QHBoxLayout(searchWidget);        QLineEdit *lineEdit = new QLineEdit();        QPushButton *searchButton = new QPushButton(&quot;Search&quot;);        layout-&gt;addWidget(lineEdit);        layout-&gt;addWidget(searchButton);        // 连接信号和槽函数        connect(lineEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onSearchTextChanged);        connect(searchButton, &amp;QPushButton::clicked, this, &amp;MyClass::onSearchClicked);        // 显示搜索框和搜索按钮        setLayout(layout);        show();    &#125;private slots:    void onSearchTextChanged(const QString &amp;text)    &#123;        m_searchText = text;    &#125;    void onSearchClicked()    &#123;        qDebug() &lt;&lt; &quot;Searching for:&quot; &lt;&lt; m_searchText;    &#125;private:    QString m_searchText;&#125;;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    MyClass myClass;    return a.exec();&#125;\n\n总结在本文中，我们介绍了如何使用Qt创建一个内嵌式搜索框和搜索按钮，并演示了如何获取用户输入和执行搜索操作。这是一个简单而有用的界面元素，可以方便地提供搜索功能并提高用户体验。## 拓展\n在上述示例中，我们只是简单地演示了如何创建一个内嵌式搜索框和搜索按钮，并获取用户输入和执行搜索操作。但实际应用中，我们可能需要更加复杂的功能和交互体验。\n以下是一些可以拓展和优化的方向：\n\n在QLineEdit中使用占位符文本（placeholder text）或默认文本（default text）来提示用户输入。\n为搜索按钮添加快捷键（例如Enter键），以方便用户进行搜索。\n在搜索过程中显示进度指示器（例如旋转的等待图标），以提示用户搜索正在进行中。\n实现自动补全（autocomplete）或联想搜索（suggestion search）功能，以提高搜索的准确性和效率。\n支持多种搜索模式（例如精确搜索、模糊搜索、正则表达式搜索等）和高级选项，以满足不同用户的需求。\n结合其他界面元素（例如QListView、QTableWidget等）来展示搜索结果，并提供相关的操作和交互。\n\n参考资料\nQt Documentation: QLineEdit Class\nQt Documentation: QPushButton Class## 代码示例\n\n以下是一个简单的代码示例，演示了如何使用Qt创建一个内嵌式搜索框和搜索按钮，并获取用户输入和执行搜索操作：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QHBoxLayout&gt;#include &lt;QLineEdit&gt;#include &lt;QPushButton&gt;#include &lt;QDebug&gt;class SearchWidget : public QWidget&#123;    Q_OBJECTpublic:    SearchWidget(QWidget *parent = nullptr) : QWidget(parent)    &#123;        // 创建搜索框和搜索按钮        QLineEdit *lineEdit = new QLineEdit();        QPushButton *searchButton = new QPushButton(&quot;Search&quot;);        // 创建水平布局        QHBoxLayout *layout = new QHBoxLayout();        layout-&gt;addWidget(lineEdit);        layout-&gt;addWidget(searchButton);        setLayout(layout);        // 连接信号和槽函数        connect(lineEdit, &amp;QLineEdit::textChanged, this, &amp;SearchWidget::onSearchTextChanged);        connect(searchButton, &amp;QPushButton::clicked, this, &amp;SearchWidget::onSearchClicked);    &#125;signals:    void searchRequested(const QString &amp;text);private slots:    void onSearchTextChanged(const QString &amp;text)    &#123;        m_searchText = text;    &#125;    void onSearchClicked()    &#123;        emit searchRequested(m_searchText);    &#125;private:    QString m_searchText;&#125;;class MainWindow : public QWidget&#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent = nullptr) : QWidget(parent)    &#123;        // 创建搜索部件        m_searchWidget = new SearchWidget();        // 创建标签和文本编辑器        QLabel *label = new QLabel(&quot;Search Result:&quot;);        m_textEdit = new QTextEdit();        // 创建垂直布局        QVBoxLayout *layout = new QVBoxLayout();        layout-&gt;addWidget(m_searchWidget);        layout-&gt;addWidget(label);        layout-&gt;addWidget(m_textEdit);        setLayout(layout);        // 连接信号和槽函数        connect(m_searchWidget, &amp;SearchWidget::searchRequested, this, &amp;MainWindow::onSearchRequested);    &#125;private slots:    void onSearchRequested(const QString &amp;text)    &#123;        // TODO: 执行搜索操作并更新m_textEdit的内容        qDebug() &lt;&lt; &quot;Searching for:&quot; &lt;&lt; text;    &#125;private:    SearchWidget *m_searchWidget;    QTextEdit *m_textEdit;&#125;;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    MainWindow mainWindow;    mainWindow.show();    return a.exec();&#125;\n\n在该代码示例中，我们使用了两个自定义部件：SearchWidget和MainWindow。SearchWidget是一个包含搜索框和搜索按钮的部件，用于获取用户输入和发出搜索请求；而MainWindow则展示了搜索结果并提供了相应的布局。\n总结在本文中，我们介绍了如何使用Qt创建一个简单的内嵌式搜索框和搜索按钮，并获取用户输入和执行搜索操作。通过将搜索框和搜索按钮组合起来，我们可以方便地添加搜索功能，并提高用户体验。另外，我们还介绍了一些可以拓展和优化的方向，包括使用占位符文本、添加快捷键、显示进度指示器、实现自动补全等。这些功能可以根据具体需求进行定制和实现，以提供更好的搜索体验。\n在实际应用中，搜索功能通常是一个非常重要的界面元素，涉及到用户体验和性能等多个方面。因此，我们需要仔细考虑搜索算法的复杂度、搜索结果的呈现方式、搜索操作的并发性等问题，以保证搜索功能的稳定性和可靠性。\n最后，Qt提供了许多相关的组件和类，如QLineEdit、QPushButton、QLabel、QTextEdit等，可以方便地创建和管理用户界面元素。结合信号和槽机制，我们可以轻松地实现各种交互和事件处理，使得搜索功能更加灵活和可扩展。\n参考资料\nQt Documentation: QLineEdit Class\nQt Documentation: QPushButton Class\nQt Documentation: QLabel Class\nQt Documentation: QTextEdit Class\n\n","slug":"Qt/基础教程/使用Qt开发一个搜索框","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"e9e9c6fb0e1daf8f843d2ec1b3fc2e05","title":"使用Qt开发一个登录界面","content":"使用Qt开发一个登录界面在许多应用程序中，我们需要提供一个登录界面来让用户输入用户名和密码，并验证其身份。在本文中，我们将介绍如何使用Qt创建一个简单的登录界面，并演示如何获取用户输入和执行身份验证操作。\n创建登录界面首先，我们需要创建一个QWidget部件，并设置其布局为垂直布局。然后，我们可以向该布局添加两个QLineEdit对象和一个QPushButton对象，以分别创建用户名输入框、密码输入框和登录按钮。\n1234567891011QWidget *loginWidget = new QWidget();QVBoxLayout *layout = new QVBoxLayout(loginWidget);QLineEdit *usernameEdit = new QLineEdit();QLineEdit *passwordEdit = new QLineEdit();passwordEdit-&gt;setEchoMode(QLineEdit::Password);QPushButton *loginButton = new QPushButton(&quot;Login&quot;);layout-&gt;addWidget(usernameEdit);layout-&gt;addWidget(passwordEdit);layout-&gt;addWidget(loginButton);\n\n请注意，我们在创建密码输入框时，将其回显模式（echo mode）设置为密码模式（Password）。这样做可以隐藏用户输入的实际字符，以保护其安全性。\n获取用户输入并执行身份验证操作为了获取用户在用户名和密码输入框中输入的文本，我们需要连接QLineEdit的textChanged()信号，并将其发送到一个槽函数。在该函数中，我们可以获取文本并存储它，以备后续身份验证操作使用。\n123456789101112connect(usernameEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onUsernameTextChanged);connect(passwordEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onPasswordTextChanged);void MyClass::onUsernameTextChanged(const QString &amp;text)&#123;    m_username = text;&#125;void MyClass::onPasswordTextChanged(const QString &amp;text)&#123;    m_password = text;&#125;\n\n要执行身份验证操作，我们只需将QPushButton的clicked()信号连接到一个槽函数即可。在该函数中，我们可以使用存储的用户名和密码信息执行身份验证操作，并根据结果显示相应的消息框（例如成功登录或登录失败）。\n1234567891011connect(loginButton, &amp;QPushButton::clicked, this, &amp;MyClass::onLoginClicked);void MyClass::onLoginClicked()&#123;    bool isAuthenticated = authenticate(m_username, m_password);    if (isAuthenticated) &#123;        QMessageBox::information(this, &quot;Success&quot;, &quot;Login succeeded!&quot;);    &#125; else &#123;        QMessageBox::warning(this, &quot;Error&quot;, &quot;Invalid username or password.&quot;);    &#125;&#125;\n\n请注意，我们在此示例中使用了一个authenticate()函数来模拟身份验证操作，返回一个布尔值以指示是否验证成功。实际应用中，我们需要使用更加复杂的身份验证逻辑来保障安全性。\n完整代码示例下面是一个完整的代码示例，用于演示如何创建一个登录界面，并获取用户输入和执行身份验证操作：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QVBoxLayout&gt;#include &lt;QLineEdit&gt;#include &lt;QPushButton&gt;#include &lt;QMessageBox&gt;class MyClass : public QWidget&#123;    Q_OBJECTpublic:    MyClass(QWidget *parent = nullptr) : QWidget(parent)    &#123;        // 创建登录界面        QWidget *loginWidget = new QWidget();        QVBoxLayout *layout = new QVBoxLayout(loginWidget);        QLineEdit *usernameEdit = new QLineEdit();        QLineEdit *passwordEdit = new QLineEdit();        passwordEdit-&gt;setEchoMode(QLineEdit::Password);        QPushButton *loginButton = new QPushButton(&quot;Login&quot;);        layout-&gt;addWidget(usernameEdit);        layout-&gt;addWidget(passwordEdit);        layout-&gt;addWidget(loginButton);        // 连接信号和槽函数        connect(usernameEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onUsernameTextChanged);        connect(passwordEdit, &amp;QLineEdit::textChanged, this, &amp;MyClass::onPasswordTextChanged);        connect(loginButton, &amp;QPushButton::clicked, this, &amp;MyClass::onLoginClicked);        // 显示登录界面        setLayout(layout);        show();    &#125;private slots:    void onUsernameTextChanged(const QString &amp;text)    &#123;        m_username = text;    &#125;    void onPasswordTextChanged(const QString &amp;text)    &#123;        m_password = text;    &#125;    void onLoginClicked()    &#123;        bool isAuthenticated = authenticate(m_username, m_password);        if (isAuthenticated) &#123;            QMessageBox::information(this, &quot;Success&quot;, &quot;Login succeeded!&quot;);        &#125; else &#123;            QMessageBox::warning(this, &quot;Error&quot;, &quot;Invalid username or password.&quot;);        &#125;    &#125;private:    QString m_username;    QString m_password;    bool authenticate(const QString &amp;username, const QString &amp;password)    &#123;        // TODO: 执行身份验证操作        return username == &quot;admin&quot; &amp;&amp; password == &quot;123456&quot;;    &#125;&#125;;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    MyClass myClass;    return a.exec();&#125;\n\n在该代码示例中，我们创建了一个名为MyClass的QWidget子类，用于展示登录界面。在构造函数中，我们创建了用户名输入框、密码输入框和登录按钮，并将它们添加到垂直布局中。然后，我们连接了QLineEdit的textChanged()信号和QPushButton的clicked()信号到相应的槽函数中，以获取用户输入和执行身份验证操作。\n在onLoginClicked()槽函数中，我们使用存储的用户名和密码信息执行身份验证操作，并根据结果显示相应的消息框。在此示例中，我们使用了一个简单的authenticate()函数来模拟身份验证操作，返回一个布尔值以指示是否验证成功。在实际应用中，我们需要使用更加复杂的身份验证逻辑来保障安全性。\n最后，在main()函数中，我们创建了一个MyClass对象，并启动Qt应用程序。\n总结在本文中，我们介绍了如何使用Qt创建一个简单的登录界面，并演示了如何获取用户输入和执行身份验证操作。通过结合QLineEdit、QPushButton和QMessageBox等组件，我们可以轻松地实现各种交互和事件处理，使得登录界面更加灵活和可扩展。\n在实际应用中，登录界面通常是一个非常关键的界面元素，涉及到身份验证和安全性等多个方面。因此，我们需要仔细考虑安全性和用户体验，以确保登录功能的稳定性和可靠性。\n最后，Qt提供了许多相关的组件和类，如QLineEdit、QPushButton、QMessageBox等，可以方便地创建和管理用户界面元素。结合信号和槽机制，我们可以轻松地实现各种交互和事件处理，使得登录功能更加灵活和可扩展。\n","slug":"Qt/基础教程/使用Qt开发一个登录界面","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"3c79f2443ad6c8142d688bf19c36b2ad","title":"QGraphicsDropShadowEffect的介绍","content":"QGraphicsDropShadowEffect的介绍QGraphicsDropShadowEffect是Qt中一个用于添加阴影效果的图形特效类，可以在图形或控件周围添加一层阴影效果。通过调整阴影的偏移、模糊度、颜色等参数，可以实现各种独特的视觉效果。\n基本用法添加阴影首先，在需要添加阴影效果的QWidget（或QGraphicsItem）对象上创建QGraphicsDropShadowEffect对象：\n1QGraphicsDropShadowEffect *shadow = new QGraphicsDropShadowEffect(this);\n\n然后，通过调整阴影效果的参数来实现不同的视觉效果。例如，以下代码将启用5个像素的模糊和45度向右下方的十六进制黑色阴影：\n123shadow-&gt;setBlurRadius(5);shadow-&gt;setOffset(3, 3);shadow-&gt;setColor(QColor(&quot;#000000&quot;));\n\n将QGraphicsDropShadowEffect应用到相应的QWidget（或QGraphicsItem）对象上：\n1myWidget-&gt;graphicsEffect() = shadow;\n\n常用函数QGraphicsDropShadowEffect提供了许多常见的方法以便对阴影进行设置和管理。例如：\n\nsetBlurRadius()：设置阴影的模糊半径。\nsetOffset()：设置阴影相对于原始控件的偏移量。\nsetColor()：设置阴影颜色。\nsetOpacity()：设置阴影透明度。\nsetEnabled()：启用或禁用阴影效果。\nboundingRectFor()：计算产生的阴影下降Qt应用程序的范围。\n\n设置形状如果需要将阴影限制在边框内，可以通过普通的设置形状来实现。\n12345678QGraphicsDropShadowEffect *shadow = new QGraphicsDropShadowEffect(this);QPainterPath path;path.addRoundedRect(0, 0, width(), height(), 10, 10);shadow-&gt;setBlurRadius(20);shadow-&gt;setColor(QColor(&quot;#000000&quot;));shadow-&gt;setOffset(5,5);setGraphicsEffect(shadow);setMask(path.toFillPolygon().toPolygon());\n\n上面代码表示一个圆角矩形的窗口，半径为10像素，向下偏移5个像素，以及黑色颜色和20像素半径的阴影。\n结论总之，QGraphicsDropShadowEffect提供了一种简单且灵活的方法来添加阴影效果以改善用户的视觉体验。开发人员可以通过更改阴影效果的参数来实现各种不同的视觉效果，通过对形状进行限制，来满足具体业务场景的需求。在实际应用中，根据需求选择适当的阴影效果参数，并注意不要过度使用阴影效果以免影响应用程序的性能。\n","slug":"Qt/进阶教程/QGraphicsDropShadowEffect的介绍","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"57a39664d5dfca7343351ad94bd0279c","title":"QAnimation的介绍","content":"QAnimation的介绍QAnimation是Qt框架中提供的一个动画类，用于实现GUI控件的各种动画效果。可以通过QAnimation实现如平移、旋转、缩放等动态效果，同时还支持动态添加或删除控件等操作。\n基本用法创建和启动动画通过继承QPropertyAnimation、QSequentialAnimationGroup或QParallelAnimationGroup等类，用户可以轻松地创建自己需要的动画。\n以下示例展示了如何创建一个简单的位移动画，并在之后启动：\n12345678QWidget* widget = new QWidget(this);widget-&gt;setGeometry(50, 50, 100, 100);QPropertyAnimation *animation = new QPropertyAnimation(widget, &quot;geometry&quot;);animation-&gt;setDuration(2000);animation-&gt;setStartValue(QRect(50, 50, 100, 100));animation-&gt;setEndValue(QRect(150, 150, 100, 100));animation-&gt;setEasingCurve(QEasingCurve::OutQuad);animation-&gt;start();\n\n常用函数QAnimation提供了一些常见的方法以便对动画进行设置和管理：\n\nsetDuration()：设置动画执行时间。\nsetStartValue() 和 setEndValue()：设置动画开始和结束状态。\nsetEasingCurve()：设置动画的缓动曲线（用于控制动画速度变化的曲线）。\nsetLoopCount()：设置动画循环次数，默认为1次（-1表示无限循环）。\nsetDirection()：设置动画的前进方向。\nstop() 和 pause()：停止或暂停动画。\nstart()：启动动画。\n\n动画组合QAnimation还提供了多种动画组合方式，例如：\n\nQSequentialAnimationGroup：顺序播放一系列动画。\nQParallelAnimationGroup：同时播放一组动画。\nQPauseAnimation：插入一个暂停时间段。\nQAnimationGroup：以任意顺序播放一组不同类型的动画。\n\n以下是一个简单的QSequentialAnimationGroup例子：\n12345678910111213141516QWidget* widget = new QWidget(this);widget-&gt;setGeometry(50, 50, 100, 100);QPropertyAnimation *animation1 = new QPropertyAnimation(widget, &quot;geometry&quot;);animation1-&gt;setDuration(1000);animation1-&gt;setStartValue(QRect(50, 50, 100, 100));animation1-&gt;setEndValue(QRect(150, 150, 100, 100));QPropertyAnimation *animation2 = new QPropertyAnimation(widget, &quot;geometry&quot;);animation2-&gt;setDuration(1000);animation2-&gt;setStartValue(QRect(150, 150, 100, 100));animation2-&gt;setEndValue(QRect(50, 50, 100, 100));QSequentialAnimationGroup *group = new QSequentialAnimationGroup;group-&gt;addAnimation(animation1);group-&gt;addAnimation(animation2);group-&gt;start();\n\n性能考虑QAnimation能够实现流畅的动画效果，但也需要注意一些性能上的问题。特别是在操作的控件数量较多或者动画较为复杂时，可能会导致性能问题。\n建议减少系统资源消耗，可以采用下列方法：\n\n通过调整setDuration()之类的参数来改变动画执行效率。\n对于无需操作（或者不可见）的控件，对其停用或暂停对应动画。\n优化界面控件布局和显示，使用缓存等手段来加速动画渲染过程。\n\n结论总之，QAnimation提供了丰富的功能，可以源源不断地为Qt应用开发人员带来无限可能。在实际应用中，需要结合具体业务需求选择各种不同的QPropertyAnimation、QSequentialAnimationGroup或其他动画组合方式，以及设置合理的参数和执行策略来达到最佳的动画效果和性能表现。\n","slug":"Qt/进阶教程/QAnimation的介绍","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"4ffa61e24f1f48ce78e535f52d6a978c","title":"Q_D指针：Qt中的私有指针","content":"Q_D指针：Qt中的私有指针在开发Qt应用程序时，为了保护对象的私有数据并提高代码健壮性，经常会使用QObject和QSharedData等。然而，Q_D指针是一种更高效且易于使用的方法，它可以避免复制数据，保护对象不受外部访问，并减少内存分配和复制。在本文中，我们将详细介绍Q_D指针的原理、优点和使用方法。\n什么是Q_D指针？Q_D指针是Qt框架中的私有指针，用于隐藏对象的实现和保护其数据。Q_D指针的原理是将对象的实现放在单独的类（例如MyClassPrivate）中，然后将Q_D指针作为指向该类的单个成员变量存储在主类中。这意味着只有该类可以访问此指针，并且对象的实现可以轻松地更改而无需更改公共接口。\n以下是一个简单的使用Q_D指针的示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;QExplicitlySharedDataPointer&gt;#include &lt;iostream&gt;class MyClassPrivate;class MyClass &#123;public:    MyClass();    ~MyClass();    void setNumber(int number);    int getNumber() const;private:    QExplicitlySharedDataPointer&lt;MyClassPrivate&gt; const d_ptr;&#125;;class MyClassPrivate &#123;public:    int m_number;&#125;;MyClass::MyClass() : d_ptr(new MyClassPrivate)&#123; &#125;MyClass::~MyClass()&#123; &#125;void MyClass::setNumber(int number) &#123;    d_ptr-&gt;m_number = number;&#125;int MyClass::getNumber() const &#123;    return d_ptr-&gt;m_number;&#125;int main() &#123;    MyClass* myObject = new MyClass;    myObject-&gt;setNumber(42);    std::cout &lt;&lt; &quot;My object&#x27;s number is: &quot; &lt;&lt; myObject-&gt;getNumber() &lt;&lt; std::endl;    delete myObject;    return 0;&#125;\n\n在这个例子中，我们定义了一个名为“MyClass”的主类和一个名为“MyClassPrivate”的辅助类。在MyClass中，我们使用Q_D指针作为私有成员变量，并将它存储在const变量d_ptr中。然后，在MyClassPrivate中，我们定义了一个简单的数据成员m_number，并从MyClass中使用setNumber()和getNumber()方法进行访问。\n最后，在main()函数中，我们创建了一个新的MyClass对象，并使用setNumber()和getNumber()方法设置和检索对象的数字。最后，我们使用delete操作符删除对象以避免内存泄漏。\nQ_D指针的优点使用Q_D指针作为Qt应用程序的开发模式有许多好处：\n\n私有化实现：Q_D指针避免直接访问和更改对象状态，从而保护对象及其数据并减少操作需要管理员风险。\n避免复制：Q_D指针避免了对象的复制，从而减少了内存分配和拷贝操作，节约时间和资源。\n可测试性：使用Q_D指针可以使类更易于测试和调试。Q_D指针减少了公共接口的复杂性，使得更容易构建自动化测试。\n\n使用Q_D指针的注意点在使用Q_D指针时，需要注意以下事项：\n\n实现需要单独定义： 辅助类型单独定义以确保辅助类型只能通过Q_D指针访问。\n指针不是线程安全的：Q_D指针仍需要锁定，有许多选项可用于实现该目标，例如信号槽机制和互斥体等。\n依赖QObject：由于Q_D指针需要访问QObject的元信息，因此只能与派生自QObject的类一起使用。\n\n结论Q_D指针是一种用于保护对象实现并防止数据复制的Qt应用程序开发模式。它使得我们开发更高效、具备更好可测试性和减少内存分配的安全代码变得轻而易举。有了Q_D指针，我们可以实现复杂对象中数据的封装和管理，帮助我们更快地开发更健壮的Qt应用程序。\n","slug":"Qt/进阶教程/Q_D指针：Qt中的私有指针","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"9eb2b1aca9e69bfaa81739ec33faa057","title":"qRegisterMetaType：Qt中的元类型注册机制","content":"qRegisterMetaType：Qt中的元类型注册机制Qt框架提供了强大的信号槽机制和反射功能。在这些机制下，元类型注册是一项重要且必须的操作。在实际开发中，我们经常需要将自定义的C++类或者结构体暴露给Qt的元对象系统，以便能够通过信号槽机制或者QVariant等进行处理。qRegisterMetaType是Qt中用于元类型注册的函数，本文将详细介绍它的使用方法和应用场景。\n什么是元类型注册？元类型注册是向Qt元对象系统中注册某个C++数据类型，使其能够被Qt信号槽机制、动态属性、QObject子类化（Q_OBJECT）等类型系统所支持和识别。C++中的简单类型，如int、char、void*等，已经被Qt进行过初始化并注册。但是我们定义的自定义类型，如个人信息、订单、消息等等，需要通过元类型注册才能为Qt框架所用。\n以下是一个简单的例子，介绍了如何使用qRegisterMetaType来注册一个自定义的类：\n123456789101112131415161718192021222324252627282930#include &lt;QtCore/QCoreApplication&gt;#include &lt;QtCore/QMetaType&gt;class MyClass &#123;public:    MyClass() : m_data(0) &#123;&#125;    explicit MyClass(int data) : m_data(data) &#123;&#125;    int getData() const &#123; return m_data; &#125;private:    int m_data;&#125;;Q_DECLARE_METATYPE(MyClass)int main(int argc, char** argv) &#123;    QCoreApplication app(argc, argv);    qRegisterMetaType&lt;MyClass&gt;(&quot;MyClass&quot;);    MyClass myObject(42);   QMetaType::Type type = QMetaType::type(&quot;MyClass&quot;);   if (type != QMetaType::UnknownType) &#123;       qDebug() &lt;&lt; &quot;MyClass is a registered meta-type!&quot;;   &#125;   return app.exec();&#125;\n\n在这个例子中，我们定义了一个叫做”MyClass”的类，并使用了Q_DECLARE_METATYPE宏来声明它是一个自定义元类型。之后，我们使用qRegisterMetaType函数将这个类注册到Qt元对象系统中，并提供了一个标签名称“MyClass”。\n创建了MyClass对象（m_data被初始化为42）之后，我们通过Q_MetaType::type()函数检查是否正确地注册了该类。如果正确注册，则返回类型QMetaType::Type无效,否则返回QMetaType::UnknownType。\nqRegisterMetaType的应用场景\n传递复杂类型参数: 元类型注册使得我们可以在信号槽之间传递我们自定义的数据类型，而不必依靠QVariant进行数据处理从而进行扩展。\n继承QObject后添加新的事件或者属性: Q_OBJECT类中定义的事件和属性是基于元对象系统实现的，因此对于新的事件或者属性，可能需要使用qRegisterMetaType增加支持。\n构建Qt对外部库的桥梁：在想要将第三方库与Qt结合使用时，我们需要将自定义类型注册为元类型。\n\nqRegisterMetaType注意点\n对于const的m_amedata需要传递包装器类 （如QSharedPointer,const_cast 包装器等）。\n元对象系统内部有一个Hardcoded list of Qt data types已经添加到Q_RegisterMetaType中了，如果已经添加则不需要额外添加两次。\n在使用自定义数据类型之前必须先进行注册，否则程序可能会崩溃。\n由于QT的meta object是用宏来声明元信息的，因此C++标准的RTTI(Run-Time Type Information)并不能应用于此。\n\n结论在Qt开发中，元类型注册是一项非常重要的操作，使得我们能够自定义数据类型成为Qt元对象系统的一部分。使用qRegisterMetaType可以轻松地完成这个任务，避免了不必要的冗余代码和其他问题，在Qt应用程序开发中又具有重要地位。 通过该机制，我们可以增加代码的健壮性，并更加有效地编写基于元对象系统的代码，实现更好的效率和可读性。\n","slug":"Qt/进阶教程/qRegisterMetaType：Qt中的元类型注册机制","date":"2021-10-04T03:34:06.000Z","categories_index":"Qt进阶教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"4d9fef62ec588fa571ad0698797e052d","title":"Qt中创建雷达扫描界面","content":"Qt中创建雷达扫描界面步骤1：添加QPainter显示区域在Qt工程中打开要处理的UI视图文件。将“QPainter”放入核心窗口中，并设置其大小和位置。下面是在Qt Creator中添加QPainter的代码示例：\n1234QPainter painter(this);painter.setPen(Qt::black);painter.setBrush(Qt::gray);painter.drawRect(0, 0, width(), height());\n\n步骤2：绘制雷达线使用QPainter在屏幕上画线，在此之前，必须调用start()与end()方法（这种方式在Qt Creator的paintEvent()函数中提供）。使用以下方法绘制雷达线：\n12painter.setPen(QPen(Qt::green, 3));painter.drawLine(0, 0, x, y);\n这将在屏幕上绘制一条从（0,0）到（x,y）的绿色线。\n步骤3：绘制雷达扇形绘制圆弧并将其填充为扇形，使用以下步骤：\n步骤1：定义QPainterPath\n利用QPainterPath类定义一个路径，并设置其起点和角度度数（d）：\n123QPainterPath path;path.moveTo(0, 0);path.arcTo(-100, -100, 200, 200, 30 * 16, d * 16);\n\n步骤2：绘制QPainterPath\n将路径传递给QPainter，并在画布上开始画图：\n123painter.setBrush(QBrush(Qt::green));painter.setPen(Qt::NoPen);painter.drawPath(path);\n\n这将在屏幕上绘制一个从当前控件的中心向右30°的圆弧并进行填充。\n随着掌握技术，您可以添加更多的代码以创建完整的雷达扫描界面。\n","slug":"Qt/基础教程/Qt中创建雷达扫描界面","date":"2021-10-03T05:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"8c7d4356d8bda200c9e956adb3733402","title":"QWidget：Qt中的基本用户界面类","content":"QWidget：Qt中的基本用户界面类QString类是Qt中非常重要的一个类，用于表示基本用户界面构件。它是其他用户界面(Widget)类的基类，例如QMainWindow、QDialog和QPushButton等。在本文中，我们将详细介绍QWidget类的功能和应用场景。\n创建QWidget对象为了创建QWidget对象，我们可以使用QWidget的默认构造函数或指定其父对象、名称和其他属性的构造函数。在这里，我们来看一下如何使用默认构造函数创建一个简单的QWidget对象：\n1234567891011#include &lt;QWidget&gt;#include &lt;QApplication&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    QWidget widget;                // 默认的QWidget实例    widget.show();    return app.exec();&#125;\n\n在这个例子中，我们使用QWidget的默认构造函数创建了一个新的名为“widget”的QWidget实例，并通过调用其show()方法使其在屏幕上可见。\nQWidget属性和方法QWidget有许多属性和方法，在这里我们列出了其中的一些最常用和最重要的:\n\nresize(): 设置QWidget的大小。\nmove(): 将QWidget移动到给定窗口坐标。\nshow(): 显示QWidget。\nhide(): 隐藏QWidget。\nsetWindowTitle(): 设置窗口标题。\nsetWindowIcon(): 设置窗口图标。\nsetLayout(): 设置QWidget的布局管理器。\n\n例如，在以下代码中，我们展示了如何使用创建一个QWidget界面和设置标题、大小和布局：\n1234567891011121314151617181920#include &lt;QWidget&gt;#include &lt;QHBoxLayout&gt;#include &lt;QApplication&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    QWidget widget;    widget.setWindowTitle(&quot;My Widget&quot;);    widget.resize(400, 300);    QHBoxLayout* layout = new QHBoxLayout;    QLabel* label = new QLabel(&quot;Hello World&quot;, &amp;widget);    layout-&gt;addWidget(label);    widget.setLayout(layout);    widget.show();    return app.exec();&#125;\n\n在这个例子中，我们首先创建了一个新的QWidget实例“widget”，并设置其标题为“My Widget”和大小为400x300。然后，我们创建了一个水平布局并向其中添加了一个包含“Hello World”文本的标签。最后，我们将该布局设置为QWidget的布局管理器，并使QWidget在屏幕上可见。\nQWidget事件处理所有QWidget都有事件处理方法。我们可以使用这些方法来响应来自系统和用户界面的事件，例如窗口重绘、鼠标单击等事件。这些方法允许我们编写自定义事件处理程序以控制用户界面的行为。\n常用的QWidget事件处理方法有：\n\nmousePressEvent(QMouseEvent *event): 鼠标按下事件。\nmouseMoveEvent(QMouseEvent *event): 鼠标移动事件。\nkeyPressEvent(QKeyEvent *event): 键盘按下事件。\nresizeEvent(QResizeEvent *event): 窗口大小调整事件。\n\n例如，在以下代码中，我们展示了如何实现QWidget的事件处理：\n1234567891011121314151617181920212223#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &lt;QApplication&gt;class MyWidget : public QWidget &#123;public:    MyWidget() &#123; &#125;protected:    void mousePressEvent(QMouseEvent *event) override &#123;        qDebug() &lt;&lt; &quot;Mouse pressed at:&quot; &lt;&lt; event-&gt;pos();    &#125;&#125;;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    MyWidget widget;    widget.resize(400, 300);    widget.show();    return app.exec();&#125;\n\n在这个例子中，我们首先创建了一个新的“MyWidget”类派生自QWidget，并重写了其mousePressEvent()方法，以处理鼠标按下事件，并通过qDebug()输出点击位置的坐标。最后，我们创建了一个名为“widget”的MyWidget对象，并使它可见。\n结论在Qt应用程序中，QWidget是所有用户界面基础的类和父类。它提供了许多属性和方法，可以帮助我们轻松地创建、设置并响应用户界面。除此之外，QWidget还提供了一个强大的事件处理系统，使我们能够编写自定义事件处理程序来控制应用程序的行为。\n","slug":"Qt/基础教程/QWidget：Qt中的基本用户界面类","date":"2021-10-03T02:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"ef385d6b305945df4f94b44ac9927f7a","title":"Qt使用布局","content":"Qt使用布局在这篇文章中，我们将会介绍Qt中的各种布局方式，以及如何使用它们来管理控件的位置和大小。在Qt中有很多种布局，我们可以根据不同的需求选择不同的布局方式。\n布局管理器在Qt中，布局管理器是用来自动调整窗口中包含控件的位置和大小的。Qt提供了四种常用的布局管理器：QHBoxLayout、QVBoxLayout、QGridLayout和QFormLayout。它们的主要不同在于它们如何管理和排列窗口中的控件。\nQHBoxLayout布局QHBoxLayout，也称为水平布局，适用于在一个水平行上对控件进行排列。以下代码将帮助你创建并实现QHBoxLayout布局：\n12345QHBoxLayout* layout = new QHBoxLayout;layout -&gt;addWidget(w1);layout -&gt;addWidget(w2);...setLayout(layout);\n\n这里我们首先创建了一个QHBoxLayout对象，接着将控件w1、w2等添加到内部，然后将该布局设置给当前的容器QWidget，例如MainWindow或其他定制化的窗口。当我们使用setGeometry()或resize()函数调整主窗口大小时，布局管理器将自动调整子控件的位置和大小。\nQVBoxLayout布局相对于QHBoxLayout水平布局， QVBoxLayout是垂直布局，适用于在一个垂直列上对控件进行排列。下面演示如何创建并实现QVBoxLayout：\n12345QVBoxLayout* layout = new QVBoxLayout;layout -&gt;addWidget(w1);layout -&gt;addWidget(w2);...setLayout(layout);\n\n与QHBoxLayout相似，我们创建一个QVBoxLayout对象，并将控件添加到内部，然后将该布局设置给当前的窗口或窗体。\nQGridLayout布局QGridLayout是将控件放置在二维网格中布局的一种方式。以下代码将帮助你创建并实现QGridLayout布局：\n12345QGridLayout* layout= new QGridLayout;layout-&gt;addWidget(w1,0,0);     //这里 0 表示行 0 ， 0 表示列 0 layout-&gt;addWidget(w2,0,1);layout-&gt;addWidget(w3,1,0,1,2); //这里 1 表示行 1 ， 0 表示列 0， 1 行 2 列setLayout(layout);\n\n在这里，我们首先创建一个QGridLayout对象，并使用addWidget()函数将控件w1、w2等添加到内部，使用（x,y）、rowSpan和colSpan参数指定需要占据的单元格信息，例如：3行2列布局，w3 占据其中2列，起始点为第2行第0列（注意：坐标从0开始）。\nQFormLayout布局QFormLayout旨在用于简单的表单布局，特别是标签&#x2F;输入组合。以下代码将帮助你创建并实现QFormLayout布局：\n12345QFormLayout* layout= new QFormLayout;layout-&gt;addRow(&quot;标签 1&quot;, w1);layout-&gt;addRow(&quot;标签 2&quot;, w2);...setLayout(layout);\n\n在这里，我们使用addRow()函数将控件w1、w2等添加到内部，并添加相应的标签。\n总结在Qt中有很多种布局方式，我们应该选择适用于特定需求的布局方式。当然，这里只是介绍了几种主要的布局管理器，Qt还有其他布局可供选择，例如：QStackedlayout、QSplitter等；在使用时需要按照实际场景进行选择。布局管理器的作用是自动调整和管理控件位置和大小，并确保它们能够自动适应不同分辨率和窗口尺寸的变化，从而使得GUI编程更加方便简单。\n","slug":"Qt/基础教程/Qt使用布局","date":"2021-10-03T02:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"340d1df588bee8247e70f61a451b98ba","title":"Qt高级绘图","content":"Qt高级绘图在这篇文章中，我们将会介绍Qt中的高级绘制技术，并了解如何使用它们来实现自定义的绘制和渲染。Qt提供了一些专业级别的API来进行绘图操作，可以创建矢量图形或者像素颜色（bitmap）图形。\nQPainter绘图框架Qt中最常用的绘制API是QPainter类。它可以用于将几何形状、图像和文本等内容绘制到窗口或Widge上。\n以下是一个简单的例子，展示如何使用QPainter在QWidget上绘制一条直线：\n1234void CustomWidget::paintEvent(QPaintEvent* event) &#123;    QPainter painter(this);    painter.drawLine(0, 0, width(), height());&#125;\n首先，我们重载QWidget的paintEvent()函数，在其参数event中派生一个QPainter对象，然后使用drawLine()函数在CustomWidget委托的窗口上绘制一条直线。\n手动绘画：绘制基本图元通过手动绘制，我们可以创建自定义的图形界面，通常需要使用以下的基本图形元素：线条、多边形、椭圆、弧形和文字等。\n例如，下面是一个绘制圆形和矩形的例子：\n123456void CustomWidget::paintEvent(QPaintEvent* event) &#123;    QPainter painter(this);    painter.setBrush(QBrush(Qt::black));    painter.drawEllipse(QRectF(20, 20, 50, 50));    painter.drawRect(QRectF(80, 20, 50, 50));&#125;\n在这个例子中，我们重载QWidget的paintEvent()函数，并使用QPainter类在CustomWidget委托的窗口上绘制了一个圆和矩形。注意：由于Qt计算尺寸是采用浮点类型的矩形标准，我们使用QRectF来定义矩形。\n高级绘图：OpenGL除了Qt自带的绘图API，Qt还支持OpenGL，通常可用于高性能、多次运动的环境中，如游戏或数据科学等。\n例如，以下代码展示了如何在QWidget上绘制三角形（当OpenGL开启时）：\n123456789101112131415void CustomWidget::paintEvent(QPaintEvent* event) &#123;#ifdef QT_OPENGL_SUPPORT    QOpenGLWidget* widget = new QOpenGLWidget(this);    widget -&gt;makeCurrent();    glBegin(GL_TRIANGLES);    glVertex2f(-1.0f,-0.5f);    glVertex2f( 1.0f,-0.5f);    glVertex2f( 0.0f, 0.5f);    glEnd();    glFlush();  #else    QPainter painter(this);    // 使用QPainter API 绘制其他内容#endif&#125;\n\n在这个例子中，我们创建了一个QOpenGLWidget对象，并调用它的makeCurrent()方法获取OpenGL渲染环境。\n接着，我们使用OpenGL API绘制三角形，并调用glFlush()函数刷新缓冲区来呈现图像。\n在不支持OpenGL的情况下（如运行在低端硬件或嵌入式设备上），我们可以使用QPainter API替代OpenGL的功能，或者提供本地CPU的软件渲染方式。\n总结Qt提供了多种高级绘制技术，可以帮助我们实现精美的UI界面和高性能的数据可视化。通过手动绘图和OpenGL，我们可以创造出令人惊叹的艺术作品和复杂的3D场景展示。\n","slug":"Qt/基础教程/Qt高级绘图","date":"2021-10-03T02:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"b7a3f67da58560c80fad50efc08e725d","title":"Qt使用QSS设置控件样式","content":"Qt使用QSS设置控件样式在这篇文章中，我们将会学习如何使用QSS（Qt样式表）来自定义QPushButton、QLabel、QLineEdit和QComboBox控件的样式。在Qt中，我们可以使用QSS来定制控件的外观，并且能够方便地整合到我们的应用程序中。\n设置QPushButton的样式我们可以通过以下方式设置QPushButton的样式：\n123456789101112131415QPushButton &#123;    background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #3b78e6, stop:1 #0f5fd7);    border-radius: 5px;    color: white;    font-weight: bold;    padding: 5px 15px;&#125;QPushButton:hover &#123;    background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #60a3f7, stop:1 #3b78e6);&#125;QPushButton:pressed &#123;    background-color: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #0f5fd7, stop:1 #3b78e6);&#125;\n\n在这里，我们将QPushButton控件的背景设置为颜色渐变，使用了border-radius属性添加圆角边框。我们还改变了字体加粗程度和颜色，并且为按钮设置了padding属性。同时，我们还在:hover和:pressed状态下分别修改按钮的渐变背景色。\n设置QLabel的样式与QPushButton的设置方式相似，我们可以使用以下代码来设置QLabel的样式：\n123456QLabel &#123;    background-color: #d8e5f4;    border: 1px solid #c7d9ea;    color: #333333;    padding: 2px;&#125;\n\n对于QLabel控件，我们将其背景设置为固定的颜色，在边界中添加了细的灰色边框，并为文本设置了适当的内边距。\n设置QLineEdit的样式我们可以使用以下代码来设置QLineEdit的样式：\n1234567891011QLineEdit &#123;    background-color: #ffffff;    border: 1px solid #c7d9ea;    color: #444444;    padding: 2px;&#125;QLineEdit:focus &#123;    border: 1px solid #3b79e6;    outline: none;&#125;\n\n这里，我们设置了QLineEdit控件的背景色和边框颜色，使其看起来更加干净。对于焦点情况，我们添加了一个以蓝色突出表示的边框线，并禁用了默认的外观字体样式应用。\n设置QComboBox的样式最后，我们使用以下代码来设置QComboBox的样式：\n12345678910111213141516QComboBox &#123;    background-color: #ffffff;    border: 1px solid #c7d9ea;    color: #444444;    padding: 2px;    &#125;QComboBox:editable &#123;    background-color: #ffffff;&#125;QComboBox QAbstractItemView &#123;    border: 1px solid #c7d9ea;    selection-background-color: #3b78e6;    selection-color: white;&#125;\n\n在这里，我们设置了QComboBox控件的背景色和边框颜色，以及它的文本颜色并添加了适当的内边距。对于可编辑的QComboBox，我们还单独为其设置了背景色。最后，我们修改QComboBox中项目视图的边框线，并为选中的项提供了更明显的文本和渐变背景颜色。\n在本篇文章中，我们学习了如何使用QSS来自定义QPushButton、QLabel、QLineEdit和QComboBox控件的外观样式。Qt提供了很多的属性可以帮助我们改变控件的外观，并且使得我们可以创建具有自定义外观的应用程序。\n","slug":"Qt/基础教程/Qt使用QSS设置控件样式","date":"2021-10-02T02:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"1175242b1cb2123c73e3f30548ab2dd7","title":"Qt绘制指针时钟","content":"Qt绘制指针时钟什么是Qt？Qt是一款跨平台的C++应用程序开发框架，它提供了一套完整的工具和库，可以帮助开发者快速构建高质量的应用程序。Qt支持多种操作系统和开发语言，包括Windows、Linux、macOS、Android、iOS等，同时也支持C++、Python、JavaScript等多种编程语言。\n指针时钟的作用和效果指针时钟是一种常见的时钟显示方式，它通过指针的旋转来显示时间，具有简洁、直观、美观等特点。在Qt中，我们可以使用QPainter类来绘制指针时钟，同时也可以通过QTimer类来实现时钟的更新。\n绘制指针时钟的代码示例下面是一个简单的示例代码，演示了如何绘制一个指针时钟：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;QtWidgets&gt;class ClockWidget : public QWidget&#123;public:    ClockWidget(QWidget *parent = nullptr) : QWidget(parent)    &#123;        setFixedSize(200, 200);        QTimer *timer = new QTimer(this);        connect(timer, &amp;QTimer::timeout, this, QOverload&lt;&gt;::of(&amp;ClockWidget::update));        timer-&gt;start(1000);    &#125;protected:    void paintEvent(QPaintEvent *event) override    &#123;        Q_UNUSED(event);        QPainter painter(this);        painter.setRenderHint(QPainter::Antialiasing);        painter.translate(width() / 2, height() / 2);        painter.scale(width() / 200.0, height() / 200.0);        // 绘制表盘        painter.setPen(Qt::NoPen);        painter.setBrush(Qt::white);        painter.drawEllipse(-90, -90, 180, 180);        // 绘制刻度        painter.setPen(QPen(Qt::black, 2));        for (int i = 0; i &lt; 12; ++i) &#123;            painter.drawLine(0, -80, 0, -70);            painter.rotate(30);        &#125;        // 绘制时针        painter.save();        painter.rotate(30 * QTime::currentTime().hour() + QTime::currentTime().minute() / 2.0);        painter.setPen(QPen(Qt::black, 4));        painter.drawLine(0, 0, 0, -40);        painter.restore();        // 绘制分针        painter.save();        painter.rotate(6 * QTime::currentTime().minute() + QTime::currentTime().second() / 10.0);        painter.setPen(QPen(Qt::black, 3));        painter.drawLine(0, 0, 0, -60);        painter.restore();        // 绘制秒针        painter.save();        painter.rotate(6 * QTime::currentTime().second());        painter.setPen(QPen(Qt::red, 2));        painter.drawLine(0, 0, 0, -70);        painter.restore();    &#125;&#125;;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    ClockWidget clock;    clock.show();    return app.exec();&#125;\n\n在上面的代码中，我们首先创建了一个ClockWidget类，继承自QWidget类，并重写了它的paintEvent函数。在paintEvent函数中，我们使用QPainter类来绘制指针时钟，包括表盘、刻度、时针、分针和秒针等。同时，我们还使用QTimer类来实现时钟的更新，每隔一秒钟就调用一次update函数，重新绘制时钟。\n通过上面的示例代码，我们可以看到Qt绘制指针时钟的过程非常简单，只需要使用QPainter类和QTimer类即可实现。如果您想要进一步了解Qt的绘图和定时器功能，可以参考Qt官方文档或者相关书籍。\n","slug":"Qt/基础教程/Qt绘制指针时钟","date":"2021-09-29T04:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"2106cd6b75d5bd1805d109460f8c2725","title":"Qt实现笔记本软件","content":"EasyNote📚简介本项目为Qt实现笔记本软件。\n\n支持富文本笔记\n支持最近文档，收藏夹，回收站，文件分类等\n支持全局笔记搜索，删除，收藏笔记\n支持回收站还原笔记\n支持设置启动密码\n支持切换主题\n支持图案密码登录\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上msvc编译器都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\nsqlite\n存储数据库\n\n\n🗺️软件展示 \n\n首次使用\n收藏夹\n收藏\n子分类\n最近文档\n删除文档\n全局搜索\n回收站\n还原\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现笔记本软件","date":"2021-09-28T08:34:06.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"6b2f41d280a5ed65f0a5d3dda2e46f20","title":"Qt创建一个动画按钮","content":"Qt创建一个动画按钮在这篇博客中，我们将会学习如何通过使用Qt来创建一个动画按钮。我们将会使用QPropertyAnimation类，它可以使我们控制一个对象的任何属性的动画。\n第1步 - 创建按钮首先，我们需要创建一个QPushButton对象来表示我们的动画按钮。我们可以使用以下代码：\n1QPushButton *button = new QPushButton(&quot;Click me&quot;, parent);\n\n这将会创建一个带有“Click me”文本的QPushButton对象，并且将其添加到指定的父QWidget对象中。\n第2步 - 为按钮设置动画属性接下来，我们需要为按钮设置属性，以便我们可以通过动画来改变它们。在这个例子中，我们将会为按钮的大小和颜色属性设置动画。我们可以使用以下代码：\n123456QPropertyAnimation *animation = new QPropertyAnimation(button, &quot;geometry&quot;);animation-&gt;setDuration(1000);animation-&gt;setStartValue(QRect(0, 0, 100, 30));animation-&gt;setEndValue(QRect(250, 250, 200, 60));animation-&gt;setEasingCurve(QEasingCurve::InOutQuad);animation-&gt;start();\n\n这里我们创建一个QPropertyAnimation对象，然后将其连接到按钮上，并将其属性设置为几何形状。我们还将动画时长设置为1000毫秒，起始和终止值设置为按钮的初始和最终位置（这里的值是矩形区域，我们可以设置其大小和位置），并且动画曲线设置为QEasingCurve::InOutQuad，以使动画具有平滑的效果。最后我们调用start()函数开始动画。\n第3步 - 运行程序现在我们可以运行程序，并点击按钮观看它的动画效果啦！完整的Qt程序代码应该如下所示：\n123456789101112131415161718192021222324#include &lt;QPushButton&gt;#include &lt;QPropertyAnimation&gt;#include &lt;QEasingCurve&gt;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QWidget *parent = new QWidget;    parent-&gt;setFixedSize(500, 500);    QPushButton *button = new QPushButton(&quot;Click me&quot;, parent);    button-&gt;setGeometry(0, 0, 100, 30);    QPropertyAnimation *animation = new QPropertyAnimation(button, &quot;geometry&quot;);    animation-&gt;setDuration(1000);    animation-&gt;setStartValue(QRect(0, 0, 100, 30));    animation-&gt;setEndValue(QRect(250, 250, 200, 60));    animation-&gt;setEasingCurve(QEasingCurve::InOutQuad);    animation-&gt;start();    parent-&gt;show();    return app.exec();&#125;\n\n恭喜你，你已经学会了如何通过Qt创建一个动画按钮！\n","slug":"Qt/基础教程/Qt创建一个动画按钮","date":"2021-09-28T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"e42b28a1e2572b90e90363072c82df61","title":"Qt实现精美时钟","content":"PerfectClock📚简介本项目为Qt实现一款拟物时钟，全部为自绘时钟，主要使用定时器，等比例绘图，绘制角度，及钟摆动画等。秒针摆动有轻微动画效果，更加接近拟物风格。\n\n右键单击切换风格\n鼠标滚轮可以放大，缩小窗口。\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQPainter\n窗口的绘制\n\n\nQPropertyAnimation\n钟摆动画\n\n\nQFont\n时间字体\n\n\n🗺️软件截图主界面\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现精美时钟","date":"2021-08-23T01:51:30.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"cb9e2c8abcfd3f6ecae0c80283194d87","title":"Qt实现水波进度条","content":"LiquidPlot📚简介本项目为Qt实现水波进度条。\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQPainter\n窗口的绘制\n\n\nQFont\n时间字体\n\n\n🗺️软件截图主界面\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现水波进度条","date":"2021-08-23T01:49:30.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"5501e08753ab993d068135c954746e49","title":"Qt模仿360桌面加速球","content":"360FloatBall📚简介本项目为Qt模仿360桌面悬浮窗。\n\n双击模拟清理\n右侧自动吸附\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上都支持\n\n🗺️软件截图主界面\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt模仿360桌面加速球","date":"2021-08-23T01:46:49.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"2b714a0f88b5cb1551afa311876b2c36","title":"Qt实现音乐播放器","content":"MusicPlayer📚简介本项目为Qt实现一款小而美的音乐播放器。\n💾体验程序\n安装包地址\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上msvc编译器都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\nQPainter\n部分窗口的绘制，例如实时天气界面\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\n🗺️软件截图主界面\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现音乐播放器","date":"2021-08-23T01:44:01.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"49aefe99718bccc223ed635b4c3f5313","title":"Qt实现汽车导航仪界面","content":"CarCompass📚简介本项目为Qt实现汽车导航仪界面，目前还不太完善，持续更新中。。。\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64) \n理论上Qt 5.6以上msvc编译器都支持\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\nQPainter\n部分窗口的绘制，例如实时天气界面\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\n🗺️软件截图开机动画\n语音输入\n下拉菜单\n电话\n音乐\n系统设置\n屏幕保护\n📝参考网址📗qt官网📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt实现汽车导航仪界面","date":"2021-08-20T07:48:18.000Z","categories_index":"Qt作品集","tags_index":"Qt","author_index":"阿木大叔"},{"id":"1054abf09256abccd528b56b6b5c666f","title":"Qt模仿企业微信界面","content":"WeCom_copy📚简介本项目为Qt实现企业微信界面项目，纯界面逻辑，不包含真实业务逻辑。主要用于学习QWidget的使用，包含绘制，布局，信号，事件，重写，多线程，qss等技术使用。\n\n💾体验程序\n安装包地址\n\n📦软件架构\nQt 5.9 + msvc 2015\nWindows(x32, x64)&#x2F;Linux(x32, x64)\n\n🛠️主要技术\n\n\n模块\n介绍\n\n\n\nqss\n样式表，本程序所有窗体、控件的样式都由qss设计\n\n\nsignal\\slot\n控件、窗体间通信，事件处理\n\n\nQThread\n异步处理\n\n\nQNetworkAccessManager\n网络请求，主要用于聊天机器人及实时天气获取\n\n\nQPainter\n部分窗口的绘制，例如实时天气界面\n\n\niconfont\n阿里巴巴矢量图标库，主要用于按钮及标签上图标等显示\n\n\nwebenginewidgets\n实现嵌入html，主要用于聊天界面\n\n\nwebchannel\n和js进行通信，用于聊天界面交互\n\n\n🗺️软件截图导航\n基础框架\n用户详情\n好友列表\n模拟登录\n聊天对话框\n聊天界面\n智能机器人\n天气预报\n自绘时钟\niconfont图标展示\n逗逗猫（小猫眼睛随着鼠标位置转动）\n组件通知提醒框\n气泡确认框\n滑动输入条\n动态主页\nECharts表格\n轮播图\n背景音乐(别撸代码了，听听歌吧)\n📝参考网址📗qt官网📘QTCN开发网📙飞扬青春📙ECharts📌CSDN🎉欢迎关注CSDN🧡Star如果你觉得项目用来学习不错，可以给项目点点star，谢谢。","slug":"Qt/作品展/Qt模仿企业微信界面","date":"2021-08-20T07:26:42.000Z","categories_index":"作品展示","tags_index":"Qt,C/C++","author_index":"阿木大叔"},{"id":"58073f8af9c920179ae6420234803ea8","title":"VUE3学习文档","content":"vue3学习文档➡️ 创建项目安装\nnpm install @vue&#x2F;cli -g\n\n新建项目\n选择vue3，自动进行新建项目\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; vue create webui  Vue CLI v4.5.13? Please pick a preset:  Default ([Vue 2] babel, eslint)&gt; Default (Vue 3) ([Vue 3] babel, eslint)   Manually select features      Vue CLI v4.5.13? Please pick a preset: Default (Vue 3) ([Vue 3] babel, eslint)    Vue CLI v4.5.13✨  Creating project in E:\\code\\workspace\\vue\\webui.🗃  Initializing git repository...⚙️  Installing CLI plugins. This might take a while...    &gt; yorkie@2.0.0 install E:\\code\\workspace\\vue\\webui\\node_modules\\yorkie&gt; node bin/install.js  setting up Git hooksdone  &gt; core-js@3.16.1 postinstall E:\\code\\workspace\\vue\\webui\\node_modules\\core-js&gt; node -e &quot;try&#123;require(&#x27;./postinstall&#x27;)&#125;catch(e)&#123;&#125;&quot;    &gt; ejs@2.7.4 postinstall E:\\code\\workspace\\vue\\webui\\node_modules\\ejs&gt; node ./postinstall.js  added 1258 packages from 656 contributors in 77.87s  81 packages are looking for funding  run `npm fund` for details  🚀  Invoking generators...📦  Installing additional dependencies...  added 80 packages from 86 contributors in 11.181s  88 packages are looking for funding  run `npm fund` for details  ⚓  Running completion hooks...  📄  Generating README.md...  🎉  Successfully created project webui.👉  Get started with the following commands:   $ cd webui $ npm run serve\n\n默认目录结构\n123456webui├─node_modules          // npm 加载的项目依赖模块├─public                // 公共资源目录└─src                   // 源码目录    ├─assets            // 资源目录    └─components        // 组件目录\n\npublic 和 assets 目录的主要区别是，public在打包后文件内容不会有任何改变(除了index.html，index.html会自动添加打包后需要引用的js，css等)，assets打包后会进行压缩，改名等。\n\n\n\n目录&#x2F;文件\n说明\n\n\n\nbuild\n项目构建(webpack)相关代码\n\n\nconfig\n配置目录，包括端口号等。我们初学可以使用默认的。\n\n\nnode_modules\nnpm 加载的项目依赖模块\n\n\nsrc\n这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：\n\n\nsrc&#x2F;assets\n放置一些图片，如logo等。\n\n\nsrc&#x2F;components\n目录里面放了一个组件文件，可以不用。\n\n\nsrc&#x2F;App.vue\n项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。\n\n\nsrc&#x2F;main.js\n项目的核心文件。\n\n\nindex.html\n首页入口文件，你可以添加一些 meta 信息啥的。\n\n\npackage.json\n项目配置文件。\n\n\n运行项目\ncd webuinpm run serve     &#x2F;&#x2F; 启动本地服务\n\n12345678910DONE  Compiled successfully in 11104ms 上午10:13:47  App running at: - Local:   http://localhost:8080/  - Network: unavailable  Note that the development build is not optimized. To create a production build, run npm run build. \n浏览器打开即可浏览网页。\n\n代码流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119Error: mermaid CLI is required to be installed.Check https://github.com/mermaid-js/mermaid.cli for more information.Error: Command failed: npx mmdc --theme default --input C:\\Users\\hudejie\\AppData\\Local\\Temp\\mume-mermaid2021713-8352-15nb1ty.drifi.mmd --output E:\\code\\doc\\assets\\5110930a681e95ebf71f91187936d3440.pngnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmjs.com/mmdc - Not foundnpm ERR! 404 npm ERR! 404  &#x27;mmdc@latest&#x27; is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404 npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     C:\\Users\\hudejie\\AppData\\Roaming\\npm-cache\\_logs\\2021-08-13T05_40_51_671Z-debug.logInstall for [ &#x27;mmdc@latest&#x27; ] failed with code 1```    ---------------------------------------------  ##  ➡️ 新建页面    ###  创建文件  - 在src下创建views目录- views下创建login.vue文件  ```html&lt;template&gt;    &lt;div class=&quot;login&quot;&gt;        &lt;div id=&quot;loginDiv&quot;&gt;            &lt;form action=&quot;&quot; id=&quot;form&quot;&gt;                &lt;h1 style=&quot;text-align: center;color: aliceblue;&quot;&gt;LOGIN IN&lt;/h1&gt;                &lt;div&gt;username:&lt;input id=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt;                &lt;div style=&quot;margin-top: 5px;&quot;&gt;password:&lt;input id=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt;                  &lt;div style=&quot;text-align: center;margin-top: 30px;&quot;&gt;                    &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt;                    &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;                &lt;/div&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;  &lt;script&gt;    export default &#123;        name: &quot;&quot;,        setup() &#123;            return &#123;              &#125;        &#125;,    &#125;&lt;/script&gt;  &lt;style scoped&gt;    * &#123;        margin: 0;        padding: 0;    &#125;      .login &#123;        background-size: cover;        display: flex;        justify-content: center;        align-items: center;        height: 100%;        background-image: linear-gradient(to right, #EBDFDB, #EBE9D9);    &#125;      #loginDiv &#123;        width: 37%;        display: flex;        justify-content: center;        align-items: center;        height: 300px;        background-color: rgba(75, 81, 95, 0.3);        box-shadow: 7px 7px 17px rgba(52, 56, 66, 0.5);        border-radius: 5px;    &#125;      #name_trip &#123;        margin-left: 50px;        color: red;    &#125;      p &#123;        margin-top: 30px;        margin-left: 20px;        color: azure;    &#125;      input &#123;        margin-left: 15px;        border-radius: 5px;        border-style: hidden;        height: 30px;        width: 140px;        background-color: rgba(216, 191, 216, 0.5);        outline: none;        color: #f0edf3;        padding-left: 10px;    &#125;      .button &#123;        border-color: cornsilk;        background-color: rgba(100, 149, 237, .7);        color: aliceblue;        border-style: hidden;        border-radius: 5px;        width: 100px;        height: 31px;        font-size: 16px;    &#125;&lt;/style&gt;\n显示页面\n将HelloWorld替换为Login界面1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;  &lt;Login/&gt;&lt;/template&gt;  &lt;script&gt;//import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;import Login from &#x27;./views/login.vue&#x27;  export default &#123;  name: &#x27;App&#x27;,  components: &#123;    Login  &#125;&#125;&lt;/script&gt;  &lt;style&gt;  html,  body &#123;    width: 100%;    height: 100%;    padding: 0;    margin: 0;    overflow: hidden;    font-family: Avenir, Helvetica, Arial, sans-serif;  &#125;    #app &#123;    width: 100%;    height: 100%;    font-family: Avenir, Helvetica, Arial, sans-serif;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;    text-align: center;    color: #2c3e50;  &#125;&lt;/style&gt;  \n\n显示效果\n  ➡️ vue-router使用简介\n\n嵌套的路由&#x2F;视图表\n模块化的、基于组件的路由配置\n路由参数、查询、通配符\n基于 Vue.js 过渡系统的视图过渡效果\n细粒度的导航控制\n带有自动激活的 CSS class 的链接\nHTML5 历史模式或 hash 模式，在 IE9 中自动降级\n自定义的滚动条行为\n\n\n安装\nnpm install –save vue-router@next\n\n创建router\n新建src&#x2F;router目录\n新建index.js文件\n文件内容如下\n\n12345678910111213141516171819202122232425262728293031323334353637383940import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;;import Login from &quot;../views/Login.vue&quot;;import HelloWorld from &quot;../components/HelloWorld.vue&quot;;  // 路由表const routes = [    &#123;        path: &quot;/&quot;,        name: &quot;Home&quot;,        component: HelloWorld,    &#125;,    &#123;        path: &quot;/login&quot;,        name: &quot;Login&quot;,        meta: &#123;            title: &#x27;登录&#x27;        &#125;,        component: Login,    &#125;]  // 创建路由const router = createRouter(&#123;    history: createWebHashHistory(),    routes&#125;);  // 路由拦截// router.beforeEach((to, from, next) =&gt; &#123;//     const role = localStorage.getItem(&#x27;username&#x27;);           // 从localStorage获取用户名//     console.log(role);//     if (!role &amp;&amp; to.path !== &#x27;/login&#x27;) &#123;                      // 如果用户名不存在，并且路由条状非login时，直接跳转login//         next(&#x27;/login&#x27;);//     &#125; else &#123;//         next();//     &#125;// &#125;);  export default router;  \n上述代码大概含义:- 创建两条路由，分别指向HelloWorld，Login界面。- 创建路由对象- 路由拦截：当localStorage中不存在用户名时，认为未登录，所有链接都跳转到Login界面,暂时去掉###  引入router- 修改main.js如下，是app是用我们创建的路由12345678import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;                               // 引入路由配置  const app = createApp(App)  app.use(router)                 // 载入路由配置    .mount(&#x27;#app&#x27;)- 修改main.js如下，app使用我们创建的路由###  显示路由页面- 修改App.vue中html块如下123&lt;template&gt;  &lt;router-view /&gt;&lt;/template&gt;此时界面就会显示当前路由对应界面- 在浏览器中输入http://localhost:8080/ 展示的是HelloWord中内容- 在浏览器中输入http://localhost:8080/#/login/ 展示的是Login中内容###  路由跳转- 在HelloWord.vue中增加跳转连接1&lt;router-link to=&quot;/login&quot;&gt;Go to Login&lt;/router-link&gt;点击页面Go to Login标签即可跳转到登录界面。\n  ➡️ vue3使用i18n简介\n在信息技术领域，国际化与本地化（英文：internationalization and localization）是指修改软件使之能适应目标市场的语言、地区差异以及技术需要。国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。本地化则是指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。国际化和本地化之间的区别虽然微妙，但却很重要。国际化意味着产品有适用于任何地方的“潜力”；本地化则是为了更适合于“特定”地方的使用，而另外增添的特色。用一项产品来说，国际化只需做一次，但本地化则要针对不同的区域各做一次。这两者之间是互补的，并且两者合起来才能让一个系统适用于各地 [1]  。基于他们的英文单字长度过长，常被分别简称成i18n（18意味着在“internationalization”这个单字中，i和n之间有18个字母）及L10n。使用大写的L以利区分i18n中的i和易于分辨小写l与1。\n\n安装\nnpm install i18n –save\n\n使用步骤1、创建I18n12345678import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;    const i18n = createI18n(&#123;  locale: localeZH.name,            // 默认中文  fallbackLocale: localeEN.name,    // 中文不存在时，显示英文  messages,                         // 自定义语言包&#125;)  \n2、创建自定义语言包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default &#123;    &#x27;zh-cn&#x27;: &#123;        main: &#123;            prjname:&#x27;后台管理系统&#x27;,            breadcrumb: &#x27;国际化产品&#x27;,            tips: &#x27;通过切换语言按钮，来改变当前内容的语言。&#x27;,            btn: &#x27;切换英文&#x27;,            title1: &#x27;常用用法&#x27;,            p1: &#x27;要是你把你的秘密告诉了风，那就别怪风把它带给树。&#x27;,            p2: &#x27;没有什么比信念更能支撑我们度过艰难的时光了。&#x27;,            p3: &#x27;只要能把自己的事做好，并让自己快乐，你就领先于大多数人了。&#x27;        &#125;,        siderbar: &#123;            dashboard:&#x27;系统首页&#x27;,            table:&#x27;基础表格&#x27;,            tabs:&#x27;tab选项卡&#x27;,            froms:&#x27;表单相关&#x27;,            icon:&#x27;自定义图标&#x27;,            charts:&#x27;schart图表&#x27;,            i18n:&#x27;国际化功能&#x27;,            error:&#x27;错误处理&#x27;,            framestyle:&#x27;画面风格&#x27;,            iconfont:&#x27;iconfont&#x27;,            donate:&#x27;支持作者&#x27;,        &#125;    &#125;,    &#x27;en&#x27;: &#123;        main:&#123;            prjname:&#x27;Management System&#x27;,            breadcrumb: &#x27;International Products&#x27;,            tips: &#x27;Click on the button to change the current language. &#x27;,            btn: &#x27;Switch Chinese&#x27;,            title1: &#x27;Common usage&#x27;,            p1: &quot;If you reveal your secrets to the wind you should not blame the wind for  revealing them to the trees.&quot;,            p2: &quot;Nothing can help us endure dark times better than our faith. &quot;,            p3: &quot;If you can do what you do best and be happy, you&#x27;re further along in life  than most people.&quot;        &#125;,        siderbar: &#123;            dashboard:&#x27;dashboard&#x27;,            table:&#x27;table&#x27;,            tabs:&#x27;tabs&#x27;,            froms:&#x27;froms&#x27;,            icon:&#x27;icon&#x27;,            charts:&#x27;charts&#x27;,            i18n:&#x27;i18n&#x27;,            error:&#x27;error&#x27;,            framestyle:&#x27;framestyle&#x27;,            iconfont:&#x27;iconfont&#x27;,            donate:&#x27;donate&#x27;,        &#125;,    &#125;&#125;\n如上，创建了两个语言包，分别为zh-cn，en.####  3、使用语言1&lt;div class=&quot;logo&quot;&gt;&#123;&#123;$t(&#x27;main.prjname&#x27;)&#125;&#125;&lt;/div&gt;此时就用到语言包中main.prjnam标签####  4、切换语言#####  4.1、html12345&lt;el-button    type=&quot;primary&quot;    @click=&quot;$i18n.locale = $i18n.locale === &#x27;zh-cn&#x27;?&#x27;en&#x27;:&#x27;zh-cn&#x27;;&quot;&gt;    切换语言    &lt;/el-button&gt;#####  4.2、js1234567import &#123; getCurrentInstance &#125; from &quot;vue&quot;;const &#123; proxy &#125; = getCurrentInstance();  const handleLangCommand = (command) =&gt; &#123;    proxy.$i18n.locale = command;  // command:zh-cn 或 en    console.log(proxy);&#125;;\n  \n  \n  ➡️ vue3+element-ui使用iconfont创建图标项目\n登录官网 \nhttps://www.iconfont.cn\n\n\n创建项目\n注意前缀请使用el-icon-开头，font-family可随意,因为element-ui中对图标样式控制采用el-icon开头，这样可以和element-ui中图标保持相同样式\n\n123456789101112131415element-ui css 源码[class*=&quot; el-icon-&quot;],[class^=el-icon-] &#123;\tfont-family: element-icons!important;\tspeak: none;\tfont-style: normal;\tfont-weight: 400;\tfont-variant: normal;\ttext-transform: none;\tline-height: 1;\tvertical-align: baseline;\tdisplay: inline-block;\t-webkit-font-smoothing: antialiased;\t-moz-osx-font-smoothing: grayscale    ...&#125;\n\n勾选Base64\n生成在线链接，也可下载下来本地使用\n\n引入iconfont图标\n在index.html中加入如下链接，链接地址换成自己项目地址1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://at.alicdn.com/t/font_2720579_wc4x6y2ql9.css&quot;&gt;\n新建iconfont.css（文件名随意），添加如下内容，指定样式为el-icon-edge开头的元素采用el-icon-edge-iconfon字符集 1234[class*=&quot; el-icon-edge&quot;],[class^=el-icon-edge] &#123;    font-family: el-icon-edge-iconfont !important;&#125;\nmain.js中引用上述iconfont.css文件\n\n实际使用\n实际使用和element-ui中图标方式一致，如下1&lt;i class=&quot;el-icon-edgechanrongxietong&quot;&gt;&lt;/i&gt;\n\n\n\n➡️ vue3+element-ui使用Animate.css简介\nanimate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn&#x2F;rotateOut）、淡入淡出（fadeIn&#x2F;fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。\n虽然借助 animate.css 能够很方便、快速的制作 CSS3 动画效果，但还是建议看看 animate.css 的代码，也许你能从中学到一些东西。\n\n兼容\n浏览器兼容：当然是只兼容支持 CSS3 animate 属性的浏览器，他们分别是：IE10+、Firefox、Chrome、Opera、Safari。\n\n使用方法1、引入文件\n123456&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt;  或者cdn方式引用 &lt;link rel=&quot;stylesheet&quot;       href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css&quot;&gt;\n\n2、使用动画2.1、结合transition使用动画 12345&lt;transition enter-active-class=&quot;animated bounceInDown&quot;             leave-active-class=&quot;animated bounceOutDown&quot;             :duration=&quot;200&quot;&gt;&lt;!--入场和离场的时间--&gt;            &lt;div&gt; 测试 &lt;/div&gt;&lt;/transition&gt;\n\n说明：结合transition标签可以设置元素入场和离场动画\n\n2.2、直接使用 123&lt;el-card class=&quot;animated bounceIn&quot; shadow=&quot;hover&quot;&gt;    &lt;schart ref=&quot;bar&quot; class=&quot;schart&quot; canvasId=&quot;bar&quot; :options=&quot;options&quot;&gt;&lt;/schart&gt;&lt;/el-card&gt;\n\n➡️ 全屏组件screenfull安装\nnpm install screenfull –save\n\n使用步骤1、引入文件1import screenfull from &#x27;screenfull&#x27;;\n2、使用2.1、整个页面全屏 12345678910111213141516// 全屏点击时const onScreenfullClick = () =&gt; &#123;    if (!screenfull.isEnabled) &#123;        ElMessage.warning(&#x27;暂不不支持全屏&#x27;);        return false;    &#125;      screenfull.toggle();        // 触发全屏切换，即在全屏与非全屏状态切换    screenfull.on(&#x27;change&#x27;, () =&gt; &#123;        // 响应全屏状态，可根据此状态，更换按钮图标等操作        if (screenfull.isFullscreen)             state.isScreenfull = true;             else             state.isScreenfull = false;    &#125;);&#125;;\n2.2、单个元素全屏 123456789&lt;div class=&quot;text&quot;  @dblclick=&quot;FuncDbClick($event)&quot;&gt;    &lt;el-image style=&quot;width: 100%;height:100%;&quot; src=&quot;../src/assets/img/camera.png&quot; :fit=&quot;fit&quot;&gt;    &lt;/el-image&gt;&lt;/div&gt;  const FuncDbClick = (event) =&gt; &#123;    state.bSignalFull ? screenfull.exit() : screenfull.request(event.currentTarget);    state.bSignalFull = !state.bSignalFull;&#125;;\n\n双击全屏及退出全屏\n\n\n➡️ vue3知识图谱学前了解###  基础知识###  组件相关语法###  高级语法###  配套工具\n  ","slug":"WEB/vue3学习文档","date":"2021-08-18T06:34:47.000Z","categories_index":"前端框架","tags_index":"vue","author_index":"阿木大叔"},{"id":"799e4e62b5b5376eafc0cedc9d50e8a4","title":"Qt面试题集合","content":"\nQt 中常用的五大模块是哪些？\n\nQt 中常用的五大模块包括：\n\nQtCore：提供了 Qt 的核心功能，例如基本的非 GUI 类、线程和事件处理等。\n\nQtGui：提供用户界面（UI）类，例如窗口部件、按钮、标签等。此外，它还包含 QPainter 和 QPalette 等绘图和调色板类。\n\nQtWidgets：是 QtGui 模块的子集，提供了一套完整的可视化 UI 控件库，例如按钮、文本编辑器、表格等，用于构建跨平台的桌面应用程序。\n\nQtNetwork：提供网络编程类，用于创建 TCP 和 UDP 客户端和服务器，以及处理套接字和 HTTP 请求。\n\nQtSql：提供简单易用的数据库访问 API，用于在 Qt 中连接、查询和操作数据源中的数据。\n\n\n\n什么是信号和机制？如何使用信号和实现对象间通信？\n\n信号和槽是 Qt 框架中用于对象间通信的机制。信号是一种特殊类型的函数，用于发出通知对象已经发生了某个事件。而是接收信号的函数，当一个信号触发时，与之相连接的将被自动调用。这样可以实现对象间的解耦和灵活的事件处理流程。\n使用信号和机制可以在一个对象内部或之间实现异步编程，也可以帮助开发者解耦不同组件、模块的代码，提高系统的可维护性和扩展性。\n\n如何创建自定义信号？\n\n您可以使用关键字 signals 在 QObject 类中声明自定义信号。例如：\n1234567class MyObject : public QObject&#123;    Q_OBJECTsignals:    void mySignal();&#125;;\n\n这里，我们在类中声明了自定义 signal“mySignal”。您可以选择不写任何参数，这意味着它是一个简单的通知信号。\n要触发信号，请使用类似 emit mySignal() 的语法。例如：\n12345void MyClass::someFunction()&#123;    // do something ...    emit mySignal();&#125;\n\n\n在 Qt 中，为何不建议作 UI 控件并修改其属性值？\n\n在 Qt 中，建议将 UI 控件（例如按钮、标签等）视为视图层控制器（View-Controller），而将业务逻辑部分分离出来，确保应用程序的低耦合性。因此，在 UI 控件中处理业务逻辑和直接更改属性值可能会导致难以维护代码、多余的重复代码以及不便于文件结构优化等一系列问题。\n相反，通过将业务逻辑分离出来，您可以更好地管理和测试代码，并保持代码的清晰度。通过连接信号和槽来实现对界面控件的修改。\n\nQPainter 是什么？它用于哪些场景？\n\nQPainter 是 Qt 的绘图引擎，用于绘制各种图形元素和渲染文本。 它提供了很多常用的函数，例如画矩形、画圆等可以绘制基本图形。它还包含设置画笔宽度、颜色和样式、字体，渐变、图案、透明度的功能等，使用户可以使用相对简单的步骤呈现出复杂的效果。 \nQPainter 在 GUI 应用程序中特别有用。 通过使用 QPainter，您可以在窗口或其他部件上实现自定义的渲染，并创建自己的图标、图表和数据可视化工具，增强应用程序的用户体验。\n\nQt 中有哪些类型的定时器？它们之间有何区别？\n\nQt 中有以下两种类型的定时器：\n\nQTimer：是一个通用的、基于事件的定时器，用于在指定时间间隔后触发 timeOut() 信号。\n\nQBasicTimer：是用于更高级别的定时操作的辅助类。它允许对象创建一个内部计时器，并使用 timerEvent() 函数处理超时事件。\n\n\n两者均支持逐个次数触发或重复触发方法，但 QBasicTimer 可自行管理其内部定时器，这使得它更适合于需要细粒度的定时器操作。\n\nQThread 和 QtConcurrent 之间有何区别？您在项目中使用哪种方式来处理多线程？\n\nQThread 是 Qt 中的一个基础类，用于在应用程序中建立新的线程。使用 QThread，可以创建一个新线程并将特定任务放在该线程中执行，从而使主线程不会被阻塞。但是，需要注意的是，直接使用 QThread 时有时候存在一些难以解决的问题，例如内存泄漏和跨线程处理信号时可能会遇到问题等。\nQtConcurrent 则是一个高级别 API，提供了许多方便加载和管理线程的函数。通过使用 QtConcurrent，您可以轻松地编写并行代码，并使用 map-reduce 模式执行算法。它更易于使用和管理，但灵活性较低。\n关于在项目中使用哪种方式来处理多线程，这取决于具体情况。如果需要更细粒度的控制，例如需要在程序级别控制线程、给线程分配优先级和分离下属线程等操作，则应使用 QThread。如果需要的仅仅是一个简单的后台线程，执行IO密集型代码或者大量简单的计算，可以使用 QtConcurrent。\n\nQt 提供了哪些用于格式化字符和字符串的类和函数？它们之间有何区别？\n\nQt 提供了很多能够格式化字符和字符串的类和函数，其中包括：\n\nQString：它是 Qt 中最常用的字符串类，支持 Unicode 和本地化字符、支持格式化；\n\nQTextStream：它可以使用 &lt;&lt; 运算符向流中添加数据，并自动进行字符串转换和缓冲处理；\n\nQLocale：提供与语言环境相关的功能，例如日期和数字格式化；\n\nQVariant：是一个通用的值类，可在特定格式和类型之间进行转换。\n\n\n这些类和函数在处理不同场景时，各自拥有它们的优点。 QString 提供了一般性字符串处理功能； QTextStream 尤其擅长于处理文件I&#x2F;O操作； QLocale 显然适用于需要国际化的字符串操作等等。选择合适的工具将会使应用程序的效率和准确性得到提高。\n\nQObject 为何禁止拷贝构造函数和拷贝赋值运符？\n\nQObject 实例通常被视为对象树的节点，也就是说，它们被分层组合在一起，形成了一个层次结构。这个层次结构中，每个 QObject 实例都有一个父对象（除了顶级的 QObject 对象），并且当父对象删除时，所有子对象也会自动删除。\n如果允许 QObject 实例的拷贝构造函数，则可能导致某些问题，例如：\n\n多个实例引用同一对象，无法确定哪个对象是“正确”的。\n\n在复制一个 QObject 实例时，我们无法确定该对象在哪个树中，该对象的父指针不正确。\n\n如果新创建的对象没有进行正确的注册，可能会导致该对象在销毁时出现错误和内存泄漏。\n\n\n因此，QObject 禁止拷贝构造函数和拷贝赋值运算符，以确保程序员不会意外地触发上述问题，在开发期间更好地进行管理。\n如果需要复制 QObject 对象，可以使用 QObject 的 clone() 函数或者其他自定义函数实现深度克隆操作，并确保处理所有子对象的引用和指针。\n\n如何在 Qt 中处理文件和目录操作？Qt 中有哪些类和函数可用于读取和写入文件？\n\n在 Qt 中，你可以使用 QFile 类来读取和写入文件。对于文件目录操作，QDir 类是一个有用的课程。您可以使用 QDir 来遍历目录、过滤和排序文件、获取有关文件&#x2F;目录信息、创建和移动文件等等。\n以下是一些常见的 Qt 文件和目录操作函数：\n\nQFile::open() - 打开文件并返回文件句柄；\n\nQFile::readAll() - 读取整个文件并返回其内容的 QByteArray；\n\nQFile::write() - 写数据到打开的文件上；\n\nQDir::setCurrent() - 设置所以绝对路径基录；\n\nQDir::exists() - 检查目录或文件是否存在；\n\nQDir::mkpath() - 递归创建新目录。\n\n\n\n在 Qt 中如何进行数据库操作？Qt 中有哪些类和函数可用于连接数据库、执行查询和更新数据？\n\nQt 提供了 QtSql模块，用于在 Qt 应用程序中进行数据库操作。它支持多种主流的数据库引擎，例如 SQLite、MySQL、PostgreSQL 和 Oracle。以下是一些常见的 QtSql 类和函数：\n\nQSqlDatabase：用于连接到一个特定的数据库引擎，并返回一个数据库对象；\n\nQSqlQuery：用于执行 SQL 查询，并提供对结果集的访问；\n\nQSqlTableModel： 提供了一个 model-view 接口，使用与数据库表的记录对应的模型数据；\n\nQSqlRelationalTableModel：QSqlTableModel的子类，支持多个表之间的关联。\n\n\n使用 QtSql 进行数据库操作的一般步骤如下：\n\n选择要使用的数据库引擎，例如 SQLite，MySQL 或 PostgreSQL。如果您不确定应该选择哪种引擎，请参阅各自的优缺点。\n\n创建并打开一个数据库连接（QSqlDatabase）。\n\n执行 SQL 查询或操作数据。这通常涉及使用 QSqlQuery 对象。\n\n处理查询结果。\n\n关闭数据库连接。\n\n\n注意：在编写 QtSql 代码时，您需要考虑多线程问题和 SQL 注入攻击等安全问题。可以使用 prepare() 和 bindValue() 等 QSqlQuery 函数来减轻 SQL 注入攻击问题。同时也建议在单独的线程中执行数据库操作，以保持高性能和更好的线程安全性。\n\nQML 和 Qt Widgets 之间有何区别？\n\nQML 和 Qt Widgets 都是 Qt 支持的 UI 开发框架，但二者有很大的不同：\n\n编写语言：Qt Widgets 使用 C++ 来编写 UI 界面，而QML 基于 JavaScript、XML和基础 HTML&#x2F;CSS。\n\n技术：Qt Widgets 是通过 QWidget 和 QML （通过 Qt Quick 的 QQuickItem 派生得来）将元素组合起来的。 Qt Widgets 采用的是固定坐标的方式布局，而 QML 使用基于着色器的引擎，能够支持应变性和动态排列。\n\n视觉风格：Qt Widgets 提供了一套独立于平台的 widget 库，并与平台的原生视觉风格类似。QML 具有灵活的主题、模板和皮肤功能，可以创建适合自定义品牌的完全可Personalized的用户界面。\n\n性能：QML 的渲染性能优于传统的 Qt Widgets，在处理复杂的 2D 和 3D 呈现任务时效果显著。\n\n\n选择使用哪种框架依赖于您的需求和特定情况。Qt Widgets适用于对控件的位置、大小和其他属性方面更为关注，而 QML 正好相反；如果您需要自定义自己的 CSS 或 JS，或者需要实现复杂的动画&#x2F; 2D&#x2F;3D 渲染等，则建议使用 QML。\n\n在 Qt 中，如何处理用户界面元素的事件？具体来说，如何处理按钮的单击事件？\n\n在 Qt 中，您可以通过信号和插机制来处理 UI 元素的事件。主要步骤如下：\n\n为 UI 元素定义信号。例如，QPushButton 的 clicked() 信号表示按钮已经单击。\n\n为 UI 元素连接插槽函数。插槽函数是事件发生时要调用的函数。\n\n编写插槽函数以响应信号。例如，clicked() 发生时执行的插槽函数可以是一个简单的计算或者启动其他操作。\n\n\n下面是 QPushButton 处理单击事件的示例代码：\n在 Header 文件中声明：\n12public slots:    void onBtnClicked();\n\n在实现文件中实现：\n1234void MyWidget::onBtnClicked()&#123;   // 按钮已被单击&#125;\n\n在构造函数中设置连接：\n1QObject::connect(ui-&gt;myButton, SIGNAL(clicked()), this, SLOT(onBtnClicked()));\n\n这里，ui-&gt;myButton 是在 .ui 文件中定义的 QPushButton 对象，SIGNAL(clicked()) 表示当点击按钮时，clicked() 信号将被发射。如果使用新语法，则需要使用 QObject::connect() 而不是上面的旧语法。\n\n如何使用 QML 创建自定义组件？\n\n在 QML 中，您可以使用 Component 来创建自定义组件。Component 是一种特殊类型的对象，可以被实例化并作为 QML 的一部分进行使用。要创建 Component，可以使用一个独立的文件，或者在同一个文件中定义多个组件。\n以下定义组件的示例代码：\n123456789101112131415161718192021// MyButton.qmlimport QtQuick 2.0Rectangle &#123;    id: root    width: 100; height: 50    color: &quot;red&quot;    radius: 10    signal clicked()    Text &#123;        anchors.centerIn: parent        text: &quot;Click me!&quot;    &#125;    MouseArea &#123;        anchors.fill: parent        onClicked: root.clicked()    &#125;&#125;\n\n在这里，我们定义了一个名为 MyButton 的自定义组件。该组件包含一个红色的圆角矩形、文本和一个 MouseArea。MouseArea 接收单击事件，并发射一个 clicked() 信号，表示按钮已被单击。下一步，我们需要将此组件实例化并作为 QML 的一部分进行使用。\n您可以在主 QML 文件中添加以下代码来实例化 MyButton 组件：\n123456789101112// main.qmlimport QtQuick 2.0Rectangle &#123;    width: 360; height: 360    color: &quot;#333&quot;    MyButton &#123;        x: 130; y: 130        onClicked: console.log(&quot;Button clicked!&quot;)    &#125;&#125;\n\n在这里，我们在主 QML 文件中实例化了一个 MyButton 组件，并将其添加到了主界面上。MyButton被点击时，我们将控制台输出一条消息。\n\n如何在 Qt 中绘制图形？\n\n在 Qt 中，您可以使用 QPainter 类进行绘图，它提供了一组画图设备和元素，例如颜色、线宽和各种几何形状。以下是一个简单的示例，演示如何使用 QPainter 绘制一个正方形：\n12345678910111213void MyWidget::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing);    // 设置画笔和背景颜色    painter.setPen(Qt::white);    painter.setBrush(Qt::gray);    // 绘制正方形    QRectF rectangle(10.0, 20.0, 80.0, 60.0);    painter.drawRect(rectangle);&#125;\n\n要绘制其他图形，您需要设置不同的 QPainter 函数，例如 drawLine()、drawEllipse()、drawText() 等等。您还可以使用 QPainterPath 类来创建复杂的自定义图形路径。\n注意：Qt 在使用 QPainter 绘图时，可能会出现绘图问题和性能问题。如果您需要进行大量绘图操作或者处理复杂的图形，请考虑使用 OpenGL 或 Qt Quick 的 QML Canvas 等更高效的绘图技术。\n\n在 Qt 中，如何使用信号和插槽机制进行对象间通信？\n\n在 Qt 中，信和插槽是实现对象间通信的一种强大方式。每个 QObject 类型的对象都有一个 signals: 以及 slots: 部分。其中 signals: 包含了所需的信号定义，slots: 则包含了响应信号的插槽函数。\n以下是一个使用信号和插槽的简单示例，演示如何在两个对象之间传递数据：\n\n创建发送方类：\n\n123456789101112131415class Sender : public QObject&#123;    Q_OBJECTpublic:    // 定义一个 signal ，以 int 类型发送数据    void sendNumber(int number)    &#123;        emit numberSent(number);    &#125;signals:    // 声明一个发送 int 类型数据的 signal    void numberSent(int number);&#125;;\n\n\n创建接收方类：\n\n1234567891011class Receiver : public QObject&#123;    Q_OBJECTpublic slots:    // 定义一个接收 int 类型数据的 slot    void receiveNumber(int number)    &#123;        qDebug() &lt;&lt; &quot;Received number:&quot; &lt;&lt; number;    &#125;&#125;;\n\n\n连接信号和插槽：\n\n123456789// 创建实例（或使用现有实例）Sender sender;Receiver receiver;// 连接 Sender 的 numberSent(int) 信号到 Receiver 的 receiveNumber(int) 槽QObject::connect(&amp;sender, &amp;Sender::numberSent, &amp;receiver,Receiver::receiveNumber);// 发送数据sender.sendNumber(42); // receiver 将会输出 &quot;Received number: 42&quot;\n\n这里，Sender 类定义了一个发送 int 类型数据的 signal（numberSent），并向信号发射器发送该数值。Receiver 类定义了一个接收 int 类型数据的 slot（receiveNumber），并在其插槽函数中打印该数据。\n最后，我们将两个对象连接起来，当 Sender 类调用 sendNumber() 发送数字时，connect() 函数会将它连接到 Receiver 类的 receiveNumber() slot，从而实现了对象间的通信。\n\n在 Qt 中，如何处理网络请求？\n\n在 Qt 中，您可以使用 Qt Network 模块处理网络请求，并发送和接收各种协议的数据。以下是一个简单的示例，演示如何使用 Qt Network 模块发送 HTTP GET 请求：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;QCoreApplication&gt;#include &lt;QtNetwork/QNetworkAccessManager&gt;#include &lt;QtNetwork/QNetworkReply&gt;#include &lt;Network/QNetworkRequest&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个 QNetworkAccessManager 实例    QNetworkAccessManager manager;    // 实例化请求对象    QNetworkRequest request;    request.setUrl(QUrl(&quot;http://www.example.com&quot;));    // 发送 GET 请求    QNetworkReply *reply = manager.get(request);    // 声明处理数据完成的槽    QObject::connect(reply, &amp;QNetworkReply::finished, [&amp;]() &#123;        // 处理返回的数据        if (reply-&gt;error() == QNetworkReply::NoError) &#123;            QString data = QString(reply-&gt;readAll());            qDebug() &lt;&lt; data;        &#125;        else &#123;            qDebug() &lt;&lt; &quot;Network error:&quot; &lt;&lt; reply-&gt;errorString();        &#125;        // 释放资源        reply-&gt;deleteLater();        a.quit();    &#125;);    return a.exec();&#125;\n\n注意：在处理网络请求时，请将其放在单独的线程中，以避免阻塞主循环和可能的性能问题。可以使用 QThread 之类的 Qt 类来处理多线程请求。18. 在 Qt 中，如何使用数据库？\n在 Qt 中，您可以使用 QSqlDatabase 类连接和操作数据库。以下是一个简单的示例，演示如何使用 Qt 连接 SQLite 数据库：\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;QCoreApplication&gt;#include &lt;QtSql&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 在默认位置创建数据库连接    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);    db.setDatabaseName(&quot;myDb.db&quot;);    // 打开数据库后进行操作    if (db.open()) &#123;        QSqlQuery query;        // 建立表格        query.exec(&quot;CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT)&quot;);        // 插入数据        query.exec(&quot;INSERT INTO people VALUES(1, &#x27;Tom&#x27;)&quot;);        query.exec(&quot;INSERT INTO people VALUES(2, &#x27;Jerry&#x27;)&quot;);        // 查询        query.exec(&quot;SELECT id, name FROM people&quot;);        while (query.next()) &#123;            int id = query.value(0).toInt();            QString name = query.value(1).toString();            qDebug() &lt;&lt; &quot;ID:&quot; &lt;&lt; &lt;&lt; &quot; Name:&quot; &lt;&lt; name;        &#125;        // 关闭连接        db.close();    &#125;    else &#123;        qDebug() &lt;&lt; &quot;Failed to open database:&quot; &lt;&lt; db.lastError().text();    &#125;    return a.exec();&#125;\n\n注意：在使用 QSqlDatabase 类时，请确保安装了所需的驱动程序（例如，SQLite 需要 Qt 自带的 SQLite 驱动）。另外请注意，Database 使用大量的资源。当您不再需要它时，请记得关闭&#x2F;删除连接，以避免内存泄漏和性能问题。\n\n在 Qt 中，如何进行多语言支持？\n\n在 Qt 中，您可以使用 QTranslator 类实现应用程序的多语言支持。以下是一个简单的示例，演示如何将此功能添加到您的应用程序中：\n\n使用 Qt Linguist 创建翻译文件\n\n首先，您需要使用 Qt Linguist 工具创建翻译文件 (.ts)。这个文件包含了所有需要翻译的文本字符串和其对应的翻译。您可以使用 Qt Creator 编辑器的一部分来打开和编辑 .ts 文件，或者使用命令行工具 lupdate 和 linguist 来生成和编辑它们。\n\n加载翻译文件\n\n在应用程序代码中，您可以使用 QTranslator 类加载 .qm 翻译文件 （从 .ts 文件编译而得）。例如，下面是一个针对英文和西班牙文翻译支持的简单示例：\n123456789101112131415161718#include &lt;QCoreApplication&gt;#include &lt;QTranslator&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 加载翻译文件    QTranslator translator;    if (translator.load(&quot;myapp_es.qm&quot;)) &#123;        a.installTranslator(&amp;translator);    &#125;    // 执行其他操作    // ...    return a.exec();&#125;\n\n这里，我们加载名为 myapp_es.qm 的西班牙语翻译文件，并将它安装到应用程序中。然后，当显示文本字符串时，它们将自动翻译成相应的西班牙语文本。\n\n重新编译和部署\n\n最后，请记得重新编译您的应用程序，并将 .qm 文件部署到正确的位置，以便应用程序可以找到这个文件并使用它进行多语言支持。20. 在 Qt 中，如何进行文件和目录操作？\n在 Qt 中，您可以使用 QFile、QDir 和 QFileInfo 等类来进行文件和目录操作。以下是一些简单的示例：\n\n创建文件并写入数据\n\n1234567891011121314151617#include &lt;QCoreApplication&gt;#include &lt;QFile&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个名为 myFile.txt 的文本文件，并向其中写入数据    QFile file(&quot;myFile.txt&quot;);    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123;        QTextStream stream(&amp;file);        stream &lt;&lt; &quot;Hello world!&quot;;        file.close();    &#125;    return a.exec();&#125;\n\n这里，我们使用 QFile 类创建一个名为 myFile.txt 的文件，并向它写入 “Hello world!” 文本数据。最后，我们关闭文件以确保所有数据都被写入。\n\n读取文件数据\n\n#include #include \nint main(int argc, char *argv[]){    QCoreApplication a(argc, argv);\ntxt// 打开文件，并读取其中的数据\nQFile file(&quot;myFile.txt&quot;);\nif (file.open(QIODevice::ReadOnly | QIODevice::Text)) &#123;\n    QTextStream stream(&amp;file);\n    QString data = stream.readAll();\n    file.close();\n    qDebug() &lt;&lt; data; // 输出文件包含的数据\n&#125;\n\nreturn a.exec();}\n123456789101112131415161718这里，我们打开名为 myFile.txt 的文件，并使用 QTextStream 类从中读取所有数据。然后，我们将文件中包含的数据打印到控制台上以进行验证。3. 删除文件```cpp#include &lt;QCoreApplication&gt;#include &lt;QFile&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 删除名为 myFile.txt 的文件    QFile::remove(&quot;myFile.txt&quot;);    return a.exec();&#125;\n\n这里，我们使用 QFile 类的静态 remove() 函数删除名为 myFile.txt 的文件。您可以使用 rename() 函数来重命名文件，并使用 exists() 函数来查看文件是否存在。\n\n遍历目录\n\n1234567891011121314151617181920#include &lt;QCoreApplication&gt;#include &lt;QDir&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 遍历名为 myFolder 的目录，并列举其中所有子文件和子目录    QDir dir(&quot;myFolder&quot;);    for (const QFileInfo&amp; info : dir.entryInfoList()) &#123;        if (info.isDir()) &#123;            qDebug() &lt;&lt; &quot;Directory:&quot; &lt;&lt; info.fileName();        &#125;        else &#123;            qDebug() &lt;&lt; &quot;File:&quot; &lt;&lt; info.fileName();        &#125;    &#125;    return a.exec();&#125;\n\n这里，我们使用 QDir 类打开名为 myFolder 的目录，并使用 entryInfoList() 函数列举目录中的文件和子目录。然后，我们检查每个条目是否是目录或文件，并打印它们的名称到控制台上以进行验证。21. 在 Qt 中，如何进行线程操作？\n在 Qt 中，您可以使用 QThread 类和 QRunnable 接口执行多线程任务。以下是一些简单的示例：\n\n使用 QThread 执行任务\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;QCoreApplication&gt;#include &lt;QThread&gt;class MyWorker : public QObject &#123;    Q_OBJECTpublic slots:    void doWork() &#123;        qDebug() &lt;&lt; &quot;Worker thread ID:&quot; &lt;&lt; QThread::currentThread();        // 执行其他操作        // ...        emit workFinished();    &#125;signals:    void workFinished();&#125;;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个新线程    QThread* thread = new QThread;    // 创建工作对象，并将其移动到新线程中    MyWorker* worker = new MyWorker;    worker-&gt;moveToThread(thread);    // 连接信号和槽以启动工作线程    QObject::connect(thread, &amp;QThread::started, worker, &amp;MyWorker::doWork);    QObject::connect(worker, &amp;MyWorker::workFinished, thread, &amp;QThread::quit);    QObject::connect(worker, &amp;MyWorker::workFinished, worker, &amp;MyWorker::deleteLater);    QObject::connect(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);    // 启动线程    thread-&gt;start();    return a.exec();&#125;\n\n这里，我们创建了一个名为 MyWorker 的工作类，该类实现了一个槽函数 doWork() 来执行工作任务。然后，我们创建了一个 QThread 实例，并将 MyWorker 移动到这个 QThread 实例的线程中。\n接下来，我们将 QThread::started 信号连接到 MyWorker::doWork ，以启动工作线程。当工作完成时，MyWorker 会发射 workFinished 信号，并将其连接到 QThread::quit 以停止工作线程。最后，我们在 QThread::finished 信号上将 QThread 实例和 MyWorker 实例删除。\n\n使用 QRunnable 执行任务\n\n1234567891011121314151617181920212223#include &lt;QCoreApplication&gt;#include &lt;QThread&gt;#include &lt;QThreadPool&gt;class MyTask : public QRunnable &#123;public:    void run() override &#123;        qDebug() &lt;&lt; &quot;Task thread ID:&quot; &lt;&lt; QThread::currentThread();        // 执行其他操作        // ...    &#125;&#125;;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个新任务并执行    MyTask* task = new MyTask;    QThreadPool::globalInstance()-&gt;start(task);    return a.exec();&#125;\n\n这里，我们创建了一个名为 MyTask 的任务，该任务实现了 QRunnable 接口。然后，我们创建了 MyTask 实例，并使用 QThreadPool::globalInstance()-&gt;start() 函数将其提交到全局线程池中以异步执行。\n注意：如果您想控制线程池的行为，可以使用 QThreadPool 类的其他函数。例如，setMaxThreadCount() 函数可用于设置最大线程数，releaseThread() 函数可释放空闲的线程资源，等等。22. 在 Qt 中，如何进行网络编程？\n在 Qt 中，您可以使用 QTcpServer、QTcpSocket、QUdpSocket 和 QSslSocket 等类来进行网络编程。以下是一些简单的示例：\n\nTCP 服务器\n\n1234567891011121314151617181920212223242526272829303132#include &lt;QCoreApplication&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个 TCP 服务器    QTcpServer server;    // 绑定服务器到本机地址和端口    if (server.listen(QHostAddress::LocalHost, 12345)) &#123;        qDebug() &lt;&lt; &quot;Listening for incoming connections on port 12345...&quot;;        // 接受传入连接        while (server.isListening()) &#123;            QTcpSocket* client = server.nextPendingConnection();            qDebug() &lt;&lt; &quot;New client connected from:&quot; &lt;&lt; client-&gt;peerAddress() &lt;&lt; &quot;:&quot; &lt;&lt; client-&gt;peerPort();            // 向客户端发送欢迎消息            client-&gt;write(&quot;Welcome to my server!&quot;);            client-&gt;flush();            // 接收并显示来自客户端的消息            QByteArray data = client-&gt;readAll();            qDebug() &lt;&lt; &quot;Client message:&quot; &lt;&lt; data;        &#125;    &#125;    return a.exec();&#125;\n\n这里，我们创建了一个 TCP 服务器，并将其绑定到本机地址（127.0.0.1）和端口 12345。然后，我们使用 nextPendingConnection() 函数阻塞等待传入连接，并显示连接客户端的地址和端口。通过 client-&gt;write() 函数向客户发送欢迎消息，并使用 readAll() 函数接收并显示来自客户端的消息。您可以使用 QTcpSocket 类实现客户端。\n\nUDP 客户端\n\n123456789101112131415161718#include &lt;QCoreApplication&gt;#include &lt;QUdpSocket&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个 UDP 套接字    QUdpSocket socket;    // 向本地主机 12345 端口发送数据报    QByteArray data = &quot;Hello, world!&quot;;    QHostAddress addr(&quot;127.0.0.1&quot;);    quint16 port = 12345;    socket.writeDatagram(data, addr, port);    return a.exec();&#125;\n\n这里，我们创建了一个 QUdpSocket 实例，并使用 writeDatagram() 函数向本地主机（127.0.0.1）和端口 12345 发送 Hello, world! 数据报。您可以在另一个应用程序中使用 QUdpSocket 类以接收这个数据包或通过其他方式与它进行通信。\n\nSSL 客户端\n\n123456789101112131415161718192021222324252627282930#include &lt;QCoreApplication&gt;#include &lt;QSslSocket&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    // 创建一个 SSL 连接套接字    QSslSocket socket;    // 连接到 SSL 服务器    socket.connectToHostEncrypted(&quot;mysslserver.com&quot;, 443);    if (socket.waitForEncrypted()) &#123;        qDebug() &lt;&lt; &quot;SSL handshake successful.&quot;;        // 发送和接收数据        socket.write(&quot;GET / HTTP/1.0\\r\\n\\r\\n&quot;);        socket.flush();        while (socket.waitForReadyRead()) &#123;            qDebug() &lt;&lt; socket.readAll();        &#125;    &#125;    else &#123;        qDebug() &lt;&lt; &quot;SSL handshake failed:&quot; &lt;&lt; socket.errorString();    &#125;    return a.exec();&#125;\n\n这里，我们创建了 QSslSocket 实例，并使用 connectToHostEncrypted() 函数连接到名为 mysslserver.com 的 SSL 服务器的端口 443。如果 SSL 握手成功，则使用 write()、flush() 和 readAll() 函数发送和接收数据。您可以使用 QSslSocket 实现 SSL 服务器。请注意，为了使 SSL 握手尽可能平滑，最好使用 QApplication 而不是 QCoreApplication 类作为 Qt 应用程序的子类，并提供上下文以支持证书验证。23. 在 Qt 中，如何进行数据库操作？\n在 Qt 中，您可以使用 QSqlDatabase、QSqlQuery 和 QSqlTableModel 等类来进行数据库操作。以下是一些简单的示例：\n\n连接到 SQLite 数据库并执行查询\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;QCoreApplication&gt;#include &lt;QSqlDatabase&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);    db.setDatabaseName(&quot;mydatabase.db&quot;);    if (db.open()) &#123;        qDebug() &lt;&lt;Database connection established.&quot;;        QSqlQuery query;        query.exec(&quot;CREATE TABLE IF NOT EXISTS mytable (&quot;                   &quot;  id INTEGER PRIMARY KEY,&quot;                   &quot;  name TEXT NOT NULL,&quot;                   &quot;  age INTEGER);&quot;);        if (query.isActive()) &#123;            qDebug() &lt;&lt; &quot;Table created successfully.&quot;;        &#125;        else &#123;            qDebug() &lt;&lt; &quot;Table creation failed:&quot; &lt;&lt; query.lastError().text();        &#125;        // 插入数据记录        query.prepare(&quot;INSERT INTO mytable (name, age) VALUES (?, ?)&quot;);        query.bindValue(0, &quot;John Doe&quot;);        query.bindValue(1, 25);        if (query.exec()) &#123;            qDebug() &lt;&lt; &quot;Record inserted successfully.&quot;;        &#125;        else &#123;            qDebug() &lt;&lt; &quot;Record insertion failed:&quot; &lt;&lt; query.lastError().text();        &#125;        // 执行查询        if (query.exec(&quot;SELECT * FROM mytable&quot;)) &#123;            while (query.next()) &#123;                int id = query.value(0).toInt();                QString name = query.value(1).toString();                int age = query.value(2).toInt();                qDebug() &lt;&lt; &quot;ID:&quot; &lt;&lt; id &lt;&lt; &quot;Name:&quot; &lt;&lt; name &lt;&lt; &quot;Age:&quot; &lt;&lt; age;            &#125;        &#125;        else &#123;            qDebug() &lt;&lt; &quot;Query execution failed:&quot; &lt;&lt;.lastError().text();        &#125;    &#125;    else &#123;        qDebug() &lt;&lt; &quot;Database connection failed:&quot; &lt;&lt;.lastError().text();    &#125;    return a.exec();&#125;\n\n这里，我们使用 addDatabase() 函数添加一个 SQLite 数据库，并使用 setDatabaseName() 函数设置数据库文件路径。然后，我们打开这个数据库并执行一个 SQL 查询以创建一个名为 mytable 的数据表。如果查询成功，我们将一个新的记录插入到该数据表中。\n接下来，我们执行另一个 SQL 查询以读取 mytable 中的数据行，并使用 next() 函数向前遍历结果集。最后，我们从每一行中提取三个整数值并打印其 ID、姓名和年龄。\n\n通过 QSqlTableModel 直接操作数据表\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;QCoreApplication&gt;#include &lt;QSqlDatabase&gt;#include &lt;QSqlError&gt;#include &lt;QSqlTableModel&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])    QCoreApplication a(argc, argv);    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);    db.setDatabaseName(&quot;mydatabase.db&quot;);    if (db.open()) &#123;        qDebug() &lt;&lt; &quot;Database connection established.&quot;;        // 创建模型并绑定到数据表        QSqlTableModel model;        model.setTable(&quot;mytable&quot;);        // 添加新行        model.insertRows(0, 1);        model.setData(model.index(0, 1), &quot;Jane Smith&quot;);        model.setData(model.index(0, 2), 30);        model.submitAll();        // 显示所有行        model.select();        for (int row = 0; row &lt; model.rowCount(); ++row) &#123;            int id = model.index(row, 0).data().toInt();            QString name = model.index(row, 1).data().toString();            int age = model.index(row, 2).data().toInt();            qDebug() &lt;&lt; &quot;ID:&quot; &lt;&lt; id &lt;&lt; &quot;Name:&quot; &lt;&lt; name &lt;&lt; &quot;Age:&quot; &lt;&lt; age;        &#125;    &#125;    else &#123;        qDebug() &lt;&lt; &quot;Database connection failed:&quot; &lt;&lt; db.lastError().text();    &#125;    return a.exec();&#125;\n\n这里，我们再次使用 addDatabase() 函数添加 SQLite 数据库，然后打开它。接着，我们创建了一个 QSqlTableModel 实例，将其绑定到 mytable 数据表，并插入一行新的数据记录。然后，我们使用 select() 函数查询整个数据表并显示所有行的 ID、姓名和年龄。\n通过上述代码，您就可以在 Qt 中连接到数据库、执行查询和操作数据表。\n","slug":"Qt/进阶教程/Qt面试题集合","date":"2021-06-13T08:23:29.000Z","categories_index":"Qt进阶教程,Qt面试题","tags_index":"Qt","author_index":"阿木大叔"},{"id":"5d28961e81afaf3d71dc0378d856ba40","title":"Qt应用程序中的 QApplication","content":"Qt应用程序中的 QApplicationQApplication类是一个Qt框架中核心的应用程序类，它提供了管理应用程序的框架、事件循环和系统级配置的基础。在本文中，我们将详细介绍QApplication类的功能和应用场景。\n创建 QApplication 对象通常，我们在主函数中创建 QApplication 对象。在创建时，我们可以指定一些命令行选项和特定于平台的参数。例如，以下代码给出了如何创建一个简单的QApplication对象：\n1234567#include &lt;QApplication&gt;    // 必需头文件int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);   // 创建QApplication对象    ...    return app.quit();&#125;\n\n在上述代码中，我们包含必需的QApplication头文件，并创建了一个名为“app”的新QApplication对象。此对象将接管应用程序的控制权，并启动基本的事件循环，以便处理用户操作或其他系统事件。\n处理应用程序全局事件QApplication类提供了许多方法来针对应用程序全局事件进行处理。这里列举了一些最常用的方法：\n\nexec(): 启动一个基础的应用程序框架，用于管理应用程序生命周期和其与用户交互的方式。\nquit(): 退出应用程序。\nprocessEvents(): 此方法允许应用程序轮询事件队列并触发事件处理程序。\nsendEvent(): 发送一个特定事件到目标对象。\npostEvent(): 在应用程序主循环中将事件添加到事件队列中，直到下次调用processEvents()或exec()。\n\n例如，在以下代码中，我们展示了如何使用QApplication全局事件处理程序：\n123456789101112#include &lt;QApplication&gt;    // 必需头文件int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);   // 创建QApplication对象        // 加载并显示窗口    QWidget myWidget;    myWidget.show();        // 进入主事件循环    return app.exec();&#125;\n\n在上述代码中，我们首先创建了一个新的QApplication对象名为“app”。接下来，我们在应用程序中加载QWidget对象“myWidget”，并调用其show()方法以使其在屏幕上可见。最后，我们使用app.exec()方法进入应用程序主事件循环，处理用户操作和其他一些系统事件。\n处理应用程序命令行参数QApplication类提供了一些方法，可以针对应用程序命令行参数进行处理。这些命令行选项可以在启动时通过main()函数传递给应用程序。例如：\n12345678910#include &lt;QApplication&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    ...    if (app.arguments().contains(&quot;--debug&quot;))        qDebug() &lt;&lt; &quot;Running in debug mode!&quot;;    ...    return app.exec();&#125;\n\n在这个例子中，我们首先创建了一个新的QApplication对象“app”。然后，我们使用arguments()方法来获取从main()函数接收到的命令行参数，如果包含字符串“–debug”，则输出调试信息。\n处理应用程序全局设置QApplication还提供了一些方法，可以处理应用程序全局设置。这允许您定义应用程序在不同系统上如何运行以及其外观。以下是其中一些最重要和常用的方法：\n\nsetApplicationName() &#x2F; applicationName(): 设置或获取应用程序名称。\nsetApplicationVersion() &#x2F; applicationVersion(): 设置或获取应用程序版本号。\nsetOrganizationDomain() &#x2F; organizationDomain(): 设置或获取组织域名。\nsetOrganizationName() &#x2F; organizationName(): 设置或获取组织名称。\nsetStyleSheet() &#x2F; styleSheet(): 设置或获取应用程序样式表。\n\n这些方法可以使用以下代码进行使用：\n123456789101112131415161718#include &lt;QApplication&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    // 设置应用程序标题和图标    app.setApplicationDisplayName(&quot;My Application&quot;);    app.setWindowIcon(QIcon(&quot;:/icons/myicon.png&quot;));    // 设置应用程序全局样式表    QFile file(&quot;:/themes/mytheme.qss&quot;);    if (file.open(QIODevice::ReadOnly)) &#123;        QString styleSheet = QLatin1String(file.readAll());        app.setStyleSheet(styleSheet);    &#125;    return app.exec();&#125;\n\n在此代码中，我们首先创建一个新的QApplication对象“app”。接下来，我们设置应用程序名称和窗口图标，以改善UI设计。最后，我们加载并设置应用程序的全局样式表，以让用户界面看起来更整洁。\n","slug":"Qt/基础教程/Qt应用程序中的 QApplication","date":"2021-06-05T08:34:06.000Z","categories_index":"Qt基础教程","tags_index":"Qt","author_index":"阿木大叔"},{"id":"7e72488827dc1c1de5e7eda02fcbe24e","title":"【转载】C++17结构化绑定","content":"C++ 17 结构化绑定stl 的 map 容器很多读者应该都很熟悉，map 容器提供了一个 insert 方法，我们用该方法向 map 中插入元素，但是应该很少有人记得 insert 方法的返回值是什么类型，让我们来看一下 C++98&#x2F;03 提供的 insert 方法的签名：\n1std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );\n\n这里我们仅关心其返回值，这个返回值是一个 std::pair 类型，由于 map 中的元素的 key 不允许重复，所以如果 insert 方法调用成功，T1 是被成功插入到 map 中的元素的迭代器，T2 的类型为 bool，此时其值为 true（表示插入成功）；如果 insert 由于 key 重复，T1 是造成 insert 插入失败、已经存在于 map 中的元素的迭代器，此时 T2 的值为 false（表示插入失败）。\n在 C++98&#x2F;03 标准中我们可以使用 std::pair 的 first 和 second 属性来分别引用 T1 和 T2 的值。如下面的我们熟悉的代码所示：\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;int main()&#123;    std::map&lt;std::string, int&gt; cities;    cities[&quot;beijing&quot;]   = 0;    cities[&quot;shanghai&quot;]  = 1;    cities[&quot;shenzhen&quot;]  = 2;    cities[&quot;guangzhou&quot;] = 3;    //for (const auto&amp; [key, value] : m)    //&#123;    //    std::cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; std::endl;    //&#125;    //这一行在 C++11 之前写法实在太麻烦了，    //std::pair&lt;std::map&lt;std::string, int&gt;::iterator, int&gt; insertResult = cities.insert(std::pair&lt;std::string, int&gt;(&quot;shanghai&quot;, 2));    //C++ 11中我们写成：    auto insertResult = cities.insert(std::pair&lt;std::string, int&gt;(&quot;shanghai&quot;, 2));    std::cout &lt;&lt; &quot;Is insertion successful ? &quot; &lt;&lt; (insertResult.second ? &quot;true&quot; : &quot;false&quot;)               &lt;&lt; &quot;, element key: &quot; &lt;&lt; insertResult.first-&gt;first &lt;&lt; &quot;, value: &quot; &lt;&lt; insertResult.first-&gt;second &lt;&lt; std::endl;    return 0;&#125;\n\n代码 19 行实在太啰嗦了，我们使用 auto 关键字让编译器自动推导类型。\nstd::pair 一般只能表示两个元素，C++11 标准中引入了 std::tuple 类型，有了这个类型，我们就可以放任意个元素了，原来需要定义成结构体的 POD 对象我们可以直接使用 std::tuple 表示，例如下面表示用户信息的结构体：\n1234567891011121314151617181920struct UserInfo&#123;    std::string username;    std::string password;    int         gender;    int         age;    std::string address;&#125;;int main()&#123;    UserInfo userInfo = &#123; &quot;Tom&quot;, &quot;123456&quot;, 0, 25, &quot;Pudong Street&quot; &#125;;    std::string username = userInfo.username;    std::string password = userInfo.password;    int gender = userInfo.gender;    int age = userInfo.age;    std::string address = userInfo.address;    return 0;&#125;\n\n我们不再需要定义 struct UserInfo 这样的对象，可以直接使用 std::tuple 表示：\n123456789101112int main()&#123;        std::tuple&lt;std::string, std::string, int, int, std::string&gt; userInfo(&quot;Tom&quot;, &quot;123456&quot;, 0, 25, &quot;Pudong Street&quot;);    std::string username = std::get&lt;0&gt;(userInfo);    std::string password = std::get&lt;1&gt;(userInfo);    int gender = std::get&lt;2&gt;(userInfo);    int age = std::get&lt;3&gt;(userInfo);    std::string address = std::get&lt;4&gt;(userInfo);    return 0;&#125;\n\n从 std::tuple 中获取对应位置的元素，我们使用 std::get ，其中 N 是元素的序号（从 0 开始）。\n与定义结构体相比，通过 std::pair 的 first 和 second 还是 std::tuple 的 std::get 方法来获取元素子属性，这些代码都是非常难以维护的，其根本原因是 first 和 second 这样的命名不能做到见名知意。\nC++17 引入的结构化绑定（Structured Binding ）将我们从这类代码中解放出来。结构化绑定使用语法如下：\n123auto [a, b, c, ...] = expression;auto [a, b, c, ...] &#123; expression &#125;;auto [a, b, c, ...] ( expression );\n\n右边的 expression 可以是一个函数调用、花括号表达式或者支持结构化绑定的某个类型的变量。例如：\n12345678910111213//形式1auto [iterator, inserted] = someMap.insert(...);//形式2double myArray[3] = &#123; 1.0, 2.0, 3.0 &#125;;auto [a, b, c] = myArray;//形式3struct Point&#123;    double x;    double y;&#125;;Point myPoint(10.0, 20.0);auto [myX, myY] = myPoint;\n\n这样，我们可以给用于绑定到目标的变量名（语法中的 a、b、c）起一个有意义的名字。\n需要注意的是，绑定名称 a、b、c 是绑定目标的一份拷贝，当绑定类型不是基础数据类型时，如果你的本意不是想要得到绑定目标的副本，为了避免拷贝带来的不必要开销，建议使用引用，如果不需要修改绑定目标建议使用 const 引用。示例如下：\n12345678910double myArray[3] = &#123; 1.0, 2.0, 3.0 &#125;;auto&amp; [a, b, c] = myArray;//形式3struct Point&#123;    double x;    double y;&#125;;Point myPoint(10.0, 20.0);const auto&amp; [myX, myY] = myPoint;\n\n结构化绑定（Structured Binding ）是 C++17 引入的一个非常好用的语法特性。有了这种语法，在遍历像 map 这样的容器时，我们可以使用更简洁和清晰的代码去遍历这些容器了：\n12345678910std::map&lt;std::string, int&gt; cities;cities[&quot;beijing&quot;] = 0;cities[&quot;shanghai&quot;] = 1;cities[&quot;shenzhen&quot;] = 2;cities[&quot;guangzhou&quot;] = 3;for (const auto&amp; [cityName, cityNumber] : cities)&#123;    std::cout &lt;&lt; cityName &lt;&lt; &quot;: &quot; &lt;&lt; cityNumber &lt;&lt; std::endl;&#125;\n\n上述代码中 cityName 和 cityNumber 可以更好地反映出这个 map 容器的元素内容。\n我们再来看一个例子，某 WebSocket 网络库（https://github.com/uNetworking/uWebSockets）中有如下代码：\n123456789101112131415161718192021222324std::pair&lt;int, bool&gt; uncork(const char *src = nullptr, int length = 0, bool optionally = false) &#123;        LoopData *loopData = getLoopData();        if (loopData-&gt;corkedSocket == this) &#123;            loopData-&gt;corkedSocket = nullptr;            if (loopData-&gt;corkOffset) &#123;                /* Corked data is already accounted for via its write call */                auto [written, failed] = write(loopData-&gt;corkBuffer, loopData-&gt;corkOffset, false, length);                loopData-&gt;corkOffset = 0;                if (failed) &#123;                    /* We do not need to care for buffering here, write does that */                    return &#123;0, true&#125;;                &#125;            &#125;            /* We should only return with new writes, not things written to cork already */            return write(src, length, optionally, 0);        &#125; else &#123;            /* We are not even corked! */            return &#123;0, false&#125;;        &#125;    &#125;\n\n代码的第 9 行 write 函数返回类型是 std::pair，被绑定到 [written, failed] 这两个变量中去。前者在写入成功的情况下表示实际写入的字节数，后者表示是否写入成功。\n123std::pair&lt;int, bool&gt; write(const char *src, int length, bool optionally = false, int nextLength = 0) &#123;    //具体实现省略...&#125;\n\n结构化绑定的限制\n结构化绑定不能使用 constexpr 修饰或被申明为 static，例如：\n123456//正常编译auto [first, second] = std::pair&lt;int, int&gt;(1, 2);//无法编译通过//constexpr auto [first, second] = std::pair&lt;int, int&gt;(1, 2);//无法编译通过//static auto [first, second] = std::pair&lt;int, int&gt;(1, 2);\n\n注意：有些编译器也不支持在 lamda 表达式捕获列表中使用结构化绑定语法。\n","slug":"转载/cpp/C++17结构化绑定","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"674a06ff970318ba143bc66d58326f5d","title":"【转载】C++必须掌握的pimpl惯用法","content":"pimpl 惯用法现在这里有一个名为 CSocketClient 的网络通信类，定义如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 网络通信的基础类, SocketClient.h * zhangyl 2017.07.11 */class CSocketClient&#123;public:    CSocketClient();    ~CSocketClient(); public:      void SetProxyWnd(HWND hProxyWnd);    bool    Init(CNetProxy* pNetProxy);    bool    Uninit();        int Register(const char* pszUser, const char* pszPassword);     void GuestLogin();          BOOL    IsClosed();    BOOL\tConnect(int timeout = 3);    void    AddData(int cmd, const std::string&amp; strBuffer);    void    AddData(int cmd, const char* pszBuff, int nBuffLen);    void    Close();    BOOL    ConnectServer(int timeout = 3);    BOOL    SendLoginMsg();    BOOL    RecvLoginMsg(int&amp; nRet);    BOOL    Login(int&amp; nRet);private:    void LoadConfig();    static UINT CALLBACK SendDataThreadProc(LPVOID lpParam);    static UINT CALLBACK RecvDataThreadProc(LPVOID lpParam);    bool Send();    bool Recv();    bool CheckReceivedData();    void SendHeartbeatPackage();private:    SOCKET                          m_hSocket;    short                           m_nPort;    char                            m_szServer[64];    long                            m_nLastDataTime;        //最近一次收发数据的时间    long                            m_nHeartbeatInterval;   //心跳包时间间隔，单位秒    CRITICAL_SECTION                m_csLastDataTime;       //保护m_nLastDataTime的互斥体     HANDLE                          m_hSendDataThread;      //发送数据线程    HANDLE                          m_hRecvDataThread;      //接收数据线程    std::string                     m_strSendBuf;    std::string                     m_strRecvBuf;    HANDLE                          m_hExitEvent;    bool                            m_bConnected;    CRITICAL_SECTION                m_csSendBuf;    HANDLE                          m_hSemaphoreSendBuf;    HWND                            m_hProxyWnd;    CNetProxy*                      m_pNetProxy;    int                             m_nReconnectTimeInterval;    //重连时间间隔    time_t                          m_nLastReconnectTime;        //上次重连时刻    CFlowStatistics*                m_pFlowStatistics;&#125;;\n\n这段代码来源于笔者实际项目中开发的一个股票客户端的软件。\nCSocketClient 类的 public 方法提供对外接口供第三方使用，每个函数的具体实现在 SocketClient.cpp 中，对第三方使用者不可见。在 Windows 系统上作为提供给第三方使用的库，一般需要提供给使用者 .h、.lib 和 .dll* 文件，在 Linux 系统上需要提供 ***.h**、.a  或 .so 文件。\n不管是在哪个操作系统平台上，像 SocketClient.h 这样的头文件提供给第三方使用时，都会让库的作者心里隐隐不安——因为 SocketClient.h 文件中 SocketClient 类大量的成员变量和私有函数暴露了这个类太多的实现细节，很容易让使用者看出实现原理。这样的头文件，对于一些不想对使用者暴露核心技术实现的库和 sdk，是非常不好的。\n那有没有什么办法既能保持对外的接口不变，又能尽量不暴露一些关键性的成员变量和私有函数的实现方法呢？有的。我们可以将代码稍微修改一下：\n1234567891011121314151617181920212223242526272829303132333435/** * 网络通信的基础类, SocketClient.h * zhangyl 2017.07.11 */class Impl;class CSocketClient&#123;public:    CSocketClient();    ~CSocketClient(); public:    void SetProxyWnd(HWND hProxyWnd);    bool    Init(CNetProxy* pNetProxy);    bool    Uninit();    int Register(const char* pszUser, const char* pszPassword);        void GuestLogin();          BOOL    IsClosed();    BOOL\tConnect(int timeout = 3);    void    AddData(int cmd, const std::string&amp; strBuffer);    void    AddData(int cmd, const char* pszBuff, int nBuffLen);    void    Close();    BOOL    ConnectServer(int timeout = 3);    BOOL    SendLoginMsg();    BOOL    RecvLoginMsg(int&amp; nRet);    BOOL    Login(int&amp; nRet);private:    Impl*\tm_pImpl;&#125;;\n\n上述代码中，所有的关键性成员变量已经没有了，取而代之的是一个类型为 Impl 的指针成员变量 m_pImpl。\n\n具体采用什么名称，读者完全可以根据自己的实际情况来定，不一定非要使用这里的 Impl 和 m_pImpl。\n\nImpl 类型现在是完全对使用者透明，为了在当前类中可以使用 Impl，使用了一个前置声明：\n12//原代码第5行class Impl;\n\n然后我们就可以将刚才隐藏的成员变量放到这个类中去：\n12345678910111213141516171819202122232425262728293031323334class Impl&#123;public:\tImpl()\t&#123;        //TODO: 你可以在这里对成员变量做一些初始化工作\t&#125;\t\t~Impl()\t&#123;        //TODO: 你可以在这里做一些清理工作\t&#125;\tpublic:\tSOCKET                          m_hSocket;    short                           m_nPort;    char                            m_szServer[64];    long                            m_nLastDataTime;        //最近一次收发数据的时间    long                            m_nHeartbeatInterval;   //心跳包时间间隔，单位秒    CRITICAL_SECTION                m_csLastDataTime;       //保护m_nLastDataTime的互斥体     HANDLE                          m_hSendDataThread;      //发送数据线程    HANDLE                          m_hRecvDataThread;      //接收数据线程    std::string                     m_strSendBuf;    std::string                     m_strRecvBuf;    HANDLE                          m_hExitEvent;    bool                            m_bConnected;    CRITICAL_SECTION                m_csSendBuf;    HANDLE                          m_hSemaphoreSendBuf;    HWND                            m_hProxyWnd;    CNetProxy*                      m_pNetProxy;    int                             m_nReconnectTimeInterval;    //重连时间间隔    time_t                          m_nLastReconnectTime;        //上次重连时刻    CFlowStatistics*                m_pFlowStatistics;&#125;;\n\n接着我们在 CSocketClient 的构造函数中创建这个 m_pImpl 对象，在 CSocketClient 析构函数中释放这个对象。\n123456789CSocketClient::CSocketClient()&#123;\tm_pImpl = new Impl();&#125;CSocketClient::~CSocketClient()&#123;\tdelete m_pImpl;&#125;\n\n这样，原来需要引用的成员变量，可以在 CSocketClient 内部使用 m_pImpl-&gt;变量名 来引用了。 \n\n这里仅仅以演示隐藏 CSocketClient 的成员变量为例，隐藏其私有方法与此类似，都是变成类 Impl 的方法。\n\n需要强调的是，在实际开发中，由于 Impl 类是 CSocketClient 的辅助类， Impl 类没有独立存在的必要，所以一般会将 Impl 类定义成 CSocketClient 的内部类。即采用如下形式：\n12345678910111213141516/** * 网络通信的基础类, SocketClient.h * zhangyl 2017.07.11 */class CSocketClient&#123;public:    CSocketClient();    ~CSocketClient(); //重复的代码省略...private:\tclass   Impl;    Impl*\tm_pImpl;&#125;;\n\n然后在 ClientSocket.cpp 中定义 Impl 类的实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 网络通信的基础类, SocketClient.cpp * zhangyl 2017.07.11 */class  CSocketClient::Impl&#123;public:    void LoadConfig()    &#123;    \t//方法的具体实现    &#125;        //其他方法省略...    public:\tSOCKET                          m_hSocket;    short                           m_nPort;    char                            m_szServer[64];    long                            m_nLastDataTime;        //最近一次收发数据的时间    long                            m_nHeartbeatInterval;   //心跳包时间间隔，单位秒    CRITICAL_SECTION                m_csLastDataTime;       //保护m_nLastDataTime的互斥体     HANDLE                          m_hSendDataThread;      //发送数据线程    HANDLE                          m_hRecvDataThread;      //接收数据线程    std::string                     m_strSendBuf;    std::string                     m_strRecvBuf;    HANDLE                          m_hExitEvent;    bool                            m_bConnected;    CRITICAL_SECTION                m_csSendBuf;    HANDLE                          m_hSemaphoreSendBuf;    HWND                            m_hProxyWnd;    CNetProxy*                      m_pNetProxy;    int                             m_nReconnectTimeInterval;    //重连时间间隔    time_t                          m_nLastReconnectTime;        //上次重连时刻    CFlowStatistics*                m_pFlowStatistics;&#125; CSocketClient::CSocketClient()&#123;\tm_pImpl = new Impl();&#125;CSocketClient::~CSocketClient()&#123;\tdelete m_pImpl;&#125;\n\n现在CSocketClient 这个类除了保留对外的接口以外，其内部实现用到的变量和方法基本上对使用者不可见了。C++ 中对类的这种封装方式，我们称之为 pimpl 惯用法，即 Pointer to Implementation （也有人认为是 Private Implementation）。\n\n在实际的开发中，Impl 类的声明和定义既可以使用 class 关键字也可以使用 struct 关键字。在 C++ 语言中，struct 类型可以定义成员方法，但 struct 所有成员变量和方法默认都是 public 的。\n\n现在来总结一下这个方法的优点：\n\n核心数据成员被隐藏；\n  核心数据成员被隐藏，不必暴露在头文件中，对使用者透明，提高了安全性。\n\n降低编译依赖，提高编译速度；\n  由于原来的头文件的一些私有成员变量可能是非指针非引用类型的自定义类型，需要在当前类的头文件中包含这些类型的头文件，使用了 pimpl 惯用法以后，这些私有成员变量被移动到当前类的 cpp 文件中，因此头文件不再需要包含这些成员变量的类型头文件，当前头文件变“干净”，这样其他文件在引用这个头文件时，依赖的类型变少，加快了编译速度。\n\n接口与实现分离。\n  使用了 pimpl 惯用法之后，即使 CSocketClient 或者 Impl 类的实现细节发生了变化，对使用者都是透明的，对外的 CSocketClient 类声明仍然可以保持不变。例如我们可以增删改 Impl 的成员变量和成员方法而保持 SocketClient.h 文件内容不变；如果不使用 pimpl 惯用法，我们做不到不改变 SocketClient.h 文件而增删改 CSocketClient 类的成员。\n\n\n智能指针用于 pimpl 惯用法\nC++ 11 标准引入了智能指针对象，我们可以使用 std::unique_ptr 对象来管理上述用于隐藏具体实现的 m_pImpl 指针。\nSocketClient.h 文件可以修改成如下方式：\n1234567891011121314#include &lt;memory&gt; //for std::unique_ptr  class CSocketClient&#123;public:    CSocketClient();    ~CSocketClient();    //重复的代码省略...private:    struct                  Impl;    std::unique_ptr&lt;Impl&gt;   m_pImpl;&#125;;\n\nSocketClient.cpp 中修改 CSocketClient 对象的构造函数和析构函数的实现如下：\n构造函数\n如果你的编译器仅支持 C++ 11 标准，我们可以按如下修改：\n12345CSocketClient::CSocketClient()&#123;    //C++11 标准并未提供 std::make_unique()，该方法是 C++14 提供的    m_pImpl.reset(new Impl());&#125;\n\n如果你的编译器支持 C++14 及以上标准，可以这么修改：\n123CSocketClient::CSocketClient() : m_pImpl(std::make_unique&lt;Impl&gt;())&#123;    &#125;\n\n由于已经使用了智能指针来管理 m_pImpl 指向的堆内存，因此析构函数中不再需要显式释放堆内存：\n12345CSocketClient::~CSocketClient()&#123;    //不再需要显式 delete 了     //delete m_pImpl;&#125;\n\n\n\npimp 惯用法是 C&#x2F;C++ 项目开发中一种非常实用的代码编写策略，建议读者掌握它。\n","slug":"转载/cpp/C++必须掌握的pimpl惯用法","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"40a7e4f59089c11e355c8f7228d5379e","title":"【转载】不定参数函数实现var_arg系列的宏","content":"不定参数函数实现var_arg系列的宏电驴的源码日志模块有一个叫 DebugLogError 函数，其签名如下：\n12//代码位于easyMule-master/src/WorkLayer/Log.h 55行void DebugLogError(LPCTSTR pszLine, ...);\n\n\n电驴的源码可以在公众号【 高性能服务器开发 】后台回复“获取电驴源码”即可获取。\n\n这个函数的申明在 Log.h 头文件中，是一个全局函数，其实现代码在 Log.cpp 文件中：\n12345678//代码位于easyMule-master/src/WorkLayer/Log.cpp 111行void DebugLogError(LPCTSTR pszFmt, ...)&#123;    va_list argp;    va_start(argp, pszFmt);    LogV(LOG_DEBUG | LOG_ERROR, pszFmt, argp);    va_end(argp);&#125;\n\n这个函数是一个具有不定参数的函数（也就是参数个数不确定），比如调用这个函数我们可以传入一个参数，也可以传入二个或者三个参数等等：\n123DebugLogError(L&quot;我喜欢你!&quot;);DebugLogError(L&quot;我喜欢你!&quot;, L&quot;你喜欢谁？&quot;);DebugLogError(L&quot;我喜欢你!&quot;, L&quot;你喜欢谁？&quot;, L&quot;萧雨萌!&quot;);\n\n与此类似， C 语言中最熟悉的函数 printf() 和 scanf() 就是能传入不定参数的函数的例子，可是你知道如何编写这样具有不定参数的函数么？\n你可以通过这段代码学习到编写方法，奥秘就在DebugLogError()中使用的几个你从来没见过的宏，让我们欢迎它们：\n\nva_list\nva_start\nva_end\n\n这几个宏是C函数库提供的，位于头文件stdarg.h中。下面我们利用这几个宏自定义一个ShowLove()函数：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;stdarg.h&gt;#include &lt;locale.h&gt;int ShowLove(wchar_t* szFirstSentence, ...)&#123;   //用来统计可变参数数量   int num = 0;   //第一步：   //申明一个va_list类型对象ap，用于对参数进行遍历   va_list ap;      //第二步：   //使用va_start对变量进行初始化   //这里需要注意的是:   //在传统C语言中，va_start把ap中内部指针设置为传递给函数参数的【第一个实参】；   //而在标准的C中，va_start接受一个额外参数，也就是最后一个【固定参数】的名称，   //并把ap中的内部指针设置为传递给函数的第一个【可变参数】.   //所以你在VC++ 6.0和VS2008等高版本的编译器中使用va_start需要注意区别   //这里使用标准C   va_start(ap, szFirstSentence);   //第三步：   //使用va_arg宏返回实参列表中的下一个参数值，并把ap的内部指针推向下一个参数（如果有的话）   //必须指定下一个参数的类型。   //在调用va_start之后第一次调用va_arg将返回第一个可变参数的值   wprintf(szFirstSentence);   wchar_t* p = 0;   while(p = va_arg(ap, wchar_t*))   &#123;       wprintf(L&quot;%s&quot;, p);       num ++;   &#125;   //第四步：   //待所有可变参数都读取完毕以后，调用va_end宏对ap和va_list做必要的清理工作   va_end(ap);   return num;&#125;int main(int argc, char* argv[])&#123;   setlocale(LC_ALL, &quot;&quot;);   int z = ShowLoveL&quot;我喜欢你！\\n&quot;);   int y = ShowLove(L&quot;我喜欢你！&quot;, L&quot;你喜欢谁？\\n&quot;);   int l = ShowLove(L&quot;我喜欢你！&quot;, L&quot;你喜欢谁？&quot;, L&quot;萧雨萌！\\n&quot;);      printf(&quot;可变参数个数依次是：%d\\t%d\\t%d\\n&quot;, z, y, l);   return 0;&#125;\n\n上述代码的运行结果是：\n\n这里顺便补充下，va 的是英文 varied arguments （可变参数）的意思。关于 va_list 等宏的实现原理其实也很容易搞明白，这里不再讲解了。\n我们现在来看看函数 DebugLogError()：\n1234567void DebugLogError(LPCTSTR pszFmt, ...)&#123;\tva_list argp;\tva_start(argp, pszFmt);\t\tLogV(LOG_DEBUG | LOG_ERROR, pszFmt, argp);\tva_end(argp);&#125;\n\n其他的没什么，就是调用了一个函数叫 LogV()，LogV() 的的声明位于 Log.h 文件中，也是一个全局函数：\n1void LogV(UINT uFlags, LPCTSTR pszFmt, va_list argp);\n\n其实现代码位于 Log.cpp 文件中：\n1234void LogV(UINT uFlags, LPCTSTR pszFmt, va_list argp)&#123;\tAddLogTextV(uFlags, DLP_DEFAULT, pszFmt, argp);&#125;\n\n这里又调用了一个函数 **AddLogTextV()**，这个函数的也声明在 Log.h 中：\n1void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)；\n\n其实现代码在 Log.cpp 文件中：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)&#123;\tASSERT(pszLine != NULL);\tif ((uFlags &amp; LOG_DEBUG) &amp;&amp; !thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;= thePrefs.GetVerboseLogPriority())\t\treturn;\t\t//Xman Anti-Leecher-Log\tif ((uFlags &amp; LOG_LEECHER) &amp;&amp; !thePrefs.GetAntiLeecherLog())\t\treturn;\t\t//Xman end\tTCHAR szLogLine[1000];\tif (_vsntprintf(szLogLine, ARRSIZE(szLogLine), pszLine, argptr) == -1)\t\tszLogLine[ARRSIZE(szLogLine) - 1] = _T(&#x27;\\0&#x27;);\tif(CGlobalVariable::m_hListenWnd)\t\tUINotify(WM_ADD_LOGTEXT, uFlags, (LPARAM)new CString(szLogLine));\t//  Comment UI\t/*if (theApp.emuledlg)\t\ttheApp.emuledlg-&gt;AddLogText(uFlags, szLogLine);\telse*/\t/*if(SendMessage(CGlobalVariable::m_hListenWnd, WM_ADD_LOGTEXT, uFlags, (LPARAM)szLogLine)==0)*/\telse\t&#123;\t\tTRACE(_T(&quot;App Log: %s\\n&quot;), szLogLine);\t\tTCHAR szFullLogLine[1060];\t\tint iLen = _sntprintf(szFullLogLine, ARRSIZE(szFullLogLine), _T(&quot;%s: %s\\r\\n&quot;), CTime::GetCurrentTime().Format(thePrefs.GetDateTimeFormat4Log()), szLogLine);\t\tif (iLen &gt;= 0)\t\t&#123;\t\t\t//Xman Anti-Leecher-Log //Xman Code Improvement\t\t\tif (!((uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER)))\t\t\t&#123;\t\t\t\tif (thePrefs.GetLog2Disk())\t\t\t\t\ttheLog.Log(szFullLogLine, iLen);\t\t\t&#125;\t\t\telse\t\t\tif (thePrefs.GetVerbose()) // &amp;&amp; ((uFlags &amp; LOG_DEBUG) || thePrefs.GetFullVerbose()))\t\t\t&#123;\t\t\t\tif (thePrefs.GetDebug2Disk())\t\t\t\t\ttheVerboseLog.Log(szFullLogLine, iLen);\t\t\t&#125;\t\t\t//Xman end\t\t&#125;\t&#125;&#125;\n\n我们从源头函数调用来理下思路：\n\n首先用下列参数调用 **DebugLogError()**：\n\n1DebugLogError(L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;);\n\n\n然后在上述函数内部又调用：\n\n123LogV(LOG_DEBUG | LOG_ERROR,\t L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;,     argp);\n\n其中，argp 是函数 DebugLogError() 的内部变量，而 LOG_DEBUG 和 LOG_ERROR 是 Log.h 中定义几个宏，其类型为整形：\n12345678910111213// Log message type enumeration#define\tLOG_INFO\t\t0#define\tLOG_WARNING\t\t1#define\tLOG_ERROR\t\t2#define\tLOG_SUCCESS\t\t3#define\tLOGMSGTYPEMASK\t0x03// Log message targets flags#define\tLOG_DEFAULT\t\t0x00#define\tLOG_DEBUG\t\t0x10#define\tLOG_STATUSBAR\t0x20#define\tLOG_DONTNOTIFY\t0x40#define LOG_LEECHER\t\t0x80 //Xman Anti-Leecher-Log\n\n\n最后调用：\n\n1234AddLogTextV(LOG_DEBUG | LOG_ERROR,           DLP_DEFAULT,           L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;,           argp);\n\n这个函数的第二个参数类型是一个定义在 Log.h 中的枚举变量 EDebugLogPriority，代表调试的记录级别，其取值如下：\n1234567enum EDebugLogPriority&#123;\tDLP_VERYLOW = 0,\tDLP_LOW,\tDLP_DEFAULT,\tDLP_HIGH,\tDLP_VERYHIGH&#125;;\n\n这里提醒一点，由于枚举量 DLP_VERYLOW &#x3D; 0，所以后面的 DLP_LOW、 DLP_DEFAULT、  DLP_HIGH、 DLP_VERYHIGH 就依次等于1、2、3、4，这是C语言规定的，C语言规定枚举量如果不赋初值，根据前面一个量的值依次递增。\n我们来实际看看AddTextLogText()函数的实现代码：\n1234567891011void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)&#123;ASSERT(pszLine != NULL);if ((uFlags &amp; LOG_DEBUG) &amp;&amp; !thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;= thePrefs.GetVerboseLogPriority())\treturn;\t//Xman Anti-Leecher-Logif ((uFlags &amp; LOG_LEECHER) &amp;&amp; !thePrefs.GetAntiLeecherLog())\treturn;\t//Xman end\n\n首先是一个ASSERT断言，这个断言要求 pszLine （函数第三个参数）不能为空。\n接着如果同时满足下列两个条件，则函数返回：\n\n条件1：表达式 ((uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER)) 为真；\n条件2：表达式 !(thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;&#x3D; thePrefs.GetVerboseLogPriority()) 为真。\n\n我们先看条件1，很多年以前，我对这种按位或运算（**|**）和按位与运算（＆）来组合这些程序中的标志的原理一头雾水，虽然那个时候，我知道这些运算符的含义。\n现在就以这两个为例吧：\n按位或运算，就是把两个数在二进制层面上按位或，比如二进制数：\n111 | 10 = 11\n\n第一个数字高位上 1 与第二个数字高位上的 1 来进行或运算，等于 1，放在高位；\n第一个数字低位上 1 与第二个数字低位上的 0 来进行或运算，等于 1，放在低位。\n同理，与运算：\n111 &amp; 10 = 10\n\n按位与，要求两个数字都是 1 才是 1；而按位或只要有一个是 1 就等于 1，除非两者都是 0，则为 0。\n看个复杂的：\n111001100 &amp; 10101010 = 10001000\n\n这种做法有个两个好处：\n\n第一，可以将某个位置的上的数字来代表当前的状态，比如电路中 1 代表开，0 代表关。那么我用下面数字 a ＝ 10001000 表示电路开关状态，你会发现电路是开的。\n再比如，颜色值 RGB 表示法：CD1298， 我想把其中绿色值单独提取出来，怎么做？\n方法：\n1GreenValue = 0xCD1298 &amp; 0x001200,\n\n这样就可以做到了。\n\n第二，因为是二进制层次上的操作，所以速度非常快。\n\n\n我们现在分析下代码：\n1(uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER)\n\n先看第一部分：\n1uFlags &amp; LOG_DEBUG\n\n再结合下面的定义：\n123456// Log message targets flags#define LOG_DEFAULT      0x00#define LOG_DEBUG       0x10#define LOG_STATUSBAR 0x20#define LOG_DONTNOTIFY   0x40#define LOG_LEECHER      0x80 //Xman Anti-Leecher-Log\n\n这几个常量定义的数值是有讲究的，不是任何数值都行的。我们将它们都化成二进制：\n12345LOG_DEFAULT      0000 0000LOG_DEBUG        0001 0000LOG_STATUSBAR    0010 0000LOG_DONTNOTIFY   0100 0000LOG_LEECHER      1000 0000\n\n这样假如 uFlags &#x3D; 1010 0000，这样我要检测是否设置了LOG_DEBUG，我只要这样做：\n1Result = uFlags &amp; LOG_DEBUG\n\n计算结果\n1Result =&gt; 0000 0000 =&gt; 0\n\n这样 if（RESULT）{} 中条件为假；说明我没有设置这个标志位；同理我需要检测是否设置 LOG_STATUSBAR 标志，则执行：\n1Result = uFlags &amp; LOG_STATUSBAR = 0001 0000\n\n这个数字化为十进制不为 0，所以为真，因此在判断语句里面条件也为真，说明设置了这个标志位。\n这是正面检测，反过来我想设置这些标识位，而且可以一次设置多个标志位，比如\n1uFlags = LOG_STATUSBAR  |  LOG_DONTNOTIFY | LOG_LEECHER = 1110 0000\n\n是不是一目了然？\n而且我也可以很方便地从设置好的标志位中去掉某个或某些标识位，比如我想从上面的uFlags值中去掉LOG_DONTNOTIFY 标识，怎么办？这样做就可以了：\n1uFlags &amp; (~LOG_DONTNOTIFY)\n\n来解释下～符号是二进制层次上求反，将对应位上的 1 改为 0，0 改为 1，那么：\n1~ LOG_DONTNOTIFY = 1011 1111\n\n然后与 uFlags 或起来等于 1010 0000，你看下是不是刚好把 LOG_DONTNOTIFY 去掉了呀？\n这种方法效率高不仅是因为在二进制层次上运算，而且它可以用一个较小的数据类型代表多个信息，对数据的利用程度精准到二进制位。\n","slug":"转载/cpp/不定参数函数实现var_arg系列的宏","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"c9abbbdef4e88dc3f27e1c9bd42d47df","title":"【转载】你一定要搞明白的C函数调用方式与栈原理","content":"你一定要搞明白的C函数调用方式与栈原理写在前面的话\n这绝对不是标题党。而是C&#x2F;C++开发中你必须要掌握的基础知识，也是高级技术岗位面试中高频题。我真的真的真的希望无论是学生还是广大C&#x2F;C++开发者，都该掌握此文中介绍的知识。\n正文\n这篇blog试图讲明当一个c函数被调用时，一个**栈帧(stack frame)**是如何被建立，又如何被消除的。这些细节跟操作系统平台及编译器的实现有关，下面的描述是针对运行在Intel奔腾芯片上Linux的gcc编译器而言。c语言的标准并没有描述实现的方式，所以，不同的编译器，处理器，操作系统都可能有自己的建立栈帧的方式。\n一个典型的栈帧\n图1是一个典型的栈帧，图中，栈顶在上，地址空间往下增长。这是如下一个函数调用时的栈的内容：\n1int foo(int arg1, int arg2, int arg3); \n\n并且，foo有两个局部的int变量（4个字节）。在这个简化的场景中，main调用foo，而程序的控制仍在foo中。这里，main是调用者（caller），foo是被调用者（callee）。ESP被foo使用来指示栈顶。EBP相当于一个“基准指针”。从main传递到foo的参数以及foo本身的局部变量都可以通过这个基准指针为参考，加上偏移量找到。由于被调用者允许使用EAX，ECX和EDX寄存器，所以如果调用者希望保存这些寄存器的值，就必须在调用子函数之前显式地把他们保存在栈中。另一方面，如果除了上面提到的几个寄存器，被调用者还想使用别的寄存器，比如EBX，ESI和EDI，那么，被调用者就必须在栈中保存这些被额外使用的寄存器，并在调用返回前回复他们。也就是说，如果被调用者只使用约定的EAX，ECX和EDX寄存器，他们由调用者负责保存并回复，但如果被调用这还额外使用了别的寄存器，则必须有他们自己保存并回复这些寄存器的值。传递给foo的参数被压到栈中，最后一个参数先进栈，所以第一个参数是位于栈顶的。foo中声明的局部变量以及函数执行过程中需要用到的一些临时变量也都存在栈中。小于等于4个字节的返回值会被保存到EAX中，如果大于4字节，小于8字节，那么EDX也会被用来保存返回值。如果返回值占用的空间还要大，那么调用者会向被调用者传递一个额外的参数，这个额外的参数指向将要保存返回值的地址。用C语言来说，就是函数调用：\n1x = foo(a, b, c);\n\n被转化为：\n1foo(&amp;x, a, b, c);\n\n注意，这仅仅在返回值占用大于8个字节时才发生。有的编译器不用EDX保存返回值，所以当返回值大于4个字节时，就用这种转换。当然，并不是所有函数调用都直接赋值给一个变量，还可能是直接参与到某个表达式的计算中，如：\n1m = foo(a, b, c) + foo(d, e, f);\n\n有或者作为另外的函数的参数， 如：\n1fooo(foo(a, b, c), 3);\n\n这些情况下，foo的返回值会被保存在一个临时变量中参加后续的运算，所以，foo(a, b, c)还是可以被转化成**foo(&amp;tmp, a, b, c)**。\n让我们一步步地看一下在c函数调用过程中，一个栈帧是如何建立及消除的。\n函数调用前调用者的动作在我们的例子中，调用者是main，它准备调用函数foo。在函数调用前，main正在用ESP和EBP寄存器指示它自己的栈帧。\n首先，main把EAX，ECX和EDX压栈。这是一个可选的步骤，只在这三个寄存器内容需要保留的时候执行此步骤。接着，main把传递给foo的参数一一进栈，最后的参数最先进栈。例如，我们的函数调用是：\n1a = foo(12, 15, 18);\n\n相应的汇编语言指令是：\n123push dword 18push dword 15push dword 12\n\n最后，main用call指令调用子函数：\n1call foo\n\n当call指令执行的时候，EIP指令指针寄存器的内容被压入栈中。因为EIP寄存器是指向main中的下一条指令，所以现在返回地址就在栈顶了。在call指令执行完之后，下一个执行周期将从名为foo的标记处开始。图2展示了call指令完成后栈的内容。图2及后续图中的粗线指示了函数调用前栈顶的位置。我们将会看到，当整个函数调用过程结束后，栈顶又回到了这个位置。\n\n被调用者在函数调用后的动作当函数foo，也就是被调用者取得程序的控制权，它必须做3件事：建立它自己的栈帧，为局部变量分配空间，最后，如果需要，保存寄存器EBX，ESI和EDI的值。首先foo必须建立它自己的栈帧。EBP寄存器现在正指向main的栈帧中的某个位置，这个值必须被保留，因此，EBP进栈。然后ESP的内容赋值给了EBP。这使得函数的参数可以通过对EBP附加一个偏移量得到，而栈寄存器ESP便可以空出来做其他事情。如此一来，几乎所有的c函数都由如下两个指令开始：\n12push ebpmov ebp, esp\n\n此时的栈入图3所示。在这个场景中，第一个参数的地址是EBP加8，因为main的EBP和返回地址各在栈中占了4个字节。\n\n​       \n下一步，foo必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。比如，foo中的一些C语句可能包括复杂的表达式，其子表达式的中间值就必须得有地方存放。这些存放中间值的地方同城被称为临时的，因为他们可以为下一个复杂表达式所复用。为说明方便，我们假设我们的foo中有两个int类型（每个4字节）的局部变量，需要额外的12字节的临时存储空间。简单地把栈指针减去20便为这20个字节分配了空间：\n1sub esp, 20\n\n现在，局部变量和临时存储都可以通过基准指针EBP加偏移量找到了。最后，如果foo用到EBX，ESI和EDI寄存器，则它f必须在栈里保存它们。结果，现在的栈如图4所示。 \n\n​    \nfoo的函数体现在可以执行了。这其中也许有进栈、出栈的动作，栈指针ESP也会上下移动，但EBP是保持不变的。这意味着我们可以一直用[EBP+8]找到第一个参数，而不管在函数中有多少进出栈的动作。函数foo的执行也许还会调用别的函数，甚至递归地调用foo本身。然而，只要EBP寄存器在这些子调用返回时被恢复，就可以继续用EBP加上偏移量的方式访问实际参数，局部变量和临时存储。\n被调用者返回前的动作在把程序控制权返还给调用者前，被调用者foo必须先把返回值保存在EAX寄存器中。我们前面已经讨论过，当返回值占用多于4个或8个字节时，接收返回值的变量地址会作为一个额外的指针参数被传到函数中，而函数本身就不需要返回值了。这种情况下，被调用者直接通过内存拷贝把返回值直接拷贝到接收地址，从而省去了一次通过栈的中转拷贝。其次，foo必须恢复EBX，ESI和EDI寄存器的值。如果这些寄存器被修改，正如我们前面所说，我们会在foo执行开始时把它们的原始值压入栈中。如果ESP寄存器指向如图4所示的正确位置，寄存器的原始值就可以出栈并恢复。可见，在foo函数的执行过程中正确地跟踪ESP是多么的重要————也就是说，进栈和出栈操作的次数必须保持平衡。这两步之后，我们不再需要foo的局部变量和临时存储了，我们可以通过下面的指令消除栈帧：\n12mov esp, ebppop ebp\n\n其结果就是现在栈里的内容跟图2中所示的栈完全一样。现在可以执行返回指令了。从栈里弹出返回地址，赋值给EIP寄存器。栈如图5所示：\n \ni386指令集有一条“leave”指令，它与上面提到的mov和pop指令所作的动作完全相同。所以，C函数通常以这样的指令结束：\n12leaveret\n\n\n\n调用者在返回后的动作在程序控制权返回到调用者（也就是我们例子中的main）后，栈如图5所示。这时，传递给foo的参数通常已经不需要了。我们可以把3个参数一起弹出栈，这可以通过把栈指针加12（&#x3D;3个4字节）实现：\n1add esp, 12\n\n如果在函数调用前，EAX，ECX和EDX寄存器的值被保存在栈中，调用者main函数现在可以把它们弹出。这个动作之后，栈顶就回到了我们开始整个函数调用过程前的位置，也就是图5中粗线的位置。\n看个具体的实例：\n这段代码反汇编后，代码是什么呢？\n12345678910111213#include &lt;stdio.h&gt;long test(int a, int b)&#123;\ta = a + 3;\tb = b + 5;\treturn a + b;&#125; int main(int argc, char* argv[])&#123;\tprintf(&quot;%d&quot;, test(10,90));\treturn 0;&#125;\n\n先来看一个概貌：\n1234567891011121314151617181920212223249:   int main(int argc, char* argv[])10:   &#123;00401070   push        ebp00401071   mov         ebp,esp00401073   sub         esp,40h00401076   push        ebx00401077   push        esi00401078   push        edi00401079   lea         edi,[ebp-40h]0040107C   mov         ecx,10h00401081   mov         eax,0CCCCCCCCh00401086   rep stos    dword ptr [edi]11:        printf(&quot;%d&quot;,test(10,90));00401088   push        5Ah0040108A   push        0Ah0040108C   call        @ILT+0(test) (00401005)00401091   add         esp,800401094   push        eax00401095   push        offset string &quot;%d&quot; (0042201c)0040109A   call        printf (004010d0)0040109F   add         esp,812:        return 0;004010A2   xor         eax,eax13:   &#125;\n\n下面来解释一下，\n开始进入Main函数 esp&#x3D;0x12FF84  ebp&#x3D;0x12FFC0完成椭圆形框起来的部分：\n100401070   push        ebp\n\nebp的值入栈，保存现场(调用现场，从test函数看，如红线所示，即保存的0x12FF80用于从test函数堆栈返回到main函数)：\n100401071    mov        ebp,esp \n\n此时ebp＝0x12FF80 此时ebp就是“当前函数堆栈”的基址 以便访问堆栈中的信息；还有就是从当前函数栈顶返回到栈底：\n100401073     sub        esp,40h   \n\n函数使用的堆栈，默认64个字节，堆栈上就是16个横条（密集线部分）此时esp&#x3D;0x12FF40。在上图中，上面密集线是test函数堆栈空间，下面是Main的堆栈空间(补充，其实这个就叫做 Stack Frame)：\n123456700401076   push        ebx00401077   push        esi00401078   push        edi    入栈 00401079   lea         edi,[ebp-40h]0040107C   mov         ecx,10h00401081   mov         eax,0CCCCCCCCh00401086   rep stos    dword ptr [edi]      \n\n初始化用于该函数的栈空间为0XCCCCCCCC，即从0x12FF40~0x12FF80所有的值均为0xCCCCCCCC：\n123411:        printf(&quot;%d&quot;,test(10,90));00401088   push        5Ah    参数入栈 从右至左 先90  后100040108A   push        0Ah 0040108C   call        @ILT+0(test) (00401005)    \n\n函数调用，转向eip 00401005 。注意，此时仍入栈，入栈的是call test 指令下一条指令的地址00401091下一条指令是add esp,8。@ILT+0(?test@@YAJHH@Z):\n100401005   jmp       test (00401020)   \n\n即转向被调函数test：\n123456789101112131415161718192021222324252627282930 2:    long test(int a,int b) 3:    &#123;00401020   push        ebp00401021   mov         ebp,esp           00401023   sub         esp,40h00401026   push        ebx00401027   push        esi00401028   push        edi00401029   lea         edi,[ebp-40h]0040102C   mov         ecx,10h00401031   mov         eax,0CCCCCCCCh00401036   rep stos    dword ptr [edi]       //这些和上面一样4:        a = a + 3;                                    00401038   mov         eax,dword ptr [ebp+8] //ebp=0x12FF24 加8 [0x12FF30]即取到了参数100040103B   add         eax,30040103E   mov         dword ptr [ebp+8],eax5:        b = b + 5;00401041   mov         ecx,dword ptr [ebp+0Ch]00401044   add         ecx,500401047   mov         dword ptr [ebp+0Ch],ecx6:        return a + b;0040104A   mov         eax,dword ptr [ebp+8]0040104D   add         eax,dword ptr [ebp+0Ch]  //最后的结果保存在eax, 结果得以返回7:   &#125;00401050   pop         edi                 00401051   pop         esi00401052   pop         ebx00401053   mov         esp,ebp    //esp指向0x12FF24, test函数的堆栈空间被放弃，从当前函数栈顶返回到栈底00401055   pop         ebp        //此时ebp=0x12FF80, 恢复现场  esp=0x12FF2800401056   ret                    //ret负责栈顶0x12FF28之值00401091弹出到指令寄存器中，esp=0x12FF30\n\n因为win32汇编一般用eax返回结果 所以如果最终结果不是在eax里面的话 还要把它放到eax。\n注意，从被调函数返回时，是弹出EBP,恢复堆栈到函数调用前的地址，弹出返回地址到EIP以继续执行程序。\n从test函数返回，执行：\n100401091   add         esp,8       \n\n清栈，清除两个压栈的参数10 90 调用者main负责。(所谓__cdecl调用由调用者负责恢复栈，调用者负责清理的只是入栈的参数，test函数自己的堆栈空间自己返回时自己已经清除，靠！一直理解错)\n123456700401094   push        eax          //入栈，计算结果108入栈，即printf函数的参数之一入栈00401095   push        offset string &quot;%d&quot; (0042201c)//入栈，参数 &quot;%d&quot;  当然其实是％d的地址0040109A   call        printf (004010d0)//函数调用 printf(&quot;%d&quot;,108) 因为printf函数时0040109F   add         esp,8       //清栈，清除参数 (&quot;%d&quot;, 108)19:        return 0;           004010A2   xor         eax,eax     //eax清零20:   &#125;     \n\nmain函数执行完毕 此时esp&#x3D;0x12FF34 ebp&#x3D;0x12FF80：\n12345678004010A4   pop         edi004010A5   pop         esi004010A6   pop         ebx004010A7   add         esp,40h    //为啥不用mov esp, ebp? 是为了下面的比较004010AA   cmp         ebp,esp   //比较，若不同则调用chkesp抛出异常004010AC   call        __chkesp (00401150)   004010B1   mov         esp,ebp   004010B3   pop         ebp          //ESP=0X12FF84  \n\nEBP&#x3D;0x12FFC0 尘归尘 土归土 一切都恢复最初的平静了 :)\n1004010B4   ret\n\n另：\n\n如果函数调用方式是**__stdcall**不同之处在于main函数call 后面没有了add esp, 8；test函数最后一句是 ret 8  (由test函数清栈, ret 8意思是执行ret后，esp+8)。\n运行过程中0x12FF28 保存了指令地址 00401091是怎么保存的？栈每个空间保存4个字节（粒度4字节） 例如下一个栈空间0x12FF2C保存参数10，因此：\n\n120x12FF28 0x12FF29 0x12FF2A 0x12FF2B      91       10       40       00       \n\nlittle-endian 认为其读的第一个字节为最小的那位上的数。\n\nchar a[] &#x3D; “abcde” 对局部字符数组变量（栈变量）赋值，是利用寄存器从全局数据内存区把字符串“abcde”拷贝到栈内存中的。\nint szNum[5] &#x3D; { 1, 2, 3, 4, 5 }; 栈中是如何分布的？\n\n1234500401798   mov         dword ptr [ebp-14h],10040179F   mov         dword ptr [ebp-10h],2004017A6   mov         dword ptr [ebp-0Ch],3004017AD   mov         dword ptr [ebp-8],4004017B4   mov         dword ptr [ebp-4],5\n\n可以看出来是从右边开始入栈，所以是 5 4 3 2 1 入栈，\n123int *ptrA = (int*)(&amp;szNum+1);int *ptrB = (int*)((int)szNum + 1);std::cout&lt;&lt; ptrA[-1] &lt;&lt; *ptrB &lt;&lt; std::endl;\n\n结果如何？\n12328:       int *ptrA = (int*)(&amp;szNum+1);004017BB   lea         eax,[ebp]004017BE   mov         dword ptr [ebp-18h],eax\n\n&amp;szNum是指向数组指针；加1是加一个数组宽度；&amp;szNum+1指向移动5个int单位之后的那个地方， 就是把EBP的地址赋给指针；ptrA[-1]是回退一个int*宽度，即ebp-4；\n12329:       int *ptrB = (int*)((int)szNum + 1);004017C1   lea         ecx,[ebp-13h]004017C4   mov         dword ptr [ebp-1Ch],ecx\n\n如果上面是指针算术，那这里就是地址算术，只是首地址+1个字节的offset，即ebp-13h给指针。实际保存是这样的：\n1201 00 00 00 02 00 00 00ebp-14h ebp-13h ebp-10h\n\n注意，是int*类型的，最后获得的是 00 00 00 02，由于Little-endian, 实际上逻辑数是02000000，转换为十进制数就为33554432，最后输出533554432。\n","slug":"转载/cpp/你一定要搞明白的C函数调用方式与栈原理","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"0e9060ff12875a627166c3e18b56f8f7","title":"【转载】利用cmake工具生成VisualStudio工程文件","content":"利用 cmake 工具生成 Visual Studio 工程文件对于习惯了 Visual Studio 强大的管理项目、编码和调试功能的读者来说，在 Linux 下使用 gcc&#x2F;g++ 编译、使用 gdb 调试是一件何其痛苦的事情，对于大多数的开源 C&#x2F;C++ 项目，如果我们不在意 Windows 和 Linux 在一些底层 API 接口上的使用差别，想熟悉该项目的执行脉络和原理，在 Windows 上使用 Visual Studio 调试该项目也未尝不可。凡是可以使用 CMake 工具编译的 Linux 程序（即提供了 CMakeLists.txt 文件），我们同样也可以利用 CMake 工具生成 Windows 上的 Visual Studio 工程文件。\n这里我们以著名的开源网络库 libuv 为例。\n从 libuv 的官方地址提供的下载链接：https://dist.libuv.org/dist/ 下载最新的 libuv 的源码得到文件 libuv-v1.31.0.tar.gz（笔者写作此书时，libuv 最新版本是 1.31.0），解压该文件。作者的机器上我将代码解压至 *F:\\mycode\\libuv-v1.31.0* ，解压后的目录中确实存在一个 CMakeLists.txt 文件，如下图所示：\n\n启动 Windows 上的 CMake 图形化工具（cmake-gui），按下图进行设置：\n\n设置完成之后，点击界面上的Configure 按钮，会提示 vsprojects 目录不存在，提示是否创建，我们点击 Yes 进行创建。\n\n如果您的机器上安装了多个版本的Visual Studio，接下来会弹窗对话框让我们选择要生成的工程文件对应的 Visual Studio 版本号。读者可以根据自己的实际情况按需选择。我这里选择 Visual Studio 2019。\n\n\n点击 Finish 按钮后开始启动 CMake 的检测和配置工作。等待一会儿，CMake 底部的输出框中提示 “Configuring Done” 表示配置工作已经完成。\n\n接下来点击 Generate 按钮即可生成所选版本的 Visual Studio 工程文件，生成的文件位于 vsprojects 目录。\n\n我们可以在界面上点击按钮 Open Project 按钮直接打开工程文件，也可以找到对应目录下的 libuv.sln 打开。\n打开后如下图所示：\n\n接下来，我们就可以使用 Visual Studio 愉快地进行编译和调试了。\n让我们再深入聊一下上述过程：在点击 Configure 按钮之后，和在 Linux 下执行 cmake 命令一样，CMake 工具也是在检测所在的系统环境是否匹配 CMakeLists.txt 中定义的各种环境，本质上是生成了一份可以在 Windows 上编译和运行的代码（也就是说该源码支持在 Windows 上运行） 。因此，对于很多虽然提供了 CMakeLists.txt 文件但并不支持在 Windows 上运行的的 Linux 工程，虽然利用上述方法也能最终生成 Visual Studio 工程文件，但是这些文件并不能在 Windows 上直接无错编译和调试。\n\n由于不同的 CMake 版本支持的 CMakeLists.txt 中的语法可能略有细微差别，有些 CMakeLists.txt 文件在使用上述方法 configure 时可能会产生一些错误，需要读者做些修改才能通过。\n\n","slug":"转载/cpp/利用cmake工具生成VisualStudio工程文件","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"3add2e8130af8265f056561f93db8e22","title":"【转载】如何使用VisualStudio管理和阅读开源项目代码","content":"如何使用 Visual Studio 管理和阅读开源项目代码对于 Linux C&#x2F;C++ 项目，虽然我们在 Linux 系统中使用 gdb 去调试，但是通常情况下对于 C&#x2F;C++ 项目笔者一般习惯使用 Visual Studio 去做项目管理，Visual Studio 提供了强大的 C&#x2F;C++ 项目开发和管理能力。这里以 redis 源码为例，介绍一下如何将这种开源项目整体添加到 Visual Studio 的解决方案中去。\n\n启动 Visual Studio 新建一个空的 Win32 控制台程序。(工程建好后，关闭该工程防止接下来的步骤中文件占用导致的无法移动。)\n\n\n\\2. 这样会在 redis 源码目录下会根据你设置的名称生成一个文件夹（这里是 redis-4.0.1），将该文件夹中所有文件拷贝到 redis 源码根目录，然后删掉生成的这个文件夹。\n\n\n \\3. 再次用 Visual Studio 打开 redis-4.0.1.sln 文件，然后在解决方案资源管理器视图中点击显示所有文件按钮并保持该按钮选中。（如果找不到解决方案资源管理器视图，可以在【视图】菜单中打开，快捷键 Ctrl + Alt + L。）\n\n\\4. 然后选中所有需要添加到解决方案中的文件，右键选择菜单【包括在项目中】即可，如果文件比较多，Visual Studio 可能需要一会儿才能完成，为了减少等待时间，读者也可以一批一批的添加。\n\n5.接着选择【文件】菜单【全部保存】菜单项保存即可（快捷键 Ctrl + Shift + S ）。\n最终效果如下图所示：\n\n这样我们就能利用 Visual Studio 强大的功能管理和阅读我们的源码了。\n\n这里要提醒一下读者：C&#x2F;C++ 开源项目中一般会使用各种宏去条件编译一些代码，实际生成的二进制文件中不一定包含这些代码，所以在 Visual Studio 中看到某段代码的行号与实际在 gdb 中调试的代码行号不一定相同，在给某一行代码设置断点时请以 gdb 中 list 命令看到的代码行号为准。\n\n","slug":"转载/cpp/如何使用VisualStudio管理和阅读开源项目代码","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"19b943d557ff5766028818e28feaf31f","title":"【转载】如何成为一名合格的CC++开发者？","content":"如何成为一名合格的 C&#x2F;C++ 开发者？写在前面的话在大多数开发或者准开发人员的认识中，C&#x2F;C++ 是一门非常难的编程语言，很多人知道它的强大，但因为认为“难”造成的恐惧让很多人放弃。\n笔者从学生时代开始接触 C&#x2F;C++，工作以后先后担任过 C++ 客户端和服务器的开发经理并带队开发，至今已经有十多年了。虽然时至今日哪种编程语言对我来说已经不再重要（我目前主要从事 Java 开发），但 C&#x2F;C++ 仍然是笔者最喜欢的编程语言。在我看来，C&#x2F;C++ 一旦学成，其妙无穷，就像武侠小说中的“九阳神功”一样，有了这个基础，您可以快速学习任何语言和编程技术。\nC&#x2F;C++ 的当前应用领域需要注意的是本文不细分 C与 C++ 的区别，通常情况下，C++ 可以看成是 C 的一个超集，在古典时期，可以认为 C++ 就是 C with classes。虽然如今的 C++ 从功能层面上来看，离 C 越来越远了；但是从语法层面来上来看，大多数 C++ 语法还是与 C 基本一致的——所谓 C++ 的面向对象特性，如果细究 C++ 类方法的具体语法还是 C 的过程式语法。当然，面向对象是一种思想，语言本身对其支持的程度固然重要，能否熟练使用更要看开发者的水平。\nC 语言目前主要用于像操作系统一类偏底层的应用开发，包括像 Windows&#x2F;Linux 这样的大型商业操作系统，以及嵌入式操作系统、嵌入式设备上的应用。还有一些开源的软件，也会选择 C 开发，这些系统主要优先考虑程序执行效率和生成的可执行文件的体积（C 代码生成的可执行文件体积相对更小），当然还有一些是历史技术选型问题，这类软件像 Redis、libevent、Nginx，目前像国内的电信服务商所使用的电话呼叫系统，一般也是基于一款叫 FreeSWITCH 的开源 C 程序做的二次开发（项目地址：https://freeswitch.com/ ）。\nC++ 面向对象的语法与 C 相比较起来，在将高级语言翻译成机器二进制码的时候，C++ 编译器在背后偷偷地做了大量工作，生成了大量的额外机器码，而这种机器码相对于 C 来说不是必须的。例如，对于一个 C++ 类的实例方法，编译器在生成这个方法的机器码时，会将函数的第一个参数设置成对象的 this 指针地址，以此来实现对象与函数的绑定。正因为如此，许多开发者会优化和调整编译器生成的汇编代码。\n我们再来说说 C++。C++ 的应用领域目前有三大类，第一类就是我们目前见到的各种桌面应用软件，尤其 Windows 桌面软件，如 QQ、安全类杀毒类软件（如金山的安全卫士，已开源，其代码地址：http://code.ijinshan.com/source/source.html ）、各种浏览器等；另外就是一些基础软件和高级语言的运行时环境，如大型数据库软件、Java 虚拟机、C# 的 CLR、Python 编译器和运行时环境等；第三类就是一些业务型应用软件的后台，像游戏的服务器后台，如魔兽世界的服务器（代码地址：https://github.com/azerothcore/azerothcore-wotlk ）和一些企业内部的应用系统。笔者曾在某交易所从事后台开发，其交易系统和行情系统就是基于 C++ 开发的。\nC++ 与操作系统平台从上面的介绍可以看出，与 Java、Python 等语言相比，C&#x2F;C++ 语言是离操作系统最近的一种高级语言，因此其执行效率也比较高。但是有得必有失，因为如此，C&#x2F;C++ 这门语言存在如下特点。\nC&#x2F;C++ 整套的语法不具备“功能完备性”，单纯地使用这门语言本身提供的功能无法创建任何有意义的程序，必须借助操作系统的 API 接口函数来达到相应的功能。当然，随着 C++ 语言标准和版本的不断更新升级，这种现状正在改变；而像 Java、Python 这类语言，其自带的 SDK 提供了各种操作系统的功能。\n举个例子，C&#x2F;C++ 语言本身不具备网络通信功能，必须使用操作系统提供的网络通信函数（如 Socket 系列函数）；而对于 Java 来说，其 JDK 自带的 java.net 和 java.io 等包则提供了完整的网络通信功能。我在读书的时候常常听人说，QQ、360 安全卫士这类软件是用 C&#x2F;C++ 开发的，但是当我学完整本 C&#x2F;C++ 教材以后，仍然写不出来一个像样的窗口程序。许多过来人应该都有类似的困惑吧？其原因是一般 C&#x2F;C++ 的教材不会教你如何使用操作系统 API 函数的内容。\nC&#x2F;C++ 语言需要直接使用操作系统的接口功能，这就造成了 C&#x2F;C++ 语言繁、难的地方。如操作内存不当容易引起程序宕机，不同操作系统的 API 接口使用习惯和风格也不一样。接口函数种类繁多，开发者如果想开发跨平台的程序，必须要学习多个平台的接口函数和对应的系统原理。\n在应用层开发，直接使用操作系统接口的函数，往往执行效率高、控制力度大。而开发能力仅仅限制于操作系统本身，Java 这类语言，很多功能即使操作系统提供了，如果 Java 虚拟机不提供，开发人员也无法使用。正如著名的编程大师 Charles Petzold 所说：\n\n“显而易见，究竟用哪种方式编写应用程序最好，其实并无一定之规。应用程序本身的特性应该是决定采用何种编程工具的最主要因素，但是无论将来你采用什么样的编程工具，通过了解操作系统 API 从而深入理解操作系统的工作原理，这本身就有很重要的意义。操作系统是一个非常复杂的系统，在 API 之上加一层编程语言并不能消除其复杂性，最多不过是把复杂性隐藏起来而已。说不定什么时候，复杂的那一面迟早会蹦出来拖你的后腿，懂得系统 API 能让你到时候可以更快地挣脱困境。\n在基本操作系统 API 之上的任何软件层或多或少都会限制你使用操作系统的全部功能。比如，你或许发现采用 Visual Basic 来编写你的应用程序非常理想，但是就有那么一两项非常基本的功能 Visual Basic 无法支持。往往这个时候你得非要调用基本 API 。作为直接使用操作系统 API 的程序员，我们的活动空间完全由 API 来规范，再没有什么其他方式比直接调用 API 更有效、更灵活多样了。”\n\n总结起来，C&#x2F;C++ 语言的开发核心建立在直接调用操作系统 API 的基础上，优点是执行效率高、发挥空间大；缺点是，需要经过系统深入的学习，学习周期长，编写代码较复杂，容易出错。\nLinux C++ 与 Windows C++ 领域之争我之所以把这个标题单独列出来，是想纠正现在很多 C&#x2F;C++ 新人和初学者一些不当的认识，一般有以下几种观点：\n\n\nLinux C++ 开发就是后台开发，而 Windows C++ 开发就是客户端开发；\n后端开发比客户端开发（前端）高级，因此后端开发行业薪资水平比客户端开发薪资要高；\n我只学 Linux，不学 Windows。\n\n\n我相信对于 80 和 90 的这一代开发者来说，当初接触计算机并进入软件行业，都是从接触 Windows 开始的。时至今日，大数据、人工智能等各种新技术方兴未艾，移动互联网如火如荼。无论是 Linux 还是 Windows，尤其是 Windows，仍然是我们大多数人工作、学习、娱乐使用最多的操作系统——我们每天都会使用其上的各种软件。使用这些软件像喝水、呼吸空气一样自然，所以很多人就忽视了这类软件的 “基础作用”。\nWindows 上的软件开发发展了很多年了，这些领域也比较成熟，一般不再招初中级开发，而是需要水平较高、经验较丰富的高级开发者。这让很多人造成了“Windows C++”开发市场需求已经很小了的错觉。试问，QQ PC 部门这些年对外招了多少人？\nLinux C++ 和 Windows C++ 一样，没有孰高孰低之分，只是两种不同的操作系统而已，不要觉得在 Linux 下敲命令就比在 Windows 的图形化界面点击鼠标达高级。\n图形化界面之于命令行，是人们对更高级、更方便的工具追求的必然结果。Linux C++ 也不一定就是后台开发，Windows C++ 也不一定就是客户端开发；所谓的服务器与客户端是个相对的概念，即谁给谁提供服务，提供服务的我们认为是服务端（后台），被服务的我们认为是客户端（前台）。而 Windows 作为后台服务的应用也比比皆是，如笔者之前所在的某交易所的服务器后台都是 Windows 下的 C++ 程序；另外如一些游戏类的服务器端，也不少是 Windows 的。\n借用《UNIX 编程艺术》这本书的观点，Windows 和 Linux 的哲学理念不一样，Windows 是假设你不会操作，它教你如何操作，而 Linux 是假设你会操作然后进行操作。根据这个理念，Windows 一般是普通人用的多，而 Linux 是程序员用的多。\n从编程的角度来说，Windows 的代码风格是所谓的匈牙利命名法，而 Linux 是短小精悍的连字符风格。例如同一个表示屏幕尺寸的整型变量，Windows 上可能被命名为 iScreen 或 cxScreen ，而 Linux 可能是 screen；再例如 Windows 上创建线程的函数叫 CreateThread，Linux 下叫 pthread_create。有时候，我觉得 Windows 的匈牙利命名法反而更容易理解代码。\n这里既然提到前端（客户端）开发和后端开发，这里不得不提一下，这二者没有优劣之分。其侧重点和开发思维是不一样的，前端（客户端）开发一般有较多的界面逻辑，它们是直接与用户打交道，因而一款客户端软件的好坏很大程度上取决于其界面的易用性和流畅性，开发者只要把这一端的“一亩三分地”给管理好即可；而后端服务，对于普通用户是透明的，开发者的程序必须尽量体现“服务”这个字眼，即更有效地为更多的客户端服务，这就要求兼顾请求响应的正确性、及时性和流畅性。\n由于服务软件也是运行在某台物理机器上的程序，鉴于 CPU、内存、网络带宽资源有限，而服务程序一般是长周期运行的，因此必须合理地分配和使用资源（如尽量回收不再使用的各种资源）。开发者应从全局考虑，不能在某个“客户端”这一棵树上“吊死”。\n从个人的职业发展来看，建议从事客户端开发的人员适当地了解一下服务器开发的思路，反过来也建议从事后端开发的人员去学习一下客户端开发，二者相得益彰。从个人的技术提高来说，也是很有帮助的。\n例如您要学习一套开源的软件代码，如果您熟悉客户端和服务器的基本开发和调试技巧，您可以更好地学习它。而在工作上，一个项目，往往是由客户端和服务器程序组成，如果您都熟悉，您可以站在一个更高的角度去审视它、规划它，这也是架构师的基本要求之一。\n最后就是很多读者关心的客户端和服务器的薪资问题，这个没有绝对的谁高谁低，因人而异，因能力而异，因岗位而异。\n如何看待 C++ 11&#x2F;14&#x2F;17 新标准C++ 开发者有个不成文的规定：即使您对 C++ 很熟悉，也不要在简历上写上您精通 C++，原因很简单—— C++ 这门语言包含的东西实在太多了，没有人能真正“精通”所有。\nC++ 既支持面向对象设计（OOP），也支持以模板语法为代表的泛型编程（GP）。而且新的 C++ 标准和遵循 C++ 新标准的编译器也层出不穷，这些年，C++ 变化越来越大、越来越快，从最初业界和开发者翘首以盼的 C++11 标准，历经 C++14、C++17 到今天的 C++20，这门语言与之前的版本差别越来越大，更多原来需要使用第三库的功能也被陆续添加到 C++ 标准库中。以致于 C++ 之父 Bjarne Stroustrup 也开始对这门语言表示担忧：\n\n“C++11 开始的基础建设尚未完成，而 C++17 在使基础更加稳固、规范性和完整性方面，基本没有做出改善。相反地，却增加了重要接口的复杂度，让人们需要学习的特性数量越来越多。C++ 可能在这种不成熟提议的重压之下崩溃，我们不应该花费大量的时间为专家级用户们（比如我们自己）去创建越来越复杂的东西。（还要考虑普通用户的学习曲线，越复杂的东西越不易普及。）”\n\n文章参看这里：https://zhuanlan.zhihu.com/p/48793948，在 Bjarne Stroustrup 的信中，他担心 C++ 会像历史的瓦萨号军舰一样，某天新的标准刚启航（发布）便立即沉没。\n当然，我们不用有这种担忧，毕竟我们既不是 C++ 标准委员会成员，也不是 C++ 编译器开发厂商。就我个人经验来说，对于C++11、C++14、C++17 乃至 C++20，我们学习它们的准则应该是以实用为主，也就是说我们应该学习其实用的部分，至于新标准提到的一些高级特性和各种复杂的模板，我们大可不必去了解。我们并不是做学术研究，我们学习 C++ 是为了投入实际的生产开发，所以应该去学习 C++ 新标准中实用的语法和工具库。关于 C++11 常用一些知识点，这里也简单地给读者列举一下。\n\nauto 关键字\nfor-each 循环\n右值及移动构造函数 + std::forward + std::move + stl 容器新增的 emplace_back() 方法\nstd::thread 库、std::chrono 库\n智能指针系列（std::shared_ptr&#x2F;std::unique_ptr&#x2F;std::weak_ptr），智能指针的实现原理一定要知道，最好是自己实现过\n线程库 std::thread + 线程同步技术库 std::mutex&#x2F;std::condition_variable&#x2F;std::lock_guard 等\nLamda 表达式（Java 中现在也常常考察 Lamda 表达式的作用）\nstd::bind&#x2F;std::function 库\n\n其他的就是一些关键字的用法（override、final、delete），还有就是一些细节如可以像 Java 一样在类成员变量定义处给出初始化值。\nC++ 语言基础与进阶基础这里说的基础不是狭义上的 C++ 语言基础，而是包括 C++ 开发这一生态体系的基础，笔者认为的基础包括：\n\nC++ 语言本身熟练使用程度。\n前面也介绍了单纯的 C++ 您啥也干不了，您必须结合一个具体的操作系统平台，所以得熟悉某个操作系统平台的 API 函数，比如Linux，以及该操作系统的原理。这里说的操作系统的原理不局限于您在操作系统原理图书上看的知识，而是实实在在与系统 API 关联起来的，如熟练使用各种进程与线程函数、多线程资源同步函数、文件操作函数、系统时间函数、窗口自绘与操作函数（这点针对 Windows）、内存分配与管理函数、PE 或 ELF 文件的编译、链接原理等等。\n网络通信，网络通信在这里具体一点就是 Socket 编程。这里的 Socket 编程不仅要求熟练使用各种网络 API 函数，还要求理解和灵活运用像三次握手四次挥手等各种基础网络通信协议与原理。关于 Socket 编程实践，《TCP&#x2F;IP 网络编程》这本书是非常好的入门教材。\n\n说了这么多，您可能会觉得很抽象。笔者在这里举个具体例子。假设我们现在要开发一个类似电驴这样的软件，软件界面如下图：\n\n\n\n如上图所示，假设操作系统选择 Windows，使用语言使用 C++，这就要求您必须熟悉 C++ 常用的语法，如果还不熟悉，就需要补充这方面的知识。\n\n电驴的源码可以在公众号【 高性能服务器开发 】后台回复“获取电驴源码”即可获取。\n\n在熟悉 C++ 语法的前提下，从这款产品实现技术来看，我们的目标产品分为 UI 和网络通信部分。下面将详细介绍这两部分。\nUI 部分对于 UI 部分，我们的认识是，这里需要使用 Windows 的窗口技术。可以直接使用原生的 Win 32 API 来制作自己的界面库，也可以选择一些熟悉的界面框架，如 MFC、WTL、Duilib、wxWidgets 等。无论您是在阅读别人的项目还是需要自己开发这样的项目，在确定了这款软件使用的 UI 库（或者使用原生 Win 32 API），您就需要对 Windows 的窗口、对话框、消息产生、派发与处理机制进行了解。同样的道理，如果不熟悉您需要补充相关的知识（关于这一点，下文不再赘述）。\n接着，根据上图中的软件功能，大致分为三大模块，即资源、下载和分享。这三大块是可以使用一个 Windows Tab 控件去组织，这个时候您需要了解 Windows Tab 控件的特性。\n\n对于资源模块，本质上是一个窗口中嵌入了一个浏览器控件（WebBrowser 控件），那么您需要了解这一个功能点的相关知识。当用户点击了某个列表中某个具体的资源，可以对其进行下载。这就又涉及到 WebBrowser 控件与 C++ 宿主程序的交互了，那么如何实现呢？可以选择使用 ActiveX 技术，也可以使用 JavaScript 与 C++ 交互技术。\n再来看下载模块，当产生一个下载操作时，界面上会产生以下下载列表，每个列表项会实时显示下载进度、下载速率等参数，同时正在下载的项目也可以被暂停、停止和删除。那么这又涉及到 ListView 控件的相关功能，以及 ListView 如何与后台网络通信的逻辑交互。\n分享模块是将本地资源分享到服务器或者给其他用户。界面左侧是文件系统的一个快照，那么这又涉及到如何遍历文件系统（了解枚举文件系统的 API），右侧也是一个 ListView 控件，这里不再赘述。\n\n网络通信部分网络通信部分，主要有两大块，第一个是程序启动时，与服务端的交互；第二个就是文件下载与分享的 P2P 网络。您在阅读或开发的过程中，如果对这些技术比较陌生，您需要补充这些知识，具体的就是 Socket 的各种 API 函数，以及基于这些 API 逻辑的组合。当然可能也会用到操作系统平台所特有的网络 API 函数，如 WSAAsyncSelect 网络模型。\n另外一点，网络通信部分如何与 UI 部分进行数据交换，是使用队列？全局变量？或者相应的 Windows 操作平台提供的特殊通信技术，如 PostMessage 函数、管道？如果使用队列，多线程之间如何保持资源的一致性和解决资源竞态，使用 Event、CriticalSection、Mutex、Semaphore 等？\n当然，笔者这里只列举了这个软件的主干部分，还有许多方方面面的细节需要考虑。这就需要读者根据自己的情况，斟酌和筛选了。您想达到什么目的，就要去学习和研究相关的代码。\n总结起来，可以得到如下公式：\n\n一款 C++ 软件 &#x3D; C++ 语法 + 操作系统 API 函数调用\n\n进阶如果您达到了我上面说的三点后，可以再找一些高质量的开源项目去实战一下。需要注意的是，最好找一些没有复杂业务或者您熟悉其业务的开源项目（如开源的 IM 系统）。如果你不熟悉其业务，不仅要学习其业务（软件功能），还需要再去学习它的源码，最后可能让我们迷失了最初学习这款软件的目的。\n学习这些项目的同时，读者应该先确定自己的学习目的，如果您的目的是学习和借鉴这款软件的架构，那么先从整体去把握，不要一开始就迷失在细枝末节中，这类我称之为“粗读”；或者您的目的是学习开源软件在一些细节上的处理与做法，这个时候，您可以针对性地去阅读您感兴趣的模块，深入到每一行代码上。\n学习开源软件存在一种风气，许多新手喜欢道听途说，一听别人说这个软件不好，那个软件存在某某瑕疵就放弃阅读它的打算了。然后到了实际开发中，因为心中没有任何已有软件开发问题的解决方案，产生挫败感，久而久之就对本来喜欢的 C&#x2F;C++ 开发失去了兴趣。\n学习的过程是先接触，再熟悉，再模仿，再创造。不管什么开源项目，在您心中没有任何思路或者解决方案时，您应该先接触熟悉，不断模仿，做到至少心中有一套对于某场景的解决方案，然后再来谈创新谈批判、改造别人的项目。\n我个人学习一套陌生的开源项目时，总是喜欢将程序用调试器正常跑起来，然后再中断下来，统计当前的线程数目，然后通过程序入口 main 函数从主线程追踪其他工作线程是如何创建的；接着，分析和研究每个线程的用途以及线程之间交互的，这就是整体把握，接着找我感兴趣的细节去学习。\n这里我以学习 Redis 为例。将 Redis 源码从官网下载下来以后，使用喜欢的代码阅读器进行管理。我这里使用的是 Visual Studio，如下图所示：\n\n在大致了解了 Redis 有哪些代码模块以后，我们把代码拷贝到 Linux 平台，然后编译并使用 GDB 调试器跑起来。如下图所示：\n\n然后按 CTRL+C 将 GDB 中断下来，输入 info threads 查看当前程序的所有线程：\n\n接着挨个使用 thread + 线程编号 和 bt 命令去查看每个线程的上下文调用堆栈：\n\n对照每个线程的上下文堆栈，搞清楚其逻辑，并结合主线程，看看每个线程是在何时启动的，端口在何时启动侦听的，等等。做完这一步，关于 redis-server 的框架也基本清楚了。\n接着我们可以选择一个自己感兴趣的命令，搞清楚 redis-cli 与 redis-server 命令的交互流程。\n最后，如果对 redis-server 源码中各种数据结构和细节感兴趣，我们可以进一步深入到具体的代码细节。\n当然，不熟悉 GDB 的读者看笔者这段操作流程比较困难，这是正常的，说明如果想通过调试去研究 Redis 这一款开源软件，您需要去补充一点 GDB 调试的知识。这就是我上文中所说的，针对性地补缺补差。\nC++ 面试关于 C++ 面试，面试的要求到底是侧重代码量、项目经验，还是侧重操作系统、数据结构这种基础知识？我在知乎上曾经专门写过一篇文章来介绍我曾经的 C++ 面试经历和经验，有兴趣的读者可以点击这里查看：https://www.zhihu.com/question/264198516/answer/341999235。\n关于 C++ 面试常见的面试题，可以参考这里：https://zhuanlan.zhihu.com/p/45668078，这篇文章问题点整理得非常详细，读者可以参考一下。\n需要注意的是，不仅仅是 C++ 面试，其他语言开发面试也是一样。如果您是想进入大型互联网公司的应届生，那么您应该优先好好准备算法和数据结构知识以应对面试，这是大型互联网公司面试频率最高的考察范围。至于其他的基础知识，如操作系统原理、网络通信等（作为计算机相关专业的学生，这些应该是您的专业课），如果您已经在平时的学习中掌握得很好，那就不用担心，这类问题一般对于应届生求职不会问得太深；倘若您尚未学得扎实，而春招或秋招又时间临近，没有足够的时间去准备这些，您应该只是尽量去补，实在来不及也没关系，还是应该把重心放在好好准备算法和数据结构等知识上。\n对于社会人士参加的 C++ 职位的面试，如果是大型互联网公司，虽然社会招聘问的更多的是项目经验，适当地为一些基础的算法和数据结构知识做一些准备也是非常有用的。举个例子，如果问到二分查找这一类基础算法，如果答不出来未免会让面试官印象不太好，场面也比较尴尬。另外，C++ 是一门讲究深度的编程技能，对于有一定工作年限的面试者，面试官往往会问很多原理性的细节，这就要求广大 C++ 开发者在平常多留心、多积累、多思考技术背后的原理。\n对于大多数小型企业，无论是应届生还是社会人士，只要有能力胜任一定的工作即可。一般只要对所面试的公司项目有类似经验或者相关的技术能力，基本上就可以通过面试。大多数小公司在乎的是您来了能不能干活，所以这类公司对实际项目经验和技能要求更高一点。\n关于项目经验，许多人可能觉得项目经验一定是自己参与的项目，其实不然，项目经验也可以来源于您阅读和学习其他人的项目代码或者开源软件，只要您能看懂并理解它们，在面试的时候提及到，能条理清晰、自圆其说即可。当然，如果不熟悉或者只是了解些皮毛，切记不可信口开河、胡编乱造甚至张冠李戴。\n我曾经面试过一些开发者，看简历项目经验丰富，实际一问的时候，只是把别人的框架或者库拿来包装调用一下，问及其技术原理时，不是顾左右而言他就是说不清道不明模棱两可含糊不清，这一类人往往比不知道还让人讨厌，面试官一般反感这一类面试者所谓的项目经验。\n学生与社会人士学习 C++ 方式的区别作为学生有充裕的时间，建议除了把 C++ 语法学好，系统地多读一点基础的书籍，如操作系统原理、网络编程、数据结构与算法等相关各方各面的经典书籍。\n可以参考下这里：\n\nhttps://mp.weixin.qq.com/s/EjgtX2Wghia7ajn2AugCtw\n\n尽量做到等您毕业走出校园以后，至少熟悉一门编程语言和其相应的开发环境，这就是一个基础扎实、理论清晰、编码能力强的求职者。可惜的是，从现在的各种招聘反馈来看，大多数学生在求职时，对相关开发工具和语言的陌生程度实在让人瞠目结舌，面试官在面试的时候会很纳闷：这位学生大学四年（或者七年）到底是否调试过程序？\n社会人士由于已经走上工作岗位，家庭、工作的琐事繁多，没有太多的时间去系统地阅读一些相关基础书籍，如果您当前工作正好是从事 C&#x2F;C++ 开发，那么请结合您当前的项目来学习，搞清楚项目的体系结构、吸收项目中优秀的实现细节，针对性地补充相关知识，这是进步最快的方式。\n但是实际情形中，很多人觉得公司的项目代码又烂又杂，不愿意去研究。这种思想千万不能有的，在您没有自己足够好的能力给公司提供更好的解决方案，请先学习和模仿，我们此时要保持“空杯”心态，公司的代码再烂，它也是公司的商业价值所在；即使是纯粹的业务代码，也有它的可取之处，择其善者而从之，其不善者而改之。尤其是开发者处于一些初中级的开发岗位时，可能接触不到公司核心框架的源码，此时千万不要盲目地去排斥。学业务，补基础，时刻意识清醒自己所需，明白自己想要学的东西。\n如果从事的不是 C++ 相关的开发，那么可以挤出一些时间去学习一些开源的代码，在阅读开源代码的过程中，针对性地补缺补差。不建议系统地去看《C++ Primer 中文版》《UNIX 环境高级编程》诸如此类的大部头书籍，实际开发中不需要太多这类书中的细枝末节，阅读这类书往往只会事倍功半，甚至最后因书籍太厚、时间不够，最后坚持不下去，最终放弃。\n当然，对于社会人士，当您有一定的时间的时候一定要去补充一些基础的、原理性的东西，千万不要沉溺于“面向搜索引擎编程”或者“面向工资编程”，有些问题虽然当时通过搜索引擎解决了，但如果想在技术或职业上有长足的发展，一定要系统地去读一些经典的、轻量级的书籍（如《C++ 对象模型》）。长期在网上的文章中寻章摘句，只会让您的知识结构碎片化、凌乱化，甚至混乱化。而且互联网上的技术文章质量良莠不齐，有时候也容易对自己形成误导和依赖。总而言之，作为技术开发人员，提高自己技术水平是改变现状、改善生活最直接的途径。\n小结关于 C&#x2F;C++，暂且就讨论这么多。最后再强调一遍，C++ 是一门讲究深度的语言，其“深度”不是体现在会多少 C++ 语法，而是能够洞察您所写的 C++ 代码背后的系统原理，这是需要长期不断的积累的，没有速成之法。反过来一旦学成，可以快速地学习其他语言和框架。个人觉得，如果自主创业或者想在二三线城市长期发展的读者，C&#x2F;C++ 应该是优选语言，有了它作为基础，您可以跳出依赖各种环境和框架的窠臼，快速地学习和开发您想要的软件，完成您想要的业务产品。\n最后，限于笔者经验水平有限，欢迎读者就文中的观点提出宝贵的建议和意见。如果想获得更多的学习资源或者想与我做进一步交流，可以加我微信 easy_coder 一起交流。\n\n文中提到的电驴的源码可以在公众号【 高性能服务器开发 】后台回复“获取电驴源码”即可获取。\n\n","slug":"转载/cpp/如何成为一名合格的CC++开发者？","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"171b5e45338b6064c4b33120174da47b","title":"【转载】深入理解CC++中的指针","content":"深入理解C&#x2F;C++中的指针C和C++中最强大的功能莫过于指针了（pointer），但是对于大多数人尤其是新手来说，指针是一个最容易出错、也最难掌握的概念了。本文将从指针的方方面面来讲述指针的概念和用法，希望对大家有所帮助。\n内存模型为了更好地理解指针，让我们来看一下计算机的内存模型。\n内存分为物理内存和虚拟内存，物理内存对应计算机中的内存条，虚拟内存是操作系统内存管理系统假象出来的。由于这些不是我们本文的重点，下面不做区分。有不清楚这些概念的同学，可以给我留言或者在线询问。\n在不考虑cpu缓存的情况下，计算机运行程序本质上就是对内存中的数据的操作，通俗地来说，就是将内存条某些部分的数据搬进搬出或者搬来搬去，其中“搬进搬出”是指将内存中的二进制数据搬入cpu寄存器及运算器中进行相应的加减运算或者将寄存器中的数据搬回内存单元中，而“搬来搬去”是指将内存中的数据由这个位置搬到另外一个位置（当然，一般不是直接搬，而是借助寄存器作为中间存储区）。如下图所示：\n\n计算机为了方便管理内存，将内存的每个单元用一个数字编号，如下图所以：\n\n图中所示，是一个大小为128个字节的内存空间，其中每一个空格代表一个字节，所以内存编号是0~127。\n对于一个32位的操作系统来说，内存空间中每一个字节的编号是一个32位二进制数，所以内存编号从0000 0000 0000 0000 0000 0000 0000 0000至1111 1111 1111 1111 1111 1111 1111 1111，转换成16进制也就是0x00000000至0xFFFFFFFF，由于是从0开始的，所以化成10机制就是从0至2的32次方减1；对于64位操作系统，内存编号也就是从64个0至64个1。\n大家需要注意的是，从上面两个图我们可以发现，我们一般将编号小的内存单元画在上面，编号大的画在下面，也就是说从上至下，内存编号越来越大。\n指针与指针变量指针的本意就是内存地址，我们可以通俗地理解成内存编号，既然计算机通过编号来操作内存单元，这就造就了指针的高效率。\n那么什么是指针变量呢？指针变量可通俗地理解成存储指针的变量，也就是存储内存地址（内存编号）的变量。首先指针变量和整型变量、字符型变量以及其他数据类型的变量一样都是变量类型；但是，反过来，我们不应该按这样的方式来分类，即：整型指针变量、字符型指针变量、浮点型指针变量等等。为什么不推荐这样的分类方法呢？首先，指针变量就是一个数据类型，指针数据类型，这种数据类型首先是一个变量数据类型，那么它的大小是多少呢？很多同学理所当然地认为整型指针变量和一个字符指针变量的大小是不一样的，这种认识是错的。指针变量也是一个变量，它是一个用来存储其他变量的内存地址的，更准确地说，指针变量时用来存储其他变量的内存首地址的，因为不同的数据类型所占的内存大小不一样。举个例子，在32位机器上，假如a是int型变量，pa是指向a的指针变量，b是一个double型变量，pb是指向b的指针变量，那么a在内存中占四个字节，b在内存中占8个字节，假如a在内存中分布是从0x11111110~0x11111113，而b在内存中分布是0x11112221至0x11112228，那么指针变量pa中存储的内容是0x11111110，而pb中存储就是0x11112221，看到了吧，也就是说，pa和pb中存储的都是地址，而且都是32位的二进制地址；再者，因为存储这样的地址需要4个字节，所以无论是int型指针变量pa或者是double型指针变量pb，它们所占的内存大小都是四个字节，从这点来说，不管什么类型的指针都是一样的，所以不论按整型指针变量、字符型指针变量、浮点型指针变量等等来区分指针变量。总结起来，指针变量和int、float、char等类型一样同属变量类型，指针变量类型占四个字节（32位机器下），存储的是32位的内存地址。下面的代码证明这一点：\n\n\n上面介绍的是指针变量的一个方面，指针变量还有另外一层含义：在C&#x2F;C++中星号（*）被定义成取内容符号，虽然所有指针变量占的内存大小和存储的内存地址大小都是一样的，但是由于存储的只是数据的内存首地址，所以指针变量存储的内存地址所指向的数据类型决定着如何解析这个首地址，也就是说对于int型指针变量，我们需要从该指针变量存储的（首）地址开始向后一直搜索4个字节的内存空间，以图中的变量a为例就是从0x12ff600x12ff63，对于变量b就是0x12ff440x12ff4b。所以从这个意义来上讲，当我们使用*pa，必须先知道pa是一个整型的指针，这里强调“整型”，而a的值1也就存储在从0x12ff600x12ff63这四个字节里面，当我们使用*pb，必须先知道pb是一个double型指针，这里强调”double”,也就是说值2.0000存储在0x12ff440x12ff4b这八个字节里面。因此，我们对指针变量进行算术运算，比如pa + 2,pb + +之类的操作，是以数据类型大小为单位的，也就是说pa + 2,相当于0x12ff60 + sizeof(int) * 2 &#x3D; 0x12ff60 + 4 * 2 &#x3D; 0x12ff68,不是0x12ff60 + 2哦；而pb - -相当于0x12ff44 + sizeof(double) * 1 &#x3D; 0x12ff44 + 8 * 1 &#x3D; 0x12ff4c。理解这一点很重要。 同理&amp;a + 2和&amp;b - 1也是一样（注意由于&amp;b是一个指针常量，所以写成&amp;b - -是错误的）。\n指针变量和指针常量指针变量首先是一个变量，由于指针变量存储了某个变量的内存首地址，我们通常认为”指针变量指向了该变量“，但是在这个时刻指针变量pa指向变量a，下个时候可能不存储变量a的首地址，而是存储变量c的首地址，那么我们可以认为这个时候，pa不再指向a，而是指向c。请别嫌我啰嗦，为了帮助你理解，我是故意说得这么细的，后面我们讨论高级主题的时候，当你觉得迷糊，请回来反复咀嚼一下这段话。也就是说指针变量是一个变量，它的值可以变动的。\n相反，指针常量可通俗地理解为存储固定的内存单元地址编号的”量“，它一旦存储了某个内存地址以后，不可再改存储其他的内存地址了。所以指针常量是坚韧，因为它”咬定青山不放松“；说是”痴情“，因为它”曾经沧海难为水“。我这里讲的指针常量对应的是const关键字定义的量，而不是指针字面量。像&amp;a, &amp;b, &amp;a + 2等是指针字面量，而const int *p &#x3D; &a;中的p才算是真正的指针常量，指针常量一般用在函数的参数中，表示该函数不可改变实参的内容。来看一个例子吧：\n\n上面的函数由于修改了一个常指针（多数情况下等同指针常量），因而会编译出错：error C3892: “x”: 不能给常量赋值。\n指针变量与数组记得多年以前，我在学生会给电子技术部和地理信息系统专业的同学进行C语言培训时，这是一个最让他们头疼和感到一头雾水的话题，尤其是指针变量与二维数组的结合，我永远忘不了胡永月那一脸迷惑与无助的表情。今天我这里给大家深入地分析一下。先看一个例子：\n\n如果你能得出下面这样的结果，说明你已经基本上对数组与指针的概念理解清楚了：\n\n通过上图，我们可以知道*(a + 1) &#x3D; 2, *(ptr - 1) &#x3D; 5。\n且不说很多同学根本得不到这样的结果，他们看到int ptr &#x3D; (int)(&amp;a+1);这样的语句就已经懵了，首先，我们知道C语言中规定数组名表示这个数组的首地址，而这里竟然出现了&amp;a这样的符号，本来a就是一个指针常量了，这里对&amp;a再次取地址难道不是非法操作吗？哈哈，当你有这样的疑问的时候，说明你对二维数组相关知识理解不深入。我这里先给你补充下知识点吧：\n看这样一个二维数组：int arr[3][4],这个数组布局如下：\n\n这是一个3行4列的数组，它在内存中的分布如下：\n\n这里每一个数组元素占4字节空间，我们知道C语言规定，数组名arr是整个数组元素的首地址，比如是0x0012ff08,而像arr[0]、arr[1]、arr[2]分别是数组第一行、第二行、第三行的首地址，也就是0x0012ff08、0x0012ff18、0x0012ff28。\n我们把arr、arr[0]和&amp;arr[0][0]单独拿出来分析，因为数组的首地址也是第一列的首地址，同时也是第一个元素的首地址，所以arr和arr[0]和&amp;arr[0][0]表示的都是同一个地址，但是这三个首地址在进行算术运算时是有区别的。如果&amp;arr[0][0] + 1，这里的相当于跳一个元素的内存字节数，也就是4个；但是arr[0] + 1，移动的内存字节数是一列元素所占的字节数，也就是4 * 4 &#x3D; 16个；最后，也是最让人迷惑的的就是arr + 1,这个时候移动的内存数目是整个数组占的内存字节数，也就是48个字节数，所以a + 1所表示的内存地址已经不属于这个数组了，这个地址位于数组最后一个元素所占内存空间的下一个字节空间。\n光有这些知识还是不能解决上面的问题，我们再补充一个知识点。\nC++是一种强类型的语言，其中有一种类型叫void类型，从本质上说void不是一种类型，因为变量都是”有类型“的，就好像人的性别，不是男人就是女人，不存在无性别的人，所以void更多是一种抽象。在程序中，void类型更多是用来”修饰“和”限制“一个函数的：例如一个函数如果不返回任何类型的值，可以用void作返回类型；如果一个函数无参数列表，可以用void作为参数列表。\n跟void类型”修饰“作用不同，void型指针作为指向抽象数据的指针，它本质上表示一段内存块。如果两个指针类型不同，在进行指针类型赋值时必须进行强制类型转换，看下面的例子：\n\n但是可以将任何指针类型赋值给void类型而无须进行强制类型转换：\n\n当然，如果把void型指针转换成并不是它实际指向的数据类型，其结果是不可预测的。试想，如果把一个int型指针赋给void型，然后再把这个void型指针强制转换成double型指针，这样的结果是不可预测的。因为不同数据类型所占内存大小不一样，这样做可能或截断内存数据或者会增加一些未知的额外数据。所以，最好是将void类型指针转换成它实际数据类型指针。\n有了上面的说明，你应该能看懂C函数库中下面这个函数的签名含义了吧？\n1void *memcpy(void *dest,const void *src,size_t len);\n\n在这里，任何数据类型的指针都可以传给这个函数，所以这个函数成为了一个通用的内存复制函数。\n好了，说了这么多，回答最初的那个问题上：\n\n我们来分析一下。首先，我们可以将这个数组看成是一个特殊的二维数组，也就是1行5列的二维数组，现在a表示的是第一个元素的首地址，那么a + 1指向的就是下一个元素的内存首地址，所以*(a + 1) &#x3D; 2；而&amp;a则是表示整个数组的首地址，那么&amp;a + 1移动的内存数目就是整个数组所占字节数，假如这里我们量化来说明，假如原先数组中第一个元素的首地址是1,那么&amp;a + 1表示的就是21，而这个地址已经不属于数组了，接着通过(int*)(&amp;a + 1)将数组指针转换成整型指针，这样原先&amp;a + 1表示的数据范围是2140一下缩小到2124,正好是一个int型的大小，所以ptr - 1的存储的地址就是17了，表示的数据内存范围是17~20,这样*(ptr - 1)正好就是最后一个元素5了。\n但是话说回来，首先这样的转换安全与否尚有争议，再次，这样的程序晦涩难懂，难于理解，所以建议不要写出这样的程序。\n上面的例子，只是通过一些简单的数据类型来说明内存分布，但是实际对于一些复杂的数据类型，尤其是一些自定义的类或者结构体类型，内存分布必须还要充分考虑到字节对齐。比如下面的代码： \n\n这是输出结果：\n\n由于结构体s1中存在字节对齐现象（以sizeof(double) &#x3D; 8个字节对齐），所以s1占据24字节内存，而s2只占16个字节。知道这点，我们平常在设计结构体字段的时候，就可以合理安排字段顺序来使用更少的内存空间了。\n函数指针函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C&#x2F;C++程序在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是一致的。函数指针有两个用途：调用函数和做函数的参数。\n我们先来先使用函数指针调用函数。如下图所示：\n\n上面的代码首先是定义了一个函数f，然后是定义一个函数指针pf，接着在主函数里面将函数f的地址赋值给函数指针，这样pf就指向了函数f，这样使用*pf就可以直接调用函数了。但是上面的例子定义函数指针的方法在某些编译器中是无法通过的，最好通过typedef关键字定义函数指针，推荐的写法如下：\n\n通过上面的例子，我们来总结下函数指针的定义和使用方法：\n首先，通过typedef关键字定义一个函数指针类型，然后定义一个该函数指针类型变量，接着将函数的入口地址赋值给该函数指针类型变量，这样就可以通过这个函数指针变量调用函数了。\n需要注意的是，定义函数指针类型时的函数签名（包括函数返回值和函数参数列表的类型、个数、顺序）要将赋值给该类型变量的函数签名保持一致，不然可能会发生很多无法预料的情况。还有一点，就是C&#x2F;C++规定函数名就表示函数入口地址，所以，函数名赋值时函数名前面加不加取地址符&amp;都一样，也就是说PF pf &#x3D; f等价于PF pf &#x3D; &amp;f。这个**&amp;是可以省略**的。但是这是单个函数的情况，在C++中取类的方法函数的地址时，这个&amp;符号式不能省略的，见下面的例子：\n\n函数指针的另外一个用处，而且是用的最多的，就是作为一个函数的参数。也就是说某个函数的某个参数类型是一个函数，这在windows编程中作为回调函数(callback)尤其常见。我们来看一个例子：\n\n上图中，函数f2第一个参数类型是一个函数，我们传入函数f1作为参数。这种函数参数是函数类型的用法很重要，建议大家掌握。\n指针变量的定义方法先插播一段广告，说下main函数的返回值问题，如下图：\n\n这种main函数无返回值的写法，在国内各大C&#x2F;C++教材上屡见不鲜，这种写法是错误的！\n有一点你必须明确：C&#x2F;C++标准中从来没有定义过void main()这样的代码形式。C++之父Bjarne Stroustrup在他的主页FAQ中明确地写了这样一句话：\n\n在C++中绝对没有出现过void main(){ &#x2F;* … *&#x2F; } 这样的函数定义，在C语言中也是。\n\nmain函数的返回值应该定义为int型，在C&#x2F;C++标准中都是这样规定的。在C99标准规定，只有以下两种定义方式是正确的的：\n121 int main(void);2 int main(int argc,char *argv[]);\n\n虽然在C和C++标准中并不支持void main()，但是在部分编译器中void main()依旧是可以通过编译并执行的，比如微软的VC++。由于微软产品的市场占有率和影响力很大，因为在某种程度上加剧了这种不良习惯的蔓延。不过，并非所有犯人编译器都支持void main()，gcc就站在VC++的对立面，它是这一不良习气的坚定抵制者，它会在编译时明确地给出一个错误。\n广告播完，我们回到正题上来。我们来看下如何定义一个指针，首先看一个例子：\n\n我来替你回答吧，你肯定认为a是一个指针变量，b是一个整型变量，c和d都是一个指针变量。好吧，恭喜你，答错了！\n其实定义指针变量的时候，星号(*)无论是与数据类型结合还是与变量名结合在一起都是一样的！但是，为了便于理解，还是推荐大家写成第一种形式，第二种形式容易误导人，不是吗？而且第一种形式还有一个好处，我们可以这样看：\n1int *a;  //将*a看成一个整体，它是一个int型数据，那么a自然就是指向*a的指针了。\n\n说完定义指针的方法，下面我们来看下如何初始化一个指针变量，看下面的代码：\n\n上面的代码有错误吗？\n错误在于我们不能这样写：int *p &#x3D; 1; 由于p是一个匿名指针，也就是说p没有正确的初始化，它可能指向一个不确定的内存地址，而这个内存地址可能是系统程序内存所在，我们将数值1装入那个不确定的内存单元中是很危险的，因为可能会破坏系统那个内存原来的数据，引发异常。换另一个方面来看，将整型数值1直接赋值给指针型变量p是非法的。 \n这样的指针我们称为匿名指针或者野指针。和其他变量类型一样，为了防止发生意料之外的错误，我们应该给新定义的指针变量一个初始值。但是有时候，我们又没有合适的初始值给这个指针，怎么办？我们可以使用NULL关键字或者C++中的nullptr。代码如下： \n\n通过上面的写法就告诉编译器，这两个指针现在不会指向不确定的内存单元了，但是目前暂时不需要使用它们。　\nC++中的引用C++中不仅有指针的概念，而且还存在一个引用的概念，看下面的代码：\n\n我开始在接触这个概念的时候，老是弄错。当时这么想的，既然b是a的引用，那么&amp;b应该等于a吧?也就是说，在需要使用变量a的时候，可以使用&amp;b来代替。\n上面的这种认识是错误的！所谓引用，使用另外一个变量名来代表某一块内存，也就是说a和b完全是一样，所以任何地方，可以使用a的，换成b也可以，而不是使用&amp;b，这就相当于同一个人有不同的名字，但是不管哪个名字，指的都是同一个人。\n\n新手在刚接触引用的使用，还有一个地方容易出错，就是忘记给引用及时初始化，注意这里的“及时”两个字，C++规定，定义一个引用时，必须马上初始化。看下面的代码：\n\n传值还是传引用(by value or by reference)看下面的伪代码：\n\n在涉及到利用一个已有初值的变量给另外一个变量赋值时，必须考虑这样的情况。图中变量a已经有了初值，然后利用a来给b赋初值，那么最后改变b的值，a的值会不会受影响呢？这就取决于b到底是a的副本还是和a同时指向同一内存区域，这就是我们常说的赋值时是传值还是传引用。各大语言都是这样规定的，也就是说不局限于C&#x2F;C++，同时Java、C#、php、javascript等都一样：\n\n如果变量类型是基元数据类型（基础数据类型），比如int、float、bool、char等小数据类型被称为基元数据类型(primitive data type)，那么赋值时传的是值。也就是说，这个时候b的值是a的拷贝，那么更改b不会影响到a，同理更改a也不会影响到b。\n\n\n但是，如果变量类型是复杂数据类型(complex data type)，不如数组、类对象，那么赋值时传的就是引用，这个时候，a和b指向的都是同一块内存区域，那么无论更改a或者b都会相互影响。\n\n让我们来深入地分析下，为什么各大语言都采取这种机制。对于那些基元数据类型，由于数据本身占用的内存空间就小，这样复制起来不仅速度快，即使这样的变量数目很多，总共也不会占多大空间。但是对于复杂数据类型，比如一些类对象，它们包含的属性字段就很多，占用的空间就大，如果赋值时，也是复制数据，那么一个两个对象还好，一旦多一点比如10个、100个，会占很大的内存单元的，这就导致效率的下降。\n最后，提醒一点，在利用C++中拷贝构造函数复制对象时需要注意，基元数据类型可以直接复制，但是对于引用类型数据，我们需要自己实现引用型数据的真正复制。\nC&#x2F;C++中的new关键字与Java、C#中的关键字对比\n我大学毕业的时候痴迷于于网页游戏开发，使用的语言是flash平台的actionscript 3.0（简称as3，唉，如今已经没落），我刚开始由as3转行至C&#x2F;C++，对于C&#x2F;C++中new出来的对象必须通过指针对象来引用它非常不习惯。上图中,Object是一个类(class)，在Java或者C#等语言中，通过new关键字定义一个对象，直接得到Object的实例，也就是说后续引用这个对象，我们可以直接使用obj.property或者**obj.method()等形式，但是在C++中不行，比如用一个指针去接受这个new出来的对象，我们引用这个对象必须使用指针引用运算符-&gt;**，也就是我们需要这样写：pObj-&gt;property或pObject-&gt;method()。代码如下：\n\n当然C++中还有一种不需要使用指针就可以实例化出来类对象的方法，从Java、C#等转向C++的程序员容易误解为未初始化对象变量的定义，看下列代码：\n\n这是C++中利用Object类实例化两个对象obj1和obj2，obj2因为调用构造函数传了两个参数param1,param2还好理解一点，对于obj1很多Java或者C#的程序员开始很难接受这种写法，因为如果放在Java或者C#中，obj1根本就没有被实例化嘛，在他们看来，obj1只是一个简单的类型申明。希望Java、C#等程序员要转换过思维来看待C++中的这种写法。\n还有一点也容易出错，在C++中，this关键字是一个指针，而不是像在Java、C#中是一个类实例。也就是说，在C++中*this才等价于Java、C#中的this。所以写法也就不一样了：\n\n\nWindows编程中的指针Windows是操作系统是用C语言写出来的，所以尽管你在Windows中看到很多不认识的数据类型，但是这些数据类型也是通过基本的C语言类型组装起来的。我们这里只介绍Windows中指针型数据。\n定义指针数据类型必须使用星号(*)，但是Windows为了开发的方便，通过宏定义将指针“隐藏起来”，严格地说应该是将星号隐藏起来了，下面给出一些例子：\n\nC++中的智能指针为了保持内容的完整性，暂且列一个标题放在这里，这个话题请参考本专题相关文章。\n我能想到的关于C&#x2F;C++中指针的内容就这么多了，希望本文对你有用。文中如果有不当或者纰漏的地方欢迎批评指正。\n","slug":"转载/cpp/深入理解CC++中的指针","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"c1544df243e5ebe89f100e61b30feb98","title":"【转载】用VisualStudio调试Linux程序","content":"用Visual Studio调试Linux程序用Visual Studio调试Linux程序？你真的没看错，这个是真的，不是标题党。当然如果你说VS2015及以上版本自带的Linux调试插件，那就算了。这些自带的插件调试一个有简单的main函数程序还凑合，稍微复杂点的程序，根本无法编译调试。\n而本文介绍的主角是VS的另外一款插件Visual GDB，让我们欢迎主角登场，下面是正文。\n使用Visual Studio+VisualGDB调试远程Linux程序需要工具：\n\nVisual Studio 2013或以上版本（以下简称VS）\nVisualGDB（一款VS插件，官网为：http://visualgdb.com/）\n含有调试符号的Linux程序文件（该程序文件为调试目标）\nVisual Assistant（番茄助手，另外一款VS插件）\n\n在VS上安装完VisualGDB插件以后，有如下几种方式来对远程Linux机器上的程序进行调试：\n\n方法一、如果该程序已经启动，则可以使用VS菜单【Debug】-&gt;【Attach to Process…】。\n\n\n\n\n\n\n这种方法有个缺点是，不能从开始启动的main函数处添加断点，自始至终地调试程序，查看完整程序运行脉络，所以下面推荐方法二。\n\n方法二、利用VS启动远程Linux机器上一个Linux程序文件进行调试。选择VS菜单【Debug】 -&gt;【Quick Debugwith GDB】。\n\n\n需要注意的地方，已经在上图中标红框。这里简单地解释一下：\n如果你安装了交叉编译环境Target可以选择MinGW&#x2F;Cygwin，否则就选择远程Linux系统。这里如果不存在一个ssh连接，则需要创建一个。 \nDebugged program是需要设置的被调试程序的路径，位于远程Linux机器上。\nArguments是该调试程序需要设置的命令行参数，如果被调试程序不需要命令行参数可以不设置。\nWorking directory是被调试程序运行的工作目录。\n另外建议勾选上Initial breakpoint in main，这样启动调试时，程序就会停在程序入口处。\n这样，我们就可以利用VS强大的功能去查看程序的各种状态了，常用的面板，如【内存】【线程】【观察】【堆栈】【GDB Session】【断点】等窗口位于VS 菜单【Debug】-&gt;【Windows】菜单下，注意，有些窗口只有在调试状态下才可见。这里有两个值得强调一下的功能是：\n\nGDB Session****窗口，在这个窗口里面可以像原来直接使用gdb调试一样输入gdb指令来进行调试。\n\n\n\nSSH console****窗口，这个窗口类似一个远程操作Linux系统的应用程序如xshell、SecureCRT。\n\n\n现在还剩下一个问题，就是我们虽然在调试时可视化地远程查看一个Linux进程的状态信息，但很多类型的定义和什么却无法看到。解决这个问题的方法就是你可以先在VS里面建立一个工程，导入你要调试的程序的源代码目录。然后利用方法一或者方法二去启动调试程序。这个时候你想查看某个类型的定义或什么只要利用Visual Assit的查看源码功能即可，快捷键是Alt + G。\n\n需要注意的时：同时安装了Visual Assist和VisualGDB后，后者也会提供一个go按钮去查找源码定义，但这个功能远不如Visual Assist按钮好用，我们可以禁用掉它来使用Visual Assist的Go功能。禁用方法，打开菜单：【Tools】-&gt;【Option…】:\n\n然后重启VS即可。\n到这里，既可以查看源码，也可以调试程序了。\nVisualGDB 下载地址：\n链接：https://share.weiyun.com/57aGHLM 密码：kj9ahs\n","slug":"转载/cpp/用VisualStudio调试Linux程序","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"ca4f18d64c449f5b0232c48e6847b463","title":"【转载】详解C++11中的智能指针","content":"详解 C++ 11 中的智能指针C&#x2F;C++ 语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在 C&#x2F;C++ 语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如 boost，智能指针技术应运而生。\nC++ 98&#x2F;03 的尝试——std::auto_ptr在 2019 年讨论 std::auto_ptr 不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11 标准的出现（最新标准是 C++20），std::auto_ptr 已经被彻底废弃了，取而代之是 std::unique_ptr。然而，我之所以还向你介绍一下 std::auto_ptr 的用法以及它的设计不足之处是想让你了解 C++ 语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？\nstd::auto_ptr 的基本用法如下代码所示：\n123456789101112#include &lt;memory&gt;int main()&#123;    //初始化方式1    std::auto_ptr&lt;int&gt; sp1(new int(8));    //初始化方式2    std::auto_ptr&lt;int&gt; sp2;    sp2.reset(new int(8));    return 0;&#125;\n\n智能指针对象 sp1 和 sp2 均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在 sp1 和 sp2 释放时得到释放。这是 std::auto_ptr 的基本用法。\n\nsp 是 smart pointer（智能指针）的简写。\n\nstd::auto_ptr 真正让人容易误用的地方是其不常用的复制语义，即当复制一个 std::auto_ptr 对象时（拷贝复制或 operator &#x3D; 复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;memory&gt;int main()&#123;    //测试拷贝构造    std::auto_ptr&lt;int&gt; sp1(new int(8));    std::auto_ptr&lt;int&gt; sp2(sp1);    if (sp1.get() != NULL)    &#123;        std::cout &lt;&lt; &quot;sp1 is not empty.&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;sp1 is empty.&quot; &lt;&lt; std::endl;    &#125;    if (sp2.get() != NULL)    &#123;        std::cout &lt;&lt; &quot;sp2 is not empty.&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;sp2 is empty.&quot; &lt;&lt; std::endl;    &#125;    //测试赋值构造    std::auto_ptr&lt;int&gt; sp3(new int(8));    std::auto_ptr&lt;int&gt; sp4;    sp4 = sp3;    if (sp3.get() != NULL)    &#123;        std::cout &lt;&lt; &quot;sp3 is not empty.&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;sp3 is empty.&quot; &lt;&lt; std::endl;    &#125;    if (sp4.get() != NULL)    &#123;        std::cout &lt;&lt; &quot;sp4 is not empty.&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;sp4 is empty.&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n上述代码中分别利用拷贝构造（sp1 &#x3D;&gt; sp2）和 赋值构造（sp3 &#x3D;&gt; sp4）来创建新的 std::auto_ptr 对象，因此 sp1 持有的堆对象被转移给 sp2，sp3 持有的堆对象被转移给 sp4。我们得到程序执行结果如下：\n123456[root@iZ238vnojlyZ testx]# g++ -g -o test_auto_ptr test_auto_ptr.cpp[root@iZ238vnojlyZ testx]# ./test_auto_ptr sp1 is empty.sp2 is not empty.sp3 is empty.sp4 is not empty.\n\n由于 std::auto_ptr 这种不常用的复制语义，我们应该避免在 stl 容器中使用 std::auto_ptr，例如我们绝不应该写出如下代码：\n1std::vector&lt;std::auto_ptr&lt;int&gt;&gt; myvectors;\n\n当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。\n以史为鉴，作为 std::auto_ptr 的替代者 std::unique_ptr 吸取了这个经验教训。下文会来详细介绍。\n正因为 std::auto_ptr 的设计存在如此重大缺陷，C++11 标准在充分借鉴和吸收了 boost 库中智能指针的设计思想，引入了三种类型的智能指针，即 std::unique_ptr、std::shared_ptr 和 std::weak_ptr。\n\nboost 还有 scoped_ptr，C++11 并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过 std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。\n\n所有的智能指针类（包括 std::unique_ptr）均包含于头文件 **** 中。\n\n正因为存在上述设计上的缺陷，在 C++11及后续语言规范中 std::auto_ptr 已经被废弃，你的代码不应该再使用它。\n\nstd::unique_ptrstd::unique_ptr 对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是 1，std::unique_ptr 对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个 std::unique_ptr 对象：\n123456789//初始化方式1std::unique_ptr&lt;int&gt; sp1(new int(123));//初始化方式2std::unique_ptr&lt;int&gt; sp2;sp2.reset(new int(123));//初始化方式3std::unique_ptr&lt;int&gt; sp3 = std::make_unique&lt;int&gt;(123);\n\n你应该尽量使用初始化方式 3 的方式去创建一个 std::unique_ptr 而不是方式 1 和 2，因为形式 3 更安全，原因 Scott Meyers 在其《Effective Modern C++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。\n\n令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared() 方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique() 方法创建一个 std::unique_ptr 对象，这个方法直到 C++14 才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：\n\n12345template&lt;typename T, typename... Ts&gt;std::unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp; ...params)&#123;    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Ts&gt;(params)...));&#125;\n\n鉴于 std::auto_ptr 的前车之鉴，std::unique_ptr 禁止复制语义，为了达到这个效果，std::unique_ptr 类的拷贝构造函数和赋值运算符（operator &#x3D;）被标记为 delete。\n123456789template &lt;class T&gt;class unique_ptr&#123;    //省略其他代码...    //拷贝构造函数和赋值运算符被标记为delete    unique_ptr(const unique_ptr&amp;) = delete;    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;&#125;;\n\n因此，下列代码是无法通过编译的：\n1234567std::unique_ptr&lt;int&gt; sp1(std::make_unique&lt;int&gt;(123));;//以下代码无法通过编译//std::unique_ptr&lt;int&gt; sp2(sp1);std::unique_ptr&lt;int&gt; sp3;//以下代码无法通过编译//sp3 = sp1;\n\n禁止复制语义也存在特例，即可以通过一个函数返回一个 std::unique_ptr：\n1234567891011121314#include &lt;memory&gt;std::unique_ptr&lt;int&gt; func(int val)&#123;    std::unique_ptr&lt;int&gt; up(new int(val));    return up;&#125;int main()&#123;    std::unique_ptr&lt;int&gt; sp1 = func(123);    return 0;&#125;\n\n上述代码从 func 函数中得到一个 std::unique_ptr 对象，然后返回给 sp1。\n既然 std::unique_ptr 不能复制，那么如何将一个 std::unique_ptr 对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：\n12345678910111213#include &lt;memory&gt;int main()&#123;    std::unique_ptr&lt;int&gt; sp1(std::make_unique&lt;int&gt;(123));    std::unique_ptr&lt;int&gt; sp2(std::move(sp1));    std::unique_ptr&lt;int&gt; sp3;    sp3 = std::move(sp2);    return 0;&#125;\n\n以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给 sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2 不再持有堆内存的引用，变成一个空的智能指针对象。并不是所有的对象的 std::move 操作都有意义，只有实现了移动构造函数（Move Constructor）或移动赋值运算符（operator &#x3D;）的类才行，而 std::unique_ptr 正好实现了这二者，以下是实现伪码：\n1234567891011121314151617181920212223template&lt;typename T, typename Deletor&gt;class unique_ptr&#123;    //其他函数省略...public:    unique_ptr(unique_ptr&amp;&amp; rhs)    &#123;        this-&gt;m_pT = rhs.m_pT;        //源对象释放        rhs.m_pT = nullptr;    &#125;    unique_ptr&amp; operator=(unique_ptr&amp;&amp; rhs)    &#123;        this-&gt;m_pT = rhs.m_pT;        //源对象释放        rhs.m_pT = nullptr;        return *this;    &#125;private:    T*    m_pT;&#125;;\n\n这是 std::unique_ptr 具有移动语义的原因，希望读者可以理解之。关于移动构造和 std::move，我们将在后面章节详细介绍。\nstd::unique_ptr 不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：\n1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;memory&gt;int main()&#123;    //创建10个int类型的堆对象    //形式1    std::unique_ptr&lt;int[]&gt; sp1(new int[10]);    //形式2    std::unique_ptr&lt;int[]&gt; sp2;    sp2.reset(new int[10]);    //形式3    std::unique_ptr&lt;int[]&gt; sp3(std::make_unique&lt;int[]&gt;(10));    for (int i = 0; i &lt; 10; ++i)    &#123;        sp1[i] = i;        sp2[i] = i;        sp3[i] = i;    &#125;    for (int i = 0; i &lt; 10; ++i)    &#123;        std::cout &lt;&lt; sp1[i] &lt;&lt; &quot;, &quot; &lt;&lt; sp2[i] &lt;&lt; &quot;, &quot; &lt;&lt; sp3[i] &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n程序执行结果如下：\n123456789101112[root@myaliyun testmybook]# g++ -g -o test_unique_ptr_with_array test_unique_ptr_with_array.cpp -std=c++17[root@myaliyun testmybook]# ./test_unique_ptr_with_array 0, 0, 01, 1, 12, 2, 23, 3, 34, 4, 45, 5, 56, 6, 67, 7, 78, 8, 89, 9, 9\n\nstd::shared_ptr 和 std::weak_ptr 也可以持有一组堆对象，用法与 std::unique_ptr 相同，下文不再赘述。\n自定义智能指针对象持有的资源的释放函数\n默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete 或者 delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个 Socket 类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以 std::unique_ptr 为例：\n123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;memory&gt;class Socket&#123;public:    Socket()    &#123;    &#125;    ~Socket()    &#123;    &#125;    //关闭资源句柄    void close()    &#123;    &#125;&#125;;int main()&#123;    auto deletor = [](Socket* pSocket) &#123;        //关闭句柄        pSocket-&gt;close();        //TODO: 你甚至可以在这里打印一行日志...        delete pSocket;    &#125;;    std::unique_ptr&lt;Socket, void(*)(Socket * pSocket)&gt; spSocket(new Socket(), deletor);    return 0;&#125;\n\n自定义 std::unique_ptr 的资源释放函数其规则是：\n1std::unique_ptr&lt;T, DeletorFuncPtr&gt;\n\n其中 T 是你要释放的对象类型，DeletorPtr 是一个自定义函数指针。上述代码 33 行表示 DeletorPtr 有点复杂，我们可以使用 decltype(deletor) 让编译器自己推导 deletor 的类型，因此可以将 33 行代码修改为：\n1std::unique_ptr&lt;Socket, decltype(deletor)&gt; spSocket(new Socket(), deletor);\n\nstd::shared_ptrstd::unique_ptr 对其持有的资源具有独占性，而 std::shared_ptr 持有的资源可以在多个 std::shared_ptr 之间共享，每多一个 std::shared_ptr 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 std::shared_ptr 对象析构时，资源引用计数减 1，最后一个 std::shared_ptr 对象析构时，发现资源计数为 0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作 std::shared_ptr 引用的对象是安全的）。std::shared_ptr 提供了一个 use_count() 方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr 用法和 std::unique_ptr 基本相同。\n下面是一个初始化 std::shared_ptr 的示例：\n12345678910//初始化方式1std::shared_ptr&lt;int&gt; sp1(new int(123));//初始化方式2std::shared_ptr&lt;int&gt; sp2;sp2.reset(new int(123));//初始化方式3std::shared_ptr&lt;int&gt; sp3;sp3 = std::make_shared&lt;int&gt;(123);\n\n和 std::unique_ptr 一样，你应该优先使用 std::make_shared 去初始化一个 std::shared_ptr 对象。\n再来看另外一段代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;memory&gt;class A&#123;public:    A()    &#123;        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;    &#125;    ~A()    &#123;        std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    &#123;        //初始化方式1        std::shared_ptr&lt;A&gt; sp1(new A());        std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;        //初始化方式2        std::shared_ptr&lt;A&gt; sp2(sp1);        std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;        sp2.reset();        std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;        &#123;            std::shared_ptr&lt;A&gt; sp3 = sp1;            std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;        &#125;        std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n\n上述代码 22 行 sp1 构造时，同时触发对象 A 的构造，因此 A 的构造函数会执行；\n此时只有一个 sp1 对象引用 22 行 new 出来的 A 对象（为了叙述方便，下文统一称之为资源对象 A），因此代码 24 行打印出来的引用计数值为 1；\n代码 27 行，利用 sp1 拷贝一份 sp2，导致代码 28 行打印出来的引用计数为 2；\n代码 30 行调用 sp2 的 reset() 方法，sp2 释放对资源对象 A 的引用，因此代码 31 行打印的引用计数值再次变为 1；\n代码 34 行 利用 sp1 再次 创建 sp3，因此代码 35 行打印的引用计数变为 2；\n程序执行到 36 行以后，sp3 出了其作用域被析构，资源 A 的引用计数递减 1，因此 代码 38 行打印的引用计数为 1；\n程序执行到 39 行以后，sp1 出了其作用域被析构，在其析构时递减资源 A 的引用计数至 0，并析构资源 A 对象，因此类 A 的析构函数被调用。\n\n所以整个程序的执行结果如下：\n12345678[root@myaliyun testmybook]# ./test_shared_ptr_use_count A constructoruse count: 1use count: 2use count: 1use count: 2use count: 1A destructor\n\nstd::enable_shared_from_this\n实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 std::enable_shared_from_this 模板对象即可。用法如下：\n1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;memory&gt;class A : public std::enable_shared_from_this&lt;A&gt;&#123;public:    A()    &#123;        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;    &#125;    ~A()    &#123;        std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl;    &#125;    std::shared_ptr&lt;A&gt; getSelf()    &#123;        return shared_from_this();    &#125;&#125;;int main()&#123;    std::shared_ptr&lt;A&gt; sp1(new A());    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;getSelf();    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    return 0;&#125;\n\n上述代码中，类 A 的继承 std::enable_shared_from_this 并提供一个 getSelf() 方法返回自身的 std::shared_ptr 对象，在 getSelf() 中调用 shared_from_this() 即可。\nstd::enable_shared_from_this 用起来比较方便，但是也存在很多不易察觉的陷阱。\n陷阱一：不应该共享栈对象的 this 给智能指针对象\n假设我们将上面代码 main 函数 25 行生成 A 对象的方式改成一个栈变量，即：\n123456789101112//其他相同代码省略...int main()&#123;    A a;    std::shared_ptr&lt;A&gt; sp2 = a.getSelf();    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl;    return 0;&#125;\n\n运行修改后的代码会发现程序在 std::shared_ptr sp2 = a.getSelf(); 产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过 shared_from_this() 将该对象交由智能指针对象管理。切记：智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）。\n陷阱二：避免 std::enable_shared_from_this 的循环引用问题\n再来看另外一段代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445// test_std_enable_shared_from_this.cpp : This file contains the &#x27;main&#x27; function. Program execution begins and ends there.//#include &lt;iostream&gt;#include &lt;memory&gt;class A : public std::enable_shared_from_this&lt;A&gt;&#123;public:    A()    &#123;        m_i = 9;        //注意:        //比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值        //但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;    &#125;    ~A()    &#123;        m_i = 0;        std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl;    &#125;    void func()    &#123;        m_SelfPtr = shared_from_this();    &#125;public:    int                 m_i;    std::shared_ptr&lt;A&gt;  m_SelfPtr;&#125;;int main()&#123;    &#123;        std::shared_ptr&lt;A&gt; spa(new A());        spa-&gt;func();    &#125;    return 0;&#125;\n\n乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：\n123[root@myaliyun testmybook]# g++ -g -o test_std_enable_shared_from_this_problem test_std_enable_shared_from_this_problem.cpp[root@myaliyun testmybook]# ./test_std_enable_shared_from_this_problemA constructor\n\n我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A 类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏了！\n我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到 42 行后，spa 出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr 对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为 1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A 才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁 A。这就是所谓的 std::enable_shared_from_this 的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。也就是说一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理。\nstd::weak_ptrstd::weak_ptr 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 std::shared_ptr 工作。\nstd::weak_ptr 可以从一个 std::shared_ptr 或另一个 std::weak_ptr 对象构造，std::shared_ptr 可以直接赋值给 std::weak_ptr ，也可以通过 std::weak_ptr 的 lock() 函数来获得 std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。std::weak_ptr 可用来解决 std::shared_ptr 相互引用时的死锁问题（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）。\n示例代码如下：\n1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;memory&gt;int main()&#123;    //创建一个std::shared_ptr对象    std::shared_ptr&lt;int&gt; sp1(new int(123));    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    //通过构造函数得到一个std::weak_ptr对象    std::weak_ptr&lt;int&gt; sp2(sp1);    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    //通过赋值运算符得到一个std::weak_ptr对象    std::weak_ptr&lt;int&gt; sp3 = sp1;    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    //通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象    std::weak_ptr&lt;int&gt; sp4 = sp2;    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    return 0;&#125;\n\n程序执行结果如下：\n123456[root@myaliyun testmybook]# g++ -g -o test_weak_ptr test_weak_ptr.cpp [root@myaliyun testmybook]# ./test_weak_ptruse count: 1use count: 1use count: 1use count: 1\n\n无论通过何种方式创建 std::weak_ptr 都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。\n既然，std::weak_ptr 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？std::weak_ptr 提供了一个 expired() 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 std::weak_ptr 的 lock() 方法得到一个 std::shared_ptr 对象然后继续操作资源，以下代码演示了该用法：\n12345678910//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象//tmpConn_引用的TcpConnection已经销毁，直接返回if (tmpConn_.expired())    return;std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.lock();if (conn)&#123;    //对conn进行操作，省略...&#125;\n\n有读者可能对上述代码产生疑问，既然使用了 std::weak_ptr 的 expired() 方法判断了对象是否存在，为什么不直接使用 std::weak_ptr 对象对引用资源进行操作呢？实际上这是行不通的，std::weak_ptr 类没有重写 operator-&gt; 和 operator* 方法，因此不能像 std::shared_ptr 或 std::unique_ptr 一样直接操作对象，同时 std::weak_ptr 类也没有重写 operator! 操作，因此也不能通过 std::weak_ptr 对象直接判断其引用的资源是否存在：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;memory&gt;class A&#123;public:    void doSomething()    &#123;    &#125;&#125;;int main()&#123;        std::shared_ptr&lt;A&gt; sp1(new A());    std::weak_ptr&lt;A&gt; sp2(sp1);    //正确代码    if (sp1)    &#123;        //正确代码        sp1-&gt;doSomething();        (*sp1).doSomething();    &#125;    //正确代码    if (!sp1)    &#123;    &#125;    //错误代码，无法编译通过    //if (sp2)    //&#123;    //    //错误代码，无法编译通过    //    sp2-&gt;doSomething();    //    (*sp2).doSomething();    //&#125;    //错误代码，无法编译通过    //if (!sp2)    //&#123;    //&#125;    return 0;&#125;\n\n之所以 std::weak_ptr 不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦。\n因此，std::weak_ptr 的正确使用场景是那些资源如果可能就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象与事实矛盾。\nstd::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。\n12345678910111213141516171819202122class Subscriber&#123;&#125;;class SubscribeManager&#123;public:    void publish()    &#123;        for (const auto&amp; iter : m_subscribers)        &#123;            if (!iter.expired())            &#123;                //TODO：给订阅者发送消息            &#125;        &#125;    &#125;private:    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt;   m_subscribers;&#125;;\n\n智能指针对象的大小一个 std::unique_ptr 对象大小与裸指针大小相同（即 sizeof(std::unique_ptr) &#x3D;&#x3D; sizeof(void*)），而 std::shared_ptr 的大小是 std::unique_ptr 的一倍。以下是我分别在 Visual Studio 2019 和 gcc&#x2F;g++ 4.8 上（二者都编译成 x64 程序）的测试结果：\n测试代码\n12345678910111213141516171819#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;int main()&#123;    std::shared_ptr&lt;int&gt; sp0;    std::shared_ptr&lt;std::string&gt; sp1;    sp1.reset(new std::string());    std::unique_ptr&lt;int&gt; sp2;    std::weak_ptr&lt;int&gt; sp3;    std::cout &lt;&lt; &quot;sp0 size: &quot; &lt;&lt; sizeof(sp0) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sp1 size: &quot; &lt;&lt; sizeof(sp1) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sp2 size: &quot; &lt;&lt; sizeof(sp2) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sp3 size: &quot; &lt;&lt; sizeof(sp3) &lt;&lt; std::endl;    return 0;&#125;\n\nVisual Studio 2019 运行结果：\n\ngcc&#x2F;g++ 运行结果：\n\n在 32 位机器上，std_unique_ptr 占 4 字节，std::shared_ptr 和 std::weak_ptr 占 8 字节；在 64 位机器上，std_unique_ptr 占 8 字节，std::shared_ptr 和 std::weak_ptr 占 16 字节。也就是说，std_unique_ptr 的大小总是和原始指针大小一样，std::shared_ptr 和 std::weak_ptr 大小是原始指针的一倍。\n智能指针使用注意事项C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++ 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，读者应该尽量去使用它们。智能指针虽然好用，但稍不注意，也可能存在许多难以发现的 bug，这里我根据经验总结了几条：\n\n一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；\n看一段代码：\n1234567891011121314151617#include &lt;memory&gt;class Subscriber&#123;&#125;;int main()&#123;      Subscriber* pSubscriber = new Subscriber();  std::unique_ptr&lt;Subscriber&gt; spSubscriber(pSubscriber);  delete pSubscriber;  return 0;&#125;\n\n这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针 spSubscriber 去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象 spSubscriber 情何以堪啊？\n记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。当然，除了 std::weak_ptr，std::unique_ptr 和 std::shared_ptr 都提供了获取原始指针的方法——get() 函数。\n1234567891011int main()&#123;      Subscriber* pSubscriber = new Subscriber();  std::unique_ptr&lt;Subscriber&gt; spSubscriber(pSubscriber);  //pTheSameSubscriber和pSubscriber指向同一个对象  Subscriber* pTheSameSubscriber= spSubscriber.get();  return 0;&#125;\n\n分清楚场合应该使用哪种类型的智能指针；\n通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr。\n\n认真考虑，避免操作某个引用资源已经释放的智能指针；\n前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码：\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;memory&gt;class T&#123;public:  void doSomething()  &#123;      std::cout &lt;&lt; &quot;T do something...&quot; &lt;&lt; m_i &lt;&lt; std::endl;  &#125;private:  int     m_i;&#125;;int main()&#123;      std::shared_ptr&lt;T&gt; sp1(new T());  const auto&amp; sp2 = sp1;  sp1.reset();  //由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为  sp2-&gt;doSomething();  return 0;&#125;\n\n上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2 也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即 **operator-&gt;**）在内部会调用 get() 方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用 doSomething() 导致程序崩溃。\n你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：\n12345678910111213141516//连接断开void MonitorServer::OnClose(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn)&#123;      std::lock_guard&lt;std::mutex&gt; guard(m_sessionMutex);  for (auto iter = m_sessions.begin(); iter != m_sessions.end(); ++iter)  &#123;      //通过比对connection对象找到对应的session      if ((*iter)-&gt;GetConnectionPtr() == conn)      &#123;          m_sessions.erase(iter);          //注意这里：程序在此处崩溃          LOGI(&quot;monitor client disconnected: %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());          break;      &#125;  &#125;&#125;\n\n这段代码不是我杜撰的，而是来自于我实际的一个商业项目中。注意代码中我提醒注意的地方，该段程序会在代码 12 行处崩溃，崩溃原因是调用了 conn-&gt;peerAddress() 方法。为什么这个方法的调用可能会引起崩溃？现在可以一目了然地看出了吗？\n崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个 std::shared_ptr 的引用，当连接断开时，对应的 TcpConnection 对象可能早已被销毁，而 conn 引用就会变成空指针（严格来说是不再拥有一个 TcpConnection 对象），此时调用 TcpConnection 的 peerAddress() 方法就会产生和上一个示例一样的错误。\n\n作为类成员变量时，应该优先使用前置声明（forward declarations）\n我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C&#x2F;C++ 项目中一般在 *.h 文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件。例如：\n12345678910111213//Test.h//在这里使用A的前置声明，而不是直接包含A.h文件class A;class Test&#123;public:  Test();  ~Test();private:  A*      m_pA;&#125;;\n\n同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。\n123456789101112131415//Test.h#include &lt;memory&gt;//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.hclass A;class Test&#123;public:  Test();  ~Test();private:    std::unique_ptr&lt;A&gt;  m_spA;&#125;;\n\nC++ 新标准中的智能指针我想介绍的就这么多了，Modern C&#x2F;C++ 已经变为 C&#x2F;C++ 开发的趋势，希望读者能善用和熟练使用本节介绍的后三种智能指针对象。\n","slug":"转载/cpp/详解C++11中的智能指针","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,学习资料","author_index":"阿木大叔"},{"id":"8ecb216f8fd8194ddd13637de67a4f14","title":"【转载】libevent源码深度剖析01","content":"libevent源码深度剖析一1. 前言libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分享心得；二则对libevent代码和设计思想做系统的、更深层次的分析，写出来，也可供后来者参考。\n附带一句：libevent是用c语言编写的（大牛们都偏爱c语言哪），而且几乎是无处不函数指针，学习其源代码也需要相当的c语言基础。\n2. Libevent简介上来当然要先夸奖啦，libevent 有几个显著的亮点：事件驱动（event-driven），高性能;轻量级，专注于网络，不如ACE那么臃肿庞大；源代码相当精炼、易读；跨平台，支持Windows、Linux、BSD和Mac Os；支持多种I&#x2F;O多路复用技术， epoll、poll、dev&#x2F;poll、select和kqueue等；支持I&#x2F;O，定时器和信号等事件；注册事件优先级；\nlibevent已经被广泛的应用，作为底层的网络库；比如memcached、Vomit、Nylon、Netchat等等。libevent当前的最新稳定版是1.4.13；这也是本文参照的版本。\n3. 学习的好处学习libevent有助于提升程序设计功力，除了网络程序设计方面外，libevent的代码里有很多有用的设计技巧和基础数据结构，比如信息隐藏、函数指针、c语言的多态支持、链表和堆等等，都有助于提升自身的程序功力。程序设计不止要了解框架，很多细节之处恰恰也是事关整个系统成败的关键。只对libevent本身的框架大概了解，那或许仅仅是一知半解，不深入代码分析，就难以了解其设计的精巧之处，也就难以为自己所用。\n事实上libevent本身就是一个典型的Reactor模型，理解Reactor模式是理解libevent的基石；因此下一节将介绍典型的事件驱动设计模式——Reactor模式。\n参考资料：libevent官方地址: http://monkey.org/~provos/libevent/\n","slug":"转载/libevent/libevent源码深度剖析01","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"0b2fd1ebe4476d5c0bbc97c748eb6d3b","title":"【转载】libevent源码深度剖析02","content":"libevent源码深度剖析02Reactor模式\n前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，并列出libevnet中的几个重要组件和Reactor的对应关系，在后面的章节中可能还会提到本节介绍的基本概念。\n1. Reactor的事件处理机制首先来回想一下普通函数调用的机制：程序调用某函数?函数执行，程序等待?函数将结果和控制权返回给程序?程序继续处理。\nReactor释义“反应堆”，是一种事件驱动机制。和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果相应的时间发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。使用libevent也是想libevent框架注册相应的事件和回调函数；当这些事件发生时，libevent会调用这些回调函数处理相应的事件（I&#x2F;O读写、定时和信号）。\n用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。\n举个例子：你去应聘某xx公司，面试结束后。\n“普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被据了；\n“Reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被据了；你不用自己打电话去问结果，事实上也不能，你没有HR的留联系方式。\n2. Reactor模式的优点Reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点\n1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；\n2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销；3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；\n3. Reactor模式框架使用Reactor模型，必备的几个组件：事件源、Reactor框架、多路复用机制和事件处理程序，先来看看Reactor模型的整体框架，接下来再对每个组件做逐一说明。\n\n1） 事件源Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I&#x2F;O事件。\n2） event demultiplexer——事件多路分发机制由操作系统提供的I&#x2F;O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到event demultiplexer上；当有事件到达时，event demultiplexer会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”；程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。对应到libevent中，依然是select、poll、epoll等，但是libevent使用结构体eventop进行了封装，以统一的接口来支持这些I&#x2F;O多路复用机制，达到了对外隐藏底层系统机制的目的。\n3） Reactor——反应器Reactor，是事件管理的接口，内部使用event demultiplexer注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到libevent中，就是event_base结构体。一个典型的Reactor声明方式：\n1234567class Reactor&#123;    public:        int register_handler(Event_Handler *pHandler, int event);        int remove_handler(Event_Handler *pHandler, int event);        void handle_events(timeval *ptv);        // ...&#125;;\n\n\n\n4） Event Handler——事件处理程序\n事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。对应到libevent中，就是event结构体。下面是两种典型的Event Handler类声明方式，二者互有优缺点。\n1234567891011121314151617class Event_Handler&#123;    public:        virtual void handle_read() = 0;        virtual void handle_write() = 0;        virtual void handle_timeout() = 0;        virtual void handle_close() = 0;        virtual HANDLE get_handle() = 0;        // ...&#125;;class Event_Handler&#123;    public:        // events maybe read/write/timeout/close .etc        virtual void handle_events(int events) = 0;        virtual HANDLE get_handle() = 0;        // ...&#125;;\n\n4. Reactor事件处理流程前面说过Reactor将事件流“逆置”了，那么使用Reactor模式后，事件控制流是什么样子呢？可以参见下面的序列图。\n\n5. 小结上面讲到了Reactor的基本概念、框架和处理流程，对Reactor有个基本清晰的了解后，再来对比看libevent就会更容易理解了，接下来就正式进入到libevent的代码世界了，加油！\n参考资料：Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2\n","slug":"转载/libevent/libevent源码深度剖析02","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"dd54cd62e1387361117c63cf12445709","title":"【转载】libevent源码深度剖析03","content":"libevent源码深度剖析03libevent基本使用场景和事件流程1. 前言学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不错的方法，至少从个人的经验上讲，用此方法分析libevent是比较有效的。\n2. 基本应用场景基本应用场景也是使用libevnet的基本流程，下面来考虑一个最简单的场景，使用livevent设置定时器，应用程序只需要执行下面几个简单的步骤即可。1）首先初始化libevent库，并保存返回的指针\n1struct event_base* base = event_init();\n\n实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。\n2）初始化事件event，设置回调函数和关注的事件\n1evtimer_set(&amp;ev, timer_cb, NULL);\n\n事实上这等价于调用 event_set(&amp;ev, -1, 0, timer_cb, NULL);event_set的函数原型是：\n1void event_set(struct event *ev, int fd, short event, void (*cb)(int, short, void *), void *arg)\n\nev：执行要初始化的event对象；fd：该event绑定的“句柄”，对于信号事件，它就是关注的信号；event：在该fd上关注的事件类型，它可以是EV_READ, EV_WRITE, EV_SIGNAL；cb：这是一个函数指针，当fd上的事件event发生时，调用该函数执行处理，它有三个参数，调用时由event_base负责传入，按顺序，实际上就是event_set时的fd, event和arg；arg：传递给cb函数指针的参数；由于定时事件不需要fd，并且定时事件是根据添加时（event_add）的超时值设定的，因此这里event也不需要设置。这一步相当于初始化一个event handler，在libevent中事件类型保存在event结构体中。注意：libevent并不会管理event事件集合，这需要应用程序自行管理；\n3）设置event从属的event_base\n1event_base_set(base, &amp;ev); \n\n这一步相当于指明event要注册到哪个event_base实例上；\n4）是正式的添加事件的时候了\n1event_add(&amp;ev, timeout);\n\n基本信息都已设置完成，只要简单的调用**event_add()函数即可完成，其中timeout是定时值；这一步相当于调用Reactor::register_handler()**函数注册事件。\n5）程序进入无限循环，等待就绪事件并执行事件处理\n1event_base_dispatch(base);\n\n3. 实例代码上面例子的程序代码如下所示\n123456789101112131415struct event ev;struct timeval tv;void time_cb(int fd, short event, void *argc)&#123;    printf(&quot;timer wakeup/n&quot;);    event_add(&amp;ev, &amp;tv); // reschedule timer&#125;int main()&#123;    struct event_base *base = event_init();    tv.tv_sec = 10; // 10s period    tv.tv_usec = 0;    evtimer_set(&amp;ev, time_cb, NULL);    event_add(&amp;ev, &amp;tv);    event_base_dispatch(base);&#125;\n\n4. 事件处理流程当应用程序向libevent注册一个事件后，libevent内部是怎么样进行处理的呢？下面的图就给出了这一基本流程。1）首先应用程序准备并初始化event，设置好事件类型和回调函数；这对应于前面第步骤2和3；2）向libevent添加该事件event。对于定时事件，libevent使用一个小根堆管理，key为超时时间；对于Signal和I&#x2F;O事件，libevent将其放入到等待链表（wait list）中，这是一个双向链表结构；3）程序调用**event_base_dispatch()**系列函数进入无限循环，等待事件，以select()函数为例；每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件；当select()返回后，首先检查超时事件，然后检查I&#x2F;O事件；Libevent将所有的就绪事件，放入到激活链表中；然后对激活链表中的事件，调用事件的回调函数执行事件处理； \n5. 小结本节介绍了libevent的简单实用场景，并旋风般的介绍了libevent的事件处理流程，读者应该对libevent有了基本的印象，下面将会详细介绍libevent的事件管理框架（Reactor模式中的Reactor框架）做详细的介绍，在此之前会对源代码文件做简单的分类。\n","slug":"转载/libevent/libevent源码深度剖析03","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"21cc3849aa98d79b1da8af8304100d2a","title":"【转载】libevent源码深度剖析04","content":"libevent源码深度剖析041. 前言详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，我想并不是说它不重要！\n2. 源代码组织结构Libevent的源代码虽然都在一层文件夹下面，但是其代码分类还是相当清晰的，主要可分为头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I&#x2F;O多路复用机制的封装、信号管理、定时事件管理、缓冲区管理、基本数据结构和基于libevent的两个实用库等几个部分，有些部分可能就是一个源文件。源代码中的test部分就不在我们关注的范畴了。1）头文件主要就是event.h：事件宏定义、接口函数声明，主要结构体event的声明；2）内部头文件xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；3）libevent框架event.c：event整体框架的代码实现；4）对系统I&#x2F;O多路复用机制的封装epoll.c：对epoll的封装；select.c：对select的封装；devpoll.c：对dev&#x2F;poll的封装;kqueue.c：对kqueue的封装；5）定时事件管理min-heap.h：其实就是一个以时间作为key的小根堆结构；6）信号管理signal.c：对信号事件的处理；7）辅助功能函数evutil.h 和evutil.c：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。8）日志log.h和log.c：log日志函数9）缓冲区管理evbuffer.c和buffer.c：libevent对缓冲区的封装；10）基本数据结构compat&#x2F;sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；11）实用网络库http和evdns：是基于libevent实现的http服务器和异步dns查询库；\n3. 小结本节介绍了libevent的组织和分类，下面将会详细介绍libevent的核心部分event结构。\n","slug":"转载/libevent/libevent源码深度剖析04","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"e23144502108769556e4aa73a855e4ee","title":"【转载】libevent源码深度剖析05","content":"libevent源码深度剖析05libevent的核心：事件event\n对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理。\n1. libevent的核心-eventlibevent是基于事件驱动（event-driven）的，从名字也可以看到event是整个库的核心。event就是Reactor框架中的事件处理程序组件；它提供了函数接口，供Reactor在事件发生时调用，以执行相应的事件处理，通常它会绑定一个有效的句柄。\n首先给出event结构体的声明，它位于event.h文件中：\n123456789101112131415161718192021222324252627282930313233struct event &#123;     TAILQ_ENTRY (event) ev_next;     TAILQ_ENTRY (event) ev_active_next;     TAILQ_ENTRY (event) ev_signal_next;     unsigned int min_heap_idx; /* for managing timeouts */     struct event_base *ev_base;     int ev_fd;     short ev_events;     short ev_ncalls;     short *ev_pncalls; /* Allows deletes in callback */     struct timeval ev_timeout;     int ev_pri;  /* smaller numbers are higher priority */     void (*ev_callback)(int, short, void *arg);     void *ev_arg;     int ev_res;  /* result passed to event callback */     int ev_flags;&#125;;\n\nev_events：event关注的事件类型，它可以是以下3种类型：\n\nI&#x2F;O事件： EV_WRITE和EV_READ 定时事件：EV_TIMEOUT 信号： EV_SIGNAL 辅助选项：EV_PERSIST，表明是一个永久事件 Libevent中的定义为：\n 123456789#define EV_TIMEOUT 0x01#define EV_READ  0x02#define EV_WRITE 0x04#define EV_SIGNAL 0x08#define EV_PERSIST 0x10 /* Persistant event */\n\n 可以看出事件类型可以使用“|”运算符进行组合，需要说明的是，信号和I&#x2F;O事件不能同时设置；\n 还可以看出libevent使用event结构体将这3种事件的处理统一起来；\n\nev_next，ev_active_next和ev_signal_next都是双向链表节点指针；它们是libevent对不同事件类型和在不同的时期，对事件的管理时使用到的字段。 libevent使用双向链表保存所有注册的I&#x2F;O和Signal事件\n\nev_next就是该I&#x2F;O事件在链表中的位置；称此链表为“已注册事件链表”；\n\n同样ev_signal_next就是signal事件在signal事件链表中的位置；\n\nev_active_next：libevent将所有的激活事件放入到链表active list中，然后遍历active list执行调度，ev_active_next就指明了event在active list中的位置；\n\nmin_heap_idx和ev_timeout，如果是timeout事件，它们是event在小根堆中的索引和超时值，libevent使用小根堆来管理定时事件，这将在后面定时事件处理时专门讲解；\n\nev_base该事件所属的反应堆实例，这是一个event_base结构体，下一节将会详细讲解；\n\nev_fd，对于I&#x2F;O事件，是绑定的文件描述符；对于signal事件，是绑定的信号；\n\nev_callback，event的回调函数，被ev_base调用，执行事件处理程序，这是一个函数指针，原型为：\n 11void (*ev_callback)(int fd, short events, void *arg)\n\n 其中参数fd对应于ev_fd；events对应于ev_events；arg对应于ev_arg；\n\nev_arg：void*，表明可以是任意类型的数据，在设置event时指定；\n\neb_flags：libevent用于标记event信息的字段，表明其当前的状态，可能的值有：\n1234567891011 1#define EVLIST_TIMEOUT 0x01 // event在time堆中 2 3#define EVLIST_INSERTED 0x02 // event在已注册事件链表中 4 5#define EVLIST_SIGNAL 0x04 // 未见使用 6 7#define EVLIST_ACTIVE 0x08 // event在激活链表中 8 9#define EVLIST_INTERNAL 0x10 // 内部使用标记1011#define EVLIST_INIT     0x80 // event已被初始化\n\nev_ncalls：事件就绪执行时，调用ev_callback的次数，通常为1；\n\nev_pncalls：指针，通常指向ev_ncalls或者为NULL；\n\nev_res：记录了当前激活事件的类型；\n\n\n2. libevent对event的管理从event结构体中的3个链表节点指针和一个堆索引出发，大体上也能窥出libevent对event的管理方法了，可以参见下面的示意图：\n\n\n每次当有事件event转变为就绪状态时，libevent就会把它移入到active event list[priority]中，其中priority是event的优先级；\n接着libevent会根据自己的调度策略选择就绪事件，调用其cb_callback()函数执行事件处理；并根据就绪的句柄和事件类型填充cb_callback函数的参数。\n\n3. 事件设置的接口函数要向libevent添加一个事件，需要首先设置event对象，这通过调用libevent提供的函数有：event_set(), event_base_set(), event_priority_set()来完成；下面分别进行讲解。\n1void event_set(struct event *ev, int fd, short events, void (*callback)(int, short, void *), void *arg)\n\n\n设置事件ev绑定的文件描述符或者信号，对于定时事件，设为-1即可；\n设置事件类型，比如EV_READ|EV_PERSIST, EV_WRITE, EV_SIGNAL等；\n设置事件的回调函数以及参数arg；\n初始化其它字段，比如缺省的event_base和优先级； int event_base_set(struct event_base *base, struct event *ev) 设置event ev将要注册到的event_base； libevent有一个全局event_base指针current_base，默认情况下事件ev将被注册到current_base上，使用该函数可以指定不同的event_base； 如果一个进程中存在多个libevent实例，则必须要调用该函数为event设置不同的event_base；\n\n1int event_priority_set(struct event *ev, int pri)\n\n设置event ev的优先级，没什么可说的，注意的一点就是：当ev正处于就绪状态时，不能设置，返回-1。\n4. 小结本节讲述了libevent的核心event结构，以及libevent支持的事件类型和libevent对event的管理模型；接下来将会描述libevent的事件处理框架，以及其中使用的重要的结构体event_base。\n","slug":"转载/libevent/libevent源码深度剖析05","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"1db95bdb6c78dab83e0028f095b96fd6","title":"【转载】libevent源码深度剖析06","content":"libevent源码深度剖析06初见事件处理框架\n前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细处理流程了，本节将分析libevent的事件处理框架event_base和libevent注册、删除事件的具体流程，可结合前一节libevent对event的管理。\n1. 事件处理框架-event_base回想Reactor模式的几个基本组件，本节讲解的部分对应于Reactor框架组件。在libevent中，这就表现为event_base结构体，结构体声明如下，它位于event-internal.h文件中：\n1234567891011121314151617struct event_base &#123;    const struct eventop *evsel;    void *evbase;　    int event_count;  /* counts number of total events */    int event_count_active; /* counts number of active events */    int event_gotterm;  /* Set to terminate loop */    int event_break;  /* Set to terminate loop immediately */    /* active event management */    struct event_list **activequeues;    int nactivequeues;    /* signal handling info */    struct evsignal_info sig;    struct event_list eventqueue;    struct timeval event_tv;    struct min_heap timeheap;    struct timeval tv_cache;&#125;;\n\n下面详细解释一下结构体中各字段的含义。\n\nevsel和evbase这两个字段的设置可能会让人有些迷惑，这里你可以把evsel和evbase看作是类和静态函数的关系，比如添加事件时的调用行为：evsel-&gt;add(evbase, ev)，实际执行操作的是evbase；这相当于class::add(instance, ev)，instance就是class的一个对象实例。 evsel指向了全局变量static const struct eventop *eventops[]中的一个； 前面也说过，libevent将系统提供的I&#x2F;O demultiplex机制统一封装成了eventop结构；因此eventops[]包含了select、poll、kequeue和epoll等等其中的若干个全局实例对象。 evbase实际上是一个eventop实例对象； 先来看看eventop结构体，它的成员是一系列的函数指针, 在event-internal.h文件中：\n 12345678910struct eventop &#123;    const char *name;    void *(*init)(struct event_base *); // 初始化    int (*add)(void *, struct event *); // 注册事件    int (*del)(void *, struct event *); // 删除事件    int (*dispatch)(struct event_base *, void *, struct timeval *); // 事件分发    void (*dealloc)(struct event_base *, void *); // 注销，释放资源    /* set if we need to reinitialize the event base */    int need_reinit;&#125;;\n\n 也就是说，在libevent中，每种I&#x2F;O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。 比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I&#x2F;O demultiplex机制了，这个在后面会再次提到。\n\nactivequeues是一个二级指针，前面讲过libevent支持事件优先级，因此你可以把它看作是数组，其中的元素activequeues[priority]是一个链表，链表的每个节点指向一个优先级为priority的就绪事件event。\n\neventqueue，链表，保存了所有的注册事件event的指针。\n\nsig是由来管理信号的结构体，将在后面信号处理时专门讲解；\n\ntimeheap是管理定时事件的小根堆，将在后面定时事件处理时专门讲解；\n\nevent_tv和tv_cache是libevent用于时间管理的变量，将在后面讲到； 其它各个变量都能因名知意，就不再啰嗦了。\n\n\n2. 创建和初始化event_base创建一个event_base对象也既是创建了一个新的libevent实例，程序需要通过调用event_init()（内部调用event_base_new函数执行具体操作）函数来创建，该函数同时还对新生成的libevent实例进行了初始化。\n\n该函数首先为event_base实例申请空间，\n然后初始化timer mini-heap，选择并初始化合适的系统I&#x2F;O 的demultiplexer机制，初始化各事件链表；\n\n函数还检测了系统的时间设置，为后面的时间管理打下基础。\n3. 接口函数前面提到Reactor框架的作用就是提供事件的注册、注销接口；根据系统提供的事件多路分发机制执行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数来处理事件。Libevent中对应的接口函数主要就是：\n12345int  event_add(struct event *ev, const struct timeval *timeout);int  event_del(struct event *ev);int  event_base_loop(struct event_base *base, int loops);void event_active(struct event *event, int res, short events);void event_process_active(struct event_base *base); \n\n本节将按介绍事件注册和删除的代码流程，libevent的事件循环框架将在下一节再具体描述。\n\n对于定时事件，这些函数将调用timer heap管理接口执行插入和删除操作；\n对于I&#x2F;O和Signal事件将调用eventopadd和delete接口函数执行插入和删除操作（eventop会对Signal事件调用Signal处理接口执行操作）；\n\n这些组件将在后面的内容描述。\n1）注册事件函数原型：\n1int event_add(struct event *ev, const struct timeval *tv)\n\n参数：ev：指向要注册的事件；tv：超时时间；\ne函数将ev注册到ev-&gt;ev_base上，事件类型由ev-&gt;ev_events指明，\n\n如果注册成功，v将被插入到已注册链表中；\n如果tv不是NULL，则会同时注册定时事件，将ev添加到timer堆上；\n\n如果其中有一步操作失败，那么函数保证没有事件会被注册，可以讲这相当于一个原子操作。这个函数也体现了libevent细节之处的巧妙设计，且仔细看程序代码，部分有省略，注释直接附在代码中。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344int event_add(struct event *ev, const struct timeval *tv) &#123;\tstruct event_base *base = ev-&gt;ev_base;\t// 要注册到的event_base\tconst struct eventop *evsel = base-&gt;evsel;\tvoid *evbase = base-&gt;evbase;\t// base使用的系统I/O策略\t// 新的timer事件，调用timer heap接口在堆上预留一个位置\t// 注：这样能保证该操作的原子性：\t// 向系统I/O机制注册可能会失败，而当在堆上预留成功后，\t// 定时事件的添加将肯定不会失败；\t// 而预留位置的可能结果是堆扩充，但是内部元素并不会改变\tif (tv != NULL &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;\t\tif (min_heap_reserve(&amp;base-&gt;timeheap, 1 + min_heap_size(&amp;base-&gt;timeheap)) == -1)\t\t        \treturn (-1);\t\t/* ENOMEM == errno */\t&#125;\t// 如果事件ev不在已注册或者激活链表中，则调用evbase注册事件\tif ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp; !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123;\t\tres = evsel-&gt;add(evbase, ev);\t\tif (res != -1) // 注册成功，插入event到已注册链表中\t\tevent_queue_insert(base, ev, EVLIST_INSERTED);\t&#125;\t// 准备添加定时事件\tif (res != -1 &amp;&amp; tv != NULL) &#123;\t\tstruct timeval now;\t\t// EVLIST_TIMEOUT表明event已经在定时器堆中了，删除旧的\t\tif (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)\t\t        \tevent_queue_remove(base, ev, EVLIST_TIMEOUT);\t\t// 如果事件已经是就绪状态则从激活链表中删除\t\tif ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;\t\t        (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;\t\t\t// 将ev_callback调用次数设置为0\t\t\tif (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;\t\t\t\t*ev-&gt;ev_pncalls = 0;\t\t\t&#125;\t\t\tevent_queue_remove(base, ev, EVLIST_ACTIVE);\t\t&#125;\t\t// 计算时间，并插入到timer小根堆中\t\tgettime(base, &amp;now);\t\tevutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout);\t\tevent_queue_insert(base, ev, EVLIST_TIMEOUT);\t&#125;\treturn (res);&#125;\n\n\nevent_queue_insert()负责将事件插入到对应的链表中，下面是程序代码；\nevent_queue_remove()负责将事件从对应的链表中删除，这里就不再重复贴代码了；\n\n12345678910111213141516171819202122void event_queue_insert(struct event_base *base, struct event *ev, int queue) &#123;\t// ev可能已经在激活列表中了，避免重复插入\tif (ev-&gt;ev_flags &amp; queue) &#123;\t\tif (queue &amp; EVLIST_ACTIVE)\t\t   return;\t&#125;\t// ...\tev-&gt;ev_flags |= queue;\t// 记录queue标记\tswitch (queue) &#123;\t\tcase EVLIST_INSERTED: // I/O或Signal事件，加入已注册事件链表\t\tTAILQ_INSERT_TAIL(&amp;base-&gt;eventqueue, ev, ev_next);\t\tbreak;\t\tcase EVLIST_ACTIVE: // 就绪事件，加入激活链表\t\tbase-&gt;event_count_active++;\t\tTAILQ_INSERT_TAIL(base-&gt;activequeues[ev-&gt;ev_pri], ev, ev_active_next);\t\tbreak;\t\tcase EVLIST_TIMEOUT: // 定时事件，加入堆\t\tmin_heap_push(&amp;base-&gt;timeheap, ev);\t\tbreak;\t&#125;&#125;\n\n2）删除事件：函数原型为：\n1int event_del(struct event *ev);\n\n该函数将删除事件ev\n\n对于I&#x2F;O事件，从I&#x2F;O 的demultiplexer上将事件注销；\n对于Signal事件，将从Signal事件链表中删除；\n对于定时事件，将从堆上删除；\n\n同样删除事件的操作则不一定是原子的，比如删除时间事件之后，有可能从系统I&#x2F;O机制中注销会失败。\n12345678910111213141516171819202122232425262728int event_del(struct event *ev) &#123;\tstruct event_base *base;\tconst struct eventop *evsel;\tvoid *evbase;\t// ev_base为NULL，表明ev没有被注册\tif (ev-&gt;ev_base == NULL)\t  return (-1);\t// 取得ev注册的event_base和eventop指针\tbase = ev-&gt;ev_base;\tevsel = base-&gt;evsel;\tevbase = base-&gt;evbase;\t// 将ev_callback调用次数设置为\tif (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;\t\t*ev-&gt;ev_pncalls = 0;\t&#125;\t// 从对应的链表中删除\tif (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)\t  event_queue_remove(base, ev, EVLIST_TIMEOUT);\tif (ev-&gt;ev_flags &amp; EVLIST_ACTIVE)\t  event_queue_remove(base, ev, EVLIST_ACTIVE);\tif (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123;\t\tevent_queue_remove(base, ev, EVLIST_INSERTED);\t\t// EVLIST_INSERTED表明是I/O或者Signal事件，\t\t// 需要调用I/O demultiplexer注销事件\t\treturn (evsel-&gt;del(evbase, ev));\t&#125;\treturn (0);&#125;\n\n4. 小结分析了event_base这一重要结构体，初步看到了libevent对系统的I&#x2F;O demultiplex机制的封装event_op结构，并结合源代码分析了事件的注册和删除处理，下面将会接着分析事件管理框架中的主事件循环部分。\n","slug":"转载/libevent/libevent源码深度剖析06","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"2db59a77cabd819a1426d0628461aab7","title":"【转载】libevent源码深度剖析07","content":"libevent源码深度剖析07事件主循环\n现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libevent事件处理的中心部分——事件主循环，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。\n1. 阶段性的胜利libevent将I&#x2F;O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。\n2. 事件处理主循环libevent的事件主循环主要是通过event_base_loop ()函数完成的，其主要操作如下面的流程图所示，event_base_loop所作的就是持续执行下面的循环。 \n清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int event_base_loop(struct event_base *base, int flags)&#123;    const struct eventop *evsel = base-&gt;evsel;    void *evbase = base-&gt;evbase;    struct timeval tv;    struct timeval *tv_p;    int res, done;    // 清空时间缓存    base-&gt;tv_cache.tv_sec = 0;    // evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例    if (base-&gt;sig.ev_signal_added)        evsignal_base = base;    done = 0;    while (!done) &#123; // 事件主循环        // 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记        // 调用event_base_loopbreak()设置event_break标记        if (base-&gt;event_gotterm) &#123;            base-&gt;event_gotterm = 0;            break;        &#125;        if (base-&gt;event_break) &#123;            base-&gt;event_break = 0;            break;        &#125;        // 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间        // 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间&lt; last wait time        // 表明时间有问题，这是需要更新timer_heap中所有定时事件的超时时间。        timeout_correct(base, &amp;tv);        // 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间        tv_p = &amp;tv;        if (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;            timeout_next(base, &amp;tv_p);        &#125; else &#123;            // 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待            // 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理            evutil_timerclear(&amp;tv);        &#125;        // 如果当前没有注册事件，就退出        if (!event_haveevents(base)) &#123;            event_debug((&quot;%s: no events registered.&quot;, __func__));            return (1);        &#125;        // 更新last wait time，并清空time cache        gettime(base, &amp;base-&gt;event_tv);        base-&gt;tv_cache.tv_sec = 0;        // 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；        // 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中        res = evsel-&gt;dispatch(base, evbase, tv_p);        if (res == -1)            return (-1);        // 将time cache赋值为当前系统时间        gettime(base, &amp;base-&gt;tv_cache);        // 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中        timeout_process(base);        // 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理        // 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，        // 然后处理链表中的所有就绪事件；        // 因此低优先级的就绪事件可能得不到及时处理；        if (base-&gt;event_count_active) &#123;            event_process_active(base);            if (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))                done = 1;        &#125; else if (flags &amp; EVLOOP_NONBLOCK)            done = 1;    &#125;    // 循环结束，清空时间缓存    base-&gt;tv_cache.tv_sec = 0;    event_debug((&quot;%s: asked to terminate loop.&quot;, __func__));    return (0);&#125;\n\n\n\n3. I&#x2F;O和Timer事件的统一libevent将Timer和Signal事件都统一到了系统的I&#x2F;O 的demultiplex机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。首先将Timer事件融合到系统I&#x2F;O多路复用机制中，还是相当清晰的，因为系统的I&#x2F;O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I&#x2F;O事件发生，它们也保证能在timeout时间内返回。那么根据所有Timer事件的最小超时时间来设置系统I&#x2F;O的timeout时间；当系统I&#x2F;O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I&#x2F;O机制中了。这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。\n4. I&#x2F;O和Signal事件的统一Signal是异步事件的经典事例，将Signal事件统一到系统的I&#x2F;O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I&#x2F;O机制，让其返回，然后再统一和I&#x2F;O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。问题的核心在于，当Signal发生时，如何通知系统的I&#x2F;O多路复用机制，这里先买个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用pipe。\n5 小节介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I&#x2F;O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。\n","slug":"转载/libevent/libevent源码深度剖析07","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"c96eddcf717cad02fc0a6f9698a4cec4","title":"【转载】libevent源码深度剖析08","content":"libevent源码深度剖析08集成信号处理\n现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I&#x2F;O事件和Signal以及Timer事件的集成，这一节将分析如何将Signal集成到事件主循环的框架中。\n1. 集成策略——使用socket pair前一节已经做了足够多的介绍了，基本方法就是采用“消息机制”。在libevent中这是通过socket pair完成的，下面就来详细分析一下。Socket pair就是一个socket对，包含两个socket，一个读socket，一个写socket。工作方式如下图所示：\n \n创建一个socket pair并不是复杂的操作，可以参见下面的流程图，清晰起见，其中忽略了一些错误处理和检查。\n\nLibevent提供了辅助函数evutil_socketpair()来创建一个socket pair，可以结合上面的创建流程来分析该函数。\n2. 集成到事件主循环——通知event_baseSocket pair创建好了，可是libevent的事件主循环还是不知道Signal是否发生了啊，看来我们还差了最后一步，那就是：为socket pair的读socket在libevent的event_base实例上注册一个persist的读事件。这样当向写socket写入数据时，读socket就会得到通知，触发读事件，从而event_base就能相应的得到通知了。前面提到过，Libevent会在事件主循环中检查标记，来确定是否有触发的signal，如果标记被设置就处理这些signal，这段代码在各个具体的I&#x2F;O机制中，以Epoll为例，在**epoll_dispatch()**函数中，代码片段如下：\n1234567891011res = epoll_wait(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout);    if (res == -1) &#123;        if (errno != EINTR) &#123;            event_warn(&quot;epoll_wait&quot;);            return (-1);        &#125;        evsignal_process(base);// 处理signal事件        return (0);    &#125; else if (base-&gt;sig.evsignal_caught) &#123;        evsignal_process(base);// 处理signal事件&#125;\n\n完整的处理框架如下所示：\n\n注1：libevent中，初始化阶段并不注册读socket的读事件，而是在注册信号阶段才会测试并注册；注2：libevent中，检查I&#x2F;O事件是在各系统I&#x2F;O机制的**dispatch()函数中完成的，该dispatch()函数在event_base_loop()**函数中被调用；\n3. evsignal_info结构体libevent中Signal事件的管理是通过结构体evsignal_info完成的，结构体位于evsignal.h文件中，定义如下：\n1234567891011121314struct evsignal_info &#123;    struct event ev_signal;    int ev_signal_pair[2];    int ev_signal_added;    volatile sig_atomic_t evsignal_caught;    struct event_list evsigevents[NSIG];    sig_atomic_t evsigcaught[NSIG];#ifdef HAVE_SIGACTION    struct sigaction **sh_old;#else    ev_sighandler_t **sh_old;#endif    int sh_old_max;&#125;;\n\n下面详细介绍一下个字段的含义和作用：1）ev_signal， 为socket pair的读socket向event_base注册读事件时使用的event结构体；2）ev_signal_pair，socket pair对，作用见第一节的介绍；3）ev_signal_added，记录ev_signal事件是否已经注册了；4）evsignal_caught，是否有信号发生的标记；是volatile类型，因为它会在另外的线程中被修改；5）evsigvents[NSIG]，数组，evsigevents[signo]表示注册到信号signo的事件链表；6）evsigcaught[NSIG]，具体记录每个信号触发的次数，evsigcaught[signo]是记录信号signo被触发的次数；7）sh_old记录了原来的signal处理函数指针，当信号signo注册的event被清空时，需要重新设置其处理函数；evsignal_info的初始化包括，创建socket pair，设置ev_signal事件（但并没有注册，而是等到有信号注册时才检查并注册），并将所有标记置零，初始化信号的注册事件链表指针等。\n4. 注册、注销signal事件注册signal事件是通过evsignal_add(struct event *ev)函数完成的，libevent对所有的信号注册同一个处理函数evsignal_handler()，该函数将在下一段介绍，注册过程如下：1 取得ev要注册到的信号signo；2 如果信号signo未被注册，那么就为signo注册信号处理函数evsignal_handler()；3 如果事件ev_signal还没哟注册，就注册ev_signal事件；4 将事件ev添加到signo的event链表中；从signo上注销一个已注册的signal事件就更简单了，直接从其已注册事件的链表中移除即可。如果事件链表已空，那么就恢复旧的处理函数；下面的讲解都以signal()函数为例，sigaction()函数的处理和signal()相似。处理函数evsignal_handler()函数做的事情很简单，就是记录信号的发生次数，并通知event_base有信号触发，需要处理：\n12345678910111213141516static void evsignal_handler(int sig)&#123;    int save_errno = errno; // 不覆盖原来的错误代码    if (evsignal_base == NULL) &#123;        event_warn(&quot;%s: received signal %d, but have no base configured&quot;, __func__, sig);        return;    &#125;    // 记录信号sig的触发次数，并设置event触发标记    evsignal_base-&gt;sig.evsigcaught[sig]++;    evsignal_base-&gt;sig.evsignal_caught = 1;#ifndef HAVE_SIGACTION    signal(sig, evsignal_handler); // 重新注册信号#endif    // 向写socket写一个字节数据，触发event_base的I/O事件，从而通知其有信号触发，需要处理    send(evsignal_base-&gt;sig.ev_signal_pair[0], &quot;a&quot;, 1, 0);    errno = save_errno; // 错误代码&#125;\n\n\n\n5. 小节本节介绍了libevent对signal事件的具体处理框架，包括事件注册、删除和socket pair通知机制，以及是如何将Signal事件集成到事件主循环之中的。\n","slug":"转载/libevent/libevent源码深度剖析08","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"3ac2d154bc8f115a96c543f8b70be68b","title":"【转载】libevent源码深度剖析09","content":"libevent源码深度剖析09集成定时器事件\n现在再来详细分析libevent中I&#x2F;O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libevent对堆的调整操作做了一些优化，本节还会描述这些优化方法。\n1. 集成到事件主循环因为系统的I&#x2F;O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I&#x2F;O事件发生，它们也保证能在timeout时间内返回。那么根据所有Timer事件的最小超时时间来设置系统I&#x2F;O的timeout时间；当系统I&#x2F;O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I&#x2F;O机制中了。具体的代码在源文件event.c的**event_base_loop()**中，现在就对比代码来看看这一处理方法：\n12345678910111213if (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;          // 根据Timer事件计算evsel-&gt;dispatch的最大等待时间          timeout_next(base, &amp;tv_p);      &#125; else &#123;           // 如果还有活动事件，就不要等待，让evsel-&gt;dispatch立即返回          evutil_timerclear(&amp;tv);      &#125;      // ...      // 调用select() or epoll_wait() 等待就绪I/O事件      res = evsel-&gt;dispatch(base, evbase, tv_p);      // ...      // 处理超时事件，将超时事件插入到激活链表中      timeout_process(base);\n\n**timeout_next()**函数根据堆中具有最小超时值的事件和当前时间来计算等待时间，下面看看代码：\n123456789101112131415161718192021 1static int timeout_next(struct event_base *base, struct timeval **tv_p)&#123; 2    struct timeval now; 3    struct event *ev; 4    struct timeval *tv = *tv_p; 5    // 堆的首元素具有最小的超时值 6    if ((ev = min_heap_top(&amp;base-&gt;timeheap)) == NULL) &#123; 7        // 如果没有定时事件，将等待时间设置为NULL,表示一直阻塞直到有I/O事件发生 8        *tv_p = NULL; 9        return (0);10    &#125;11    // 取得当前时间12    gettime(base, &amp;now);13    // 如果超时时间&lt;=当前值，不能等待，需要立即返回14    if (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) &#123;15        evutil_timerclear(tv);16        return (0);17    &#125;18    // 计算等待的时间=当前时间-最小的超时时间19    evutil_timersub(&amp;ev-&gt;ev_timeout, &amp;now, tv);20    return (0);21&#125;\n\n\n\n2. Timer小根堆libevent使用堆来管理Timer事件，其key值就是事件的超时时间，源代码位于文件min_heap.h中。所有的数据结构书中都有关于堆的详细介绍，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)。堆是一个完全二叉树，基本存储方式是一个数组。libevent实现的堆还是比较轻巧的，虽然我不喜欢这种编码方式（搞一些复杂的表达式）。轻巧到什么地方呢，就以插入元素为例，来对比说明，下面伪代码中的size表示当前堆的元素个数：\n典型的代码逻辑如下：\n12345678910Heap[size++] = new; // 先放到数组末尾，元素个数+1// 下面就是shift_up()的代码逻辑，不断的将new向上调整_child = size;while(_child&gt;0) // 循环&#123;    _parent = (_child-1)/2; // 计算parent    if(Heap[_parent].key &lt; Heap[_child].key)    \tbreak; // 调整结束，跳出循环    swap(_parent, _child); // 交换parent和child&#125;\n\n而libevent的heap代码对这一过程做了优化，在插入新元素时，只是为新元素预留了一个位置hole（初始时hole位于数组尾部），但并不立刻将新元素插入到hole上，而是不断向上调整hole的值，将父节点向下调整，最后确认hole就是新元素的所在位置时，才会真正的将新元素插入到hole上，因此在调整过程中就比上面的代码少了一次赋值的操作，代码逻辑是：\n123456789101112// 下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整_hole = size; // _hole就是为new预留的位置，但并不立刻将new放上while(_hole&gt;0) // 循环&#123;    _parent = (_hole-1)/2; // 计算parent    if(Heap[_parent].key &lt; new.key)        break; // 调整结束，跳出循环    Heap[_hole] = Heap[_parent]; // 将parent向下调整    _hole = _parent; // 将_hole调整到_parent&#125;Heap[_hole] = new; // 调整结束，将new插入到_hole指示的位置size++; // 元素个数+1\n\n由于每次调整都少做一次赋值操作，在调整路径比较长时，调整效率会比第一种有所提高。libevent中的**min_heap_shift_up_()函数就是上面逻辑的具体实现，对应的向下调整函数是min_heap_shift_down_()**。\n举个例子，向一个小根堆3, 5, 8, 7, 12中插入新元素2，使用第一中典型的代码逻辑，其调整过程如下图所示：\n\n使用libevent中的堆调整逻辑，调整过程如下图所示：\n\n对于删除和元素修改操作，也遵从相同的逻辑，就不再罗嗦了。\n3. 小节通过设置系统I&#x2F;O机制的wait时间，从而简洁的集成Timer事件；主要分析了libevent对堆调整操作的优化。\n","slug":"转载/libevent/libevent源码深度剖析09","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"7d0768b2cfc1e99a9f8dcf0642553217","title":"【转载】libevent源码深度剖析10","content":"libevent源码深度剖析10支持I&#x2F;O多路复用技术\nlibevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I&#x2F;O多路复用技术，而这些在Windows、Linux、Unix等不同平台上却各有不同，如何能提供优雅而统一的支持方式，是首要关键的问题，这其实不难，本节就来分析一下。\n1. 统一的关键libevent支持多种I&#x2F;O多路复用技术的关键就在于结构体eventop，这个结构体前面也曾提到过，它的成员是一系列的函数指针, 定义在event-internal.h文件中：\n12345678910struct eventop &#123;    const char *name;    void *(*init)(struct event_base *); // 初始化    int (*add)(void *, struct event *); // 注册事件    int (*del)(void *, struct event *); // 删除事件    int (*dispatch)(struct event_base *, void *, struct timeval *); // 事件分发    void (*dealloc)(struct event_base *, void *); // 注销，释放资源    /* set if we need to reinitialize the event base */    int need_reinit;&#125;;\n\n 在libevent中，每种I&#x2F;O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I&#x2F;O demultiplex机制了。\n2. 设置I&#x2F;O demultiplex机制libevent把所有支持的I&#x2F;O demultiplex机制存储在一个全局静态数组eventops中，并在初始化时选择使用何种机制，数组内容根据优先级顺序声明如下：\n12345678910111213141516171819202122232425/* In order of preference */static const struct eventop *eventops[] = &#123;#ifdef HAVE_EVENT_PORTS    &amp;evportops,#endif#ifdef HAVE_WORKING_KQUEUE    &amp;kqops,#endif#ifdef HAVE_EPOLL    &amp;epollops,#endif#ifdef HAVE_DEVPOLL    &amp;devpollops,#endif#ifdef HAVE_POLL    &amp;pollops,#endif#ifdef HAVE_SELECT    &amp;selectops,#endif#ifdef WIN32    &amp;win32ops,#endif    NULL&#125;; \n\n然后libevent根据系统配置和编译选项决定使用哪一种I&#x2F;O demultiplex机制，这段代码在函数**event_base_new()**中：\n12345678910111213base-&gt;evbase = NULL;for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) &#123;    base-&gt;evsel = eventops[i];    base-&gt;evbase = base-&gt;evsel-&gt;init(base);&#125; base-&gt;evbase = NULL;for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) &#123;    base-&gt;evsel = eventops[i];    base-&gt;evbase = base-&gt;evsel-&gt;init(base);&#125; \n\n可以看出，libevent在编译阶段选择系统的I&#x2F;O demultiplex机制，而不支持在运行阶段根据配置再次选择。\n以Linux下面的epoll为例，实现在源文件epoll.c中，eventops对象epollops定义如下：\n123456789const struct eventop epollops = &#123;    &quot;epoll&quot;,    epoll_init,    epoll_add,    epoll_del,    epoll_dispatch,    epoll_dealloc,    1 /* need reinit */&#125;;\n\n变量epollops中的函数指针具体声明如下，注意到其返回值和参数都和eventop中的定义严格一致，这是函数指针的语法限制。\n12345static void *epoll_init    (struct event_base *);static int epoll_add    (void *, struct event *);static int epoll_del    (void *, struct event *);static int epoll_dispatch(struct event_base *, void *, struct timeval *);static void epoll_dealloc    (struct event_base *, void *);\n\n那么如果选择的是epoll，那么调用结构体eventop的init和dispatch函数指针时，实际调用的函数就是epoll的初始化函数**epoll_init()和事件分发函数epoll_dispatch()**了；\nhttp://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx同样的，上面epollops以及epoll的各种函数都直接定义在了epoll.c源文件中，对外都是不可见的。对于libevent的使用者而言，完全不会知道它们的存在，对epoll的使用也是通过eventop来完成的，达到了信息隐藏的目的。\n3. 小节支持多种I&#x2F;O demultiplex机制的方法其实挺简单的，借助于函数指针就OK了。通过对源代码的分析也可以看出，libevent是在编译阶段选择系统的I&#x2F;O demultiplex机制的，而不支持在运行阶段根据配置再次选择。\n","slug":"转载/libevent/libevent源码深度剖析10","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"e1ec444aa92c9259448efee0050b6181","title":"【转载】libevent源码深度剖析11","content":"libevent源码深度剖析11时间管理\n为了支持定时器，libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的时间值调整等。下面就结合源代码来分析一下。\n1. 初始化检测libevent在初始化时会检测系统时间的类型，通过调用函数*d***etect_monotonic()完成，它通过调用clock_gettime()**来检测系统是否支持monotonic时钟类型：\n1234567static void detect_monotonic(void)&#123;#if defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)    struct timespec    ts;    if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) == 0)        use_monotonic = 1; // 系统支持monotonic时间#endif&#125;\n\nMonotonic时间指示的是系统从boot后到现在所经过的时间，如果系统支持Monotonic时间就将全局变量use_monotonic设置为1，设置use_monotonic到底有什么用，这个在后面说到时间校正时就能看出来了。\n2. 时间缓存结构体event_base中的tv_cache，用来记录时间缓存。这个还要从函数**gettime()**说起，先来看看该函数的代码：\n1234567891011121314151617181920static int gettime(struct event_base *base, struct timeval *tp)&#123;    // 如果tv_cache时间缓存已设置，就直接使用    if (base-&gt;tv_cache.tv_sec) &#123;        *tp = base-&gt;tv_cache;        return (0);    &#125;    // 如果支持monotonic，就用clock_gettime获取monotonic时间#if defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)    if (use_monotonic) &#123;        struct timespec    ts;        if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) == -1)            return (-1);        tp-&gt;tv_sec = ts.tv_sec;        tp-&gt;tv_usec = ts.tv_nsec / 1000;        return (0);    &#125;#endif    // 否则只能取得系统当前时间    return (evutil_gettimeofday(tp, NULL));&#125;\n\n如果tv_cache已经设置，那么就直接使用缓存的时间；否则需要再次执行系统调用获取系统时间。函数**evutil_gettimeofday()用来获取当前系统时间，在Linux下其实就是系统调用gettimeofday()；Windows没有提供函数gettimeofday，而是通过调用_ftime()**来完成的。在每次系统事件循环中，时间缓存tv_cache将会被相应的清空和设置，再次来看看下面event_base_loop的主要代码逻辑：\n123456789101112131415161718192021int event_base_loop(struct event_base *base, int flags)&#123;    // 清空时间缓存    base-&gt;tv_cache.tv_sec = 0;    while(!done)&#123;        timeout_correct(base, &amp;tv); // 时间校正        // 更新event_tv到tv_cache指示的时间或者当前时间（第一次）         // event_tv &lt;--- tv_cache        gettime(base, &amp;base-&gt;event_tv);        // 清空时间缓存-- 时间点1        base-&gt;tv_cache.tv_sec = 0;        // 等待I/O事件就绪        res = evsel-&gt;dispatch(base, evbase, tv_p);        // 缓存tv_cache存储了当前时间的值-- 时间点2         // tv_cache &lt;--- now        gettime(base, &amp;base-&gt;tv_cache);        // .. 处理就绪事件    &#125;    // 退出时也要清空时间缓存    base-&gt;tv_cache.tv_sec = 0;    return (0);&#125;\n\n时间event_tv指示了dispatch()上次返回，也就是I&#x2F;O事件就绪时的时间，第一次进入循环时，由于tv_cache被清空，因此gettime()执行系统调用获取当前系统时间；而后将会更新为tv_cache指示的时间。时间tv_cache在dispatch()返回后被设置为当前系统时间，因此它缓存了本次I&#x2F;O事件就绪时的时间（event_tv）。从代码逻辑里可以看出event_tv取得的是tv_cache上一次的值，因此event_tv应该小于tv_cache的值。设置时间缓存的优点是不必每次获取时间都执行系统调用，这是个相对费时的操作；在上面标注的时间点2到时间点1的这段时间（处理就绪事件时），调用gettime()取得的都是tv_cache缓存的时间。\n3. 时间校正如果系统支持monotonic时间，该时间是系统从boot后到现在所经过的时间，因此不需要执行校正。根据前面的代码逻辑，如果系统不支持monotonic时间，用户可能会手动的调整时间，如果时间被向前调整了（MS前面第7部分讲成了向后调整，要改正），比如从5点调整到了3点，那么在时间点2取得的值可能会小于上次的时间，这就需要调整了，下面来看看校正的具体代码，由函数**timeout_correct()**完成：\n123456789101112131415161718192021222324static void timeout_correct(struct event_base *base, struct timeval *tv)&#123;    struct event **pev;    unsigned int size;    struct timeval off;    if (use_monotonic) // monotonic时间就直接返回，无需调整        return;    gettime(base, tv); // tv &lt;---tv_cache    // 根据前面的分析可以知道event_tv应该小于tv_cache    // 如果tv &lt; event_tv表明用户向前调整时间了，需要校正时间    if (evutil_timercmp(tv, &amp;base-&gt;event_tv, &gt;=)) &#123;        base-&gt;event_tv = *tv;        return;    &#125;    // 计算时间差值    evutil_timersub(&amp;base-&gt;event_tv, tv, &amp;off);    // 调整定时事件小根堆    pev = base-&gt;timeheap.p;    size = base-&gt;timeheap.n;    for (; size-- &gt; 0; ++pev) &#123;        struct timeval *ev_tv = &amp;(**pev).ev_timeout;        evutil_timersub(ev_tv, &amp;off, ev_tv);    &#125;    base-&gt;event_tv = *tv; // 更新event_tv为tv_cache&#125;\n\n在调整小根堆时，因为所有定时事件的时间值都会被减去相同的值，因此虽然堆中元素的时间键值改变了，但是相对关系并没有改变，不会改变堆的整体结构。因此只需要遍历堆中的所有元素，将每个元素的时间键值减去相同的值即可完成调整，不需要重新调整堆的结构。当然调整完后，要将event_tv值重新设置为tv_cache值了。\n4. 小节主要分析了一下libevent对系统时间的处理，时间缓存、时间校正和定时堆的时间值调整等，逻辑还是很简单的，时间的加减、设置等辅助函数则非常简单，主要在头文件evutil.h中，就不再多说了。\n","slug":"转载/libevent/libevent源码深度剖析11","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"6ab33ba5c42af5d08609eb8e6d060470","title":"【转载】libevent源码深度剖析12","content":"libevent源码深度剖析12让libevent支持多线程\nlibevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代码并没有太大的关系，纯粹是使用上的技巧。\n1. 错误使用示例在多核的CPU上只使用一个线程始终是对不起CPU的处理能力啊，那好吧，那就多创建几个线程，比如下面的简单服务器场景。1 主线程创建工作线程1；2 接着主线程监听在端口上，等待新的连接；3 在线程1中执行event事件循环，等待事件到来；4 新连接到来，主线程调用libevent接口event_add将新连接注册到libevent上；… …上面的逻辑看起来没什么错误，在很多服务器设计中都可能用到主线程和工作线程的模式….可是就在线程1注册事件时，主线程很可能也在操作事件，比如删除，修改，通过libevent的源代码也能看到，没有同步保护机制，问题麻烦了，看起来不能这样做啊，难道只能使用单线程不成！？\n2. 支持多线程的几种模式libevent并不是线程安全的，但这不代表libevent不支持多线程模式，其实方法在前面已经将signal事件处理时就接触到了，那就是消息通知机制。一句话，“你发消息通知我，然后再由我在合适的时间来处理”；说到这就再多说几句，再打个比方，把你自己比作一个工作线程，而你的头是主线程，你有一个消息信箱来接收别人发给你的消息，当时头有个新任务要指派给你。\n2.1 暴力抢占那么第一节中使用的多线程方法相当下面的流程：1 当时你正在做事，比如在写文档；2 你的头找到了一个任务，要指派给你，比如帮他搞个PPT，哈；3 头命令你马上搞PPT，你这是不得不停止手头的工作，把PPT搞定了再接着写文档；…\n2.2 纯粹的消息通知机制那么基于纯粹的消息通知机制的多线程方式就像下面这样：1 当时你正在写文档；2 你的头找到了一个任务，要指派给你，帮他搞个PPT；3 头发个消息到你信箱，有个PPT要帮他搞定，这时你并不鸟他；4 你写好文档，接着检查消息发现头有个PPT要你搞定，你开始搞PPT；…第一种的好处是消息可以立即得到处理，但是很方法很粗暴，你必须立即处理这个消息，所以你必须处理好切换问题，省得把文档上的内容不小心写到PPT里。在操作系统的进程通信中，消息队列（消息信箱）都是操作系统维护的，你不必关心。第二种的优点是通过消息通知，切换问题省心了，不过消息是不能立即处理的（基于消息通知机制，这个总是难免的），而且所有的内容都通过消息发送，比如PPT的格式、内容等等信息，这无疑增加了通信开销。\n2.3 消息通知+同步层有个折中机制可以减少消息通信的开销，就是提取一个同步层，还拿上面的例子来说，你把工作安排都存放在一个工作队列中，而且你能够保证“任何人把新任务扔到这个队列”，“自己取出当前第一个任务”等这些操作都能够保证不会把队列搞乱（其实就是个加锁的队列容器）。再来看看处理过程和上面有什么不同：1 当时你正在写文档；2 你的头找到了一个任务，要指派给你，帮他搞个PPT；2 头有个PPT要你搞定，他把任务push到你的工作队列中，包括了PPT的格式、内容等信息；3 头发个消息（一个字节）到你信箱，有个PPT要帮他搞定，这时你并不鸟他；4 你写好文档，发现有新消息（这预示着有新任务来了），检查工作队列知道头有个PPT要你搞定，你开始搞PPT；…工作队列其实就是一个加锁的容器（队列、链表等等），这个很容易实现实现；而消息通知仅需要一个字节，具体的任务都push到了在工作队列中，因此想比2.2减少了不少通信开销。多线程编程有很多陷阱，线程间资源的同步互斥不是一两句能说得清的，而且出现bug很难跟踪调试；这也有很多的经验和教训，因此如果让我选择，在绝大多数情况下都会选择机制3作为实现多线程的方法。\n3. 例子——memcachedMemcached中的网络部分就是基于libevent完成的，其中的多线程模型就是典型的消息通知+同步层机制。下面的图足够说明其多线程模型了，其中有详细的文字说明。\n\n注：该图的具体出处忘记了，感谢原作者。\n4. 小节本节更是libevent的使用方面的技巧，讨论了一下如何让libevent支持多线程，以及几种支持多线程的机制，和memcached使用libevent的多线程模型。\n","slug":"转载/libevent/libevent源码深度剖析12","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"467347dafd8ded07c13ba37241779bf0","title":"【转载】libevent源码深度剖析13","content":"libevent源码深度剖析13libevent信号处理注意点\n前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况需要小心处理，那就是不能在多个 libevent 实例上注册信号事件。依然冠名追加到 libevent 系列。\n以 2 个线程为例，做简单的场景分析。\n1 首先是创建并初始化线程 1 的 libevent 实例 base1 ，线程 1 的 libevent 实例 base2 ；\n2 在 base1 上注册 SIGALRM 信号；在 base2 上注册 SIGINT 信号；\n3 假设当前 base1 和 base2 上都没有注册其他的事件；\n4 线程 1 和 2 都进入 event_base_loop 事件循环：\n\n5 假设线程 1 先进入 event_base_loop ，并设置 evsignal_base &#x3D; base1 ；并等待；\n6 接着线程 2 也进入 event_base_loop ，并设置 evsignal_base &#x3D; base2 ；并等待；\n 于是 evsignal_base 就指向了 base2 ；\n7 信号 ALARM 触发，调用服务例程：\n12345678static void evsignal_handler(int sig)&#123;       ...       evsignal_base-&gt;sig.evsigcaught[sig]++;       evsignal_base-&gt;sig.evsignal_caught = 1;       /* Wake up our notification mechanism */       send(evsignal_base-&gt;sig.ev_signal_pair[0], &quot;a&quot;, 1, 0);       ...&#125;\n\n于是 base2 得到通知 ALARM 信号发生了，而实际上 ALARM 是注册在 base1 上的， base2 上的 ALARM 注册 event 是空的，于是处理函数将不能得到调用；因此在 libevent 中，如果需要处理信号，只能将信号注册到一个 libevent 实例上。\nmemcached 就没有使用 libevent 提供的 signal 接口，而是直接使用系统提供的原生 API ，看起来这样更简洁。\nlibevent源码深度剖析全系列完。\n","slug":"转载/libevent/libevent源码深度剖析13","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,libevent,源码解析","author_index":"阿木大叔"},{"id":"c1e8331f572d9e5ea51efac83edeef24","title":"【转载】业务数据处理一定要单独开线程吗","content":"业务数据处理一定要单独开线程吗在 《one thread one loop 思想》一文我们介绍了一个 loop 的主要结构一般如下所示：\n12345678while (!m_bQuitFlag)&#123;\tepoll_or_select_func();\thandle_io_events();\thandle_other_things();&#125;\n\n对于一些业务逻辑处理比较简单、不会太耗时的应用来说，handle_io_events() 方法除了收发数据也可以直接用来直接做业务的处理，即其结构如下：\n12345678void handle_io_events()&#123;\t//收发数据\trecv_or_send_data();\t\t//解包并处理数据\tdecode_packages_and_process();&#125;\n\n其中 recv_or_send_data() 方法中调用 send&#x2F;recv API 进行实际的网络数据收发。以收数据为例，收完数据存入接收缓冲区后，接下来进行解包处理，然后进行业务处理，例如一个登陆数据包，其业务就是验证登陆的账户密码是否正确、记录其登陆行为等等。从程序函数调用堆栈来看，这些业务处理逻辑其实是直接在网络收发数据线程中处理的。我的意思是：网络线程调用 handle_io_events() 方法，handle_io_events() 方法调用 decode_packages_and_process() 方法，decode_packages_and_process() 方法做具体的业务逻辑处理。\n需要注意的是，为了让网络层与业务层脱耦，网络层中通常会提供一些回调函数的接口，这些回调函数我们将其指向具体的业务处理函数。以 libevent 网络库的用法为例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243int main(int argc, char **argv)&#123;\tstruct event_base *base;\tstruct evconnlistener *listener;\tstruct event *signal_event;\tstruct sockaddr_in sin;\tbase = event_base_new();\tmemset(&amp;sin, 0, sizeof(sin));\tsin.sin_family = AF_INET;\tsin.sin_port = htons(PORT);\t//listener_cb是我们自定义回调函数\tlistener = evconnlistener_new_bind(base, listener_cb, (void *)base,\t    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,\t    (struct sockaddr*)&amp;sin,\t    sizeof(sin));\tif (!listener) &#123;\t\tfprintf(stderr, &quot;Could not create a listener!\\n&quot;);\t\treturn 1;\t&#125;\t//signal_cb是我们自定义回调函数\tsignal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);\tif (!signal_event || event_add(signal_event, NULL)&lt;0) &#123;\t\tfprintf(stderr, &quot;Could not create/add a signal event!\\n&quot;);\t\treturn 1;\t&#125;\t//启动loop\tevent_base_dispatch(base);\tevconnlistener_free(listener);\tevent_free(signal_event);\tevent_base_free(base);\tprintf(&quot;done\\n&quot;);\treturn 0;&#125;\n\n上述代码根据 libevent 自带的 helloworld 示例修改而来，其中 listener_cb 和 signal_cb 是自定义的回调函数，有相应的事件触发后，libevent 的事件循环会调用我们设置的回调，在这些回调函数中，我们可以编写自己的业务逻辑代码。\n这种基本的服务器结构，我们可以绘制成如下流程图：\n\n这是这个结构的最基本逻辑，在这基础上可以延伸出很多变体。不知道读者有没有发现，上述流程图中第三步解包和业务逻辑处理这一步中（位于 handle_io_events() 中的 decode_packages_and_process() 方法中），如果业务逻辑处理过程比较耗时（例如，从数据库取大量数据、写文件），那么会导致 网络线程在这个步骤停留时间很长，导致很久以后才能执行下一次循环，影响网络数据的检测和收发，最终导致整个程序的效率低下。\n因此，对于这种情形，我们需要将业务处理逻辑单独拆出来交给另外的业务工作线程处理，业务工作线程可以是一个线程池，这个过程业务数据从网络线程组流向业务线程组。\n这样的程序结构图如下图所示：\n\n上图中，对于网络线程将业务数据包交给业务线程，可以使用一个共享的业务数据队列来实现，此时网络线程是生产者，业务线程从业务数据队列中取出任务去处理，业务线程是消费者。业务线程处理完成后如果需要将结果数据发出去，则再将数据交给网络线程。这里处理后的数据从业务线程再次流向网络线程，那么如何将数据从业务线程交给网络线程呢？这里以发数据为例，一般有三种方法：\n方法一\n直接调用相应的的发数据的方法，如果你的网络线程本身也会调用这些发数据的方法，那么此时就可能会出现网络线程和业务线程同时对发方法进行调用，相当于多个线程同时调用 socket send 函数，这样可能会导致同一个连接上的数据顺序有问题，此时的做法时，利用锁机制，同一时刻只有一个线程可以调用 socket send 方法。这里给出一段伪代码，假设 TcpConnection 对象表示某路连接，无论网络线程还是业务线程处理完数据后需要发送数据，则使用：\n123456void TcpConnection::sendData(const std::string&amp; data)&#123;\t//加上锁\tstd::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForConnection);\t//在这里调用 send&#125;\n\n方法一的做法在设计上来说，存在让人不满意的地方，即数据发送应该属于网络层自己的事情，而不是其他模块（这里指的是业务线程）强行抢夺过来越俎代庖。\n方法二\n前面章节介绍了存在定时器结构的情况，网络线程结构变成如下流程：\n12345678while (!m_bQuitFlag)&#123;\tcheck_and_handle_timers();\t\tepoll_or_select_func();\thandle_io_events();&#125;\n\n业务线程可以将需要发送的数据放入另外一个共享区域中（例如相应的 TcpConnection 对象的一个成员变量中），定时器定时从这个共享区域取出来，再发送出去，这种方案的优点是网络线程做了它该做的事情，缺点是需要添加定时器，让程序逻辑变得复杂，且定时器是每隔一段时间才会触发，发送的数据可能会有一定的延迟。\n方法三\n利用线程执行流中的 handle_other_things() 方法，再来看下前面章节中介绍的基本结构：\n12345678while (!m_bQuitFlag)&#123;\tepoll_or_select_func();\thandle_io_events();\thandle_other_things();&#125;\n\n我们在《one thread one loop 思想》章节介绍了 handle_other_things() 函数可以做一些“其他事情”，这个函数可以在需要执行时通过前面章节介绍的唤醒机制立即被唤醒执行。业务线程将数据放入某个共享区域中（这一步和方法二介绍的一样），然后添加 “other_things” ，在 handle_other_things() 中执行数据的发送。\n如果读者能清晰明白地看到这里，说明您大致明白了一个不错的服务器框架是怎么回事了。上面介绍的服务器结构是目前主流的基于 Reactor 模式的服务程序的通用结构，例如 libevent、libuv。\n如果读者有兴趣，咱们可以再进一步深入讨论一下。\n实际应用中，很多程序的业务逻辑处理其实是不耗时的，也就是说这些业务逻辑处理速度很快。由于 CPU 核数有限，当线程数量超过 CPU 数量时，各个线程（网络线程和业务线程）也不是真正地并行执行，那么即使开了一组业务线程也不一定能真正地并发执行，而业务逻辑处理并不耗时，不会影响网络线程的执行效率，那么我们不如就在网络线程里面直接处理。\n上文介绍了在 handle_io_events() 方法中直接处理，如果处理的业务逻辑会产生新的其他任务，那么我们可以投递 “other_things”，最终交给 handle_other_things() 方法来处理。此时的服务器程序结构如下：\n特别说明一下：这种方式仅限于 handle_io_events() 或 handle_other_things() 里面不会有耗时的逻辑，才可以替代专门开业务线程，如果有耗时操作还得老老实实单独开业务线程。虽然线程数量超过 CPU 数量时，各个线程不会得到真正的并行，但那是操作系统线程调度的事情了，应用层开发不必关心这点。\n","slug":"转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"51dbd98ea18bf4e97e2efcaab62e6cec","title":"【转载】C++高性能服务器网络框架设计细节","content":"C++ 高性能服务器网络框架设计细节这篇文章我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。需要注意的是一般大型服务器，其复杂程度在于其业务，而不是在于其代码工程的基本框架。大型服务器一般有多个服务组成，可能会支持CDN，或者支持所谓的“分布式”等，这篇文章不会介绍这些东西，因为不管结构多么复杂的服务器，都是由单个服务器组成的。所以这篇文章的侧重点是讨论单个服务程序的结构，而且这里的结构指的也是单个服务器的网络通信层结构，如果你能真正地理解了我所说的，那么在这个基础的结构上面开展任何业务都是可以的，也可以将这种结构扩展成复杂的多个服务器组，例如“分布式”服务。文中的代码示例虽然是以C++为例，但同样适合Java（我本人也是Java开发者），原理都是一样的，只不过Java可能在基本的操作系统网络通信API的基础上用虚拟机包裹了一层接口而已（Java甚至可能基于一些常用的网络通信框架思想提供了一些现成的API，例如NIO）。有鉴于此，这篇文章不讨论那些大而空、泛泛而谈的技术术语，而是讲的是实实在在的能指导读者在实际工作中实践的编码方案或优化已有编码的方法。另外这里讨论的技术同时涉及windows和linux两个平台。\n所谓高性能就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；所谓高并发，不仅指的是服务器可以同时支持多的客户端连接，而且这些客户端在连接期间内会不断与服务器有数据来往。网络上经常有各种网络库号称单个服务能同时支持百万甚至千万的并发，然后我实际去看了下，结果发现只是能同时支持很多的连接而已。如果一个服务器能单纯地接受ｎ个连接（ｎ可能很大），但是不能有条不紊地处理与这些连接之间的数据来往也没有任何意义，这种服务器框架只是“玩具型”的，对实际生产和应用没有任何意义。\n这篇文章将从两个方面来介绍，一个是服务器中的基础的网络通信部件；另外一个是，如何利用这些基础通信部件整合成一个完整的高效的服务器框架。注意：本文以下内容中的客户端是相对概念，指的是连接到当前讨论的服务程序的终端，所以这里的客户端既可能是我们传统意义上的客户端程序，也可能是连接该服务的其他服务器程序。\n一、网络通信部件 按上面介绍的思路，我们先从服务程序的网络通信部件开始介绍。\n（一）、需要解决的问题既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？目前，网络上有很多网络通信框架，如libevent、boost asio、ACE，但都网络通信的常见的技术手段都大同小异，至少要解决以下问题：\n\n如何检测有新客户端连接？\n如何接受客户端连接？\n如何检测客户端是否有数据发来？\n如何收取客户端发来的数据？\n如何检测连接异常？发现连接异常之后，如何处理？\n如何给客户端发送数据？\n如何在给客户端发完数据后关闭连接？\n\n稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API。确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是如何巧妙地组织这些基础的socket API，才是问题的关键。我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样，从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待或者不等待”这一原则就是高效的，也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情123456789，另外一部分闲在那里无所事事。说的可能有点抽象，下面我们来举一些例子具体来说明一下。例如：\n\n默认情况下，recv函数如果没有数据的时候，线程就会阻塞在那里；\n默认情况下，send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；\nconnect函数默认连接另外一端的时候，也会阻塞在那里；\n又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。\n\n以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的IO Multiplexing技术（IO复用技术）。\n（二）、几种IO复用机制的比较目前windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP），linux系统支持select、poll、epoll。这里我们不具体介绍每个具体的函数的用法，我们来讨论一点深层次的东西，以上列举的API函数可以分为两个层次：\n\n层次一 select和poll\n层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll\n\n为什么这么分呢？先来介绍第一层次，select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。这也就是层次二的各个函数做的事情，它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，比如WSAAsyncSelect是利用windows窗口消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已。\n例如，connect函数连接另外一端，如果用于连接socket是非阻塞的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的第二个原则：尽量减少做无用功的时间。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，这里就成了性能的一个瓶颈。\n（三）、检测网络事件的正确姿势根据上面的介绍，第一，为了避免无意义的等待时间，第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。我们的socket都要设置成非阻塞的。在此基础上我们回到栏目（一）中提到的七个问题：\n\n如何检测有新客户端连接？\n\n如何接受客户端连接？ 默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。\n 　　\n\n如何检测客户端是否有数据发来？\n\n如何收取客户端发来的数据？ 同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待，至于一次性收多少数据好呢？我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了。示例：\n bool CIUSocket::Recv() { int nRet &#x3D; 0; while(true) {     char buff[512];     nRet &#x3D; ::recv(m_hSocket, buff, 512, 0);     if(nRet &#x3D;&#x3D; SOCKET_ERROR)     {         if (::WSAGetLastError() &#x3D;&#x3D; WSAEWOULDBLOCK)            break;         else             return false;     }     else if(nRet &lt; 1)         return false;     m_strRecvBuf.append(buff, nRet);     ::Sleep(1); } return true; }\n\n如何检测连接异常？发现连接异常之后，如何处理？ 同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。\n\n如何给客户端发送数据？ 这也是一道常见的网络通信面试题，某一年的腾讯后台开发职位就问到过这样的问题。给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。首先我们不能像注册检测数据可读事件一样一开始就注册检测数据可写事件，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。所以正确的做法是：如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后再设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。\n 　　\n\n如何在给客户端发完数据后关闭连接？ 这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。当然，你也可以调用shutdown函数来实现所谓的“半关闭”。关于关闭连接的话题，我们再单独开一个小的标题来专门讨论一下。\n\n\n（四）被动关闭连接和主动关闭连接在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接。\n而主动关闭连接，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。\n（五）发送缓冲区和接收缓冲区上面已经介绍了发送缓冲区了，并说明了其存在的意义。接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如需要进行复杂的运算，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。\n说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。\n需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个。这是我们最常见的设计方案。\n（六）协议的设计除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。我们知道tcp&#x2F;ip协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限。比如A端给B端连续发了三个数据包，每个数据包都是50个字节，B端可能先收到10个字节，再收到140个字节；或者先收到20个字节，再收到20个字节，再收到110个字节；也可能一次性收到150个字节。这150个字节可以以任何字节数目组合和次数被B收到。所以我们讨论协议的设计第一个问题就是如何界定包的界限，也就是接收端如何知道每个包数据的大小。目前常用有如下三种方法：１. 固定大小，这种方法就是假定每一个包的大小都是固定字节数目，例如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包。２. 指定包结束符，例如以一个\\r\\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容。３. 指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。\n协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。\n协议要讨论的第三个问题是，根据协议组装的单个数据包应该尽量小，注意这里指的是单个数据包，这样有如下好处：第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。试想：假如一个股票服务器，如果一只股票的数据包是100个字节或者1000个字节，那同样是10000只股票区别呢？\n协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度，比如long型，在32位机器上是32位4个字节，但是如果在64位机器上，就变成了64位8个字节了。这样同样是一个long型，发送方和接收方可能因为机器位数的不同会用不同的长度去解码。所以建议最好，在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，比如int32、int64等等。下面是一个协议的接口的例子，当然java程序员应该很熟悉这样的接口：\ntxtclass BinaryReadStream\n&#123;\nprivate:\n    const char* const ptr;\n    const size_t      len;\n    const char*       cur;\n    BinaryReadStream(const BinaryReadStream&amp;);\n    BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);\npublic:\n    BinaryReadStream(const char* ptr, size_t len);\n    virtual const char* GetData() const;\n    virtual size_t GetSize() const;\n    bool IsEmpty() const;\n    bool ReadString(string* str, size_t maxlen, size_t&amp; outlen);\n    bool ReadCString(char* str, size_t strlen, size_t&amp; len);\n    bool ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen);\n    bool ReadInt32(int32_t&amp; i);\n    bool ReadInt64(int64_t&amp; i);\n    bool ReadShort(short&amp; i);\n    bool ReadChar(char&amp; c);\n    size_t ReadAll(char* szBuffer, size_t iLen) const;\n    bool IsEnd() const;\n    const char* GetCurrent() const&#123; return cur; &#125;\n\npublic:\n    bool ReadLength(size_t &amp; len);\n    bool ReadLengthWithoutOffset(size_t &amp;headlen, size_t &amp; outlen);\n&#125;;\n\nclass BinaryWriteStream\n&#123;\npublic:\n    BinaryWriteStream(string* data);\n    virtual const char* GetData() const;\n    virtual size_t GetSize() const;\n    bool WriteCString(const char* str, size_t len);\n    bool WriteString(const string&amp; str);\n    bool WriteDouble(double value, bool isNULL = false);\n    bool WriteInt64(int64_t value, bool isNULL = false);\n    bool WriteInt32(int32_t i, bool isNULL = false);\n    bool WriteShort(short i, bool isNULL = false);\n    bool WriteChar(char c, bool isNULL = false);\n    size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;\n    void Flush();\n    void Clear();\nprivate:\n    string* m_data;\n&#125;;其中BinaryWriteStream是编码协议的类，BinaryReadStream是解码协议的类。可以按下面这种方式来编码和解码。编码：\n123456std::string outbuf;BinaryWriteStream writeStream(&amp;outbuf);writeStream.WriteInt32(msg_type_register);writeStream.WriteInt32(m_seq);writeStream.WriteString(retData);writeStream.Flush();\n\n解码：\n12345678910111213141516171819BinaryReadStream readStream(strMsg.c_str(), strMsg.length());int32_t cmd;if (!readStream.ReadInt32(cmd))&#123;\treturn false;&#125;//int seq;if (!readStream.ReadInt32(m_seq))&#123;\treturn false;&#125;std::string data;size_t datalength;if (!readStream.ReadString(&amp;data, 0, datalength))&#123;\treturn false;&#125;\n\n\n\n\n二、服务器程序结构的组织\n上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。根据我的个人经验，目前主流的思想是one thread one loop+reactor模式（也有proactor模式）的策略。通俗点说就是一个线程一个循环，即在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑。我们先从最简单地来说，设定一些线程在一个循环里面做网络通信相关的事情，伪码如下：\n123456789101112while(退出标志)  &#123;  \t//IO复用技术检测socket可读事件、出错事件  \t//（如果有数据要发送，则也检测可写事件）  \t//如果有可读事件，对于侦听socket则接收新连接；      //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；      //如果有数据要发送，有可写事件，则发送数据      //如果有出错事件，关闭该连接   &#125;  \n\n另外设定一些线程去处理接收到的数据，并解包处理业务逻辑，这些线程可以认为是业务线程了，伪码如下：\ntxt//从接收缓冲区中取出数据解包，分解成不同的业务来处理  上面的结构是目前最通用的服务器逻辑结构，但是能不能再简化一下或者说再综合一下呢？我们试试，你想过这样的问题没有：假如现在的机器有两个cpu（准确的来说应该是两个核），我们的网络线程数量是2个，业务逻辑线程也是2个，这样可能存在的情况就是：业务线程运行的时候，网络线程并没有运行，它们必须等待，如果是这样的话，干嘛要多建两个线程呢？除了程序结构上可能稍微清楚一点，对程序性能没有任何实质性提高，而且白白浪费cpu时间片在线程上下文切换上。所以，我们可以将网络线程与业务逻辑线程合并，合并后的伪码看起来是这样子的：\ntxtwhile(退出标志)  \n&#123;  \n    //IO复用技术检测socket可读事件、出错事件  \n    //（如果有数据要发送，则也检测可写事件）  \n      \n　　//如果有可读事件，对于侦听socket则接收新连接；  \n　　//对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  \n  \n　　//如果有数据要发送，有可写事件，则发送数据  \n  \n　　//如果有出错事件，关闭该连接  \n  \n　　//从接收缓冲区中取出数据解包，分解成不同的业务来处理  \n&#125; 你没看错，其实就是简单的合并，合并之后和不仅可以达到原来合并前的效果，而且在没有网络IO事件的时候，可以及时处理我们想处理的一些业务逻辑，并且减少了不必要的线程上下文切换时间。\n我们再更进一步，甚至我们可以在这个while循环增加其它的一些任务的处理，比如程序的逻辑任务队列、定时器事件等等，伪码如下：\ntxtwhile(退出标志)  \n&#123;  \n    //定时器事件处理  \n\n    //IO复用技术检测socket可读事件、出错事件  \n    //（如果有数据要发送，则也检测可写事件）  \n\n    //如果有可读事件，对于侦听socket则接收新连接；  \n    //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  \n\n    //如果有数据要发送，有可写事件，则发送数据  \n\n    //如果有出错事件，关闭该连接  \n\n    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  \n\n    //程序自定义任务1  \n\n    //程序自定义任务2  \n&#125; 注意：之所以将定时器事件的处理放在网络IO事件的检测之前，是因为避免定时器事件过期时间太长。假如放在后面的话，可能前面的处理耗费了一点时间，等到处理定时器事件时，时间间隔已经过去了不少时间。虽然这样处理，也没法保证定时器事件百分百精确，但是能尽量保证。当然linux系统下提供eventfd这样的定时器对象，所有的定时器对象就能像处理socket这样的fd一样统一成处理。这也是网络库libevent的思想很像，libevent将socket、定时器、信号封装成统一的对象进行处理。\n说了这么多理论性的东西，我们来一款流行的开源网络库muduo来说明吧（作者：陈硕），原库是基于boost的，我改成了C++11的版本，并修改了一些bug，在此感谢原作者陈硕。\n上文介绍的核心线程函数的while循环位于eventloop.cpp中：\ntxtvoid EventLoop::loop()\n&#123;\n    assert(!looping_);\n    assertInLoopThread();\n    looping_ = true;\n    quit_ = false;  \n    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;\n    while (!quit_)\n    &#123;\n        activeChannels_.clear();\n        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);\n        ++iteration_;\n        if (Logger::logLevel() &lt;= Logger::TRACE)\n        &#123;\n            printActiveChannels();\n        &#125;\n        // TODO sort channel by priority\n        eventHandling_ = true;\n        for (ChannelList::iterator it = activeChannels_.begin();\n            it != activeChannels_.end(); ++it)\n        &#123;\n            currentActiveChannel_ = *it;\n            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);\n        &#125;\n        currentActiveChannel_ = NULL;\n        eventHandling_ = false;\n        doPendingFunctors();\n\n        if (frameFunctor_)\n        &#123;\n            frameFunctor_();\n        &#125;\t\t\n    &#125;\n\n    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;\n    looping_ = false;\n&#125;poller_-&gt;poll利用epoll分离网络事件，然后接着处理分离出来的网络事件，每一个客户端socket对应一个连接，即一个TcpConnection和Channel通道对象。currentActiveChannel_-&gt;handleEvent(pollReturnTime_)根据是可读、可写、出错事件来调用对应的处理函数，这些函数都是回调函数，程序初始化阶段设置进来的：\ntxtvoid Channel::handleEvent(Timestamp receiveTime)\n&#123;  \n    std::shared_ptr&lt;void&gt; guard;  \n    if (tied_)  \n    &#123;  \n        guard = tie_.lock();  \n        if (guard)  \n        &#123;  \n            handleEventWithGuard(receiveTime);  \n        &#125;  \n    &#125;  \n    else  \n    &#123;  \n        handleEventWithGuard(receiveTime);  \n    &#125;  \n&#125;  \n\nvoid Channel::handleEventWithGuard(Timestamp receiveTime)  \n&#123;  \n    eventHandling_ = true;  \n    LOG_TRACE &lt;&lt; reventsToString();  \n    if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))  \n    &#123;  \n        if (logHup_)  \n        &#123;  \n            LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLHUP&quot;;  \n        &#125;  \n        if (closeCallback_) closeCallback_();  \n    &#125;\n    if (revents_ &amp; POLLNVAL)  \n    &#123;  \n        LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLNVAL&quot;;  \n    &#125;  \n\n    if (revents_ &amp; (POLLERR | POLLNVAL))  \n    &#123;  \n        if (errorCallback_) errorCallback_();  \n    &#125;  \n    if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))  \n    &#123;  \n        //当是侦听socket时，readCallback_指向Acceptor::handleRead  \n        //当是客户端socket时，调用TcpConnection::handleRead   \n        if (readCallback_) readCallback_(receiveTime);  \n    &#125;  \n    if (revents_ &amp; POLLOUT)  \n    &#123;  \n        //如果是连接状态服的socket，则writeCallback_指向Connector::handleWrite()  \n        if (writeCallback_) writeCallback_();  \n    &#125;  \n    eventHandling_ = false; \n&#125; 当然，这里利用了Channel对象的“多态性”，如果是普通socket，可读事件就会调用预先设置的回调函数；但是如果是侦听socket，则调用Aceptor对象的handleRead()来接收新连接：\n1234567891011121314151617181920212223242526272829303132333435void Acceptor::handleRead()  &#123;      loop_-&gt;assertInLoopThread();      InetAddress peerAddr;      //FIXME loop until no more      int connfd = acceptSocket_.accept(&amp;peerAddr);      if (connfd &gt;= 0)      &#123;          // string hostport = peerAddr.toIpPort();          // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;          //newConnectionCallback_实际指向TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)          if (newConnectionCallback_)          &#123;              newConnectionCallback_(connfd, peerAddr);          &#125;          else          &#123;              sockets::close(connfd);          &#125;      &#125;      else      &#123;          LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;          // Read the section named &quot;The special problem of          // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.          // By Marc Lehmann, author of livev.          if (errno == EMFILE)          &#123;              ::close(idleFd_);              idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);              ::close(idleFd_);              idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);          &#125;      &#125;  &#125;  \n\n主循环里面的业务逻辑处理对应：\ntxtdoPendingFunctors();  \nif (frameFunctor_)  \n&#123;  \n   frameFunctor_();  \n&#125;       123456789101112131415void EventLoop::doPendingFunctors()  &#123;      std::vector&lt;Functor&gt; functors;      callingPendingFunctors_ = true;     &#123;          std::unique_lock&lt;std::mutex&gt; lock(mutex_);          functors.swap(pendingFunctors_);  \t&#125;        for (size_t i = 0; i &lt; functors.size(); ++i)      &#123;          functors[i]();      &#125;      callingPendingFunctors_ = false;&#125; \n\n 这里增加业务逻辑是增加执行任务的函数指针的，增加的任务保存在成员变量pendingFunctors_中，这个变量是一个函数指针数组（vector对象），执行的时候，调用每个函数就可以了。上面的代码先利用一个栈变量将成员变量pendingFunctors_里面的函数指针换过来，接下来对这个栈变量进行操作就可以了，这样减少了锁的粒度。因为成员变量pendingFunctors_在增加任务的时候，也会被用到，设计到多个线程操作，所以要加锁，增加任务的地方是：\ntxtvoid EventLoop::queueInLoop(const Functor&amp; cb)  \n&#123;  \n    &#123;  \n        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  \n        pendingFunctors_.push_back(cb);  \n    &#125;  \n    if (!isInLoopThread() || callingPendingFunctors_)  \n    &#123;  \n        wakeup();  \n    &#125;  \n&#125;  而frameFunctor_就更简单了，就是通过设置一个函数指针就可以了。当然这里有个技巧性的东西，即增加任务的时候，为了能够立即执行，使用唤醒机制，通过往一个fd里面写入简单的几个字节，来唤醒epoll，使其立刻返回，因为此时没有其它的socke有事件，这样接下来就执行刚才添加的任务了。\n我们看一下数据收取的逻辑：\n1234567891011121314151617181920void TcpConnection::handleRead(Timestamp receiveTime)  &#123;      loop_-&gt;assertInLoopThread();      int savedErrno = 0;      ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);      if (n &gt; 0)      &#123;            messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);      &#125;      else if (n == 0)      &#123;          handleClose();      &#125;      else      &#123;          errno = savedErrno;          LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;          handleError();      &#125;  &#125;  \n\n将收到的数据放到接收缓冲区里面，将来我们来解包：\n123456789101112131415161718192021222324252627void ClientSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)  &#123;      while (true)      &#123;          //不够一个包头大小          if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))          &#123;              LOG_INFO &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);              return;          &#125;         //不够一个整包大小          msg header;          memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));          if (pBuffer-&gt;readableBytes() &lt; (size_t)header.packagesize + sizeof(msg))              return;          pBuffer-&gt;retrieve(sizeof(msg));          std::string inbuf;          inbuf.append(pBuffer-&gt;peek(), header.packagesize);          pBuffer-&gt;retrieve(header.packagesize);          if (!Process(conn, inbuf.c_str(), inbuf.length()))          &#123;              LOG_WARN &lt;&lt; &quot;Process error, close TcpConnection&quot;;              conn-&gt;forceClose();          &#125;  \t&#125;// end while-loop  &#125; \n\n先判断接收缓冲区里面的数据是否够一个包头大小，如果够再判断够不够包头指定的包体大小，如果还是够的话，接着在Process函数里面处理该包。\n再看看发送数据的逻辑：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void TcpConnection::sendInLoop(const void* data, size_t len)  &#123;      loop_-&gt;assertInLoopThread();      ssize_t nwrote = 0;      size_t remaining = len;      bool faultError = false;      if (state_ == kDisconnected)      &#123;          LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;          return;      &#125;      // if no thing in output queue, try writing directly      if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)      &#123;          nwrote = sockets::write(channel_-&gt;fd(), data, len);          if (nwrote &gt;= 0)          &#123;              remaining = len - nwrote;              if (remaining == 0 &amp;&amp; writeCompleteCallback_)              &#123;                  loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));              &#125;          &#125;          else // nwrote &lt; 0          &#123;              nwrote = 0;              if (errno != EWOULDBLOCK)              &#123;                  LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;                  if (errno == EPIPE || errno == ECONNRESET) // FIXME: any others?                  &#123;                      faultError = true;                  &#125;              &#125;          &#125;      &#125;      assert(remaining &lt;= len);      if (!faultError &amp;&amp; remaining &gt; 0)      &#123;          size_t oldLen = outputBuffer_.readableBytes();          if (oldLen + remaining &gt;= highWaterMark_                                      &amp;&amp; oldLen &lt; highWaterMark_              &amp;&amp; highWaterMarkCallback_)          &#123;              loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));          &#125;          outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);          if (!channel_-&gt;isWriting())          &#123;              channel_-&gt;enableWriting();          &#125;      &#125; &#125; \n\n如果剩余的数据remaining大于则调用channel_-&gt;enableWriting();开始监听可写事件，可写事件处理如下：\n123456789101112131415161718192021222324252627282930313233343536373839void TcpConnection::handleWrite()  &#123;      loop_-&gt;assertInLoopThread();      if (channel_-&gt;isWriting())      &#123;          ssize_t n = sockets::write(channel_-&gt;fd(),              outputBuffer_.peek(),              outputBuffer_.readableBytes());          if (n &gt; 0)          &#123;              outputBuffer_.retrieve(n);              if (outputBuffer_.readableBytes() == 0)              &#123;                  channel_-&gt;disableWriting();                  if (writeCompleteCallback_)                  &#123;                      loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));                  &#125;                  if (state_ == kDisconnecting)                  &#123;                      shutdownInLoop();                  &#125;              &#125;          &#125;          else          &#123;              LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;              // if (state_ == kDisconnecting)              // &#123;              //   shutdownInLoop();              // &#125;          &#125;      &#125;      else      &#123;          LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()              &lt;&lt; &quot; is down, no more writing&quot;;      &#125;  &#125;  \n\n如果发送完数据以后调用channel_-&gt;disableWriting();移除监听可写事件。\n很多读者可能一直想问，文中不是说解包数据并处理逻辑是业务代码而非网络通信的代码，你这里貌似都混在一起了，其实没有，这里实际的业务代码处理都是框架曾提供的回调函数里面处理的，具体怎么处理，由框架使用者——业务层自己定义。\n总结起来，实际上就是一个线程函数里一个loop那么点事情，不信你再看我曾经工作上的一个交易系统服务器项目代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void CEventDispatcher::Run()  &#123;      m_bShouldRun = true;      while(m_bShouldRun)      &#123;          DispatchIOs();                SyncTime();          CheckTimer();          DispatchEvents();      &#125;  &#125;  void CEpollReactor::DispatchIOs()  &#123;      DWORD dwSelectTimeOut = SR_DEFAULT_EPOLL_TIMEOUT;      if (HandleOtherTask())      &#123;          dwSelectTimeOut = 0;      &#125;      struct epoll_event ev;      CEventHandlerIdMap::iterator itor = m_mapEventHandlerId.begin();      for(; itor!=m_mapEventHandlerId.end(); itor++)      &#123;          CEventHandler *pEventHandler = (CEventHandler *)(*itor).first;          if(pEventHandler == NULL)&#123;              continue;          &#125;          ev.data.ptr = pEventHandler;          ev.events = 0;          int nReadID, nWriteID;          pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);            if (nReadID &gt; 0)          &#123;              ev.events |= EPOLLIN;          &#125;          if (nWriteID &gt; 0)          &#123;              ev.events |= EPOLLOUT;          &#125;          epoll_ctl(m_fdEpoll, EPOLL_CTL_MOD, (*itor).second, &amp;ev);      &#125;      struct epoll_event events[EPOLL_MAX_EVENTS];      int nfds = epoll_wait(m_fdEpoll, events, EPOLL_MAX_EVENTS, dwSelectTimeOut/1000);      for (int i=0; i&lt;nfds; i++)      &#123;          struct epoll_event &amp;evref = events[i];          CEventHandler *pEventHandler = (CEventHandler *)evref.data.ptr;          if ((evref.events|EPOLLIN)!=0 &amp;&amp; m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())          &#123;              pEventHandler-&gt;HandleInput();          &#125;          if ((evref.events|EPOLLOUT)!=0 &amp;&amp; m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())          &#123;              pEventHandler-&gt;HandleOutput();          &#125;      &#125; &#125; void CEventDispatcher::DispatchEvents()  &#123;      CEvent event;      CSyncEvent *pSyncEvent;      while(m_queueEvent.PeekEvent(event))      &#123;          int nRetval;         if(event.pEventHandler != NULL)          &#123;              nRetval = event.pEventHandler-&gt;HandleEvent(event.nEventID, event.dwParam, event.pParam);          &#125;          else          &#123;              nRetval = HandleEvent(event.nEventID, event.dwParam, event.pParam);          &#125;          if(event.pAdd != NULL)      //同步消息          &#123;              pSyncEvent=(CSyncEvent *)event.pAdd;              pSyncEvent-&gt;nRetval = nRetval;              pSyncEvent-&gt;sem.UnLock();          &#125;  \t&#125;&#125;\n\n再看看蘑菇街开源的TeamTalk的源码（代码下载地址：https://github.com/baloonwj/TeamTalk）：\ntxtvoid CEventDispatch::StartDispatch(uint32_t wait_timeout)  \n&#123;  \n    fd_set read_set, write_set, excep_set;  \n    timeval timeout;  \n    timeout.tv_sec = 0;  \n    timeout.tv_usec = wait_timeout * 1000;  // 10 millisecond \n    if(running)  \n        return;  \n    running = true;  \n  \n    while (running) \n    &#123;  \n        _CheckTimer();  \n        _CheckLoop(); \n        if (!m_read_set.fd_count &amp;&amp; !m_write_set.fd_count &amp;&amp; !m_excep_set.fd_count)  \n        &#123;  \n            Sleep(MIN_TIMER_DURATION);  \n            continue;  \n        &#125;  \n  \n        m_lock.lock();  \n        memcpy(&amp;read_set, &amp;m_read_set, sizeof(fd_set));  \n        memcpy(&amp;write_set, &amp;m_write_set, sizeof(fd_set));  \n        memcpy(&amp;excep_set, &amp;m_excep_set, sizeof(fd_set));  \n        m_lock.unlock();  \n\n        int nfds = select(0, &amp;read_set, &amp;write_set, &amp;excep_set, &amp;timeout);  \n\n        if (nfds == SOCKET_ERROR)  \n        &#123;  \n            log(&quot;select failed, error code: %d&quot;, GetLastError());  \n            Sleep(MIN_TIMER_DURATION);  \n            continue;           // select again  \n        &#125;  \n\n        if (nfds == 0)  \n        &#123;  \n            continue;  \n        &#125;  \n\n        for (u_int i = 0; i &lt; read_set.fd_count; i++)  \n        &#123;  \n            //log(&quot;select return read count=%d\\n&quot;, read_set.fd_count);  \n            SOCKET fd = read_set.fd_array[i];  \n            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  \n            if (pSocket)  \n            &#123;  \n                pSocket-&gt;OnRead();  \n                pSocket-&gt;ReleaseRef();  \n            &#125;  \n        &#125;  \n\n        for (u_int i = 0; i &lt; write_set.fd_count; i++)  \n        &#123;  \n            //log(&quot;select return write count=%d\\n&quot;, write_set.fd_count);  \n            SOCKET fd = write_set.fd_array[i];  \n            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  \n            if (pSocket)  \n            &#123;  \n                pSocket-&gt;OnWrite();  \n                pSocket-&gt;ReleaseRef();  \n            &#125;  \n        &#125;  \n\n        for (u_int i = 0; i &lt; excep_set.fd_count; i++)  \n        &#123;  \n            //log(&quot;select return exception count=%d\\n&quot;, excep_set.fd_count);  \n            SOCKET fd = excep_set.fd_array[i];  \n            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  \n            if (pSocket)  \n            &#123;  \n                pSocket-&gt;OnClose();  \n                pSocket-&gt;ReleaseRef();  \n            &#125;  \n        &#125;   \n    &#125; \n&#125;  再看filezilla，一款ftp工具的服务器端，它采用的是Windows的WSAAsyncSelect模型（代码下载地址：https://github.com/baloonwj/filezilla）：\ntxt//Processes event notifications sent by the sockets or the layers\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n&#123;\n    if (message&gt;=WM_SOCKETEX_NOTIFY)\n    &#123;\n        //Verify parameters\n        ASSERT(hWnd);\n        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);\n        ASSERT(pWnd);\n        if (!pWnd)\n            return 0;\n\n        if (message &lt; static_cast&lt;UINT&gt;(WM_SOCKETEX_NOTIFY+pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage\n        &#123;\n            //Lookup socket and verify if it&#39;s valid\n            CAsyncSocketEx *pSocket=pWnd-&gt;m_pAsyncSocketExWindowData[message - WM_SOCKETEX_NOTIFY].m_pSocket;\n            SOCKET hSocket = wParam;\n            if (!pSocket)\n                return 0;\n            if (hSocket == INVALID_SOCKET)\n                return 0;\n            if (pSocket-&gt;m_SocketData.hSocket != hSocket)\n                return 0;\n\n            int nEvent = lParam &amp; 0xFFFF;\n            int nErrorCode = lParam &gt;&gt; 16;\n\n            //Dispatch notification\n            if (!pSocket-&gt;m_pFirstLayer) &#123;\n                //Dispatch to CAsyncSocketEx instance\n                switch (nEvent)\n                &#123;\n                case FD_READ:\n                 #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                        &#123;\n                            pSocket-&gt;m_nPendingEvents |= FD_READ;\n                            break;\n                        &#125;\n                        else if (pSocket-&gt;GetState() == attached)\n                            pSocket-&gt;SetState(connected);\n                        if (pSocket-&gt;GetState() != connected)\n                            break;\n                            // Ignore further FD_READ events after FD_CLOSE has been received\n                        if (pSocket-&gt;m_SocketData.onCloseCalled)\n                            break;\n                             #endif //NOSOCKETSTATES\n\n #ifndef NOSOCKETSTATES\n                        if (nErrorCode)\n                            pSocket-&gt;SetState(aborted);\n #endif //NOSOCKETSTATES\n                        if (pSocket-&gt;m_lEvent &amp; FD_READ) &#123;\n                            pSocket-&gt;OnReceive(nErrorCode);\n                        &#125;\n                        break;\n                    case FD_FORCEREAD: //Forceread does not check if there&#39;s data waiting\n #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                        &#123;\n                            pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;\n                            break;\n                        &#125;\n                        else if (pSocket-&gt;GetState() == attached)\n                            pSocket-&gt;SetState(connected);\n                        if (pSocket-&gt;GetState() != connected)\n                            break;\n #endif //NOSOCKETSTATES\n                        if (pSocket-&gt;m_lEvent &amp; FD_READ)\n                        &#123;\n #ifndef NOSOCKETSTATES\n                            if (nErrorCode)\n                                pSocket-&gt;SetState(aborted);\n #endif //NOSOCKETSTATES\n                            pSocket-&gt;OnReceive(nErrorCode);\n                        &#125;\n                        break;\n                    case FD_WRITE:\n #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                        &#123;\n                            pSocket-&gt;m_nPendingEvents |= FD_WRITE;\n                            break;\n                        &#125;\n                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                            pSocket-&gt;SetState(connected);\n                        if (pSocket-&gt;GetState() != connected)\n                            break;\n #endif //NOSOCKETSTATES\n                        if (pSocket-&gt;m_lEvent &amp; FD_WRITE)\n                        &#123;\n #ifndef NOSOCKETSTATES\n                            if (nErrorCode)\n                                pSocket-&gt;SetState(aborted);\n #endif //NOSOCKETSTATES\n                            pSocket-&gt;OnSend(nErrorCode);\n                        &#125;\n                        break;\n                    case FD_CONNECT:\n #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() == connecting)\n                        &#123;\n                            if (nErrorCode &amp;&amp; pSocket-&gt;m_SocketData.nextAddr)\n                            &#123;\n                                if (pSocket-&gt;TryNextProtocol())\n                                    break;\n                            &#125;\n                            pSocket-&gt;SetState(connected);\n                        &#125;\n                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                            pSocket-&gt;SetState(connected);\n #endif //NOSOCKETSTATES\n                        if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)\n                            pSocket-&gt;OnConnect(nErrorCode);\n #ifndef NOSOCKETSTATES\n                        if (!nErrorCode)\n                        &#123;\n                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp; pSocket-&gt;GetState() == connected)\n                                pSocket-&gt;OnReceive(0);\n                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp; pSocket-&gt;GetState() == connected)\n                                pSocket-&gt;OnReceive(0);\n                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp; pSocket-&gt;GetState() == connected)\n                                pSocket-&gt;OnSend(0);\n                        &#125;\n                        pSocket-&gt;m_nPendingEvents = 0;\n #endif\n                        break;\n                    case FD_ACCEPT:\n #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() != listening &amp;&amp; pSocket-&gt;GetState() != attached)\n                            break;\n #endif //NOSOCKETSTATES\n                        if (pSocket-&gt;m_lEvent &amp; FD_ACCEPT)\n                            pSocket-&gt;OnAccept(nErrorCode);\n                        break;\n                    case FD_CLOSE:\n #ifndef NOSOCKETSTATES\n                        if (pSocket-&gt;GetState() != connected &amp;&amp; pSocket-&gt;GetState() != attached)\n                            break;\n                            // If there are still bytes left to read, call OnReceive instead of\n                    // OnClose and trigger a new OnClose\n                    DWORD nBytes = 0;\n                    if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))\n                    &#123;\n                        if (nBytes &gt; 0)\n                        &#123;\n                            // Just repeat message.\n                            pSocket-&gt;ResendCloseNotify();\n                            pSocket-&gt;m_SocketData.onCloseCalled = true;\n                            pSocket-&gt;OnReceive(WSAESHUTDOWN);\n                            break;\n                        &#125;\n                    &#125;\n\n                    pSocket-&gt;SetState(nErrorCode ? aborted : closed);\n                     #endif //NOSOCKETSTATES\n                     pSocket-&gt;OnClose(nErrorCode);\n                    break;\n                &#125;\n            &#125;\n            else //Dispatch notification to the lowest layer\n            &#123;\n                if (nEvent == FD_READ)\n                &#123;\n                    // Ignore further FD_READ events after FD_CLOSE has been received\n                    if (pSocket-&gt;m_SocketData.onCloseCalled)\n                        return 0;\n\n                    DWORD nBytes;\n                    if (!pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))\n                        nErrorCode = WSAGetLastError();\n                    if (pSocket-&gt;m_pLastLayer)\n                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);\n                &#125;\n                else if (nEvent == FD_CLOSE)\n                &#123;\n                    // If there are still bytes left to read, call OnReceive instead of\n                    // OnClose and trigger a new OnClose\n                    DWORD nBytes = 0;\n                    if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))\n                    &#123;\n                        if (nBytes &gt; 0)\n                        &#123;\n                            // Just repeat message.\n                            pSocket-&gt;ResendCloseNotify();\n                            if (pSocket-&gt;m_pLastLayer)\n                                pSocket-&gt;m_pLastLayer-&gt;CallEvent(FD_READ, 0);\n                            return 0;\n                        &#125;\n                    &#125;\n                    pSocket-&gt;m_SocketData.onCloseCalled = true;\n                    if (pSocket-&gt;m_pLastLayer)\n                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);\n                &#125;\n                else if (pSocket-&gt;m_pLastLayer)\n                    pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n    else if (message == WM_USER) //Notification event sent by a layer\n    &#123;\n        //Verify parameters, lookup socket and notification message\n        //Verify parameters\n        ASSERT(hWnd);\n        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);\n        ASSERT(pWnd);\n        if (!pWnd)\n            return 0;\n\n        if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage\n        &#123;\n            return 0;\n        &#125;\n\n        CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;\n        CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = (CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;\n        if (!pMsg || !pSocket || pSocket-&gt;m_SocketData.hSocket != pMsg-&gt;hSocket)\n        &#123;\n            delete pMsg;\n            return 0;\n        &#125;\n        int nEvent=pMsg-&gt;lEvent&amp;0xFFFF;\n        int nErrorCode=pMsg-&gt;lEvent&gt;&gt;16;\n\n        //Dispatch to layer\n        if (pMsg-&gt;pLayer)\n            pMsg-&gt;pLayer-&gt;CallEvent(nEvent, nErrorCode);\n        else\n        &#123;\n            //Dispatch to CAsyncSocketEx instance\n            switch (nEvent)\n            &#123;\n            case FD_READ:\n            #ifndef NOSOCKETSTATES\n                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                    &#123;\n                        pSocket-&gt;m_nPendingEvents |= FD_READ;\n                        break;\n                    &#125;\n                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                        pSocket-&gt;SetState(connected);\n                    if (pSocket-&gt;GetState() != connected)\n                        break;\n#endif //NOSOCKETSTATES\n                    if (pSocket-&gt;m_lEvent &amp; FD_READ)\n                    &#123;\n#ifndef NOSOCKETSTATES\n                        if (nErrorCode)\n                            pSocket-&gt;SetState(aborted);\n#endif //NOSOCKETSTATES\n                        pSocket-&gt;OnReceive(nErrorCode);\n                    &#125;\n                    break;\n                case FD_FORCEREAD: //Forceread does not check if there&#39;s data waiting\n#ifndef NOSOCKETSTATES\n                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                    &#123;\n                        pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;\n                        break;\n                    &#125;\n                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                        pSocket-&gt;SetState(connected);\n                    if (pSocket-&gt;GetState() != connected)\n                        break;\n#endif //NOSOCKETSTATES\n                    if (pSocket-&gt;m_lEvent &amp; FD_READ)\n                    &#123;\n#ifndef NOSOCKETSTATES\n                        if (nErrorCode)\n                            pSocket-&gt;SetState(aborted);\n#endif //NOSOCKETSTATES\n                        pSocket-&gt;OnReceive(nErrorCode);\n                    &#125;\n                    break;\n                case FD_WRITE:\n#ifndef NOSOCKETSTATES\n                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)\n                    &#123;\n                        pSocket-&gt;m_nPendingEvents |= FD_WRITE;\n                        break;\n                    &#125;\n                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                        pSocket-&gt;SetState(connected);\n                    if (pSocket-&gt;GetState() != connected)\n                        break;\n#endif //NOSOCKETSTATES\n                    if (pSocket-&gt;m_lEvent &amp; FD_WRITE)\n                    &#123;\n#ifndef NOSOCKETSTATES\n                        if (nErrorCode)\n                            pSocket-&gt;SetState(aborted);\n#endif //NOSOCKETSTATES\n                        pSocket-&gt;OnSend(nErrorCode);\n                    &#125;\n                    break;\n                case FD_CONNECT:\n#ifndef NOSOCKETSTATES\n                    if (pSocket-&gt;GetState() == connecting)\n                        pSocket-&gt;SetState(connected);\n                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)\n                        pSocket-&gt;SetState(connected);\n#endif //NOSOCKETSTATES\n                    if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)\n                        pSocket-&gt;OnConnect(nErrorCode);\n#ifndef NOSOCKETSTATES\n                    if (!nErrorCode)\n                    &#123;\n                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_READ))\n                            pSocket-&gt;OnReceive(0);\n                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_READ))\n                            pSocket-&gt;OnReceive(0);\n                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_WRITE))\n                            pSocket-&gt;OnSend(0);\n                    &#125;\n                    pSocket-&gt;m_nPendingEvents = 0;\n#endif //NOSOCKETSTATES\n                    break;\n                case FD_ACCEPT:\n#ifndef NOSOCKETSTATES\n                    if ((pSocket-&gt;GetState() == listening || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_ACCEPT))\n#endif //NOSOCKETSTATES\n                    &#123;\n                        pSocket-&gt;OnAccept(nErrorCode);\n                    &#125;\n                    break;\n                case FD_CLOSE:\n#ifndef NOSOCKETSTATES\n                    if ((pSocket-&gt;GetState() == connected || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_CLOSE))\n                    &#123;\n                        pSocket-&gt;SetState(nErrorCode?aborted:closed);\n#else\n                    &#123;\n#endif //NOSOCKETSTATES\n                        pSocket-&gt;OnClose(nErrorCode);\n                    &#125;\n                    break;\n                &#125;\n            &#125;\n            delete pMsg;\n            return 0;\n        &#125;\n        else if (message == WM_USER+1)\n        &#123;\n            // WSAAsyncGetHostByName reply\n            // Verify parameters\n        ASSERT(hWnd);\n        CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);\n        ASSERT(pWnd);\n        if (!pWnd)\n            return 0;\n\n        CAsyncSocketEx *pSocket = NULL;\n        for (int i = 0; i &lt; pWnd-&gt;m_nWindowDataSize; ++i) &#123;\n            pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[i].m_pSocket;\n            if (pSocket &amp;&amp; pSocket-&gt;m_hAsyncGetHostByNameHandle &amp;&amp;\n                pSocket-&gt;m_hAsyncGetHostByNameHandle == (HANDLE)wParam &amp;&amp;\n                pSocket-&gt;m_pAsyncGetHostByNameBuffer)\n                break;\n        &#125;\n        if (!pSocket || !pSocket-&gt;m_pAsyncGetHostByNameBuffer)\n            return 0;\n\n        int nErrorCode = lParam &gt;&gt; 16;\n        if (nErrorCode) &#123;\n            pSocket-&gt;OnConnect(nErrorCode);\n            return 0;\n        &#125;\n\n        SOCKADDR_IN sockAddr&#123;&#125;;\n        sockAddr.sin_family = AF_INET;\n        sockAddr.sin_addr.s_addr = ((LPIN_ADDR)((LPHOSTENT)pSocket-&gt;m_pAsyncGetHostByNameBuffer)-&gt;h_addr)-&gt;s_addr;\n\n        sockAddr.sin_port = htons(pSocket-&gt;m_nAsyncGetHostByNamePort);\n\n        BOOL res = pSocket-&gt;Connect((SOCKADDR*)&amp;sockAddr, sizeof(sockAddr));\n        delete [] pSocket-&gt;m_pAsyncGetHostByNameBuffer;\n        pSocket-&gt;m_pAsyncGetHostByNameBuffer = 0;\n        pSocket-&gt;m_hAsyncGetHostByNameHandle = 0;\n\n        if (!res)\n            if (GetLastError() != WSAEWOULDBLOCK)\n                pSocket-&gt;OnConnect(GetLastError());\n        return 0;\n    &#125;\n    else if (message == WM_USER + 2)\n    &#123;\n        //Verify parameters, lookup socket and notification message\n        //Verify parameters\n        if (!hWnd)\n            return 0;\n\n        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);\n        if (!pWnd)\n            return 0;\n\n        if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage\n            return 0;\n\n        CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;\n        if (!pSocket)\n            return 0;\n\n        // Process pending callbacks\n        std::list&lt;t_callbackMsg&gt; tmp;\n        tmp.swap(pSocket-&gt;m_pendingCallbacks);\n        pSocket-&gt;OnLayerCallback(tmp);\n\n        for (auto &amp; cb : tmp) &#123;\n            delete [] cb.str;\n        &#125;\n    &#125;\n    else if (message == WM_TIMER)\n    &#123;\n        if (wParam != 1)\n            return 0;\n\n        ASSERT(hWnd);\n        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);\n        ASSERT(pWnd &amp;&amp; pWnd-&gt;m_pThreadData);\n        if (!pWnd || !pWnd-&gt;m_pThreadData)\n            return 0;\n\n        if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())\n        &#123;\n            KillTimer(hWnd, 1);\n            return 0;\n        &#125;\n        CAsyncSocketEx* socket = pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.front();\n        pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.pop_front();\n        if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())\n            KillTimer(hWnd, 1);\n\n        if (socket)\n            PostMessage(hWnd, socket-&gt;m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, socket-&gt;m_SocketData.hSocket, FD_CLOSE);\n        return 0;\n    &#125;\n    return DefWindowProc(hWnd, message, wParam, lParam);\n&#125;\t上面截取的代码段，如果你对这些项目不是很熟悉的话，估计你也没有任何兴趣去细细看每一行代码逻辑。但是你一定要明白我所说的这个结构的逻辑，基本上目前主流的网络框架都是这套原理。比如filezilla的网络通信层同样也被用在大名鼎鼎的电驴（easyMule）中。\n关于单个服务程序的框架，我已经介绍完了，如果你能完全理解我要表达的意思，我相信你也能构建出一套高性能服务程序来。\n另外，服务器框架也可以在上面的设计思路的基础上增加很多有意思的细节，比如流量控制。举另外 一个我实际做过的项目中的例子吧：\n一般实际项目中，当客户端连接数目比较多的时候，服务器在处理网络数据的时候，如果同时有多个socket上有数据要处理，由于cpu核数有限，根据上面先检测iO事件再处理IO事件可能会出现工作线程一直处理前几个socket的事件，直到前几个socket处理完毕后再处理后面几个socket的数据。这就相当于，你去饭店吃饭，大家都点了菜，但是有些桌子上一直在上菜，而有些桌子上一直没有菜。这样肯定不好，我们来看下如何避免这种现象：\ntxtint CFtdEngine::HandlePackage(CFTDCPackage *pFTDCPackage, CFTDCSession *pSession)\n&#123;\n    //NET_IO_LOG0(&quot;CFtdEngine::HandlePackage\\n&quot;);\n    FTDC_PACKAGE_DEBUG(pFTDCPackage);\n    if (pFTDCPackage-&gt;GetTID() != FTD_TID_ReqUserLogin)\n    &#123;\n        if (!IsSessionLogin(pSession-&gt;GetSessionID()))\n        &#123;\n            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;客户未登录&quot;);\n            return 0;\n        &#125;\n    &#125;\n\n    CalcFlux(pSession, pFTDCPackage-&gt;Length());\t//统计流量\n\n    REPORT_EVENT(LOG_DEBUG, &quot;Front/Fgateway&quot;, &quot;登录请求%0x&quot;, pFTDCPackage-&gt;GetTID()); \n\n    int nRet = 0;\n    switch(pFTDCPackage-&gt;GetTID()) \n    &#123;\n\n    case FTD_TID_ReqUserLogin:\n        ///huwp：20070608：检查过高版本的API将被禁止登录\n        if (pFTDCPackage-&gt;GetVersion()&gt;FTD_VERSION)\n        &#123;\n            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;Too High FTD Version&quot;);\n            return 0;\n        &#125;\n        nRet = OnReqUserLogin(pFTDCPackage, (CFTDCSession *)pSession);\n        FTDRequestIndex.incValue();\n        break;\n    case FTD_TID_ReqCheckUserLogin:\n        nRet = OnReqCheckUserLogin(pFTDCPackage, (CFTDCSession *)pSession);\n        FTDRequestIndex.incValue();\n        break;\n    case FTD_TID_ReqSubscribeTopic:\n        nRet = OnReqSubscribeTopic(pFTDCPackage, (CFTDCSession *)pSession);\n        FTDRequestIndex.incValue();\n        break;\t\n    &#125;\n\n    return 0;\n&#125;当有某个socket上有数据可读时，接着接收该socket上的数据，对接收到的数据进行解包，然后调用CalcFlux(pSession, pFTDCPackage-&gt;Length())进行流量统计：\n1234567891011121314void CFrontEngine::CalcFlux(CSession *pSession, const int nFlux)&#123;\tTFrontSessionInfo *pSessionInfo = m_mapSessionInfo.Find(pSession-&gt;GetSessionID());\tif (pSessionInfo != NULL)\t&#123;\t\t//流量控制改为计数\t\tpSessionInfo-&gt;nCommFlux ++; \t\t///若流量超过规定，则挂起该会话的读操作\t\tif (pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux)\t\t&#123;\t\t\tpSession-&gt;SuspendRead(true);\t\t&#125;\t&#125;&#125;\n\n该函数会先让某个连接会话（Session）处理的包数量递增，接着判断是否超过最大包数量，则设置读挂起标志：\n1234void CSession::SuspendRead(bool bSuspend)  &#123;  \tm_bSuspendRead = bSuspend;  &#125;  \n\n这样下次将会从检测的socket列表中排除该socket：\n12345678910111213141516171819202122232425262728void CEpollReactor::RegisterIO(CEventHandler *pEventHandler)  &#123;      int nReadID, nWriteID;      pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);      if (nWriteID != 0 &amp;&amp; nReadID ==0)      &#123;          nReadID = nWriteID;      &#125;      if (nReadID != 0)      &#123;          m_mapEventHandlerId[pEventHandler] = nReadID;          struct epoll_event ev;          ev.data.ptr = pEventHandler;          if(epoll_ctl(m_fdEpoll, EPOLL_CTL_ADD, nReadID, &amp;ev) != 0)          &#123;              perror(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);          &#125;      &#125;  &#125;  void CSession::GetIds(int *pReadId, int *pWriteId)  &#123;      m_pChannelProtocol-&gt;GetIds(pReadId,pWriteId);      if (m_bSuspendRead)      &#123;          *pReadId = 0;      &#125;  &#125;  \n\n也就是说不再检测该socket上是否有数据可读。然后在定时器里1秒后重置该标志，这样这个socket上有数据的话又可以重新检测到了：\n123456789101112131415161718192021222324252627282930313233const int SESSION_CHECK_TIMER_ID    = 9;  const int SESSION_CHECK_INTERVAL    = 1000;  SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);  void CFrontEngine::OnTimer(int nIDEvent)  &#123;      if (nIDEvent == SESSION_CHECK_TIMER_ID)      &#123;          CSessionMap::iterator itor = m_mapSession.Begin();          while (!itor.IsEnd())          &#123;              TFrontSessionInfo *pFind = m_mapSessionInfo.Find((*itor)-&gt;GetSessionID());              if (pFind != NULL)              &#123;                  CheckSession(*itor, pFind);              &#125;              itor++;          &#125;      &#125;  &#125;  void CFrontEngine::CheckSession(CSession *pSession, TFrontSessionInfo *pSessionInfo)  &#123;      ///重新开始计算流量      pSessionInfo-&gt;nCommFlux -= pSessionInfo-&gt;nMaxCommFlux;      if (pSessionInfo-&gt;nCommFlux &lt; 0)      &#123;          pSessionInfo-&gt;nCommFlux = 0;      &#125;      ///若流量超过规定，则挂起该会话的读操作      pSession-&gt;SuspendRead(pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux);  &#125;  \n\n这就相当与饭店里面先给某一桌客人上一些菜，让他们先吃着，等上了一些菜之后不会再给这桌继续上菜了，而是给其它空桌上菜，大家都吃上后，继续回来给原先的桌子继续上菜。实际上我们的饭店都是这么做的。上面的例子是单服务流量控制的实现的一个非常好的思路，它保证了每个客户端都能均衡地得到服务，而不是一些客户端等很久才有响应。当然，这样的技术不能适用于有顺序要求的业务，例如销售系统，这些系统一般是先下单先得到的。\n另外现在的服务器为了加快ＩＯ操作，大量使用缓存技术，缓存实际上是以空间换取时间的策略。对于一些反复使用的，但是不经常改变的信息，如果从原始地点加载这些信息就比较耗时的数据（比如从磁盘中、从数据库中），我们就可以使用缓存。所以时下像redis、leveldb、fastdb等各种内存数据库大行其道。如果你要从事服务器开发，你至少需要掌握它们中的几种。\n　　鉴于笔者能力和经验有限，文中难免有错漏之处，欢迎提意见。\n","slug":"转载/高性能服务器框架设计/C++高性能服务器网络框架设计细节","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"f49eefb0c9add12a3ac803e71934ac10","title":"【转载】Reactor模式","content":"Reactor模式最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analogous_love/9673008\n书上是这么介绍Reactor模式的：\n\n按照这个思路，我写个简单的练习：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376/**  *@desc:   用reactor模式练习服务器程序，main.cpp *@author: zhangyl *@date:   2016.11.23 */ #include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;  //for htonl() and htons()#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;signal.h&gt;     //for signal()#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;list&gt;#include &lt;errno.h&gt;#include &lt;time.h&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt; //for std::setw()/setfill()#include &lt;stdlib.h&gt;  #define WORKER_THREAD_NUM   5 #define min(a, b) ((a &lt;= b) ? (a) : (b))  int g_epollfd = 0;bool g_bStop = false;int g_listenfd = 0;pthread_t g_acceptthreadid = 0;pthread_t g_threadid[WORKER_THREAD_NUM] = &#123; 0 &#125;;pthread_cond_t g_acceptcond;pthread_mutex_t g_acceptmutex; pthread_cond_t g_cond /*= PTHREAD_COND_INITIALIZER*/;pthread_mutex_t g_mutex /*= PTHREAD_MUTEX_INITIALIZER*/; pthread_mutex_t g_clientmutex; std::list&lt;int&gt; g_listClients; void prog_exit(int signo)&#123;    ::signal(SIGINT, SIG_IGN);    //::signal(SIGKILL, SIG_IGN);//该信号不能被阻塞、处理或者忽略    ::signal(SIGTERM, SIG_IGN);     std::cout &lt;&lt; &quot;program recv signal &quot; &lt;&lt; signo &lt;&lt; &quot; to exit.&quot; &lt;&lt; std::endl;     g_bStop = true;     ::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, g_listenfd, NULL);     //TODO: 是否需要先调用shutdown()一下？    ::shutdown(g_listenfd, SHUT_RDWR);    ::close(g_listenfd);    ::close(g_epollfd);     ::pthread_cond_destroy(&amp;g_acceptcond);    ::pthread_mutex_destroy(&amp;g_acceptmutex);        ::pthread_cond_destroy(&amp;g_cond);    ::pthread_mutex_destroy(&amp;g_mutex);     ::pthread_mutex_destroy(&amp;g_clientmutex);&#125; bool create_server_listener(const char* ip, short port)&#123;    g_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);    if (g_listenfd == -1)        return false;     int on = 1;    ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));    ::setsockopt(g_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on));     struct sockaddr_in servaddr;    memset(&amp;servaddr, 0, sizeof(servaddr));     servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = inet_addr(ip);    servaddr.sin_port = htons(port);    if (::bind(g_listenfd, (sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1)        return false;     if (::listen(g_listenfd, 50) == -1)        return false;     g_epollfd = ::epoll_create(1);    if (g_epollfd == -1)        return false;     struct epoll_event e;    memset(&amp;e, 0, sizeof(e));    e.events = EPOLLIN | EPOLLRDHUP;    e.data.fd = g_listenfd;    if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, g_listenfd, &amp;e) == -1)        return false;     return true;&#125; void release_client(int clientfd)&#123;    if (::epoll_ctl(g_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1)        std::cout &lt;&lt; &quot;release client socket failed as call epoll_ctl failed&quot; &lt;&lt; std::endl;     ::close(clientfd);&#125; void* accept_thread_func(void* arg)&#123;       while (!g_bStop)    &#123;        ::pthread_mutex_lock(&amp;g_acceptmutex);        ::pthread_cond_wait(&amp;g_acceptcond, &amp;g_acceptmutex);        //::pthread_mutex_lock(&amp;g_acceptmutex);         //std::cout &lt;&lt; &quot;run loop in accept_thread_func&quot; &lt;&lt; std::endl;         struct sockaddr_in clientaddr;        socklen_t addrlen;        int newfd = ::accept(g_listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen);        ::pthread_mutex_unlock(&amp;g_acceptmutex);        if (newfd == -1)            continue;         std::cout &lt;&lt; &quot;new client connected: &quot; &lt;&lt; ::inet_ntoa(clientaddr.sin_addr) &lt;&lt; &quot;:&quot; &lt;&lt; ::ntohs(clientaddr.sin_port) &lt;&lt; std::endl;         //将新socket设置为non-blocking        int oldflag = ::fcntl(newfd, F_GETFL, 0);        int newflag = oldflag | O_NONBLOCK;        if (::fcntl(newfd, F_SETFL, newflag) == -1)        &#123;            std::cout &lt;&lt; &quot;fcntl error, oldflag =&quot; &lt;&lt; oldflag &lt;&lt; &quot;, newflag = &quot; &lt;&lt; newflag &lt;&lt; std::endl;            continue;        &#125;         struct epoll_event e;        memset(&amp;e, 0, sizeof(e));        e.events = EPOLLIN | EPOLLRDHUP | EPOLLET;        e.data.fd = newfd;        if (::epoll_ctl(g_epollfd, EPOLL_CTL_ADD, newfd, &amp;e) == -1)        &#123;            std::cout &lt;&lt; &quot;epoll_ctl error, fd =&quot; &lt;&lt; newfd &lt;&lt; std::endl;        &#125;    &#125;     return NULL;&#125;  void* worker_thread_func(void* arg)&#123;       while (!g_bStop)    &#123;        int clientfd;        ::pthread_mutex_lock(&amp;g_clientmutex);        while (g_listClients.empty())            ::pthread_cond_wait(&amp;g_cond, &amp;g_clientmutex);        clientfd = g_listClients.front();        g_listClients.pop_front();          pthread_mutex_unlock(&amp;g_clientmutex);         //gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来        std::cout &lt;&lt; std::endl;         std::string strclientmsg;        char buff[256];        bool bError = false;        while (true)        &#123;            memset(buff, 0, sizeof(buff));            int nRecv = ::recv(clientfd, buff, 256, 0);            if (nRecv == -1)            &#123;                if (errno == EWOULDBLOCK)                    break;                else                &#123;                    std::cout &lt;&lt; &quot;recv error, client disconnected, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;                    release_client(clientfd);                    bError = true;                    break;                &#125;                                &#125;            //对端关闭了socket，这端也关闭。            else if (nRecv == 0)            &#123;                std::cout &lt;&lt; &quot;peer closed, client disconnected, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;                release_client(clientfd);                bError = true;                break;            &#125;             strclientmsg += buff;        &#125;         //出错了，就不要再继续往下执行了        if (bError)            continue;                std::cout &lt;&lt; &quot;client msg: &quot; &lt;&lt; strclientmsg;         //将消息加上时间标签后发回        time_t now = time(NULL);        struct tm* nowstr = localtime(&amp;now);        std::ostringstream ostimestr;        ostimestr &lt;&lt; &quot;[&quot; &lt;&lt; nowstr-&gt;tm_year + 1900 &lt;&lt; &quot;-&quot;                   &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_mon + 1 &lt;&lt; &quot;-&quot;                   &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_mday &lt;&lt; &quot; &quot;                  &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_hour &lt;&lt; &quot;:&quot;                   &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_min &lt;&lt; &quot;:&quot;                   &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_sec &lt;&lt; &quot;]server reply: &quot;;         strclientmsg.insert(0, ostimestr.str());                while (true)        &#123;            int nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0);            if (nSent == -1)            &#123;                if (errno == EWOULDBLOCK)                &#123;                    ::sleep(10);                    continue;                &#125;                else                &#123;                    std::cout &lt;&lt; &quot;send error, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;                    release_client(clientfd);                    break;                &#125;                               &#125;                       std::cout &lt;&lt; &quot;send: &quot; &lt;&lt; strclientmsg;            strclientmsg.erase(0, nSent);             if (strclientmsg.empty())                break;        &#125;    &#125;     return NULL;&#125; void daemon_run()&#123;    int pid;    signal(SIGCHLD, SIG_IGN);    //1）在父进程中，fork返回新创建子进程的进程ID；    //2）在子进程中，fork返回0；    //3）如果出现错误，fork返回一个负值；    pid = fork();    if (pid &lt; 0)    &#123;        std:: cout &lt;&lt; &quot;fork error&quot; &lt;&lt; std::endl;        exit(-1);    &#125;    //父进程退出，子进程独立运行    else if (pid &gt; 0) &#123;        exit(0);    &#125;    //之前parent和child运行在同一个session里,parent是会话（session）的领头进程,    //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。    //执行setsid()之后,child将重新获得一个新的会话(session)id。    //这时parent退出之后,将不会影响到child了。    setsid();    int fd;    fd = open(&quot;/dev/null&quot;, O_RDWR, 0);    if (fd != -1)    &#123;        dup2(fd, STDIN_FILENO);        dup2(fd, STDOUT_FILENO);        dup2(fd, STDERR_FILENO);    &#125;    if (fd &gt; 2)        close(fd); &#125;  int main(int argc, char* argv[])&#123;      short port = 0;    int ch;    bool bdaemon = false;    while ((ch = getopt(argc, argv, &quot;p:d&quot;)) != -1)    &#123;        switch (ch)        &#123;        case &#x27;d&#x27;:            bdaemon = true;            break;        case &#x27;p&#x27;:            port = atol(optarg);            break;        &#125;    &#125;     if (bdaemon)        daemon_run();      if (port == 0)        port = 12345;         if (!create_server_listener(&quot;0.0.0.0&quot;, port))    &#123;        std::cout &lt;&lt; &quot;Unable to create listen server: ip=0.0.0.0, port=&quot; &lt;&lt; port &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;        return -1;    &#125;         //设置信号处理    signal(SIGCHLD, SIG_DFL);    signal(SIGPIPE, SIG_IGN);    signal(SIGINT, prog_exit);    //signal(SIGKILL, prog_exit);//该信号不能被阻塞、处理或者忽略     signal(SIGTERM, prog_exit);     ::pthread_cond_init(&amp;g_acceptcond, NULL);    ::pthread_mutex_init(&amp;g_acceptmutex, NULL);     ::pthread_cond_init(&amp;g_cond, NULL);    ::pthread_mutex_init(&amp;g_mutex, NULL);     ::pthread_mutex_init(&amp;g_clientmutex, NULL);         ::pthread_create(&amp;g_acceptthreadid, NULL, accept_thread_func, NULL);    //启动工作线程    for (int i = 0; i &lt; WORKER_THREAD_NUM; ++i)    &#123;        ::pthread_create(&amp;g_threadid[i], NULL, worker_thread_func, NULL);    &#125;     while (!g_bStop)    &#123;               struct epoll_event ev[1024];        int n = ::epoll_wait(g_epollfd, ev, 1024, 10);        if (n == 0)            continue;        else if (n &lt; 0)        &#123;            std::cout &lt;&lt; &quot;epoll_wait error&quot; &lt;&lt; std::endl;            continue;        &#125;         int m = min(n, 1024);        for (int i = 0; i &lt; m; ++i)        &#123;            //通知接收连接线程接收新连接            if (ev[i].data.fd == g_listenfd)                pthread_cond_signal(&amp;g_acceptcond);            //通知普通工作线程接收数据            else            &#123;                               pthread_mutex_lock(&amp;g_clientmutex);                              g_listClients.push_back(ev[i].data.fd);                pthread_mutex_unlock(&amp;g_clientmutex);                pthread_cond_signal(&amp;g_cond);                //std::cout &lt;&lt; &quot;signal&quot; &lt;&lt; std::endl;            &#125;                        &#125;     &#125;        return 0;&#125;\n\n程序的功能一个简单的echo服务：客户端连接上服务器之后，给服务器发送信息，服务器加上时间戳等信息后返回给客户端。\n使用到的知识点有：\n\n条件变量\n\nepoll的边缘触发模式\n\n\n程序的大致框架是：\n\n主线程只负责监听侦听socket上是否有新连接，如果有新连接到来，交给一个叫accept的工作线程去接收新连接，并将新连接socket绑定到主线程使用epollfd上去。\n主线程如果侦听到客户端的socket上有可读事件，则通知另外五个工作线程去接收处理客户端发来的数据，并将数据加上时间戳后发回给客户端。\n可以通过传递-p port来设置程序的监听端口号；可以通过传递-d来使程序以daemon模式运行在后台。这也是标准linux daemon模式的书写方法。\n\n程序难点和需要注意的地方是：\n\n条件变量为了防止虚假唤醒，一定要在一个循环里面调用pthread_cond_wait()函数，我在worker_thread_func()中使用了：\n\n12while (g_listClients.empty())  \t::pthread_cond_wait(&amp;g_cond, &amp;g_clientmutex); \n\n在accept_thread_func()函数里面我没有使用循环，这样会有问题吗？\n\n使用条件变量pthread_cond_wait()函数的时候一定要先获得与该条件变量相关的mutex，即像下面这样的结构：\n\n123456789mutex_lock(...); while (condition is true)    ::pthread_cond_wait(...); //这里可以有其他代码...mutex_unlock(...); //这里可以有其他代码...\n\n因为pthread_cond_wait()如果阻塞的话，它解锁相关mutex和阻塞当前线程这两个动作加在一起是原子的。\n\n作为服务器端程序最好对侦听socket调用setsocketopt()设置SO_REUSEADDR和SO_REUSEPORT两个标志，因为服务程序有时候会需要重启（比如调试的时候就会不断重启），如果不设置这两个标志的话，绑定端口时就会调用失败。因为一个端口使用后，即使不再使用，因为四次挥手该端口处于TIME_WAIT状态，有大约2min的MSL（Maximum Segment Lifetime，最大存活期）。这2min内，该端口是不能被重复使用的。你的服务器程序上次使用了这个端口号，接着重启，因为这个缘故，你再次绑定这个端口就会失败（bind函数调用失败）。要不你就每次重启时需要等待2min后再试（这在频繁重启程序调试是难以接收的），或者设置这种SO_REUSEADDR和SO_REUSEPORT立即回收端口使用。\n\n其实，SO_REUSEADDR在Windows上和Unix平台上还有些细微的区别，我在libevent源码中看到这样的描述：\n12345678910111213int evutil_make_listen_socket_reuseable(evutil_socket_t sock)&#123;#ifndef WIN32\tint one = 1;\t/* REUSEADDR on Unix means, &quot;don&#x27;t hang on to this address after the\t * listener is closed.&quot;  On Windows, though, it means &quot;don&#x27;t keep other\t * processes from binding to this address while we&#x27;re using it. */\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one,\t    (ev_socklen_t)sizeof(one));#else\treturn 0;#endif&#125; \n\n注意注释部分，在Unix平台上设置这个选项意味着，任意进程可以复用该地址；而在windows，不要阻止其他进程复用该地址。也就是在在Unix平台上，如果不设置这个选项，任意进程在一定时间内，不能bind该地址；在windows平台上，在一定时间内，其他进程不能bind该地址，而本进程却可以再次bind该地址。\n\nepoll_wait对新连接socket使用的是边缘触发模式EPOLLET（edge trigger），而不是默认的水平触发模式（level trigger)。因为如果采取水平触发模式的话，主线程检测到某个客户端socket数据可读时，通知工作线程去收取该socket上的数据，这个时候主线程继续循环，只要在工作线程没有将该socket上数据全部收完，或者在工作线程收取数据的过程中，客户端有新数据到来，主线程会继续发通知（通过pthread_cond_signal()）函数，再次通知工作线程收取数据。这样会可能导致多个工作线程同时调用recv函数收取该客户端socket上的数据，这样产生的结果将会导致数据错乱。\n\n相反，采取边缘触发模式，只有等某个工作线程将那个客户端socket上数据全部收取完毕，主线程的epoll_wait才可能会再次触发来通知工作线程继续收取那个客户端socket新来的数据。\n\n代码中有这样一行：\n 12//gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来 std::cout &lt;&lt; std::endl;\n\n如果不加上这一行，正常运行服务器程序，程序中要打印到控制台的信息都会打印出来，但是如果用gdb调试状态下，程序的所有输出就不显示了。我不知道这是不是gdb的一个bug，所以这里加上std::endl来输出一个换行符并flush标准输出，让输出显示出来。（std::endl不仅是输出一个换行符而且是同时刷新输出，相当于fflush()函数）。\n程序我部署起来了，你可以使用linux的nc命令或自己写程序连接服务器来查看程序效果，当然也可以使用telnet命令，方法：\nLinux:\n1nc 120.55.94.78 12345\n\n或\n1telnet 120.55.94.78 12345\n\n然后就可以给服务器自由发送数据了，服务器会给你发送的信息加上时间戳返回给你。效果如图：\n\n另外我将这个代码改写了成纯C++11版本，使用CMake编译，为了支持编译必须加上这-std&#x3D;c++11：\nCMakeLists.txt代码如下：\n123456789101112131415161718192021222324cmake_minimum_required(VERSION 2.8) PROJECT(myreactorserver) AUX_SOURCE_DIRECTORY(./ SRC_LIST)SET(EXECUTABLE_OUTPUT_PATH ./) ADD_DEFINITIONS(-g -W -Wall -Wno-deprecated -DLINUX -D_REENTRANT -D_FILE_OFFSET_BITS=64 -DAC_HAS_INFO -DAC_HAS_WARNING -DAC_HAS_ERROR -DAC_HAS_CRITICAL -DTIXML_USE_STL -DHAVE_CXX_STDHEADERS $&#123;CMAKE_CXX_FLAGS&#125; -std=c++11) INCLUDE_DIRECTORIES(./)LINK_DIRECTORIES(./) set(main.cppmyreator.cpp) ADD_EXECUTABLE(myreactorserver $&#123;SRC_LIST&#125;) TARGET_LINK_LIBRARIES(myreactorserver pthread)\n\nmyreactor.h文件内容：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** *@desc: myreactor头文件, myreactor.h *@author: zhangyl *@date: 2016.12.03 */#ifndef __MYREACTOR_H__#define __MYREACTOR_H__ #include &lt;list&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt; #define WORKER_THREAD_NUM   5 class CMyReactor&#123;public:\tCMyReactor();\t~CMyReactor(); \tbool init(const char* ip, short nport);\tbool uninit(); \tbool close_client(int clientfd); \tstatic void* main_loop(void* p); private:\t//no copyable\tCMyReactor(const CMyReactor&amp; rhs);\tCMyReactor&amp; operator = (const CMyReactor&amp; rhs); \tbool create_server_listener(const char* ip, short port);\t\tstatic void accept_thread_proc(CMyReactor* pReatcor);\tstatic void worker_thread_proc(CMyReactor* pReatcor); private:\t//C11语法可以在这里初始化\tint\t\t\t\t\t\t\t m_listenfd = 0;\tint\t\t\t\t\t\t\t m_epollfd  = 0;\tbool\t\t\t\t\t\t m_bStop    = false;\t\tstd::shared_ptr&lt;std::thread&gt; m_acceptthread;\tstd::shared_ptr&lt;std::thread&gt; m_workerthreads[WORKER_THREAD_NUM];\t\tstd::condition_variable\t\t m_acceptcond;\tstd::mutex\t\t\t\t\t m_acceptmutex; \tstd::condition_variable\t\t m_workercond ;\tstd::mutex\t\t\t\t\t m_workermutex; \tstd::list&lt;int&gt;\t\t\t\t m_listClients;&#125;; #endif //!__MYREACTOR_H__\n\nmyreactor.cpp文件内容：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326/**  *@desc: myreactor实现文件, myreactor.cpp *@author: zhangyl *@date: 2016.12.03 */#include &quot;myreactor.h&quot;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;  //for htonl() and htons()#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;list&gt;#include &lt;errno.h&gt;#include &lt;time.h&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt; //for std::setw()/setfill()#include &lt;unistd.h&gt; #define min(a, b) ((a &lt;= b) ? (a) : (b)) CMyReactor::CMyReactor()&#123;\t//m_listenfd = 0;\t//m_epollfd = 0;\t//m_bStop = false;&#125; CMyReactor::~CMyReactor()&#123; &#125; bool CMyReactor::init(const char* ip, short nport)&#123;\tif (!create_server_listener(ip, nport))\t&#123;\t\tstd::cout &lt;&lt; &quot;Unable to bind: &quot; &lt;&lt; ip &lt;&lt; &quot;:&quot; &lt;&lt; nport &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;\t\treturn false;\t&#125;  \tstd::cout &lt;&lt; &quot;main thread id = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; \t//启动接收新连接的线程\tm_acceptthread.reset(new std::thread(CMyReactor::accept_thread_proc, this));\t\t//启动工作线程\tfor (auto&amp; t : m_workerthreads)\t&#123;\t\tt.reset(new std::thread(CMyReactor::worker_thread_proc, this));\t&#125;  \treturn true;&#125; bool CMyReactor::uninit()&#123;\tm_bStop = true;\tm_acceptcond.notify_one();\tm_workercond.notify_all(); \tm_acceptthread-&gt;join();\tfor (auto&amp; t : m_workerthreads)\t&#123;\t\tt-&gt;join();\t&#125; \t::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, m_listenfd, NULL); \t//TODO: 是否需要先调用shutdown()一下？\t::shutdown(m_listenfd, SHUT_RDWR);\t::close(m_listenfd);\t::close(m_epollfd); \treturn true;&#125; bool CMyReactor::close_client(int clientfd)&#123;\tif (::epoll_ctl(m_epollfd, EPOLL_CTL_DEL, clientfd, NULL) == -1)\t&#123;\t\tstd::cout &lt;&lt; &quot;close client socket failed as call epoll_ctl failed&quot; &lt;&lt; std::endl;\t\t//return false;\t&#125;\t\t \t::close(clientfd); \treturn true;&#125;  void* CMyReactor::main_loop(void* p)&#123;\tstd::cout &lt;&lt; &quot;main thread id = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;\t\tCMyReactor* pReatcor = static_cast&lt;CMyReactor*&gt;(p);\t\twhile (!pReatcor-&gt;m_bStop)\t&#123;\t\tstruct epoll_event ev[1024];\t\tint n = ::epoll_wait(pReatcor-&gt;m_epollfd, ev, 1024, 10);\t\tif (n == 0)\t\t\tcontinue;\t\telse if (n &lt; 0)\t\t&#123;\t\t\tstd::cout &lt;&lt; &quot;epoll_wait error&quot; &lt;&lt; std::endl;\t\t\tcontinue;\t\t&#125; \t\tint m = min(n, 1024);\t\tfor (int i = 0; i &lt; m; ++i)\t\t&#123;\t\t\t//通知接收连接线程接收新连接\t\t\tif (ev[i].data.fd == pReatcor-&gt;m_listenfd)\t\t\t\tpReatcor-&gt;m_acceptcond.notify_one();\t\t\t//通知普通工作线程接收数据\t\t\telse\t\t\t&#123;\t\t\t\t&#123;\t\t\t\t\tstd::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_workermutex);\t\t\t\t\tpReatcor-&gt;m_listClients.push_back(ev[i].data.fd);\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\tpReatcor-&gt;m_workercond.notify_one();\t\t\t\t//std::cout &lt;&lt; &quot;signal&quot; &lt;&lt; std::endl;\t\t\t&#125;// end if \t\t&#125;// end for-loop\t&#125;// end while \tstd::cout &lt;&lt; &quot;main loop exit ...&quot; &lt;&lt; std::endl; \treturn NULL;&#125; void CMyReactor::accept_thread_proc(CMyReactor* pReatcor)&#123;\tstd::cout &lt;&lt; &quot;accept thread, thread id = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; \twhile (true)\t&#123;\t\tint newfd;\t\tstruct sockaddr_in clientaddr;\t\tsocklen_t addrlen;\t\t&#123;\t\t\tstd::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_acceptmutex);\t\t\tpReatcor-&gt;m_acceptcond.wait(guard);\t\t\tif (pReatcor-&gt;m_bStop)\t\t\t\tbreak; \t\t\t//std::cout &lt;&lt; &quot;run loop in accept_thread_proc&quot; &lt;&lt; std::endl;\t\t\t\t\t\tnewfd = ::accept(pReatcor-&gt;m_listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen);\t\t&#125;\t\tif (newfd == -1)\t\t\tcontinue; \t\tstd::cout &lt;&lt; &quot;new client connected: &quot; &lt;&lt; ::inet_ntoa(clientaddr.sin_addr) &lt;&lt; &quot;:&quot; &lt;&lt; ::ntohs(clientaddr.sin_port) &lt;&lt; std::endl; \t\t//将新socket设置为non-blocking\t\tint oldflag = ::fcntl(newfd, F_GETFL, 0);\t\tint newflag = oldflag | O_NONBLOCK;\t\tif (::fcntl(newfd, F_SETFL, newflag) == -1)\t\t&#123;\t\t\tstd::cout &lt;&lt; &quot;fcntl error, oldflag =&quot; &lt;&lt; oldflag &lt;&lt; &quot;, newflag = &quot; &lt;&lt; newflag &lt;&lt; std::endl;\t\t\tcontinue;\t\t&#125; \t\tstruct epoll_event e;\t\tmemset(&amp;e, 0, sizeof(e));\t\te.events = EPOLLIN | EPOLLRDHUP | EPOLLET;\t\te.data.fd = newfd;\t\tif (::epoll_ctl(pReatcor-&gt;m_epollfd, EPOLL_CTL_ADD, newfd, &amp;e) == -1)\t\t&#123;\t\t\tstd::cout &lt;&lt; &quot;epoll_ctl error, fd =&quot; &lt;&lt; newfd &lt;&lt; std::endl;\t\t&#125;\t&#125; \tstd::cout &lt;&lt; &quot;accept thread exit ...&quot; &lt;&lt; std::endl;&#125; void CMyReactor::worker_thread_proc(CMyReactor* pReatcor)&#123;\tstd::cout &lt;&lt; &quot;new worker thread, thread id = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; \twhile (true)\t&#123;\t\tint clientfd;\t\t&#123;\t\t\tstd::unique_lock&lt;std::mutex&gt; guard(pReatcor-&gt;m_workermutex);\t\t\twhile (pReatcor-&gt;m_listClients.empty())\t\t\t&#123;\t\t\t\tif (pReatcor-&gt;m_bStop)\t\t\t\t&#123;\t\t\t\t\tstd::cout &lt;&lt; &quot;worker thread exit ...&quot; &lt;&lt; std::endl;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\t\t\t\t\t\tpReatcor-&gt;m_workercond.wait(guard);\t\t\t&#125;\t\t\t\t\t\t\tclientfd = pReatcor-&gt;m_listClients.front();\t\t\tpReatcor-&gt;m_listClients.pop_front();\t\t&#125; \t\t//gdb调试时不能实时刷新标准输出，用这个函数刷新标准输出，使信息在屏幕上实时显示出来\t\tstd::cout &lt;&lt; std::endl; \t\tstd::string strclientmsg;\t\tchar buff[256];\t\tbool bError = false;\t\twhile (true)\t\t&#123;\t\t\tmemset(buff, 0, sizeof(buff));\t\t\tint nRecv = ::recv(clientfd, buff, 256, 0);\t\t\tif (nRecv == -1)\t\t\t&#123;\t\t\t\tif (errno == EWOULDBLOCK)\t\t\t\t\tbreak;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tstd::cout &lt;&lt; &quot;recv error, client disconnected, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;\t\t\t\t\tpReatcor-&gt;close_client(clientfd);\t\t\t\t\tbError = true;\t\t\t\t\tbreak;\t\t\t\t&#125; \t\t\t&#125;\t\t\t//对端关闭了socket，这端也关闭。\t\t\telse if (nRecv == 0)\t\t\t&#123;\t\t\t\tstd::cout &lt;&lt; &quot;peer closed, client disconnected, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;\t\t\t\tpReatcor-&gt;close_client(clientfd);\t\t\t\tbError = true;\t\t\t\tbreak;\t\t\t&#125; \t\t\tstrclientmsg += buff;\t\t&#125; \t\t//出错了，就不要再继续往下执行了\t\tif (bError)\t\t\tcontinue; \t\tstd::cout &lt;&lt; &quot;client msg: &quot; &lt;&lt; strclientmsg; \t\t//将消息加上时间标签后发回\t\ttime_t now = time(NULL);\t\tstruct tm* nowstr = localtime(&amp;now);\t\tstd::ostringstream ostimestr;\t\tostimestr &lt;&lt; &quot;[&quot; &lt;&lt; nowstr-&gt;tm_year + 1900 &lt;&lt; &quot;-&quot;\t\t\t&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_mon + 1 &lt;&lt; &quot;-&quot;\t\t\t&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_mday &lt;&lt; &quot; &quot;\t\t\t&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_hour &lt;&lt; &quot;:&quot;\t\t\t&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_min &lt;&lt; &quot;:&quot;\t\t\t&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; nowstr-&gt;tm_sec &lt;&lt; &quot;]server reply: &quot;; \t\tstrclientmsg.insert(0, ostimestr.str()); \t\twhile (true)\t\t&#123;\t\t\tint nSent = ::send(clientfd, strclientmsg.c_str(), strclientmsg.length(), 0);\t\t\tif (nSent == -1)\t\t\t&#123;\t\t\t\tif (errno == EWOULDBLOCK)\t\t\t\t&#123;\t\t\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tstd::cout &lt;&lt; &quot;send error, fd = &quot; &lt;&lt; clientfd &lt;&lt; std::endl;\t\t\t\t\tpReatcor-&gt;close_client(clientfd);\t\t\t\t\tbreak;\t\t\t\t&#125; \t\t\t&#125; \t\t\tstd::cout &lt;&lt; &quot;send: &quot; &lt;&lt; strclientmsg;\t\t\tstrclientmsg.erase(0, nSent); \t\t\tif (strclientmsg.empty())\t\t\t\tbreak;\t\t&#125;\t&#125;&#125; bool CMyReactor::create_server_listener(const char* ip, short port)&#123;\tm_listenfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\tif (m_listenfd == -1)\t\treturn false; \tint on = 1;\t::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));\t::setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on)); \tstruct sockaddr_in servaddr;\tmemset(&amp;servaddr, 0, sizeof(servaddr));\tservaddr.sin_family = AF_INET;\tservaddr.sin_addr.s_addr = inet_addr(ip);\tservaddr.sin_port = htons(port);\tif (::bind(m_listenfd, (sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1)\t\treturn false; \tif (::listen(m_listenfd, 50) == -1)\t\treturn false; \tm_epollfd = ::epoll_create(1);\tif (m_epollfd == -1)\t\treturn false; \tstruct epoll_event e;\tmemset(&amp;e, 0, sizeof(e));\te.events = EPOLLIN | EPOLLRDHUP;\te.data.fd = m_listenfd;\tif (::epoll_ctl(m_epollfd, EPOLL_CTL_ADD, m_listenfd, &amp;e) == -1)\t\treturn false; \treturn true;&#125;\n\nmain.cpp文件内容：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/**  *@desc:   用reactor模式练习服务器程序 *@author: zhangyl *@date:   2016.12.03 */ #include &lt;iostream&gt;#include &lt;signal.h&gt;     //for signal()#include&lt;unistd.h&gt;#include &lt;stdlib.h&gt;\t\t//for exit()#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &quot;myreactor.h&quot; CMyReactor g_reator; void prog_exit(int signo)&#123;    std::cout &lt;&lt; &quot;program recv signal &quot; &lt;&lt; signo &lt;&lt; &quot; to exit.&quot; &lt;&lt; std::endl;  \tg_reator.uninit();&#125; void daemon_run()&#123;    int pid;    signal(SIGCHLD, SIG_IGN);    //1）在父进程中，fork返回新创建子进程的进程ID；    //2）在子进程中，fork返回0；    //3）如果出现错误，fork返回一个负值；    pid = fork();    if (pid &lt; 0)    &#123;        std:: cout &lt;&lt; &quot;fork error&quot; &lt;&lt; std::endl;        exit(-1);    &#125;    //父进程退出，子进程独立运行    else if (pid &gt; 0) &#123;        exit(0);    &#125;    //之前parent和child运行在同一个session里,parent是会话（session）的领头进程,    //parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。    //执行setsid()之后,child将重新获得一个新的会话(session)id。    //这时parent退出之后,将不会影响到child了。    setsid();    int fd;    fd = open(&quot;/dev/null&quot;, O_RDWR, 0);    if (fd != -1)    &#123;        dup2(fd, STDIN_FILENO);        dup2(fd, STDOUT_FILENO);        dup2(fd, STDERR_FILENO);    &#125;    if (fd &gt; 2)        close(fd);&#125;  int main(int argc, char* argv[])&#123;  \t//设置信号处理\tsignal(SIGCHLD, SIG_DFL);\tsignal(SIGPIPE, SIG_IGN);\tsignal(SIGINT, prog_exit);\tsignal(SIGKILL, prog_exit);\tsignal(SIGTERM, prog_exit);\t\tshort port = 0;\tint ch;\tbool bdaemon = false;\twhile ((ch = getopt(argc, argv, &quot;p:d&quot;)) != -1)\t&#123;\t\tswitch (ch)\t\t&#123;\t\tcase &#x27;d&#x27;:\t\t\tbdaemon = true;\t\t\tbreak;\t\tcase &#x27;p&#x27;:\t\t\tport = atol(optarg);\t\t\tbreak;\t\t&#125;\t&#125; \tif (bdaemon)\t\tdaemon_run();  \tif (port == 0)\t\tport = 12345; \t\tif (!g_reator.init(&quot;0.0.0.0&quot;, 12345))\t\treturn -1;    \tg_reator.main_loop(&amp;g_reator);     return 0;&#125;\n\n完整实例代码下载地址：\n普通版本：https://pan.baidu.com/s/1o82Mkno\nC++11版本：https://pan.baidu.com/s/1dEJdrih\n","slug":"转载/高性能服务器框架设计/Reactor模式","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"429b34147de6862baa596a57a6482f88","title":"【转载】主线程与工作线程的分工","content":"主线程与工作线程的分工服务器端为了能流畅处理多个客户端链接，一般在某个线程A里面accept新的客户端连接并生成新连接的socket fd，然后将这些新连接的socketfd给另外开的数个工作线程B1、B2、B3、B4，这些工作线程处理这些新连接上的网络IO事件（即收发数据），同时，还处理系统中的另外一些事务。这里我们将线程A称为主线程，B1、B2、B3、B4等称为工作线程。工作线程的代码框架一般如下：\n12345678while (!m_bQuit) &#123;      epoll_or_select_func();        handle_io_events();        handle_other_things();&#125;  \n\n在epoll_or_select_func()中通过select()或者poll&#x2F;epoll()去检测socket fd上的io事件，若存在这些事件则下一步handle_io_events()来处理这些事件（收发数据），做完之后可能还要做一些系统其他的任务，即调用handle_other_things()。\n这样做有三个好处：\n\n线程A只需要处理新连接的到来即可，不用处理网络IO事件。由于网络IO事件处理一般相对比较慢，如果在线程A里面既处理新连接又处理网络IO，则可能由于线程忙于处理IO事件，而无法及时处理客户端的新连接，这是很不好的。\n\n线程A接收的新连接，可以根据一定的负载均衡原则将新的socket fd分配给工作线程。常用的算法，比如round robin，即轮询机制，即，假设不考虑中途有连接断开的情况，一个新连接来了分配给B1，又来一个分配给B2，再来一个分配给B3，再来一个分配给B4。如此反复，也就是说线程A记录了各个工作线程上的socket fd数量，这样可以最大化地来平衡资源，避免一些工作线程“忙死”，另外一些工作线程“闲死”的现象。\n\n即使工作线程不满载的情况下，也可以让工作线程做其他的事情。比如现在有四个工作线程，但只有三个连接。那么线程B4就可以在handle_other_thing()做一些其他事情。\n\n\n下面讨论一个很重要的效率问题：\n在上述while循环里面，epoll_or_selec_func()中的epoll_wait&#x2F;poll&#x2F;select等函数一般设置了一个超时时间。如果设置超时时间为0，那么在没有任何网络IO时间和其他任务处理的情况下，这些工作线程实际上会空转，白白地浪费cpu时间片。如果设置的超时时间大于0，在没有网络IO时间的情况，epoll_wait&#x2F;poll&#x2F;select仍然要挂起指定时间才能返回，导致handle_other_thing()不能及时执行，影响其他任务不能及时处理，也就是说其他任务一旦产生，其处理起来具有一定的延时性。这样也不好。那如何解决该问题呢？\n其实我们想达到的效果是，如果没有网络IO时间和其他任务要处理，那么这些工作线程最好直接挂起而不是空转；如果有其他任务要处理，这些工作线程要立刻能处理这些任务而不是在epoll_wait&#x2F;poll&#x2F;selec挂起指定时间后才开始处理这些任务。\n我们采取如下方法来解决该问题，以linux为例，不管epoll_fd上有没有文件描述符fd，我们都给它绑定一个默认的fd，这个fd被称为唤醒fd。当我们需要处理其他任务的时候，向这个唤醒fd上随便写入1个字节的，这样这个fd立即就变成可读的了，epoll_wait()&#x2F;poll()&#x2F;select()函数立即被唤醒，并返回，接下来马上就能执行handle_other_thing()，其他任务得到处理。反之，没有其他任务也没有网络IO事件时，epoll_or_select_func()就挂在那里什么也不做。\n这个唤醒fd，在linux平台上可以通过以下几种方法实现：\n\n管道pipe，创建一个管道，将管道绑定到epoll_fd上。需要时，向管道一端写入一个字节，工作线程立即被唤醒。\n\nlinux 2.6新增的eventfd：\n\n\n1int eventfd(unsigned int initval, int flags); \n\n步骤也是一样，将生成的eventfd绑定到epoll_fd上。需要时，向这个eventfd上写入一个字节，工作线程立即被唤醒。\n\n第三种方法最方便。即linux特有的socketpair，socketpair是一对相互连接的socket，相当于服务器端和客户端的两个端点，每一端都可以读写数据。\n\n1int socketpair(int domain, int type, int protocol, int sv[2]);\n\n\n\n调用这个函数返回的两个socket句柄就是sv[0]，和sv[1]，在一个其中任何一个写入字节，在另外一个收取字节。\n将收取的字节的socket绑定到epoll_fd上。需要时，向另外一个写入的socket上写入一个字节，工作线程立即被唤醒。如果是使用socketpair，那么domain参数一定要设置成AFX_UNIX。\n由于在windows，select函数只支持检测socket这一种fd，所以Windows上一般只能用方法3的原理。而且需要手动创建两个socket，然后一个连接另外一个，将读取的那一段绑定到select的fd上去。这在写跨两个平台代码时，需要注意的地方。\n","slug":"转载/高性能服务器框架设计/主线程与工作线程的分工","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"f6cf431fde3fe424d56db6051dddeb05","title":"【转载】如何设计断线自动重连机制","content":"如何设计断线自动重连机制在有连接依赖关系的服务与服务之间，或客户端与服务器之间，无论是出于方便使用、降低运维成本、提高工作效率（服务与服务之间），还是优化用户体验（客户端与服务器之间）自动重连机制通常都是一个非常重要的功能。\n\n情景一\n\n对于一组服务之间，如果其中一些服务（主动连接方，下文以 A 代称）需要与另外一些服务（被连接方，下文以 B 代称）建立 TCP 长连接，如果 A 没有自动连接 B 的功能，那么在部署或者测试这些服务的时候，必须先启动 B，再启动 A，因为一旦先启动 A，A 此时去尝试连接 B（由于 B 还没有启动）会失败，之后 A 再也不会去连接 B了（即使随后 B 被启动了），从而导致整个系统不能正常工作。这是缺点一。\n\n情景二\n\n即使部署或测试的时候，先启动了 B，再启动 A，A 与 B 之间的连接在运行期间内，可能由于网络波动等原因导致 A 与 B 之间连接断开，之后整个系统也不能再正常工作了。这是缺点二。\n\n情景三\n\n如果我们想升级 B，更新完程序后，重启 B，也必须重启 A。如果这种依赖链比较长（例如 A 连接 B，B 连接 C，C 连接 D，D 连接 E，等等），那么更新某个程序的效率和成本会非常高。这是缺点三。\n\n情景四\n\n对于客户端软件来说，如果因为用户的网络短暂故障导致客户端与服务器失去连接，等网络恢复后，较好的用户体验是客户端能检测到用户网络变化后，自动与服务器重连，以便用户能及时收到最新的消息。\n以上四个情景说明了断线自动重连功能的重要性，那如何去设计好的断线重连机制呢？\n重连本身的功能开发很简单，其实就是调用 socket 函数 connect 函数，不断去“重试”。这里的“重试”我使用了双引号，是为了说明重试的技巧非常有讲究：\n\n对于服务器端程序，例如 A 连接 B，如果连接不上，整个系统将无法工作，那么我们开发 A 服务时，重连的逻辑可以很简单，即 A 一旦发现与 B 断开了连接，就立即尝试与 B 重新连接，如果连接不上，隔一段时间再重试（一般设置为 3 秒或 5 秒即可），一直到连接成功为止。当然，期间可以不断发送报警邮件或者持续输出错误日志，来引起开发或者运维人员的尽快干预，以便尽早排查和解决连接不上的原因。\n对于客户端软件，以上做法也是可以的，但是不是最优的。客户端所处的网络环境比服务器程序所处的网络环境一般要恶劣的多，等间隔的定时去重连，一般作用不大（例如用户拔掉了网线）。因此，对于客户端软件，一般出现断线，会尝试去重连，如果连接不上，会隔个比前一次时间更长的时间间隔去重连，例如这个时间间隔可以是 2 秒、4 秒、8 秒、16秒等等。但是，这样也存在一个问题，随着重连次数的变多，重连的时间间隔会越来越大（当然，你也可以设置一个最大重连时间间隔，之后恢复到之前较小的时间间隔）。如果网络此时已经恢复（例如用户重新插上网线），我们的程序需要等待一个很长的时间间隔（如 16 秒）才能恢复连接，这同样不利于用户体验。一般情况下，如果网络发生波动，我们的程序可以检测网络状态，如果网络状态恢复正常此时应该立即进行一次重连，而不是一成不变地按照设置的时间间隔去重连。\n\n\n操作系统提供了检测网络状态变化的 API 函数，例如对于 Windows 可以使用 IsNetworkAlive() 函数去检测，对于 Android，网络变化时会发送消息类型是 WifiManager.NETWORK_STATE_CHANGED_ACTION 的广播通知。\n\n另外，还需要注意的是，如果客户端网络断开，一般会在界面某个地方显式地告诉用户当前连接状态，并提醒当前正在进行断线重连，且应该有一个可以让用户放弃断线重连或者立即进行一次断线重连的功能。\n综上所述，总结起来，对于服务器程序之间的重连可以设计成等时间间隔的定时重连，对于客户端程序要结合依次放大重连时间间隔、网络状态变化立即重连或用户主动发起重连这三个因素来设计。\n不需要重连的情形不需要重连一般有以下情形：\n\n用户使用客户端主动放弃重连；\n\n因为一些业务上的规定，禁止客户端重连；\n举个例子，如果某个系统同一时刻同一个账户只允许登陆一个，某个账户在机器 A 上登陆，此时接着又在机器 B 上登陆，此时 A 将被服务器踢下线，那么此时 A 客户端的逻辑就应该禁止自动重连。\n\n\n技术上的断线重连和业务上的断线重连这里说的技术上的重连，指的是调用 connect 函数连接，在实际开发中，大多数系统光有技术上的重连成功（即 connect 连接成功）是没有任何意义的，网络连接成功以后，接下来还得再次向服务器发送账号验证信息等等（如登陆数据包），只有这些数据验签成功后，才能算是真正的重连成功，这里说的发送账号验证信息并验签成功就是业务上的重连成功。复杂的系统可能会需要连续好几道验签流程。因此，我们在设计断线重连机制的时候，不仅要考虑技术上的重连，还要考虑业务上的重连。只有完整地包含这两个流程，才算是较优的断线自动重连功能。\n本节介绍的知识点主要是思路性的内容，一旦搞清楚了思路，技术上实现起来并不会存在什么困难，因此本节没有给出具体的代码示例。\n欢迎关注公众号『easyserverdev』，本公众号推崇基础学习与原理理解，不谈大而空的架构与技术术语，分享接地气的服务器开发实战技巧与项目经验，实实在在分享可用于实际编码的编程知识。同时，您也可以加入我的 QQ 群578019391。\n\n文章已于2019-08-12修改\n","slug":"转载/高性能服务器框架设计/如何设计断线自动重连机制","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"109d28235b9c7b6892c4c14f9b41b157","title":"【转载】实例：一个服务器程序的架构介绍","content":"实例：一个服务器程序的架构介绍本文将介绍我曾经做过的一个项目的服务器架构和服务器编程的一些重要细节。\n一、程序运行环境操作系统：Centos 7.0\n编译器：gcc&#x2F;g++ 4.8.3、cmake 2.8.11\nmysql数据库：5.5.47\n项目代码管理工具：Visual Studio 2013\n一、程序结构该程序总共有 17 个线程，其中分为 9 个数据库工作线程 D 和一个日志线程 L，6 个普通工作线程 W，一个主线程 M。（以下会用这些字母来代指这些线程）\n（一）、数据库工作线程的用途9 个数据库工作线程在线程启动之初，与 mysql 建立连接，也就是说每个线程都与 mysql 保持一路连接，共 9 个数据库连接。\n每个数据库工作线程同时存在两个任务队列，第一个队列 A 存放需要执行数据库增删查改操作的任务 sqlTask，第二个队列 B 存放 sqlTask 执行完成后的结果。sqlTask 执行完成后立即放入结果队列中，因而结果队列中任务也是一个个的需要执行的任务。大致伪代码如下：\n123456789101112131415void db_thread_func()  &#123;      while (!m_bExit)      &#123;          if (NULL != (pTask = m_sqlTask.Pop()))          &#123;              //从m_sqlTask中取出的任务先执行完成后，pTask将携带结果数据              pTask-&gt;Execute();                          //得到结果后，立刻将该任务放入结果任务队列              m_resultTask.Push(pTask);              continue;          &#125;          sleep(1000);      &#125;//end while-loop  &#125;  \n\n现在的问题来了：\n\n任务队列 A 中的任务从何而来，目前只有消费者，没有生产者，那么生产者是谁？\n任务队列 B 中的任务将去何方，目前只有生产者没有消费者。\n\n这两个问题先放一会儿，等到后面我再来回答。\n（二）工作线程和主线程在介绍主线程和工作线程具体做什么时，我们介绍下服务器编程中常常抽象出来的几个概念（这里以 tcp 连接为例）：\n\nTcpServer 即 Tcp 服务，服务器需要绑定ip地址和端口号，并在该端口号上侦听客户端的连接（往往由一个成员变量 TcpListener 来管理侦听细节）。所以一个 TcpServer 要做的就是这些工作。除此之外，每当有新连接到来时，TcpServer 需要接收新连接，当多个新连接存在时，TcpServer 需要有条不紊地管理这些连接：连接的建立、断开等，即产生和管理下文中说的 TcpConnection 对象。\n一个连接对应一个 TcpConnection 对象，TcpConnection 对象管理着这个连接的一些信息：如连接状态、本端和对端的 ip 地址和端口号等。\n数据通道对象 Channel，Channel 记录了 socket 的句柄，因而是一个连接上执行数据收发的真正执行者，Channel 对象一般作为 TcpConnection 的成员变量。\nTcpSession 对象，是将 Channel 收取的数据进行解包，或者对准备好的数据进行装包，并传给 Channel 发送。\n\n归纳起来：一个 TcpServer 依靠 TcpListener 对新连接的侦听和处理，依靠 TcpConnection 对象对连接上的数据进行管理，TcpConnection 实际依靠 Channel 对数据进行收发，依靠 TcpSession 对数据进行装包和解包。也就是说一个 TcpServer 存在一个 TcpListener，对应多个 TcpConnection，有几个TcpConnection 就有几个 TcpSession，同时也就有几个 Channel。\n以上说的 TcpServer、TcpListener、TcpConnection、Channel 和 TcpSession 是服务器框架的网络层。一个好的网络框架，应该做到与业务代码脱耦。即上层代码只需要拿到数据，执行业务逻辑，而不用关注数据的收发和网络数据包的封包和解包以及网络状态的变化（比如网络断开与重连）。\n拿数据的发送来说：\n当业务逻辑将数据交给 TcpSession，TcpSession 将数据装好包后（装包过程后可以有一些加密或压缩操作），交给 TcpConnection::SendData()，而TcpConnection::SendData() 实际是调用 **Channel::SendData()**，因为 Channel 含有 socket 句柄，所以 Channel::SendData() 真正调用send()&#x2F;sendto()&#x2F;write() 方法将数据发出去。\n对于数据的接收，稍微有一点不同：\n通过 select()&#x2F;poll()&#x2F;epoll() 等IO multiplex技术，确定好了哪些 TcpConnection 上有数据到来后，激活该 TcpConnection 的 Channel 对象去调用recv()&#x2F;recvfrom()&#x2F;read() 来收取数据。数据收到以后，将数据交由 TcpSession来处理，最终交给业务层。注意数据收取、解包乃至交给业务层是一定要分开的。我的意思是：最好不要解包并交给业务层和数据收取的逻辑放在一起。因为数据收取是 IO 操作，而解包和交给业务层是逻辑计算操作。IO 操作一般比逻辑计算要慢。到底如何安排要根据服务器业务来取舍，也就是说你要想好你的服务器程序的性能瓶颈在网络 IO 还是逻辑计算，即使是网络 IO，也可以分为上行操作和下行操作，上行操作即客户端发数据给服务器，下行即服务器发数据给客户端。有时候数据上行少，下行大。（如游戏服务器，一个 npc 移动了位置，上行是该客户端通知服务器自己最新位置，而下行确是服务器要告诉在场的每个客户端）。\n在我的文章《主线程与工作线程的分工》中介绍了，工作线程的流程：\n12345678while (!m_bQuit)  &#123;      epoll_or_select_func();      handle_io_events();      handle_other_things();  &#125;\n\n\n其中 epoll_or_select_func() 即是上文所说的通过 select()&#x2F;poll()&#x2F;epoll() 等 IO multiplex 技术，确定好了哪些 TcpConnection 上有数据到来。我的服务器代码中一般只会监测 socket 可读事件，而不会监测 socket 可写事件。至于如何发数据，文章后面会介绍。所以对于可读事件，以 epoll 为例，这里需要设置的标识位是：\n\nEPOLLIN 普通可读事件（当连接正常时，产生这个事件，recv()&#x2F;read()函数返回收到的字节数；当连接关闭，这两个函数返回0，也就是说我们设置这个标识已经可以监测到新来数据和对端关闭事件）\nEPOLLRDHUP 对端关闭事件（linux man 手册上说这个事件可以监测对端关闭，但我实际调试时发送即使对端关闭也没触发这个事件，仍然是EPOLLIN，只不过此时调用recv()&#x2F;read()函数，返回值会为0，所以实际项目中是否可以通过设置这个标识来监测对端关闭，仍然待考证）\nEPOLLPRI 带外数据\n\nmuduo 里面将 epoll_wait 的超时事件设置为 1 毫秒，我的另一个项目将 epoll_wait 超时时间设置为 10 毫秒。这两个数值供大家参考。\n这个项目中，工作线程和主线程都是上文代码中的逻辑，主线程监听侦听socket 上的可读事件，也就是监测是否有新连接来了。主线程和每个工作线程上都存在一个 epollfd。如果新连接来了，则在主线程的 handle_io_events() 中接受新连接。产生的新连接的socket句柄挂接到哪个线程的 epollfd 上呢？这里采取的做法是 round-robin 算法，即存在一个对象 CWorkerThreadManager 记录了各个工作线程上工作状态。伪码大致如下：\n12345678void attach_new_fd(int newsocketfd)  &#123;      workerthread = get_next_worker_thread(next);      workerthread.attach_to_epollfd(newsocketfd);      ++next;      if (next &gt; max_worker_thread_num)          next = 0;  &#125;  \n\n即先从第一个工作线程的 epollfd 开始挂接新来 socket，接着累加索引，这样下次就是第二个工作线程了。如果所以超出工作线程数目，则从第一个工作重新开始。这里解决了新连接 socket “负载均衡”的问题。在实际代码中还有个需要注意的细节就是：epoll_wait 的函数中的 struct epoll_event 数量开始到底要设置多少个才合理？存在的顾虑是，多了浪费，少了不够用，我在曾经一个项目中直接用的是 4096：\n1234const int EPOLL_MAX_EVENTS = 4096;  const int dwSelectTimeout = 10000;  struct epoll_event events[EPOLL_MAX_EVENTS];  int nfds = epoll_wait(m_fdEpoll, events, EPOLL_MAX_EVENTS, dwSelectTimeout / 1000);\n\n\n我在陈硕的 muduo 网络库中发现作者才用了一个比较好的思路，即动态扩张数量：开始是 n 个，当发现有事件的 fd 数量已经到达 n 个后，将 struct epoll_event 数量调整成 2n 个，下次如果还不够，则变成 4n 个，以此类推，作者巧妙地利用 stl::vector 在内存中的连续性来实现了这种思路：\n123456789101112131415//初始化代码  std::vector&lt;struct epoll_event&gt; events_(16);  //线程循环里面的代码  while (m_bExit)  &#123;      int numEvents = ::epoll_wait(epollfd_, &amp;*events_.begin(), static_cast&lt;int&gt;(events_.size()), 1);      if (numEvents &gt; 0)      &#123;          if (static_cast&lt;size_t&gt;(numEvents) == events_.size())          &#123;              events_.resize(events_.size() * 2);          &#125;      &#125;  &#125;\n\n读到这里，你可能觉得工作线程所做的工作也不过就是调用 handle_io_events() 来接收网络数据，其实不然，工作线程也可以做程序业务逻辑上的一些工作。也就是在 handle_other_things() 里面。那如何将这些工作加到 handle_other_things() 中去做呢？写一个队列，任务先放入队列，再让 handle_other_things() 从队列中取出来做？我在该项目中也借鉴了muduo库的做法。即 handle_other_things() 中调用一系列函数指针，伪码如下：\n1234567891011121314void do_other_things()  &#123;      somefunc();  &#125;//m_functors是一个stl::vector,其中每一个元素为一个函数指针  void somefunc()  &#123;      for (size_t i = 0; i &lt; m_functors.size(); ++i)      &#123;          m_functors[i]();      &#125;      m_functors.clear();  &#125;\n\n当任务产生时，只要我们将执行任务的函数 push_back 到 m_functors 这个 stl::vector 对象中即可。但是问题来了，如果是其他线程产生的任务，两个线程同时操作 m_functors，必然要加锁，这也会影响效率。muduo 是这样做的：\n12345678910111213141516171819void add_task(const Functor&amp; cb)  &#123;      std::unique_lock&lt;std::mutex&gt; lock(mutex_);      m_functors.push_back(cb);     &#125;  void do_task()  &#123;      std::vector&lt;Functor&gt; functors;      &#123;          std::unique_lock&lt;std::mutex&gt; lock(mutex_);          functors.swap(m_functors);      &#125;      for (size_t i = 0; i &lt; functors.size(); ++i)      &#123;          functors[i]();      &#125;  &#125;\n\n\n看到没有，利用一个栈变量 functors 将 m_functors 中的任务函数指针倒换（swap）过来了，这样大大减小了对 m_functors 操作时的加锁粒度。前后变化：变化前，相当于原来 A 给 B 多少东西，B 消耗多少，A 给的时候，B 不能消耗；B 消耗的时候A不能给。现在变成A将东西放到篮子里面去，B 从篮子里面拿，B 如果拿去一部分后，只有消耗完了才会来拿，或者 A 通知 B 去篮子里面拿，而 B 忙碌时，A 是不会通知 B 来拿，这个时候 A 只管将东西放在篮子里面就可以了。\n1234567891011121314151617181920212223242526272829bool bBusy = false;  void add_task(const Functor&amp; cb)  &#123;      std::unique_lock&lt;std::mutex&gt; lock(mutex_);      m_functors_.push_back(cb);      //B不忙碌时只管往篮子里面加，不要通知B      if (!bBusy)      &#123;          wakeup_to_do_task();      &#125;  &#125;  void do_task()  &#123;      bBusy = true;      std::vector&lt;Functor&gt; functors;      &#123;          std::unique_lock&lt;std::mutex&gt; lock(mutex_);          functors.swap(pendingFunctors_);      &#125;      for (size_t i = 0; i &lt; functors.size(); ++i)      &#123;          functors[i]();      &#125;      bBusy = false;  &#125;\n\n\n看，多巧妙的做法！\n因为每个工作线程都存在一个 m_functors，现在问题来了，如何将产生的任务均衡地分配给每个工作线程。这个做法类似上文中如何将新连接的 socket 句柄挂载到工作线程的 epollfd 上，也是 round-robin 算法。上文已经描述，此处不再赘述。\n还有种情况，就是希望任务产生时，工作线程能够立马执行这些任务，而不是等 epoll_wait 超时返回之后。这个时候的做法，就是使用一些技巧唤醒epoll_wait，Linux 系统可以使用 socketpair 或 timerevent、eventfd 等技巧。\n上文中留下三个问题：\n\n数据库线程任务队列A中的任务从何而来，目前只有消费者，没有生产者，那么生产者是谁？\n数据库线程任务队列B中的任务将去何方，目前只有生产者没有消费者。\n业务层的数据如何发送出去？\n\n问题 1 的答案是：业务层产生任务可能会交给数据库任务队列A，这里的业务层代码可能就是工作线程中 do_other_things() 函数执行体中的调用。至于交给这个 9 个数据库线程的哪一个的任务队列，同样采用了 round-robin 算法。所以就存在一个对象 CDbThreadManager 来管理这九个数据库线程。下面的伪码是向数据库工作线程中加入任务：\n123456789bool CDbThreadManager::AddTask(IMysqlTask* poTask )  &#123;      if (m_index &gt;= m_dwThreadsCount)      &#123;          m_index = 0;      &#125;      return m_aoMysqlThreads[m_index++].AddTask(poTask);  &#125;\n\n\n同理问题 2 中的消费者也可能就是 do_other_things() 函数执行体中的调用。\n现在来说问题 3，业务层的数据产生后，经过 TcpSession 装包后，需要发送的话，产生任务丢给工作线程的 do_other_things()，然后在相关的 Channel 里面发送，因为没有监测该 socket 上的可写事件，所以该数据可能调用 send() 或者 write() 时会阻塞，没关系，sleep() 一会儿，继续发送，一直尝试，到数据发出去。伪码如下：\n1234567891011121314151617181920212223242526272829bool Channel::Send()  &#123;      int offset = 0;      while (true)      &#123;          int n = ::send(socketfd, buf + offset, length - offset);          if (n == -1)          &#123;              if (errno == EWOULDBLOCK)              &#123;                  ::sleep(100);                  continue;              &#125;          &#125;          //对方关闭了socket，这端建议也关闭          else if (n == 0)          &#123;              close(socketfd);              return false;          &#125;          offset += n;          if (offset &gt;= length)              break;      &#125;      return true;      &#125;\n","slug":"转载/高性能服务器框架设计/实例：一个服务器程序的架构介绍","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"dadb03aa4cb6e4085adc0ea3361dcdbd","title":"【转载】心跳包机制设计详解","content":"心跳包机制设计详解存在下面两种情形：\n情形一：一个客户端连接服务器以后，如果长期没有和服务器有数据来往，可能会被防火墙程序关闭连接，有时候我们并不想要被关闭连接。例如，对于一个即时通讯软件，如果服务器没有消息时，我们确实不会和服务器有任何数据交换，但是如果连接被关闭了，有新消息来时，我们再也没法收到了，这就违背了“即时通讯”的设计要求。\n情形二：通常情况下，服务器与某个客户端一般不是位于同一个网络，其之间可能经过数个路由器和交换机，如果其中某个必经路由器或者交换器出现了故障，并且一段时间内没有恢复，导致这之间的链路不再畅通，而此时服务器与客户端之间也没有数据进行交换，由于 TCP 连接是状态机，对于这种情况，无论是客户端或者服务器都无法感知与对方的连接是否正常，这类连接我们一般称之为“死链”。\n情形一中的应用场景要求必须保持客户端与服务器之间的连接正常，就是我们通常所说的“保活“。如上文所述，当服务器与客户端一定时间内没有有效业务数据来往时，我们只需要给对端发送心跳包即可实现保活。\n情形二中的死链，只要我们此时任意一端给对端发送一个数据包即可检测链路是否正常，这类数据包我们也称之为”心跳包”，这种操作我们称之为“心跳检测”。顾名思义，如果一个人没有心跳了，可能已经死亡了；一个连接长时间没有正常数据来往，也没有心跳包来往，就可以认为这个连接已经不存在，为了节约服务器连接资源，我们可以通过关闭 socket，回收连接资源。\n根据上面的分析，让我再强调一下，心跳检测一般有两个作用：\n\n保活\n检测死链\n\nTCP keepalive 选项操作系统的 TCP&#x2F;IP 协议栈其实提供了这个的功能，即 keepalive 选项。在 Linux 操作系统中，我们可以通过代码启用一个 socket 的心跳检测（即每隔一定时间间隔发送一个心跳检测包给对端），代码如下：\n123//on 是 1 表示打开 keepalive 选项，为 0 表示关闭，0 是默认值int on = 1;setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on));\n\n但是，即使开启了这个选项，这个选项默认发送心跳检测数据包的时间间隔是 7200 秒（2 小时），这时间间隔实在是太长了，不具有实用性。\n我们可以通过继续设置 keepalive 相关的三个选项来改变这个时间间隔，它们分别是 TCP_KEEPIDLE、TCP_KEEPINTVL 和 TCP_KEEPCNT，示例代码如下：\n12345678910//发送 keepalive 报文的时间间隔int val = 7200;setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;val, sizeof(val));//两次重试报文的时间间隔int interval = 75;setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;interval, sizeof(interval));int cnt = 9;setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;cnt, sizeof(cnt));\n\nTCP_KEEPIDLE 选项设置了发送 keepalive 报文的时间间隔，发送时如果对端回复 ACK。则本端 TCP 协议栈认为该连接依然存活，继续等 7200 秒后再发送 keepalive 报文；如果对端回复 RESET，说明对端进程已经重启，本端的应用程序应该关闭该连接。\n如果对端没有任何回复，则本端做重试，如果重试 9 次（TCP_KEEPCNT 值）（前后重试间隔为 75 秒（TCP_KEEPINTVL 值））仍然不可达，则向应用程序返回 ETIMEOUT（无任何应答）或 EHOST 错误信息。\n我们可以使用如下命令查看 Linux 系统上的上述三个值的设置情况：\n1234[root@iZ238vnojlyZ ~]# sysctl -a | grep keepalivenet.ipv4.tcp_keepalive_intvl = 75net.ipv4.tcp_keepalive_probes = 9net.ipv4.tcp_keepalive_time = 7200\n\n在 Windows 系统设置 keepalive 及对应选项的代码略有不同：\n12345678910111213//开启 keepalive 选项const char on = 1;setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (char *)&amp;on, sizeof(on);// 设置超时详细信息DWORD cbBytesReturned;tcp_keepalive klive;// 启用保活klive.onoff = 1;klive.keepalivetime = 7200;// 重试间隔为10秒klive.keepaliveinterval = 1000 * 10; WSAIoctl(socket, SIO_KEEPALIVE_VALS, &amp;klive, sizeof(tcp_keepalive), NULL, 0, &amp;cbBytesReturned, NULL, NULL);\n\n应用层的心跳包机制设计由于 keepalive 选项需要为每个连接中的 socket 开启，这不一定是必须的，可能会产生大量无意义的带宽浪费，且 keepalive 选项不能与应用层很好地交互，因此一般实际的服务开发中，还是建议读者在应用层设计自己的心跳包机制。那么如何设计呢？\n从技术来讲，心跳包其实就是一个预先规定好格式的数据包，在程序中启动一个定时器，定时发送即可，这是最简单的实现思路。但是，如果通信的两端有频繁的数据来往，此时到了下一个发心跳包的时间点了，此时发送一个心跳包。这其实是一个流量的浪费，既然通信双方不断有正常的业务数据包来往，这些数据包本身就可以起到保活作用，为什么还要浪费流量去发送这些心跳包呢？所以，对于用于保活的心跳包，我们最佳做法是，设置一个上次包时间，每次收数据和发数据时，都更新一下这个包时间，而心跳检测计时器每次检测时，将这个包时间与当前系统时间做一个对比，如果时间间隔大于允许的最大时间间隔（实际开发中根据需求设置成 15 ~ 45 秒不等），则发送一次心跳包。总而言之，就是在与对端之间，没有数据来往达到一定时间间隔时才发送一次心跳包。\n发心跳包的伪码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132bool CIUSocket::Send()&#123;    int nSentBytes = 0;    int nRet = 0;    while (true)    &#123;        nRet = ::send(m_hSocket, m_strSendBuf.c_str(), m_strSendBuf.length(), 0);        if (nRet == SOCKET_ERROR)        &#123;            if (::WSAGetLastError() == WSAEWOULDBLOCK)                break;            else            &#123;                LOG_ERROR(&quot;Send data error, disconnect server:%s, port:%d.&quot;, m_strServer.c_str(), m_nPort);                Close();                return false;            &#125;        &#125;        else if (nRet &lt; 1)        &#123;            //一旦出现错误就立刻关闭Socket            LOG_ERROR(&quot;Send data error, disconnect server:%s, port:%d.&quot;, m_strServer.c_str(), m_nPort);            Close();            return false;        &#125;        m_strSendBuf.erase(0, nRet);        if (m_strSendBuf.empty())            break;        ::Sleep(1);    &#125;    &#123;        //记录一下最近一次发包时间        std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);        m_nLastDataTime = (long)time(NULL);    &#125;    return true;&#125;bool CIUSocket::Recv()&#123;    int nRet = 0;    char buff[10 * 1024];    while (true)    &#123;        nRet = ::recv(m_hSocket, buff, 10 * 1024, 0);        if (nRet == SOCKET_ERROR)                //一旦出现错误就立刻关闭Socket        &#123;            if (::WSAGetLastError() == WSAEWOULDBLOCK)                break;            else            &#123;                LOG_ERROR(&quot;Recv data error, errorNO=%d.&quot;, ::WSAGetLastError());                //Close();                return false;            &#125;        &#125;        else if (nRet &lt; 1)        &#123;            LOG_ERROR(&quot;Recv data error, errorNO=%d.&quot;, ::WSAGetLastError());            //Close();            return false;        &#125;        m_strRecvBuf.append(buff, nRet);        ::Sleep(1);    &#125;    &#123;        std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);        //记录一下最近一次收包时间        m_nLastDataTime = (long)time(NULL);    &#125;    return true;&#125;void CIUSocket::RecvThreadProc()&#123;    LOG_INFO(&quot;Recv data thread start...&quot;);    int nRet;    //上网方式     DWORD   dwFlags;    BOOL    bAlive;    while (!m_bStop)    &#123;        //检测到数据则收数据        nRet = CheckReceivedData();        //出错        if (nRet == -1)        &#123;            m_pRecvMsgThread-&gt;NotifyNetError();        &#125;        //无数据        else if (nRet == 0)        &#123;                       long nLastDataTime = 0;            &#123;                std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);                nLastDataTime = m_nLastDataTime;            &#125;            if (m_nHeartbeatInterval &gt; 0)            &#123;                //当前系统时间与上一次收发数据包的时间间隔超过了m_nHeartbeatInterval                //则发一次心跳包                if (time(NULL) - nLastDataTime &gt;= m_nHeartbeatInterval)                    SendHeartbeatPackage();            &#125;        &#125;        //有数据        else if (nRet == 1)        &#123;            if (!Recv())            &#123;                m_pRecvMsgThread-&gt;NotifyNetError();                continue;            &#125;            DecodePackages();        &#125;// end if    &#125;// end while-loop    LOG_INFO(&quot;Recv data thread finish...&quot;);&#125;\n\n同理，检测心跳包的一端，应该是在与对端没有数据来往达到一定时间间隔时才做一次心跳检测。\n心跳检测一端的伪码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void BusinessSession::send(const char* pData, int dataLength)&#123;    bool sent = TcpSession::send(pData, dataLength);    //发送完数据更新下发包时间    updateHeartbeatTime();      &#125;void BusinessSession::handlePackge(char* pMsg, int msgLength, bool&amp; closeSession, std::vector&lt;std::string&gt;&amp; vectorResponse)&#123;    //对数据合法性进行校验    if (pMsg == NULL || pMsg[0] == 0 || msgLength &lt;= 0 || msgLength &gt; MAX_DATA_LENGTH)    &#123;        //非法刺探请求，不做任何应答，直接关闭连接        closeSession = true;        return;    &#125;    //更新下收包时间    updateHeartbeatTime();    //省略包处理代码...&#125;void BusinessSession::updateHeartbeatTime()&#123;    std::lock_guard&lt;std::mutex&gt; scoped_guard(m_mutexForlastPackageTime);    m_lastPackageTime = (int64_t)time(nullptr);&#125;bool BusinessSession::doHeartbeatCheck()&#123;    const Config&amp; cfg = Singleton&lt;Config&gt;::Instance();    int64_t now = (int64_t)time(nullptr);    std::lock_guard&lt;std::mutex&gt; lock_guard(m_mutexForlastPackageTime);    if (now - m_lastPackageTime &gt;= cfg.m_nMaxClientDataInterval)    &#123;        //心跳包检测，超时，关闭连接        LOGE(&quot;heartbeat expired, close session&quot;);        shutdown();        return true;    &#125;    return false;&#125;void TcpServer::checkSessionHeartbeat()&#123;    int64_t now = (int64_t)time(nullptr);    if (now - m_nLastCheckHeartbeatTime &gt;= m_nHeartbeatCheckInterval)    &#123;        m_spSessionManager-&gt;checkSessionHeartbeat();        m_nLastCheckHeartbeatTime = (int64_t)time(nullptr);    &#125;      &#125;void SessionManager::checkSessionHeartbeat()&#123;       std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForSession);    for (const auto&amp; iter : m_mapSessions)    &#123;        //这里调用 BusinessSession::doHeartbeatCheck()        iter.second-&gt;doHeartbeatCheck();    &#125;  &#125;\n\n\n需要注意的是：一般是客户端主动给服务器端发送心跳包，服务器端做心跳检测决定是否断开连接。而不是反过来，从客户端的角度来说，客户端为了让自己得到服务器端的正常服务有必要主动和服务器保持连接状态正常，而服务器端不会局限于某个特定的客户端，如果客户端不能主动和其保持连接，那么就会主动回收与该客户端的连接。当然，服务器端在收到客户端的心跳包时应该给客户端一个心跳应答。\n\n带业务数据的心跳包上面介绍的心跳包是从纯技术的角度来说的，在实际应用中，有时候我们需要定时或者不定时从服务器端更新一些数据，我们可以把这类数据放在心跳包中，定时或者不定时更新。\n这类带业务数据的心跳包，就不再是纯粹技术上的作用了（这里说的技术的作用指的上文中介绍的心跳包起保活和检测死链作用）。\n这类心跳包实现也很容易，即在心跳包数据结构里面加上需要的业务字段信息，然后在定时器中定时发送，客户端发给服务器，服务器在应答心跳包中填上约定的业务数据信息即可。\n心跳包与流量通常情况下，多数应用场景下，与服务器端保持连接的多个客户端中，同一时间段活跃用户（这里指的是与服务器有频繁数据来往的客户端）一般不会太多。当连接数较多时，进出服务器程序的数据包通常都是心跳包（为了保活）。所以为了减轻网络代码压力，节省流量，尤其是针对一些 3&#x2F;4 G 手机应用，我们在设计心跳包数据格式时应该尽量减小心跳包的数据大小。\n心跳包与调试如前文所述，对于心跳包，服务器端的逻辑一般是在一定时间间隔内没有收到客户端心跳包时会主动断开连接。在我们开发调试程序过程中，我们可能需要将程序通过断点中断下来，这个过程可能是几秒到几十秒不等。等程序恢复执行时，连接可能因为心跳检测逻辑已经被断开。\n调试过程中，我们更多的关注的是业务数据处理的逻辑是否正确，不想被一堆无意义的心跳包数据干扰实线。\n鉴于以上两点原因，我们一般在调试模式下关闭或者禁用心跳包检测机制。代码大致如下：\n1234567891011121314ChatSession::ChatSession(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, int sessionid) :TcpSession(conn), m_id(sessionid),m_seq(0),m_isLogin(false)&#123;    m_userinfo.userid = 0;    m_lastPackageTime = time(NULL);//这里设置了非调试模式下才开启心跳包检测功能#ifndef _DEBUG    EnableHearbeatCheck();#endif&#125;\n\n当然，你也可以将开启心跳检测的开关做成配置信息放入程序配置文件中。\n心跳包与日志实际生产环境，我们一般会将程序收到的和发出去的数据包写入日志中，但是无业务信息的心跳包信息是个例外，一般会刻意不写入日志，这是因为心跳包数据一般比较多，如果写入日志会导致日志文件变得很大，且充斥大量无意义的心跳包日志，所以一般在写日志时会屏蔽心跳包信息写入。\n我这里的建议是，可以将心跳包信息是否写入日志做成一个配置开关，一般处于关闭状态，有需要时再开启。例如，对于一个 WebSocket 服务，ping 和 pong 是心跳包数据，下面示例代码按需输出心跳日志信息：\n12345678910111213141516void BusinessSession::send(std::string_view strResponse)&#123;       bool success = WebSocketSession::send(strResponse);    if (success)    &#123;        bool enablePingPongLog = Singleton&lt;Config&gt;::Instance().m_bPingPongLogEnabled;        //其他消息正常打印，心跳消息按需打印        if (strResponse != &quot;pong&quot; || enablePingPongLog)        &#123;            LOGI(&quot;msg sent to client [%s], sessionId: %s, session: 0x%0x, clientId: %s, accountId: %s, frontId: %s, msg: %s&quot;,                 getClientInfo(), m_strSessionId.c_str(), (int64_t)this, m_strClientID.c_str(), m_strAccountID.c_str(), BusinessSession::m_strFrontId.c_str(), strResponse.data());        &#125;    &#125;&#125;\n\n需要说明的是，以上示例代码使用 C&#x2F;C++ 语言编写，但是本节介绍的心跳包机制设计思路和注意事项是普适性原理，同样适用于其他编程语言。\n","slug":"转载/高性能服务器框架设计/心跳包机制设计详解","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"ce0a6a8a156c3a000bce90a0bc7659bd","title":"【转载】日志系统的设计","content":"日志系统的设计为什么需要日志实际的软件项目产出都有一个流程，即先开发、测试，再发布生产，由于人的因素，既然是软件产品就不可能百分百没有 bug 或者逻辑错误，对于已经发布到生产的项目，一旦某个时刻产生非预期的结果，我们就需要去定位和排查问题。但是一般正式的生产环境的服务器或者产品是不允许开发人员通过附加调试器去排查问题的，主要有如下可能原因：\n\n在很多互联网企业，开发部门、测试部分和产品运维部门是分工明确的，软件产品一旦发布到生产环境以后，将全部交由运维部门人员去管理和维护，而原来开发此产品的开发人员不再拥有相关的操作程序的权限。\n对于已经上了生产环境的服务，其数据和程序稳定性是公司的核心产值所在，一般不敢或不允许被开发人员随意调试或者操作，以免造成损失。\n发布到生产环境的服务，一般为了让程序执行效率更高、文件体积更小，都是去掉调试符号后的版本，不方便也不利于调试。\n\n既然我们无法通过调试器去调试，这个时候为了跟踪和回忆当时的程序行为进而定位问题，我们就需要日志系统。\n退一步说，即使在开发或者测试环境，我们可以把程序附加到调试器上去调试，但是对于一些特定的程序行为，我们无法通过设置断点，让程序在某个时刻暂停下来进行调试。例如，对于某些网络通信功能，如果暂停时间过长（相对于某些程序逻辑来说），通信的对端可能由于彼端没有在规定时间内响应而断开连接，导致程序逻辑无法进入我们想要的执行流中去；再例如，对于一些高频操作（如心跳包、定时器、界面绘制下的某些高频重复行为），可能在少量次数下无法触发我们想要的行为，而通过断点的暂停方式，我们不得不重复操作几十次、上百次甚至更多，这样排查问题效率是非常低下的。对于这类操作，我们可以通过打印日志，将当时的程序行为上下文现场记录下来，然后从日志系统中找到某次不正常的行为的上下文信息。这也是日志的另外一个作用。\n本文将从技术和业务上两个方面来介绍日志系统相关的设计与开发，所谓技术上，就是如何从程序开发的角度设计一款功能强大、性能优越、使用方便的日志系统；而业务上，是指我们在使用日志系统时，应该去记录哪些行为和数据，既简洁、不啰嗦，又方便需要时快速准确地定位到问题。\n日志系统的技术上的实现日志的最初的原型即将程序运行的状态打印出来，对于 C&#x2F;C++ 这门语言来说，即可以利用 printf、std::cout 等控制台输出函数，将日志信息输出到控制台，这类简单的情形我们不在此过多赘述。\n对于商业项目，为了方便排查问题，我们一般不将日志写到控制台，而是输出到文件或者数据库系统。不管哪一种，其思路基本上一致，我们这里以写文件为例来详细介绍。\n同步写日志所谓同步写日志，指的是在输出日志的地方，将日志即时写入到文件中去。根据笔者的经验，这种设计广泛地用于相当多的的客户端软件。笔者曾从事过数年的客户端开发（包括 PC、安卓软件），设计过一些功能复杂的金融客户端产品，在这些系统中采用的就是这种同步写日志的方式。之所以使用这种方式其主要原因就是设计简单，而又不会影响用户使用体验。说到这里读者可能有这样一个疑问：一般的客户端软件，一般存在界面，而界面部分所属的逻辑就是程序的主线程，如果采取这种同步写日志的方式，当写日志时，写文件是磁盘 IO 操作，相比较程序其他部分是 CPU 操作，前者要慢很多，这样势必造成CPU等待，进而导致主线程“卡”在写文件处，进而造成界面卡顿，从而导致用户使用软件的体验不好。读者的这种顾虑确实是存在的。但是，很多时候我们不用担心这种问题，主要有两个原因：\n\n对于客户端程序，即使在主线程（UI 线程）中同步写文件，其单次或者几次磁盘操作累加时间，与人（用户）的可感知时间相比，也是非常小的，也就是说用户根本感觉不到这种同步写文件造成的延迟。当然，这里也给您一个提醒就是，如果在 UI 线程里面写日志，尤其是在一些高频操作中（如 Windows 的界面绘制消息 WM_PAINT 处理逻辑中），一定要控制写日志的长度和次数，否则就会因频繁写文件或一次写入数据过大而对界面造成卡顿。\n客户端程序除了 UI 线程，还有其他与界面无关的工作线程，在这些线程中直接写文件，一般不会对用户的体验产生什么影响。\n\n说了这么多，我们给出一个具体的例子。\n日志类的 .h 文件\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** *@desc:   IULog.h *@author: zhangyl *@date:   2014.12.25 */#ifndef __LOG_H__#define __LOG_H__enum LOG_LEVEL&#123;    LOG_LEVEL_INFO,    LOG_LEVEL_WARNING,    LOG_LEVEL_ERROR&#125;;//注意：如果打印的日志信息中有中文，则格式化字符串要用_T()宏包裹起来，#define LOG_INFO(...)     CIULog::Log(LOG_LEVEL_INFO, __FUNCSIG__,__LINE__, __VA_ARGS__)#define LOG_WARNING(...)  CIULog::Log(LOG_LEVEL_WARNING, __FUNCSIG__, __LINE__,__VA_ARGS__)#define LOG_ERROR(...)    CIULog::Log(LOG_LEVEL_ERROR, __FUNCSIG__,__LINE__, __VA_ARGS__)class CIULog&#123;public:    static bool Init(bool bToFile, bool bTruncateLongLog, PCTSTR pszLogFileName);    static void Uninit();    static void SetLevel(LOG_LEVEL nLevel);    //不输出线程ID号和所在函数签名、行号    static bool Log(long nLevel, PCTSTR pszFmt, ...);    //输出线程ID号和所在函数签名、行号    static bool Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCTSTR pszFmt, ...);        //注意:pszFunctionSig参数为Ansic版本    static bool Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCSTR pszFmt, ...);private:    CIULog() = delete;    ~CIULog() = delete;    CIULog(const CIULog&amp; rhs) = delete;    CIULog&amp; operator=(const CIULog&amp; rhs) = delete;    static void GetTime(char* pszTime, int nTimeStrLength);private:    static bool             m_bToFile;              //日志写入文件还是写到控制台      static HANDLE           m_hLogFile;    static bool             m_bTruncateLongLog;     //长日志是否截断    static LOG_LEVEL        m_nLogLevel;            //日志级别&#125;;#endif // !__LOG_H__\n\n日志的 cpp 文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332/** *@desc:   IULog.cpp *@author: zhangyl *@date:   2014.12.25 */#include &quot;stdafx.h&quot;#include &quot;IULog.h&quot;#include &quot;EncodingUtil.h&quot;#include &lt;tchar.h&gt;#ifndef LOG_OUTPUT#define LOG_OUTPUT#endif#define MAX_LINE_LENGTH 256bool CIULog::m_bToFile = false;bool CIULog::m_bTruncateLongLog = false;HANDLE CIULog::m_hLogFile = INVALID_HANDLE_VALUE;LOG_LEVEL CIULog::m_nLogLevel = LOG_LEVEL_INFO;bool CIULog::Init(bool bToFile, bool bTruncateLongLog, PCTSTR pszLogFileName)&#123;#ifdef LOG_OUTPUT    m_bToFile = bToFile;    m_bTruncateLongLog = bTruncateLongLog;    if (pszLogFileName == NULL || pszLogFileName[0] == NULL)        return FALSE;    TCHAR szHomePath[MAX_PATH] = &#123;0&#125;;    ::GetModuleFileName(NULL, szHomePath, MAX_PATH);    for (int i = _tcslen(szHomePath); i &gt;= 0; --i)    &#123;        if (szHomePath[i] == _T(&#x27;\\\\&#x27;))        &#123;            szHomePath[i] = _T(&#x27;\\0&#x27;);            break;        &#125;    &#125;    TCHAR szLogDirectory[MAX_PATH] = &#123; 0 &#125;;    _stprintf_s(szLogDirectory, _T(&quot;%s\\\\Logs\\\\&quot;), szHomePath);    DWORD dwAttr = ::GetFileAttributes(szLogDirectory);    if (!((dwAttr != 0xFFFFFFFF) &amp;&amp; (dwAttr &amp; FILE_ATTRIBUTE_DIRECTORY)))    &#123;        TCHAR cPath[MAX_PATH] = &#123; 0 &#125;;        TCHAR cTmpPath[MAX_PATH] = &#123; 0 &#125;;        TCHAR* lpPos = NULL;        TCHAR cTmp = _T(&#x27;\\0&#x27;);        _tcsncpy_s(cPath, szLogDirectory, MAX_PATH);        for (int i = 0; i &lt; (int)_tcslen(cPath); i++)        &#123;            if (_T(&#x27;\\\\&#x27;) == cPath[i])                cPath[i] = _T(&#x27;/&#x27;);        &#125;        lpPos = _tcschr(cPath, _T(&#x27;/&#x27;));        while (lpPos != NULL)        &#123;            if (lpPos == cPath)            &#123;                lpPos++;            &#125;            else            &#123;                cTmp = *lpPos;                *lpPos = _T(&#x27;\\0&#x27;);                _tcsncpy_s(cTmpPath, cPath, MAX_PATH);                ::CreateDirectory(cTmpPath, NULL);                *lpPos = cTmp;                lpPos++;            &#125;            lpPos = _tcschr(lpPos, _T(&#x27;/&#x27;));        &#125;    &#125;    m_hLogFile = ::CreateFile(pszLogFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);    if (m_hLogFile == INVALID_HANDLE_VALUE)        return false;#endif // end LOG_OUTPUT    return true;&#125;void CIULog::Uninit()&#123;#ifdef LOG_OUTPUT    if(m_hLogFile != INVALID_HANDLE_VALUE)    &#123;        ::CloseHandle(m_hLogFile);        m_hLogFile = INVALID_HANDLE_VALUE;    &#125;#endif //end LOG_OUTPUT&#125;void CIULog::SetLevel(LOG_LEVEL nLevel)&#123;    m_nLogLevel = nLevel;&#125;bool CIULog::Log(long nLevel, PCTSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime,ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[Warning]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[Error]&quot;;    strDebugInfo += strLevel;    //当前线程信息    char szThreadID[32] = &#123; 0 &#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %u]&quot;, dwThreadID);      strDebugInfo += szThreadID;    //log正文    std::wstring strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vsctprintf(pszFmt, ap);    //容量必须算上最后一个\\0    if ((int)strLogMsg.capacity() &lt; nLogMsgLength + 1)    &#123;        strLogMsg.resize(nLogMsgLength + 1);    &#125;    _vstprintf_s((TCHAR*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    va_end(ap);    //string内容正确但length不对，恢复一下其length    std::wstring strMsgFormal;    strMsgFormal.append(strLogMsg.c_str(), nLogMsgLength);    //如果日志开启截断，长日志只取前MAX_LINE_LENGTH个字符    if (m_bTruncateLongLog)        strMsgFormal = strMsgFormal.substr(0, MAX_LINE_LENGTH);    std::string strLogMsgAscii;    strLogMsgAscii = EncodeUtil::UnicodeToAnsi(strMsgFormal);    strDebugInfo += strLogMsgAscii;    strDebugInfo += &quot;\\r\\n&quot;;    if(m_bToFile)    &#123;        if(m_hLogFile == INVALID_HANDLE_VALUE)            return false;        ::SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;               ::WriteFile(m_hLogFile, strDebugInfo.c_str(), strDebugInfo.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);        return true;    &#125;    ::OutputDebugStringA(strDebugInfo.c_str());#endif // end LOG_OUTPUT    return true;&#125;bool CIULog::Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCTSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    //时间    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime, ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    //错误级别    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[Warning]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[Error]&quot;;    strDebugInfo += strLevel;    //当前线程信息    char szThreadID[32] = &#123;0&#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %u]&quot;, dwThreadID);    strDebugInfo += szThreadID;    //函数签名    char szFuncSig[512] = &#123; 0 &#125;;    sprintf_s(szFuncSig, &quot;[%s:%d]&quot;, pszFunctionSig, nLineNo);    strDebugInfo += szFuncSig;    //log正文    std::wstring strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vsctprintf(pszFmt, ap);    //容量必须算上最后一个\\0     if ((int)strLogMsg.capacity() &lt; nLogMsgLength + 1)    &#123;        strLogMsg.resize(nLogMsgLength + 1);    &#125;    _vstprintf_s((TCHAR*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    va_end(ap);    //string内容正确但length不对，恢复一下其length    std::wstring strMsgFormal;    strMsgFormal.append(strLogMsg.c_str(), nLogMsgLength);    //如果日志开启截断，长日志只取前MAX_LINE_LENGTH个字符    if (m_bTruncateLongLog)        strMsgFormal = strMsgFormal.substr(0, MAX_LINE_LENGTH);    std::string strLogMsgAscii;    strLogMsgAscii = EncodeUtil::UnicodeToAnsi(strMsgFormal);    strDebugInfo += strLogMsgAscii;    strDebugInfo += &quot;\\r\\n&quot;;    if(m_bToFile)    &#123;        if(m_hLogFile == INVALID_HANDLE_VALUE)            return false;        ::SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;        ::WriteFile(m_hLogFile, strDebugInfo.c_str(), strDebugInfo.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);        return true;    &#125;    ::OutputDebugStringA(strDebugInfo.c_str());#endif // end LOG_OUTPUT    return true;&#125;bool CIULog::Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    //时间    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime, ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    //错误级别    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[Warning]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[Error]&quot;;    strDebugInfo += strLevel;    //当前线程信息    char szThreadID[32] = &#123;0&#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %u]&quot;, dwThreadID);    strDebugInfo += szThreadID;    //函数签名    char szFuncSig[512] = &#123; 0 &#125;;    sprintf_s(szFuncSig, &quot;[%s:%d]&quot;, pszFunctionSig, nLineNo);    strDebugInfo += szFuncSig;    //日志正文    std::string strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vscprintf(pszFmt, ap);    //容量必须算上最后一个\\0    if ((int)strLogMsg.capacity() &lt; nLogMsgLength + 1)    &#123;        strLogMsg.resize(nLogMsgLength + 1);    &#125;    vsprintf_s((char*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    va_end(ap);    //string内容正确但length不对，恢复一下其length    std::string strMsgFormal;    strMsgFormal.append(strLogMsg.c_str(), nLogMsgLength);    //如果日志开启截断，长日志只取前MAX_LINE_LENGTH个字符    if (m_bTruncateLongLog)        strMsgFormal = strMsgFormal.substr(0, MAX_LINE_LENGTH);    strDebugInfo += strMsgFormal;    strDebugInfo += &quot;\\r\\n&quot;;    if(m_bToFile)    &#123;        if(m_hLogFile == INVALID_HANDLE_VALUE)            return false;        ::SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;        ::WriteFile(m_hLogFile, strDebugInfo.c_str(), strDebugInfo.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);        return true;    &#125;    ::OutputDebugStringA(strDebugInfo.c_str());#endif // end LOG_OUTPUT    return true;&#125;void CIULog::GetTime(char* pszTime, int nTimeStrLength)&#123;    SYSTEMTIME st = &#123;0&#125;;    ::GetLocalTime(&amp;st);    sprintf_s(pszTime, nTimeStrLength, &quot;[%04d-%02d-%02d %02d:%02d:%02d:%04d]&quot;, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);&#125;\n\n上述代码中根据日志级别定义了三个宏 LOG_INFO、LOG_WARNING、LOG_ERROR，如果要使用该日志模块，只需要在程序启动处的地方调用 CIULog::Init 函数初始化日志：\n12345SYSTEMTIME st = &#123;0&#125;;::GetLocalTime(&amp;st);TCHAR szLogFileName[MAX_PATH] = &#123;0&#125;;_stprintf_s(szLogFileName, MAX_PATH, _T(&quot;%s\\\\Logs\\\\%04d%02d%02d%02d%02d%02d.log&quot;), g_szHomePath, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);CIULog::Init(true, false, szLogFileName);\n\n当然，最佳的做法，在程序退出的地方，调用 CIULog::Uninit 回收日志模块相关的资源：\n1CIULog::Uninit();\n\n在做好这些准备工作以后，如果你想在程序的某个地方写一条日志，只需要这样写：\n123456//打印一条 INFO 级别的日志LOG_INFO(&quot;Request logon: Account=%s, Password=*****, Status=%d, LoginType=%d.&quot;, pLoginRequest-&gt;m_szAccountName, pLoginRequest-&gt;m_szPassword, pLoginRequest-&gt;m_nStatus, (long)pLoginRequest-&gt;m_nLoginType);//打印一条 WARNING 级别的日志LOG_WARN(&quot;Some warning...&quot;);//打印一条 ERROR 级别的日志LOG_ERROR(&quot;Recv data error, errorNO=%d.&quot;, ::WSAGetLastError());\n\n关于 CIULog 这个日志模块类，如果读者要想实际运行查看效果，可以从链接（https://github.com/baloonwj/flamingo/tree/master/flamingoclient ）下载完整的项目代码来运行。该日志输出效果如下：\n12345[2018-11-09 23:52:54:0826][INFO][ThreadID: 7252][bool __thiscall CIUSocket::Login(const char *,const char *,int,int,int,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;):1107]Request logon: Account=zhangy, Password=*****, Status=76283204, LoginType=1.[2018-11-09 23:52:56:0352][INFO][ThreadID: 5828][void __thiscall CIUSocket::SendThreadProc(void):794]Recv data thread start...[2018-11-09 23:52:56:0385][INFO][ThreadID: 6032][void __thiscall CSendMsgThread::HandleUserBasicInfo(const class CUserBasicInfoRequest *):298]Request to get userinfo.[2018-11-09 23:52:56:0355][INFO][ThreadID: 7140][void __thiscall CIUSocket::RecvThreadProc(void):842]Recv data thread start...[2018-11-09 23:52:57:0254][INFO][ThreadID: 7220][int __thiscall CRecvMsgThread::HandleFriendListInfo(const class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;):593]Recv user basic info, info count=1.\n\n多线程同步写日志出现的问题一从上面的日志输出来看，这种同步的日志输出方式，也存在时间顺序不正确的问题（时间戳大的日志比时间戳小的日志靠前）。这是由于多线程同时写日志到同一个文件时，产生日志的时间和实际写入磁盘的时间不是一个原子操作。下图解释了该现象出现的根源：\n\n多线程写同一个日志文件出现先产生的日志后写入到文件中的现象\n好在这种时间顺序不正确只会出现在不同线程之间，对于同一个线程的不同时间的日志记录顺序肯定是正确的。所以这种日期错乱现象，并不影响我们使用日志。\n多线程同步写日志出现的问题二多线程同时写入同一个日志文件还有一个问题，就是假设线程 A 写某一个时刻追加日志内容为 “AAAAA” ，线程 B 在同一时刻追加日志内容为 “BBBBB” ，线程 C 在同一时刻追加日志内容为 “CCCCC” ，那么最终的日志文件中的内容会不会出现 “AABBCCABCAACCBB” 这种格式？\n在类 Unix 系统上（包括 Linux），同一个进程内针对同一个 FILE* 的操作是线程安全的，也就是说，在这类操作系统上得到的日志结果 A、B、C 各个字母组一定是连续在一起，也就是说最终得到的日志内容可能是 “AAAAACCCCCBBBBB” 或 “AAAAABBBBBCCCCC” 等这种连续的格式，绝不会出现 A、B、C 字母交错相间的现象。\n而在Windows系统上，对于 FILE* 的操作并不是线程安全的。但是笔者做了大量实验，在 Windows 系统上也没有出现这种 A、B、C 字母相间的现象。（关于这个问题的讨论，可以参考这里：https://www.zhihu.com/question/40472431 ）\n这种同步日志的实现方式，一般用于低频写日志的软件系统中（如客户端软件），所以我可以认为这种多线程同时写日志到一个文件中是可行的。\n异步写日志当然，对于性能要求不高的应用（如大多数客户端程序、某些并发数量不高的服务）来说，这种同步写日志的实现方式是可以满足要求的。但是对于 QPS 要求很高或者对性能有一定要求的服务器程序，同步写日志等待磁盘 IO 的完成对于服务的关键性逻辑的快速执行和及时响应性会造成一定的性能损失。为了减小这种损失，我们可以采用异步日志。\n所谓异步写日志，与同步写日志相反，即产生日志的地方，不会将日志实时写入到文件中去，而是通过一些线程同步技术将日志先暂存下来，然后再通过一个或多个专门的日志写入线程去将这些缓存的日志写入到磁盘中去，这样的话，原来输出日志的线程就不存在等待写日志到磁盘这样的效率损耗了。这本质上，其实就是一个生产者和消费者，产生日志的线程是生产者，将日志写入文件的线程是消费者。当然，对于日志的消费者线程，我这里提到“一个”或“多个”日志线程，在实际开发中，如果多个日志消费线程，我们又要考虑多个线程可能会造成写日志的时间顺序错位（时间较晚的日志写在时间较早的日志前面），这在上文中已经讨论过，这里不再赘述。\n总结起来，为了方便读者理解和编码，我们可以认为异步写日志的逻辑一般存在一组专门写日志的线程（一个或多个），程序的其他线程为这些日志线程生产日志。\n至于其他线程如何将产生的日志交给日志线程，这就是多线程之间资源同步的问题了。我们可以使用一个队列来存储其他线程产生的日志，日志线程从该队列中取出日志，然后将日志内容写入文件。最简单的方式是日志生产线程将每次产生的日志信息放入一个队列时、日志写入线程从队列中取出日志时，都使用一个**互斥体( mutex )**保护起来。代码示例如下（C++11 代码）：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** *@desc: AsyncLogger.cpp *@author: zhangyl *@date: 2018.11.10 */#include &quot;stdafx.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;//保护队列的互斥体std::mutex log_mutex;std::list&lt;std::string&gt; cached_logs;FILE* log_file = NULL;bool init_log_file()&#123;    //以追加内容的形式写入文件内容，如果文件不存在，则创建    log_file = fopen(&quot;my.log&quot;, &quot;a+&quot;);    return log_file != NULL;&#125;void uninit_log_file()&#123;    if (log_file != NULL)        fclose(log_file);&#125;bool write_log_tofile(const std::string&amp; line)&#123;    if (log_file == NULL)        return false;    if (fwrite((void*)line.c_str(), 1, line.length(), log_file) != line.length())        return false;    //将日志立即冲刷到文件中去    fflush(log_file);    return true;&#125;void log_producer()&#123;    int index = 0;    while (true)    &#123;        ++ index;        std::ostringstream os;        os &lt;&lt; &quot;This is log, index: &quot; &lt;&lt; index &lt;&lt; &quot;, producer threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;\\n&quot;;        //使用花括号括起来为的是减小锁的粒度        &#123;            std::lock_guard&lt;std::mutex&gt; lock(log_mutex);            cached_logs.emplace_back(os.str());        &#125;        std::chrono::milliseconds duration(100);        std::this_thread::sleep_for(duration);    &#125;&#125;void log_consumer()&#123;    std::string line;    while (true)    &#123;        //使用花括号括起来为的是减小锁的粒度        &#123;            std::lock_guard&lt;std::mutex&gt; lock(log_mutex);            if (!cached_logs.empty())            &#123;                line = cached_logs.front();                cached_logs.pop_front();            &#125;        &#125;        if (line.empty())        &#123;                    std::chrono::milliseconds duration(1000);            std::this_thread::sleep_for(duration);            continue;        &#125;        write_log_tofile(line);        line.clear();    &#125;&#125;int main(int argc, char* argv[])&#123;    if (!init_log_file())    &#123;        std::cout &lt;&lt; &quot;init log file error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    std::thread log_producer1(log_producer);    std::thread log_producer2(log_producer);    std::thread log_producer3(log_producer);    std::thread log_consumer1(log_consumer);    std::thread log_consumer2(log_consumer);    std::thread log_consumer3(log_consumer);    log_producer1.join();    log_producer2.join();    log_producer3.join();    log_consumer1.join();    log_consumer2.join();    log_consumer3.join();    uninit_log_file();    return 0;&#125;\n\n上述代码分别模拟了三个生产日志的线程（log_producer1～3）和三个消费日志线程（log_consumer1～3）。当然上述代码可以继续优化，如果当前缓存队列中没有日志记录，那么消费日志线程会做无用功。\n优化方法一可以使用条件变量，如果当前队列中没有日志记录，则将日志消费线程挂起；当生产日志的线程产生了新的日志后，置信（signal）条件变量，这样日志消费线程会被唤醒，以将日志从队列中取出来并写入文件。我们来看下代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** *@desc: AsyncLoggerLinux.cpp *@author: zhangyl *@date: 2018.11.10 */#include &quot;stdafx.h&quot;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;std::mutex log_mutex;std::condition_variable log_cv;std::list&lt;std::string&gt; cached_logs;FILE* log_file = NULL;bool init_log_file()&#123;    //以追加内容的形式写入文件内容，如果文件不存在，则创建    log_file = fopen(&quot;my.log&quot;, &quot;a+&quot;);    return log_file != NULL;&#125;void uninit_log_file()&#123;    if (log_file != NULL)        fclose(log_file);&#125;bool write_log_tofile(const std::string&amp; line)&#123;    if (log_file == NULL)        return false;    if (fwrite((void*)line.c_str(), 1, line.length(), log_file) != line.length())        return false;    //将日志立即冲刷到文件中去    fflush(log_file);    return true;&#125;void log_producer()&#123;    int index = 0;    while (true)    &#123;        ++ index;        std::ostringstream os;        os &lt;&lt; &quot;This is log, index: &quot; &lt;&lt; index &lt;&lt; &quot;, producer threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;\\n&quot;;        //使用花括号括起来为的是减小锁的粒度        &#123;            std::lock_guard&lt;std::mutex&gt; lock(log_mutex);            cached_logs.emplace_back(os.str());            log_cv.notify_one();        &#125;        std::chrono::milliseconds duration(100);        std::this_thread::sleep_for(duration);    &#125;&#125;void log_consumer()&#123;    std::string line;    while (true)    &#123;        //使用花括号括起来为的是减小锁的粒度        &#123;            std::unique_lock&lt;std::mutex&gt; lock(log_mutex);            if (cached_logs.empty())            &#123;                //无限等待                log_cv.wait(lock);            &#125;            line = cached_logs.front();            cached_logs.pop_front();        &#125;        if (line.empty())        &#123;                    std::chrono::milliseconds duration(1000);            std::this_thread::sleep_for(duration);            continue;        &#125;        write_log_tofile(line);        line.clear();    &#125;&#125;int main(int argc, char* argv[])&#123;    if (!init_log_file())    &#123;        std::cout &lt;&lt; &quot;init log file error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    std::thread log_producer1(log_producer);    std::thread log_producer2(log_producer);    std::thread log_producer3(log_producer);    std::thread log_consumer1(log_consumer);    std::thread log_consumer2(log_consumer);    std::thread log_consumer3(log_consumer);    log_producer1.join();    log_producer2.join();    log_producer3.join();    log_consumer1.join();    log_consumer2.join();    log_consumer3.join();    uninit_log_file();    return 0;&#125;\n\n优化方法二除了条件变量以外，我们还可以使用信号量来设计我们的异步日志系统，信号量是带有资源计数的线程同步对象，当每产生一条日志时，我们将信号量资源计数自增1，日志消费线程默认是等待这个信号量是否受信，如果受信，每唤醒一个日志消费线程，信号量字数计数将自动减1。通俗地说就是生成者每生产一个资源，就将资源计数加1，而消费者每消费一个资源数量，就将资源计数减一；如果当前资源计数已经为0，则消费者将自动挂起。\n由于 C++ 11 没有提供对不同平台的信号量对象的封装，我们这里分别给出 Windows 和 Linux 两个平台的实现代码，读者可以根据需要来学习其中一个或两个同时学习。注意，为了保持代码风格一致，对于线程和读写文件相关函数，在不同的操作系统平台，我们使用该系统平台相关的 API 接口，而不再使用 C++ 11 的相关函数和类库。\nWindows 平台代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** *@desc: AsyncLogger.cpp，Windows版本 *@author: zhangyl *@date: 2018.11.10 */#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;std::list&lt;std::string&gt; cached_logs;CRITICAL_SECTION g_cs;HANDLE g_hSemaphore = NULL;HANDLE g_hLogFile = INVALID_HANDLE_VALUE;bool Init()&#123;    InitializeCriticalSection(&amp;g_cs);    //假设资源数量上限是0xFFFFFFFF    g_hSemaphore = CreateSemaphore(NULL, 0, 0xFFFFFFFF, NULL);    //如果文件不存在，则创建    g_hLogFile = CreateFile(_T(&quot;my.log&quot;), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    if (g_hLogFile == INVALID_HANDLE_VALUE)        return false;    return true;&#125;void Uninit()&#123;    DeleteCriticalSection(&amp;g_cs);    if (g_hSemaphore != NULL)        CloseHandle(g_hSemaphore);    if (g_hLogFile != INVALID_HANDLE_VALUE)        CloseHandle(g_hLogFile);&#125;bool WriteLogToFile(const std::string&amp; line)&#123;    if (g_hLogFile == INVALID_HANDLE_VALUE)        return false;    DWORD dwBytesWritten;    //如果对于比较长的日志，应该分段写入，因为单次写入可能只能写入部分，这里为了演示方便，逻辑从简    if (!WriteFile(g_hLogFile, line.c_str(), line.length(), &amp;dwBytesWritten, NULL) || dwBytesWritten != line.length())        return false;    //将日志立即冲刷到文件中去    FlushFileBuffers(g_hLogFile);    return true;&#125;DWORD CALLBACK LogProduceThreadProc(LPVOID lpThreadParameter)&#123;    int index = 0;    while (true)    &#123;        ++ index;        std::ostringstream os;        os &lt;&lt; &quot;This is log, index: &quot; &lt;&lt; index &lt;&lt; &quot;, producer threadID: &quot; &lt;&lt; GetCurrentThreadId() &lt;&lt; &quot;\\n&quot;;        EnterCriticalSection(&amp;g_cs);               cached_logs.emplace_back(os.str());        LeaveCriticalSection(&amp;g_cs);        ReleaseSemaphore(g_hSemaphore, 1, NULL);        Sleep(100);    &#125;    return 0;&#125;DWORD CALLBACK LogConsumeThreadProc(LPVOID lpThreadParameter)&#123;    std::string line;    while (true)    &#123;             //无限等待        WaitForSingleObject(g_hSemaphore, INFINITE);        EnterCriticalSection(&amp;g_cs);        if (!cached_logs.empty())        &#123;            line = cached_logs.front();            cached_logs.pop_front();        &#125;             LeaveCriticalSection(&amp;g_cs);                  if (line.empty())        &#123;                    Sleep(1000);            continue;        &#125;        WriteLogToFile(line);        line.clear();    &#125;&#125;int main(int argc, char* argv[])&#123;    if (!Init())    &#123;        std::cout &lt;&lt; &quot;init log file error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    HANDLE hProducers[3];    for (int i = 0; i &lt; sizeof(hProducers) / sizeof(hProducers[0]); ++i)    &#123;        hProducers[i] = CreateThread(NULL, 0, LogProduceThreadProc, NULL, 0, NULL);    &#125;    HANDLE hConsumers[3];    for (int i = 0; i &lt; sizeof(hConsumers) / sizeof(hConsumers[0]); ++i)    &#123;        hConsumers[i] = CreateThread(NULL, 0, LogConsumeThreadProc, NULL, 0, NULL);    &#125;    //等待消费者线程退出    for (int i = 0; i &lt; sizeof(hProducers) / sizeof(hProducers[0]); ++i)    &#123;        WaitForSingleObject(hProducers[i], INFINITE);    &#125;    //等待生产者线程退出    for (int i = 0; i &lt; sizeof(hConsumers) / sizeof(hConsumers[0]); ++i)    &#123;        WaitForSingleObject(hConsumers[i], INFINITE);    &#125;    Uninit();    return 0;&#125;\n\n上述代码，在多线程向队列中增加日志记录和从队列中取出日志记录使用了Windows的上的临界区（CRITICAL_SECTION，有的书上译作“关键段”）对象来对队列进行保护。\nLinux 平台代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** *@desc: AsyncLogger.cpp，linux版本 *@author: zhangyl *@date: 2018.11.10 */#include &lt;unistd.h&gt;#include &lt;list&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;std::list&lt;std::string&gt; cached_logs;pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;sem_t           log_semphore;FILE* plogfile = NULL;bool init()&#123;    pthread_mutex_init(&amp;log_mutex, NULL);    //初始信号量资源数目是0    sem_init(&amp;log_semphore, 0, 0);    //如果文件不存在，则创建    plogfile = fopen(&quot;my.log&quot;, &quot;a++&quot;);    return plogfile != NULL;&#125;void uninit()&#123;    pthread_mutex_destroy(&amp;log_mutex);    sem_destroy(&amp;log_semphore);    if (plogfile != NULL)        fclose(plogfile);&#125;bool write_log_to_file(const std::string&amp; line)&#123;    if (plogfile == NULL)        return false;    //如果对于比较长的日志，应该分段写入，因为单次写入可能只能写入部分，这里为了演示方便，逻辑从简    if (fwrite((void*)line.c_str(), 1, line.length(), plogfile) != line.length())        return false;    //将日志立即冲刷到文件中去    fflush(plogfile);    return true;&#125;void* producer_thread_proc(void* arg)&#123;    int index = 0;    while (true)    &#123;        ++ index;        std::ostringstream os;        os &lt;&lt; &quot;This is log, index: &quot; &lt;&lt; index &lt;&lt; &quot;, producer threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;\\n&quot;;        pthread_mutex_lock(&amp;log_mutex);        cached_logs.push_back(os.str());        pthread_mutex_unlock(&amp;log_mutex);        sem_post(&amp;log_semphore);        usleep(100000);    &#125;&#125;void* consumer_thread_proc(void* arg)&#123;    std::string line;    while (true)    &#123;             //无限等待        sem_wait(&amp;log_semphore);        pthread_mutex_lock(&amp;log_mutex);        if (!cached_logs.empty())        &#123;            line = cached_logs.front();            cached_logs.pop_front();        &#125;             pthread_mutex_unlock(&amp;log_mutex);        if (line.empty())        &#123;                    sleep(1);            continue;        &#125;        write_log_to_file(line);        line.clear();    &#125;&#125;int main(int argc, char* argv[])&#123;    if (!init())    &#123;        std::cout &lt;&lt; &quot;init log file error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    pthread_t producer_thread_id[3];    for (int i = 0; i &lt; sizeof(producer_thread_id) / sizeof(producer_thread_id[0]); ++i)    &#123;        pthread_create(&amp;producer_thread_id[i], NULL, producer_thread_proc, NULL);    &#125;    pthread_t consumer_thread_id[3];    for (int i = 0; i &lt; sizeof(consumer_thread_id) / sizeof(consumer_thread_id[0]); ++i)    &#123;        pthread_create(&amp;consumer_thread_id[i], NULL, consumer_thread_proc, NULL);    &#125;    //等待消费者线程退出    for (int i = 0; i &lt; sizeof(producer_thread_id) / sizeof(producer_thread_id[0]); ++i)    &#123;        pthread_join(producer_thread_id[i], NULL);    &#125;    //等待生产者线程退出    for (int i = 0; i &lt; sizeof(consumer_thread_id) / sizeof(consumer_thread_id[0]); ++i)    &#123;        pthread_join(consumer_thread_id[i], NULL);    &#125;    uninit();    return 0;&#125;\n\n我们使用 g++ 编译器编译上述代码，使用如下命令生成可移植性文件 AsyncLoggerLinux：\n1g++ -g -o AsyncLoggerLinux AsyncLoggerLinux.cpp -lpthread\n\n接着执行生成的 AsyncLoggerLinux 文件，然后生成的日志效果如下：\n12345678910111213141516This is log, index: 1, producer threadID: 140512358795008This is log, index: 1, producer threadID: 140512367187712This is log, index: 1, producer threadID: 140512375580416This is log, index: 2, producer threadID: 140512358795008This is log, index: 2, producer threadID: 140512367187712This is log, index: 2, producer threadID: 140512375580416This is log, index: 3, producer threadID: 140512358795008This is log, index: 3, producer threadID: 140512367187712This is log, index: 3, producer threadID: 140512375580416This is log, index: 4, producer threadID: 140512358795008This is log, index: 4, producer threadID: 140512367187712This is log, index: 4, producer threadID: 140512375580416This is log, index: 5, producer threadID: 140512358795008This is log, index: 5, producer threadID: 140512367187712This is log, index: 5, producer threadID: 140512375580416//省略...\n\n\n当然，您可能需要同时能在 Windows 和 Linux 同时运行的代码，我们自然而然想到用 C++11 语法的信号量，由于 C++ 11 本身没有提供现成的信号量库，我们可以自己利用std::mutex、std::condition_variable模拟一下信号量的功能，这里就不再详细介绍了，有兴趣的可以自行尝试一下。\n\n以上就是异步日志的基本原理，在这个原理的基础上，我们可以增加很多的特性。\n","slug":"转载/高性能服务器框架设计/日志系统的设计","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"244b4809351f4fc8c6cac7d22fa4014d","title":"【转载】错误码系统的设计","content":"错误码系统的设计\n本文介绍服务器开发中一组服务中错误码系统的设计理念与实践，如果读者从来没想过或者没接触过这种设计理念，建议认真体会一下这种设计思路的优点。\n\n错误码的作用读者如果有使用过中国电信的宽带账号上网的经历，如果我们登陆不成功，一般服务器会返回一个错误码，如651、678。然后，我们打中国电信的客服电话，客服会询问我们错误码是多少，通过错误码他们的技术人员就大致知道了错误原因；并且通过错误码，他们就知道到底是电信的服务器问题还是宽带用户自己的设备或者操作问题，如果是用户自己的问题，他们一般会尝试教用户如何操作，而不是冒然就派遣维修人员上门，这样不仅能尽早解决问题同时也节约了人力成本。\n再举另外一个例子，我们日常浏览网页，当Web服务器正常返回页面时，状态码一般是200(OK)，而当页面不存在时，错误码一般是404，另外像503等错误都是比较常见的。\n通过以上两个例子，读者应该能明白，对于服务器系统来说，设计一套好的错误码是非常有必要的，可以在用户请求出问题时迅速定位并解决问题。具体包括两个方面：\n\n可以迅速定位是用户“输入”问题还是服务器自身的问题。\n\n所谓的用户“输入”问题，是指用户的不当操作，这里的“用户的不当操作”可能是因为客户端软件本身的逻辑错误或漏洞，也可能是使用客户端的人的非法操作，而客户端软件在设计上因为考虑不周而缺乏有效性校验，这两类情形都可能会产生非法的数据，并且直接发给服务器。一个好的服务端系统不能假设客户端的请求数据一定是合法的，必须对传过来的数据做有效性校验。服务器没有义务一定给非法的请求做出应答，因此请求的最终结果是服务器不应答或给客户端不想要的应答。\n以上面的例子为例，宽带用户输入了无效的用户名或者密码造成服务器拒绝访问；用户在浏览器中输入了一个无效的网址等。这类错误，都是需要用户自己解决或者用户可以自己解决的。如果错误码可以反映出这类错误，那么在实际服务器运维的过程中，当用户反馈这一类故障时，我们通过服务器内部产生的错误码或者应答给客户端的错误码，准确快速地确定问题原因。如果是用户非法请求造成的，可以让用户自行解决。注意，这里的“用户”，可以代指人，也可以代指使用某个服务器的所有下游服务和客户端。\n\n可以快速定位哪个步骤或哪个服务出了问题。\n对于单个服务，假设收到某个“客户端”请求时，需要经历多个步骤才能完成，而这中间任何一个步骤都可能出问题，在不同步骤出错时返回不同的错误码，那么就可以知道是哪个步骤出了问题。\n其次，一般稍微复杂一点的系统，都不是单个服务，往往是由一组服务构成。如果将错误码分段，每个服务的错误码都有各自的范围，那么通过错误码，我们也能准确地知道是哪个服务出了问题。\n\n\n错误码系统设计实践前面介绍了太多的理论知识，我们来看一个具体的例子。假设如下一个“智能邮件系统”，其结构如下所示：\n\n上图中的服务“智能邮件坐席站点”和“配置站点”是客户端，”智能邮件操作综合接口“和”邮件配置服务“是对客户端提供服务的前置服务，这两个前置服务后面还依赖后面的数个服务。由于这里我们要说明的是技术问题，而不是业务问题，所以具体每个服务作何用途这里就不一一介绍了。在这个系统中，当客户端得到前置服务某个不正确应答时，会得到一个错误码，我们按以下规则来设计错误码：\n\n\n\n服务名称\n正值错误码范围\n负值错误码范围\n\n\n\n智能邮件综合操作接口\n100~199\n-100~-199\n\n\nES数据同步服务\n200~299\n-200~-299\n\n\n邮件配置服务\n300~399\n-300~-399\n\n\n邮件基础服务\n400~499\n-400~-499\n\n\n我们在设计这套系统时，做如下规定：\n\n所有的正值错误码表示所在服务的上游服务发来的请求不满足业务要求。举个例子，假设某次智能邮件坐席站点客户端得到了一个错误码101，我们可以先确定错误产生的服务器是智能邮件综合操作接口服务；其次，产生该错误的原因是智能邮件坐席站点客户端发送给智能邮件综合操作接口服务的请求不满足要求，通过这个错误码我们甚至可以进一步确定发送的请求哪里不符合要求。如我们可以这样定义：\n\n\n100 用户名不存在\n\n101 密码无效\n\n102 发送的邮件收件人非法\n\n103 邮件正文含有非法字符\n其他从略，此处就不一一列举了。\n\n\n\n所有的负值错误码表示程序内部错误。如：\n\n\n-100 数据库操作错误\n\n-101 网络错误\n\n-102 内存分配失败\n\n-103 ES数据同步服务连接不上\n其他从略，此处就不一一列举了。\n对负值错误码的特殊处理\n\n通过前面的介绍，读者应该能看出正值错误码与负值错误码的区别，即正值错误码一般是由请求服务的客户产生，如果出现这样的错误，应该由客户自己去解决问题；而负值错误码，则一般是服务内部产生的错误。因此，如果是正值错误码，错误码和错误信息一般可以直接返回给客户端；而对于负值错误，我们一般只将错误码返回给客户端，而不带上具体的错误信息，这也是读者在使用很多软件产品时，经常会得到“网络错误”这类万能错误提示。也就是说对于负值错误码的错误信息，我们可以统一显示成“网络错误”或者其他比较友好的错误提示。\n这样做的原因有二：\n\n客户端即使拿到这样的错误信息，也不能对排查和解决问题提供任何帮助，因为这些错误是程序内部错误或者bug。\n这类错误有可能是企业内部的设计缺陷，直接暴露给客户，除了让客户对企业的技术实力产生质疑以外，没有任何其他正面效应。\n\n而之所以带上错误码，是为了方便内部排查和定位问题。当然，现在的企业服务，内部也有大量监控系统，可能也不会再暴露这样的错误码了。\n扩展上文介绍了利用错误码的分段来定位问题的技术思想，其实不仅仅是错误码可以分段，我们在开发一组服务时，业务类型也可以通过编号来分段，这样通过业务号就能知道归属哪个服务了。\n如果读者以前没接触过这种设计思想，希望可以好好的思考和体会一下。\n","slug":"转载/高性能服务器框架设计/错误码系统的设计","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"10a9cf5937dc7bc9f3410b780f114a73","title":"【转载】高性能服务器架构设计总结","content":"高性能服务器架构设计总结系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n这篇文章算是对这个系列的一个系统性地总结。我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。\n所谓高性能就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；所谓高并发，指的是服务器可以同时支持多的客户端连接，且这些客户端在连接期间内会不断与服务器有数据来往。\n这篇文章将从两个方面来介绍，一个是服务器的框架，即单个服务器程序的代码组织结构；另外一个是一组服务程序的如何组织与交互，即架构。注意：本文以下内容中的客户端是相对概念，指的是连接到当前讨论的服务程序的终端，所以这里的客户端既可能是我们传统意义上的客户端程序，也可能是连接该服务的其他服务器程序。\n一、框架篇按上面介绍的思路，我们先从单个服务程序的组织结构开始介绍。\n（一）、网络通信既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？\n笔者认为至少要解决以下问题：\n\n如何检测有新客户端连接？\n如何接受客户端连接？\n如何检测客户端是否有数据发来？\n如何收取客户端发来的数据？\n如何检测连接异常？发现连接异常之后，如何处理？\n如何给客户端发送数据？\n如何在给客户端发完数据后关闭连接？\n\n稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API。确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是如何巧妙地组织这些基础的socket API，才是问题的关键。我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待”就是高效。也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情123456789，另外一部分闲在那里无所事事。说的可能有点抽象，下面我们来举一些例子具体来说明一下。\n比如默认recv函数如果没有数据的时候，线程就会阻塞在那里；默认send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；connect函数默认连接另外一端的时候，也会阻塞在那里；又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的IO Multiplexing技术（IO复用技术）。\n（二）、几种IO复用机制的比较目前windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP），linux系统支持select、poll、epoll。这里我们不具体介绍每个具体的函数的用法，我们来讨论一点深层次的东西，以上列举的API函数可以分为两个层次：\n\n层次一 select和poll\n层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll\n\n为什么这么分呢？先来介绍第一层次，select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。这也就是层次二的各个函数做的事情，它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，比如WSAAsyncSelect是利用windows消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已。\n比如connect函数连接另外一端，如果连接socket是异步的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。\n所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的第二个原则：尽量减少做无用功的时间。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，个人觉得这个可能带来无用。\n（三）、检测网络事件的正确姿势根据上面的介绍，第一，为了避免无意义的等待时间，第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。我们的socket都要设置成异步的。在此基础上我们回到栏目（一）中提到的七个问题：\n\n如何检测有新客户端连接？\n\n如何接受客户端连接？\n默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。\n\n如何检测客户端是否有数据发来？\n\n如何收取客户端发来的数据？\n同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待。\n至于一次性收多少数据好呢？\n我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了。示例：\n1234567891011121314151617181920212223242526 1bool CIUSocket::Recv()   2&#123;   3    int nRet = 0;   4 5    while(true)   6    &#123;   7        char buff[512];   8        nRet = ::recv(m_hSocket, buff, 512, 0); 9     //一旦出现错误就立刻关闭Socket    10    if(nRet == SOCKET_ERROR)11    &#123;  12        if (::WSAGetLastError() == WSAEWOULDBLOCK)  13           break;   14        else  15            return false;  16    &#125;  17    else if(nRet &lt; 1)  18        return false;  1920        m_strRecvBuf.append(buff, nRet);  2122        ::Sleep(1);  23    &#125;   2425    return true;  26&#125;  \n\n如何检测连接异常？发现连接异常之后，如何处理？\n同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。\n\n如何给客户端发送数据？\n给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。首先我们不能像检测数据可读一样检测数据可写，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。所以正确的做法是：如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。\n\n如何在给客户端发完数据后关闭连接？\n这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。关闭连接的话题，我们再单独开一个小的标题来专门讨论一下。\n\n\n（四）被动关闭连接和主动关闭连接在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接。\n而主动关闭连接，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。\n（五）发送缓冲区和接收缓冲区上面已经介绍了发送缓冲区了，并说明了其存在的意义。接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，\n\n理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。\n理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如读取磁盘文件，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。\n\n说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。\n需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个。这是我们最常见的设计方案。\n（六）协议的设计除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。我们知道tcp&#x2F;ip协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限。比如A端给B端连续发了三个数据包，每个数据包都是50个字节，B端可能先收到10个字节，再收到140个字节；或者先收到20个字节，再收到20个字节，再收到110个字节；也可能一次性收到150个字节。这150个字节可以以任何字节数目组合和次数被B收到。\n所以我们讨论协议的设计第一个问题就是如何界定包的界线，也就是接收端如何知道每个包数据的大小。目前常用有如下三种方法：\n\n固定大小，这种方法就是假定每一个包的大小都是固定字节数目，比如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包；\n指定包结束符，比如以一个\\r\\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容；\n指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。\n\n协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。\n协议要讨论的第三个问题是，根据协议组装的数据包应该尽量小，这样有如下好处：\n\n第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；\n第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。试想：假如一个股票服务器，如果一只股票的数据包是100个字节或者1000个字节，那100只股票和10000只股票区别呢？\n\n协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度，比如long型，如果在32位机器上是32位的4个字节，但是如果在64位机器上，就变成了64位8个字节了。这样同样是一个long型，发送方和接收方可能会用不同的长度去解码。所以建议最好在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，比如int32,int64等等。下面是一个协议的接口的例子：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 1class BinaryReadStream   2&#123;   3    private:   4        const char* const ptr;   5        const size_t      len;   6        const char*       cur;   7        BinaryReadStream(const BinaryReadStream&amp;);   8        BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);   910    public:  11        BinaryReadStream(const char* ptr, size_t len);  12        virtual const char* GetData() const;  13        virtual size_t GetSize() const;  14        bool IsEmpty() const;  15        bool ReadString(string* str,16                        size_t maxlen,17                        size_t&amp; outlen);  18        bool ReadCString(char* str,  19                         size_t strlen,20                         size_t&amp; len);  21        bool ReadCCString(const char** str,      22                          size_t maxlen,23                          size_t&amp; outlen);  24        bool ReadInt32(int32_t&amp; i);  25        bool ReadInt64(int64_t&amp; i);  26        bool ReadShort(short&amp; i);  27        bool ReadChar(char&amp; c);  28        size_t ReadAll(char* szBuffer, size_t iLen) const;  29        bool IsEnd() const;  30        const char* GetCurrent() const&#123; return cur; &#125;  3132    public:  33        bool ReadLength(size_t &amp; len);  34        bool ReadLengthWithoutOffset(size_t &amp;headlen,35                                     size_t &amp; outlen);  36    &#125;;  3738    class BinaryWriteStream  39    &#123;  40    public:  41        BinaryWriteStream(string* data);  42        virtual const char* GetData() const;  43        virtual size_t GetSize() const;  44        bool WriteCString(const char* str, size_t len);  45        bool WriteString(const string&amp; str);  46        bool WriteDouble(double value, bool isNULL = false);  47        bool WriteInt64(int64_t value, bool isNULL = false);  48        bool WriteInt32(int32_t i, bool isNULL = false);  49        bool WriteShort(short i, bool isNULL = false);  50        bool WriteChar(char c, bool isNULL = false);  51        size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;  52        void Flush();  53        void Clear();  54    private:  55        string* m_data;  56   &#125;;  \n\n其中BinaryWriteStream是编码协议的类，BinaryReadStream是解码协议的类。可以按下面这种方式来编码和解码。\n编码：\n1234561std::string outbuf;  2BinaryWriteStream writeStream(&amp;outbuf);  3writeStream.WriteInt32(msg_type_register);  4writeStream.WriteInt32(m_seq);  5writeStream.WriteString(retData);  6writeStream.Flush(); \n\n解码：\n1234567891011121314151617181920 1BinaryReadStream readStream(strMsg.c_str(), 2                            strMsg.length());   3int32_t cmd;   4if (!readStream.ReadInt32(cmd))   5&#123;   6    return false;   7&#125;   8 9//int seq;  10if (!readStream.ReadInt32(m_seq))  11&#123;  12    return false;  13&#125;  1415std::string data;  16size_t datalength;  17if (!readStream.ReadString(&amp;data, 0, datalength))  18&#123;  19    return false;  20&#125;  \n\n（七）、服务器程序结构的组织上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。根据我的个人经验，目前主流的思想是one thread one loop的策略。通俗点说就是在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑。我们先从最简单地来说，设定一些线程在一个循环里面做网络通信相关的事情，伪码如下：\n123456789101112 1while(退出标志)   2&#123;   3    //IO复用技术检测socket可读事件、出错事件   4    //（如果有数据要发送，则也检测可写事件）   5 6    //如果有可读事件，对于侦听socket则接收新连接；   7    //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；   8 9    //如果有数据要发送，有可写事件，则发送数据  1011    //如果有出错事件，关闭该连接   12&#125; \n\n&#96; 另外设定一些线程去处理接收到的数据，并解包处理业务逻辑，这些线程可以认为是业务线程了，伪码如下：\n11//从接收缓冲区中取出数据解包，分解成不同的业务来处理  \n\n上面的结构是目前最通用的服务器逻辑结构，但是能不能再简化一下或者说再综合一下呢？我们试试，你想过这样的问题没有：假如现在的机器有两个cpu，我们的网络线程数量是2个，业务逻辑线程也是2个，这样可能存在的情况就是：业务线程运行的时候，网络线程并没有运行，它们必须等待，如果是这样的话，干嘛要多建两个线程呢？除了程序结构上可能稍微清楚一点，对程序性能没有任何实质性提高，而且白白浪费cpu时间片在线程上下文切换上。所以，我们可以将网络线程与业务逻辑线程合并，合并后的伪码看起来是这样子的：\n123456789101112131415 1while(退出标志)   2&#123;   3    //IO复用技术检测socket可读事件、出错事件   4    //（如果有数据要发送，则也检测可写事件）   5 6    //如果有可读事件，对于侦听socket则接收新连接；   7    //对于普通socket则收取该socket上的数据， 8    //收取的数据存入对应的接收缓冲区，如果出错则关闭连接；   910    //如果有数据要发送，有可写事件，则发送数据  1112    //如果有出错事件，关闭该连接  1314    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  15&#125;  \n\n&#96;你没看错，其实就是简单的合并，合并之后和不仅可以达到原来合并前的效果，而且在没有网络IO事件的时候，可以及时处理我们想处理的一些业务逻辑，并且减少了不必要的线程上下文切换时间。\n我们再更进一步，甚至我们可以在这个while循环增加其它的一些任务的处理，比如程序的逻辑任务队列、定时器事件等等，伪码如下：\n123456789101112131415161718192021 1while(退出标志)   2&#123;   3    //定时器事件处理   4 5    //IO复用技术检测socket可读事件、出错事件   6    //（如果有数据要发送，则也检测可写事件）   7 8    //如果有可读事件，对于侦听socket则接收新连接；   9    //对于普通socket则收取该socket上的数据，10    //收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  1112    //如果有数据要发送，有可写事件，则发送数据  1314    //如果有出错事件，关闭该连接  1516    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  1718    //程序自定义任务1  1920    //程序自定义任务2  21&#125; \n\n注意：之所以将定时器事件的处理放在网络IO事件的检测之前，是因为避免定时器事件过期时间太长。假如放在后面的话，可能前面的处理耗费了一点时间，等到处理定时器事件时，时间间隔已经过去了不少时间。虽然这样处理，也没法保证定时器事件百分百精确，但是能尽量保证。\n（八）高性能服务器架构设计总结2——以flamigo服务器代码为例系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n说了这么多，我们来以flamingo的服务器程序的网络框架设计为例来验证上述介绍的理论。flamingo的网络框架是基于陈硕的muduo库，改成C++11的版本，并修改了一些bug。在此感谢原作者陈硕。flamingo的源码可以在这里下载：https://github.com/baloonwj/flamingo，打不开github的可以移步csdn：http://download.csdn.net/detail/analogous_love/9805797。\n上文介绍的核心线程函数的while循环位于eventloop.cpp中：\n12345678910111213141516171819202122232425262728293031323334353637383940 1void EventLoop::loop()   2&#123;   3    assert(!looping_);   4    assertInLoopThread();   5    looping_ = true;   6    quit_ = false; 7  // FIXME: what if someone calls quit() before loop() ?   8    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;   910    while (!quit_)  11    &#123;  12        activeChannels_.clear();  13        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs,14                                        &amp;activeChannels_);  15        ++iteration_;  16        if (Logger::logLevel() &lt;= Logger::TRACE)  17        &#123;  18            printActiveChannels();  19        &#125;  20        // TODO sort channel by priority  21        eventHandling_ = true;  22        for (ChannelList::iterator it = activeChannels_.begin();  23            it != activeChannels_.end(); ++it)  24        &#123;  25            currentActiveChannel_ = *it;  26            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);  27        &#125;  28        currentActiveChannel_ = NULL;  29        eventHandling_ = false;  30        doPendingFunctors();  3132        if (frameFunctor_)  33        &#123;  34            frameFunctor_();  35        &#125;         36    &#125;  3738    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;  39    looping_ = false;  40&#125; \n\npoller_-&gt;poll利用epoll分离网络事件，然后接着处理分离出来的网络事件，每一个客户端socket对应一个连接，即一个TcpConnection和Channel通道对象。**currentActiveChannel_-&gt;handleEvent(pollReturnTime_)**根据是可读、可写、出错事件来调用对应的处理函数，这些函数都是回调函数，程序初始化阶段设置进来的：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 1void Channel::handleEvent(Timestamp receiveTime)   2&#123;   3    std::shared_ptr&lt;void&gt; guard;   4    if (tied_)   5    &#123;   6        guard = tie_.lock();   7        if (guard)   8        &#123;   9            handleEventWithGuard(receiveTime);  10        &#125;  11    &#125;  12    else  13    &#123;  14        handleEventWithGuard(receiveTime);  15    &#125;  16&#125;  1718void Channel::handleEventWithGuard(Timestamp receiveTime)  19&#123;  20    eventHandling_ = true;  21    LOG_TRACE &lt;&lt; reventsToString();  22    if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))  23    &#123;  24        if (logHup_)  25        &#123;  26            LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLHUP&quot;;  27        &#125;  28        if (closeCallback_) closeCallback_();  29    &#125;  3031    if (revents_ &amp; POLLNVAL)  32    &#123;  33        LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLNVAL&quot;;  34    &#125;  3536    if (revents_ &amp; (POLLERR | POLLNVAL))  37    &#123;  38        if (errorCallback_) errorCallback_();  39    &#125;  40    if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))  41    &#123;  42        //当是侦听socket时，readCallback_指向Acceptor::handleRead  43        //当是客户端socket时，调用TcpConnection::handleRead   44        if (readCallback_) readCallback_(receiveTime);  45    &#125;  46    if (revents_ &amp; POLLOUT)  47    &#123;  48        //如果是连接状态服的socket，49        //则writeCallback_指向Connector::handleWrite()  50        if (writeCallback_) writeCallback_();  51    &#125;  52    eventHandling_ = false;  53&#125;  \n\n当然，这里利用了Channel对象的“多态性”\n\n如果是普通socket，可读事件就会调用预先设置的回调函数；\n但是如果是侦听socket，则调用Aceptor对象的handleRead()来接收新连接：\n\n123456789101112131415161718192021222324252627282930313233343536 1void Acceptor::handleRead()   2&#123;   3    loop_-&gt;assertInLoopThread();   4    InetAddress peerAddr;   5    //FIXME loop until no more   6    int connfd = acceptSocket_.accept(&amp;peerAddr);   7    if (connfd &gt;= 0)   8    &#123;   9        // string hostport = peerAddr.toIpPort();  10        // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;  11        //newConnectionCallback_实际指向:12        //TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)  13        if (newConnectionCallback_)  14        &#123;  15            newConnectionCallback_(connfd, peerAddr);  16        &#125;  17        else  18        &#123;  19            sockets::close(connfd);  20        &#125;  21    &#125;  22    else  23    &#123;  24        LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;  25        // Read the section named &quot;The special problem of  26        // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.  27        // By Marc Lehmann, author of livev.  28        if (errno == EMFILE)  29        &#123;  30            ::close(idleFd_);  31            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);  32            ::close(idleFd_);  33            idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);  34        &#125;  35    &#125;  36&#125;\n\n主循环里面的业务逻辑处理对应：\n123456789101112131415161718192021222324 1doPendingFunctors();   2 3if (frameFunctor_)   4&#123;   5   frameFunctor_();   6&#125;          7 8 9void EventLoop::doPendingFunctors()  10&#123;  11    std::vector&lt;Functor&gt; functors;  12    callingPendingFunctors_ = true;  1314    &#123;  15        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  16        functors.swap(pendingFunctors_);  17    &#125;  1819    for (size_t i = 0; i &lt; functors.size(); ++i)  20    &#123;  21        functors[i]();  22    &#125;  23    callingPendingFunctors_ = false;  24&#125;  \n\n这里增加业务逻辑是增加执行任务的函数指针的，增加的任务保存在成员变量pendingFunctors_中，这个变量是一个函数指针数组（vector对象），执行的时候，调用每个函数就可以了。上面的代码先利用一个栈变量将成员变量pendingFunctors_里面的函数指针换过来，接下来对这个栈变量进行操作就可以了，这样减少了锁的粒度。\n因为成员变量pendingFunctors_在增加任务的时候，也会被用到，设计到多个线程操作，所以要加锁，增加任务的地方是：\n123456789101112 1void EventLoop::queueInLoop(const Functor&amp; cb)   2&#123;   3    &#123;   4        std::unique_lock&lt;std::mutex&gt; lock(mutex_);   5        pendingFunctors_.push_back(cb);   6    &#125;   7 8    if (!isInLoopThread() || callingPendingFunctors_)   9    &#123;  10        wakeup();  11    &#125;  12&#125;\n\n而**frameFunctor_**就更简单了，就是通过设置一个函数指针就可以了。当然这里有个技巧性的东西，即增加任务的时候，为了能够立即执行，使用唤醒机制，通过往一个fd里面写入简单的几个字节，来唤醒epoll，使其立刻返回，因为此时没有其它的socke有事件，这样接下来就执行刚才添加的任务了。\n我们看一下数据收取的逻辑：\n12345678910111213141516171819202122232425 1void TcpConnection::handleRead(Timestamp receiveTime)   2&#123;   3    loop_-&gt;assertInLoopThread();   4    int savedErrno = 0;   5    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);   6    if (n &gt; 0)   7    &#123;   8        /*messageCallback_指向 9       CTcpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn,10                           Buffer* pBuffer, 11                           Timestamp receiveTime)*/  12        messageCallback_(shared_from_this(),13                         &amp;inputBuffer_, receiveTime);  14    &#125;  15    else if (n == 0)  16    &#123;  17        handleClose();  18    &#125;  19    else  20    &#123;  21        errno = savedErrno;  22        LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;  23        handleError();  24    &#125;  25&#125; \n\n将收到的数据放到接收缓冲区里面，将来我们来解包：\n1234567891011121314151617181920212223242526272829 1void ClientSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)   2&#123;   3    while (true)   4    &#123;   5        //不够一个包头大小   6        if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))   7        &#123;   8            LOG_INFO &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);   9            return;  10        &#125;  1112        //不够一个整包大小  13        msg header;  14        memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));  15        if (pBuffer-&gt;readableBytes() &lt; (size_t)header.packagesize + sizeof(msg))  16            return;  1718        pBuffer-&gt;retrieve(sizeof(msg));  19        std::string inbuf;  20        inbuf.append(pBuffer-&gt;peek(), header.packagesize);  21        pBuffer-&gt;retrieve(header.packagesize);  22        if (!Process(conn, inbuf.c_str(), inbuf.length()))  23        &#123;  24            LOG_WARN &lt;&lt; &quot;Process error, close TcpConnection&quot;;  25            conn-&gt;forceClose();  26        &#125;  27    &#125;// end while-loop  2829&#125;  \n\n先判断接收缓冲区里面的数据是否够一个包头大小，如果够再判断够不够包头指定的包体大小，如果还是够的话，接着在Process函数里面处理该包。\n再看看发送数据的逻辑：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 1void TcpConnection::sendInLoop(const void* data,  2                               size_t len)   3&#123;   4    loop_-&gt;assertInLoopThread();   5    ssize_t nwrote = 0;   6    size_t remaining = len;   7    bool faultError = false;   8    if (state_ == kDisconnected)   9    &#123;  10        LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;  11        return;  12    &#125;  13    // if no thing in output queue, try writing directly  14    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)  15    &#123;  16        nwrote = sockets::write(channel_-&gt;fd(), data, len);  17        if (nwrote &gt;= 0)  18        &#123;  19            remaining = len - nwrote;  20            if (remaining == 0 &amp;&amp; writeCompleteCallback_)  21            &#123;  22                loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, 23                                             shared_from_this()));  24            &#125;  25        &#125;  26        else // nwrote &lt; 0  27        &#123;  28            nwrote = 0;  29            if (errno != EWOULDBLOCK)  30            &#123;  31                LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;32                // FIXME: any others?   33                if (errno == EPIPE || errno == ECONNRESET)  34                &#123;  35                    faultError = true;  36                &#125;  37            &#125;  38        &#125;  39    &#125;  4041    assert(remaining &lt;= len);  42    if (!faultError &amp;&amp; remaining &gt; 0)  43    &#123;  44        size_t oldLen = outputBuffer_.readableBytes();  45        if (oldLen + remaining &gt;= highWaterMark_                          46            &amp;&amp; oldLen &lt; highWaterMark_  47            &amp;&amp; highWaterMarkCallback_)  48        &#123;  49            loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_,50                                         shared_from_this(),51                                         oldLen + remaining));  52        &#125;  53        outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote,54                             remaining);  55        if (!channel_-&gt;isWriting())  56        &#123;  57            channel_-&gt;enableWriting();  58        &#125;  59    &#125;  60&#125; \n\n如果剩余的数据remaining大于则调用**channel_-&gt;enableWriting();**开始监听可写事件，可写事件处理如下：\n12345678910111213141516171819202122232425262728293031323334353637383940 1void TcpConnection::handleWrite()   2&#123;   3    loop_-&gt;assertInLoopThread();   4    if (channel_-&gt;isWriting())   5    &#123;   6        ssize_t n = sockets::write(channel_-&gt;fd(),   7            outputBuffer_.peek(),   8            outputBuffer_.readableBytes());   9        if (n &gt; 0)  10        &#123;  11            outputBuffer_.retrieve(n);  12            if (outputBuffer_.readableBytes() == 0)  13            &#123;  14                channel_-&gt;disableWriting();  15                if (writeCompleteCallback_)  16                &#123;  17                    loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, 18                                       shared_from_this()));  19                &#125;   20                if (state_ == kDisconnecting)  21                &#123;  22                    shutdownInLoop();  23                &#125;  24            &#125;  25        &#125;  26        else  27        &#123;  28            LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;  29            // if (state_ == kDisconnecting)  30            // &#123;  31            //   shutdownInLoop();  32            // &#125;  33        &#125;  34    &#125;  35    else  36    &#123;  37        LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()  38            &lt;&lt; &quot; is down, no more writing&quot;;  39    &#125;  40&#125;\n\n如果发送完数据以后调用channel_-&gt;disableWriting();移除监听可写事件。\n很多读者可能一直想问，文中不是说解包数据并处理逻辑是业务代码而非网络通信的代码，你这里貌似都混在一起了，其实没有，这里实际的业务代码处理都是框架曾提供的回调函数里面处理的，具体怎么处理，由框架使用者——业务层自己定义。\n总结起来，实际上就是一个线程函数里一个loop那么点事情，不信你再看我曾经工作上的一个交易系统项目代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 1void CEventDispatcher::Run()   2&#123;   3    m_bShouldRun = true;   4    while(m_bShouldRun)   5    &#123;   6        DispatchIOs();         7        SyncTime();   8        CheckTimer();   9        DispatchEvents();  10    &#125;  11&#125;  121314void CEpollReactor::DispatchIOs()  15&#123;  16    DWORD dwSelectTimeOut = SR_DEFAULT_EPOLL_TIMEOUT;  17    if (HandleOtherTask())  18    &#123;  19        dwSelectTimeOut = 0;  20    &#125;  2122    struct epoll_event ev;  23    CEventHandlerIdMap::iterator itor = m_mapEventHandlerId.begin();  24    for(; itor!=m_mapEventHandlerId.end(); itor++)  25    &#123;  26        CEventHandler *pEventHandler = (CEventHandler *)(*itor).first;  27        if(pEventHandler == NULL)&#123;  28            continue;  29        &#125;  30        ev.data.ptr = pEventHandler;  31        ev.events = 0;  32        int nReadID, nWriteID;  33        pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);    34        if (nReadID &gt; 0)  35        &#123;  36            ev.events |= EPOLLIN;  37        &#125;  38        if (nWriteID &gt; 0)  39        &#123;  40            ev.events |= EPOLLOUT;  41        &#125;  4243        epoll_ctl(m_fdEpoll, EPOLL_CTL_MOD, (*itor).second, &amp;ev);  44    &#125;  4546    struct epoll_event events[EPOLL_MAX_EVENTS];  4748    int nfds = epoll_wait(m_fdEpoll, events, 49                          EPOLL_MAX_EVENTS, 50                          dwSelectTimeOut/1000);  5152    for (int i=0; i&lt;nfds; i++)  53    &#123;  54        struct epoll_event &amp;evref = events[i];  55        CEventHandler *pEventHandler = (CEventHandler *)evref.data.ptr;  56        if ((evref.events|EPOLLIN)!=0 &amp;&amp; 57             m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  58        &#123;  59            pEventHandler-&gt;HandleInput();  60        &#125;  61        if ((evref.events|EPOLLOUT)!=0 &amp;&amp;62             m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  63        &#123;  64            pEventHandler-&gt;HandleOutput();  65        &#125;  66    &#125;     67&#125;  686970void CEventDispatcher::DispatchEvents()  71&#123;  72    CEvent event;  73    CSyncEvent *pSyncEvent;  74    while(m_queueEvent.PeekEvent(event))  75    &#123;  76        int nRetval;  7778        if(event.pEventHandler != NULL)  79        &#123;  80            nRetval = event.pEventHandler-&gt;HandleEvent(event.nEventID,81                                                       event.dwParam,82                                                       event.pParam);  83        &#125;  84        else  85        &#123;  86            nRetval = HandleEvent(event.nEventID,87                                  event.dwParam, 88                                  event.pParam);  89        &#125;  9091        if(event.pAdd != NULL)      //同步消息  92        &#123;  93            pSyncEvent=(CSyncEvent *)event.pAdd;  94            pSyncEvent-&gt;nRetval = nRetval;  95            pSyncEvent-&gt;sem.UnLock();  96        &#125;  97    &#125;  98&#125;  \n\n再看看蘑菇街开源的TeamTalk的源码（代码下载地址：https://github.com/baloonwj/TeamTalk）：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 1void CEventDispatch::StartDispatch(uint32_t wait_timeout)   2&#123;   3    fd_set read_set, write_set, excep_set;   4    timeval timeout;   5    timeout.tv_sec = 0; 6    // 10 millisecond     7    timeout.tv_usec = wait_timeout * 1000; 8 9    if(running)  10        return;  11    running = true;  1213    while (running)  14   &#123;  15        _CheckTimer();  16        _CheckLoop();  1718        if (!m_read_set.fd_count &amp;&amp; 19            !m_write_set.fd_count &amp;&amp;20            !m_excep_set.fd_count)  21        &#123;  22            Sleep(MIN_TIMER_DURATION);  23            continue;  24        &#125;  2526        m_lock.lock();  27        memcpy(&amp;read_set, &amp;m_read_set, 28               sizeof(fd_set));  29        memcpy(&amp;write_set, &amp;m_write_set, 30               sizeof(fd_set));  31        memcpy(&amp;excep_set, &amp;m_excep_set, 32               sizeof(fd_set));  33        m_lock.unlock();  3435        int nfds = select(0, &amp;read_set, 36                          &amp;write_set,37                          &amp;excep_set,38                          &amp;timeout);  3940        if (nfds == SOCKET_ERROR)  41        &#123;  42            log(&quot;select failed, error code: %d&quot;, GetLastError());  43            Sleep(MIN_TIMER_DURATION);  44            continue;           // select again  45        &#125;  4647        if (nfds == 0)  48        &#123;  49            continue;  50        &#125;  5152        for (u_int i = 0; i &lt; read_set.fd_count; i++)  53        &#123;  54            //log(&quot;select return read count=%d\\n&quot;, read_set.fd_count);  55            SOCKET fd = read_set.fd_array[i];  56            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  57            if (pSocket)  58            &#123;  59                pSocket-&gt;OnRead();  60                pSocket-&gt;ReleaseRef();  61            &#125;  62        &#125;  6364        for (u_int i = 0; i &lt; write_set.fd_count; i++)  65        &#123;  66            //log(&quot;select return write count=%d\\n&quot;, write_set.fd_count);  67            SOCKET fd = write_set.fd_array[i];  68            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  69            if (pSocket)  70            &#123;  71                pSocket-&gt;OnWrite();  72                pSocket-&gt;ReleaseRef();  73            &#125;  74        &#125;  7576        for (u_int i = 0; i &lt; excep_set.fd_count; i++)  77        &#123;  78            //log(&quot;select return exception count=%d\\n&quot;, excep_set.fd_count);  79            SOCKET fd = excep_set.fd_array[i];  80            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  81            if (pSocket)  82            &#123;  83                pSocket-&gt;OnClose();  84                pSocket-&gt;ReleaseRef();  85            &#125;  86        &#125;  8788    &#125;  89&#125;\n\n****由于公众号文章字数有限，您可以接着阅读下******一篇:**《服务器端编程心得（八）——高性能服务器架构设计总结3——以flamigo服务器代码为例》。\n系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n（八）高性能服务器架构设计总结3——以flamigo服务器代码为例系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n再看filezilla，一款ftp工具的服务器端，它采用的是Windows的WSAAsyncSelect模型（代码下载地址：https://github.com/baloonwj/filezilla）：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469  1//Processes event notifications sent by the sockets or the layers    2    static LRESULT CALLBACK WindowProc(HWND hWnd,  3                                       UINT message,  4                                       WPARAM wParam,  5                                       LPARAM lParam)    6    &#123;    7        if (message&gt;=WM_SOCKETEX_NOTIFY)    8        &#123;    9            //Verify parameters   10            ASSERT(hWnd);   11            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *) 12                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);   13            ASSERT(pWnd);   14            if (!pWnd)   15                return 0;   16            //Index is within socket storage   17            if (message &lt; static_cast&lt;UINT&gt;(WM_SOCKETEX_NOTIFY+pWnd-&gt;m_nWindowDataSize))  18            &#123;   19                //Lookup socket and verify if it&#x27;s valid   20                CAsyncSocketEx *pSocket=pWnd-&gt;m_pAsyncSocketExWindowData[message - WM_SOCKETEX_NOTIFY].m_pSocket;   21                SOCKET hSocket = wParam;   22                if (!pSocket)   23                    return 0;   24                if (hSocket == INVALID_SOCKET)   25                    return 0;   26                if (pSocket-&gt;m_SocketData.hSocket != hSocket)   27                    return 0;   28 29                int nEvent = lParam &amp; 0xFFFF;   30                int nErrorCode = lParam &gt;&gt; 16;   31 32                //Dispatch notification   33                if (!pSocket-&gt;m_pFirstLayer) &#123;   34                    //Dispatch to CAsyncSocketEx instance   35                    switch (nEvent)   36                    &#123;   37                    case FD_READ:   38#ifndef NOSOCKETSTATES   39                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)   40                        &#123;   41                            pSocket-&gt;m_nPendingEvents |= FD_READ;   42                            break;   43                        &#125;   44                        else if (pSocket-&gt;GetState() == attached)   45                            pSocket-&gt;SetState(connected);   46                        if (pSocket-&gt;GetState() != connected)   47                            break;   48 49                        // Ignore further FD_READ events after FD_CLOSE has been received   50                        if (pSocket-&gt;m_SocketData.onCloseCalled)   51                            break;   52#endif //NOSOCKETSTATES   53 54#ifndef NOSOCKETSTATES   55                        if (nErrorCode)   56                            pSocket-&gt;SetState(aborted);   57#endif //NOSOCKETSTATES   58                        if (pSocket-&gt;m_lEvent &amp; FD_READ) &#123;   59                            pSocket-&gt;OnReceive(nErrorCode);   60                        &#125;   61                        break;   62                    case FD_FORCEREAD: //Forceread does not check if there&#x27;s data waiting   63#ifndef NOSOCKETSTATES   64                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)   65                        &#123;   66                            pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;   67                            break;   68                        &#125;   69                        else if (pSocket-&gt;GetState() == attached)   70                            pSocket-&gt;SetState(connected);   71                        if (pSocket-&gt;GetState() != connected)   72                            break;   73#endif //NOSOCKETSTATES   74                        if (pSocket-&gt;m_lEvent &amp; FD_READ)   75                        &#123;   76#ifndef NOSOCKETSTATES   77                            if (nErrorCode)   78                                pSocket-&gt;SetState(aborted);   79#endif //NOSOCKETSTATES   80                            pSocket-&gt;OnReceive(nErrorCode);   81                        &#125;   82                        break;   83                    case FD_WRITE:   84#ifndef NOSOCKETSTATES   85                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)   86                        &#123;   87                            pSocket-&gt;m_nPendingEvents |= FD_WRITE;   88                            break;   89                        &#125;   90                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)   91                            pSocket-&gt;SetState(connected);   92                        if (pSocket-&gt;GetState() != connected)   93                            break;   94#endif //NOSOCKETSTATES   95                        if (pSocket-&gt;m_lEvent &amp; FD_WRITE)   96                        &#123;   97#ifndef NOSOCKETSTATES   98                            if (nErrorCode)   99                                pSocket-&gt;SetState(aborted);  100#endif //NOSOCKETSTATES  101                            pSocket-&gt;OnSend(nErrorCode);  102                        &#125;  103                        break;  104                    case FD_CONNECT:  105#ifndef NOSOCKETSTATES  106                        if (pSocket-&gt;GetState() == connecting)  107                        &#123;  108                            if (nErrorCode &amp;&amp; pSocket-&gt;m_SocketData.nextAddr)  109                            &#123;  110                                if (pSocket-&gt;TryNextProtocol())  111                                    break;  112                            &#125;  113                            pSocket-&gt;SetState(connected);  114                        &#125;  115                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  116                            pSocket-&gt;SetState(connected);  117#endif //NOSOCKETSTATES  118                        if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)  119                            pSocket-&gt;OnConnect(nErrorCode);  120#ifndef NOSOCKETSTATES  121                        if (!nErrorCode)  122                        &#123;  123                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp;124                                 pSocket-&gt;GetState() == connected)  125                                pSocket-&gt;OnReceive(0);  126                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp;127                                 pSocket-&gt;GetState() == connected)  128                                pSocket-&gt;OnReceive(0);  129                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp;130                                 pSocket-&gt;GetState() == connected)  131                                pSocket-&gt;OnSend(0);  132                        &#125;  133                        pSocket-&gt;m_nPendingEvents = 0;  134#endif  135                        break;  136                    case FD_ACCEPT:  137#ifndef NOSOCKETSTATES  138                        if (pSocket-&gt;GetState() != listening &amp;&amp;139                            pSocket-&gt;GetState() != attached)  140                            break;  141#endif //NOSOCKETSTATES  142                        if (pSocket-&gt;m_lEvent &amp; FD_ACCEPT)  143                            pSocket-&gt;OnAccept(nErrorCode);  144                        break;  145                    case FD_CLOSE:  146#ifndef NOSOCKETSTATES  147                        if (pSocket-&gt;GetState() != connected &amp;&amp;148                            pSocket-&gt;GetState() != attached)  149                            break;  150151                        // If there are still bytes left to read,152                        // call OnReceive instead of  153                        // OnClose and trigger a new OnClose  154                        DWORD nBytes = 0;  155                        if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  156                        &#123;  157                            if (nBytes &gt; 0)  158                            &#123;  159                                // Just repeat message.  160                                pSocket-&gt;ResendCloseNotify();  161                                pSocket-&gt;m_SocketData.onCloseCalled = true;  162                                pSocket-&gt;OnReceive(WSAESHUTDOWN);  163                                break;  164                            &#125;  165                        &#125;  166167                        pSocket-&gt;SetState(nErrorCode ? aborted : closed);  168#endif //NOSOCKETSTATES  169                        pSocket-&gt;OnClose(nErrorCode);  170                        break;  171                    &#125;  172                &#125;  173                else //Dispatch notification to the lowest layer  174                &#123;  175                    if (nEvent == FD_READ)  176                    &#123;  177                        // Ignore further FD_READ events after FD_CLOSE has been received  178                        if (pSocket-&gt;m_SocketData.onCloseCalled)  179                            return 0;  180181                        DWORD nBytes;  182                        if (!pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  183                            nErrorCode = WSAGetLastError();  184                        if (pSocket-&gt;m_pLastLayer)  185                            pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  186                    &#125;  187                    else if (nEvent == FD_CLOSE)  188                    &#123;  189                        // If there are still bytes left to read,190                        // call OnReceive instead of  191                        // OnClose and trigger a new OnClose  192                        DWORD nBytes = 0;  193                        if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  194                        &#123;  195                            if (nBytes &gt; 0)  196                            &#123;  197                                // Just repeat message.  198                                pSocket-&gt;ResendCloseNotify();  199                                if (pSocket-&gt;m_pLastLayer)  200                                    pSocket-&gt;m_pLastLayer-&gt;CallEvent(FD_READ, 0);  201                                return 0;  202                            &#125;  203                        &#125;  204                        pSocket-&gt;m_SocketData.onCloseCalled = true;  205                        if (pSocket-&gt;m_pLastLayer)  206                            pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  207                    &#125;  208                    else if (pSocket-&gt;m_pLastLayer)  209                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  210                &#125;  211            &#125;  212            return 0;  213        &#125;  214        else if (message == WM_USER) //Notification event sent by a layer  215        &#123;  216            //Verify parameters, lookup socket and notification message  217            //Verify parameters  218            ASSERT(hWnd);  219            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)220                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  221            ASSERT(pWnd);  222            if (!pWnd)  223                return 0;  224             //Index is within socket storage  225            if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize))226            &#123;  227                return 0;  228            &#125;  229230            CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;  231            CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = (CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;  232            if (!pMsg || !pSocket || pSocket-&gt;m_SocketData.hSocket != pMsg-&gt;hSocket)  233            &#123;  234                delete pMsg;  235                return 0;  236            &#125;  237            int nEvent=pMsg-&gt;lEvent&amp;0xFFFF;  238            int nErrorCode=pMsg-&gt;lEvent&gt;&gt;16;  239240            //Dispatch to layer  241            if (pMsg-&gt;pLayer)  242                pMsg-&gt;pLayer-&gt;CallEvent(nEvent, nErrorCode);  243            else  244            &#123;  245                //Dispatch to CAsyncSocketEx instance  246                switch (nEvent)  247                &#123;  248                case FD_READ:  249#ifndef NOSOCKETSTATES  250                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  251                    &#123;  252                        pSocket-&gt;m_nPendingEvents |= FD_READ;  253                        break;  254                    &#125;  255                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  256                        pSocket-&gt;SetState(connected);  257                    if (pSocket-&gt;GetState() != connected)  258                        break;  259#endif //NOSOCKETSTATES  260                    if (pSocket-&gt;m_lEvent &amp; FD_READ)  261                    &#123;  262#ifndef NOSOCKETSTATES  263                        if (nErrorCode)  264                            pSocket-&gt;SetState(aborted);  265#endif //NOSOCKETSTATES  266                        pSocket-&gt;OnReceive(nErrorCode);  267                    &#125;  268                    break; 269                //Forceread does not check if there&#x27;s data waiting  270                case FD_FORCEREAD:  271#ifndef NOSOCKETSTATES  272                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  273                    &#123;  274                        pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;  275                        break;  276                    &#125;  277                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  278                        pSocket-&gt;SetState(connected);  279                    if (pSocket-&gt;GetState() != connected)  280                        break;  281#endif //NOSOCKETSTATES  282                    if (pSocket-&gt;m_lEvent &amp; FD_READ)  283                    &#123;  284#ifndef NOSOCKETSTATES  285                        if (nErrorCode)  286                            pSocket-&gt;SetState(aborted);  287#endif //NOSOCKETSTATES  288                        pSocket-&gt;OnReceive(nErrorCode);  289                    &#125;  290                    break;  291                case FD_WRITE:  292#ifndef NOSOCKETSTATES  293                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  294                    &#123;  295                        pSocket-&gt;m_nPendingEvents |= FD_WRITE;  296                        break;  297                    &#125;  298                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  299                        pSocket-&gt;SetState(connected);  300                    if (pSocket-&gt;GetState() != connected)  301                        break;  302#endif //NOSOCKETSTATES  303                    if (pSocket-&gt;m_lEvent &amp; FD_WRITE)  304                    &#123;  305#ifndef NOSOCKETSTATES  306                        if (nErrorCode)  307                            pSocket-&gt;SetState(aborted);  308#endif //NOSOCKETSTATES  309                        pSocket-&gt;OnSend(nErrorCode);  310                    &#125;  311                    break;  312                case FD_CONNECT:  313#ifndef NOSOCKETSTATES  314                    if (pSocket-&gt;GetState() == connecting)  315                        pSocket-&gt;SetState(connected);  316                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  317                        pSocket-&gt;SetState(connected);  318#endif //NOSOCKETSTATES  319                    if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)  320                        pSocket-&gt;OnConnect(nErrorCode);  321#ifndef NOSOCKETSTATES  322                    if (!nErrorCode)  323                    &#123;  324                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp;325                              pSocket-&gt;GetState() == connected) &amp;&amp;326                              (pSocket-&gt;m_lEvent &amp; FD_READ))  327                            pSocket-&gt;OnReceive(0);  328                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp;329                              pSocket-&gt;GetState() == connected) &amp;&amp;330                              (pSocket-&gt;m_lEvent &amp; FD_READ))  331                             pSocket-&gt;OnReceive(0);  332                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp;333                              pSocket-&gt;GetState() == connected) &amp;&amp;334                              (pSocket-&gt;m_lEvent &amp; FD_WRITE))  335                            pSocket-&gt;OnSend(0);  336                    &#125;  337                    pSocket-&gt;m_nPendingEvents = 0;  338#endif //NOSOCKETSTATES  339                    break;  340                case FD_ACCEPT:  341#ifndef NOSOCKETSTATES  342                    if ((pSocket-&gt;GetState() == listening || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_ACCEPT))  343#endif //NOSOCKETSTATES  344                    &#123;  345                        pSocket-&gt;OnAccept(nErrorCode);  346                    &#125;  347                    break;  348                case FD_CLOSE:  349#ifndef NOSOCKETSTATES  350                    if ((pSocket-&gt;GetState() == connected ||351                         pSocket-&gt;GetState() == attached) &amp;&amp;352                         (pSocket-&gt;m_lEvent &amp; FD_CLOSE))  353                    &#123;  354                        pSocket-&gt;SetState(nErrorCode?aborted:closed);  355#else  356                    &#123;  357#endif //NOSOCKETSTATES  358                        pSocket-&gt;OnClose(nErrorCode);  359                    &#125;  360                    break;  361                &#125;  362            &#125;  363            delete pMsg;  364            return 0;  365        &#125;  366        else if (message == WM_USER+1)  367        &#123;  368            // WSAAsyncGetHostByName reply  369370            // Verify parameters  371            ASSERT(hWnd);  372            CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)373                                                GetWindowLongPtr(hWnd, GWLP_USERDATA);  374            ASSERT(pWnd);  375            if (!pWnd)  376                return 0;  377378            CAsyncSocketEx *pSocket = NULL;  379            for (int i = 0; i &lt; pWnd-&gt;m_nWindowDataSize; ++i) &#123;  380                pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[i].m_pSocket;  381                if (pSocket &amp;&amp; pSocket-&gt;m_hAsyncGetHostByNameHandle &amp;&amp;  382                    pSocket-&gt;m_hAsyncGetHostByNameHandle == (HANDLE)wParam &amp;&amp;  383                    pSocket-&gt;m_pAsyncGetHostByNameBuffer)  384                    break;  385            &#125;  386            if (!pSocket || !pSocket-&gt;m_pAsyncGetHostByNameBuffer)  387                return 0;  388389            int nErrorCode = lParam &gt;&gt; 16;  390            if (nErrorCode) &#123;  391                pSocket-&gt;OnConnect(nErrorCode);  392                return 0;  393            &#125;  394395            SOCKADDR_IN sockAddr&#123;&#125;;  396            sockAddr.sin_family = AF_INET;  397            sockAddr.sin_addr.s_addr = ((LPIN_ADDR)((LPHOSTENT)pSocket-&gt;m_pAsyncGetHostByNameBuffer)-&gt;h_addr)-&gt;s_addr;  398399            sockAddr.sin_port = htons(pSocket-&gt;m_nAsyncGetHostByNamePort);  400401            BOOL res = pSocket-&gt;Connect((SOCKADDR*)&amp;sockAddr, sizeof(sockAddr));  402            delete [] pSocket-&gt;m_pAsyncGetHostByNameBuffer;  403            pSocket-&gt;m_pAsyncGetHostByNameBuffer = 0;  404            pSocket-&gt;m_hAsyncGetHostByNameHandle = 0;  405406            if (!res)  407                if (GetLastError() != WSAEWOULDBLOCK)  408                    pSocket-&gt;OnConnect(GetLastError());  409            return 0;  410        &#125;  411        else if (message == WM_USER + 2)  412        &#123;  413            //Verify parameters, lookup socket and notification message  414            //Verify parameters  415            if (!hWnd)  416                return 0;  417418            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)419                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  420            if (!pWnd)  421                return 0;  422423            if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage  424                return 0;  425426            CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;  427            if (!pSocket)  428                return 0;  429430            // Process pending callbacks  431            std::list&lt;t_callbackMsg&gt; tmp;  432            tmp.swap(pSocket-&gt;m_pendingCallbacks);  433            pSocket-&gt;OnLayerCallback(tmp);  434435            for (auto &amp; cb : tmp) &#123;  436                delete [] cb.str;  437            &#125;  438        &#125;  439        else if (message == WM_TIMER)  440        &#123;  441            if (wParam != 1)  442                return 0;  443444            ASSERT(hWnd);  445            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)446                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  447            ASSERT(pWnd &amp;&amp; pWnd-&gt;m_pThreadData);  448            if (!pWnd || !pWnd-&gt;m_pThreadData)  449                return 0;  450451            if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())  452            &#123;  453                KillTimer(hWnd, 1);  454                return 0;  455            &#125;  456            CAsyncSocketEx* socket = pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.front();  457            pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.pop_front();  458            if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())  459                KillTimer(hWnd, 1);  460461            if (socket)  462                PostMessage(hWnd,463                            socket-&gt;m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, 464                            socket-&gt;m_SocketData.hSocket,465                            FD_CLOSE);  466            return 0;  467        &#125;  468        return DefWindowProc(hWnd, message, wParam, lParam);  469    &#125; \n\n关于单个服务程序的框架，我已经介绍完了，如果你能完全理解我要表达的意思，我相信你也能构建出一套高性能服务程序来。\n（八）高性能服务器架构设计总结4——以flamigo服务器代码为例系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n二、架构篇一个项目的服务器端往往由很多服务组成，就算单个服务在性能上做到极致，支持的并发数量也是有限的。举个简单的例子，假如一个聊天服务器，每个用户的信息是1k，那对于一个8G的内存的机器，在不考虑其它的情况下810241024*1024 &#x2F; 100 &#x3D; 1024，实际有838万，但实际这只是非常理想的情况。所以我们有时候需要需要某个服务部署多套，就单个服务的实现来讲还是《框架篇》中介绍的。\n1\n我们举个例子：\n这是蘑菇街TeamTalk的服务器架构。\nMsgServer是聊天服务，可以部署多套，每个聊天服务器启动时都会告诉loginSever和routeSever自己的ip地址和端口号，当有用户上线或者下线的时候，MsgServer也会告诉loginSever和routeSever自己上面最新的用户数量和用户id列表。\n现在一个用户需要登录，先连接loginServer，loginServer根据记录的各个MsgServer上的用户情况，返回一个最小负载的MsgServer的ip地址和端口号给客户端，客户端再利用这个ip地址和端口号去登录MsgServer。当聊天时，位于A MsgServer上的用户给另外一个用户发送消息，如果该用户不在同一个MsgServer上，MsgServer将消息转发给RouteServer，RouteServer根据自己记录的用户id信息找到目标用户所在的MsgServer并转发给对应的MsgServer。\n2\n上面是分布式部署的一个例子，我们再来看另外一个例子。这个例子是单个服务的策略，实际服务器在处理网络数据的时候，如果同时有多个socket上有数据要处理，可能会出现一直服务前几个socket，直到前几个socket处理完毕后再处理后面几个socket的数据。这就相当于，你去饭店吃饭，大家都点了菜，但是有些桌子上一直在上菜，而有些桌子上一直没有菜。这样肯定不好，我们来看下如何避免这种现象：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 1int CFtdEngine::HandlePackage(CFTDCPackage *pFTDCPackage, 2                              CFTDCSession *pSession)   3&#123;   4    //NET_IO_LOG0(&quot;CFtdEngine::HandlePackage\\n&quot;);   5    FTDC_PACKAGE_DEBUG(pFTDCPackage);   6 7    if (pFTDCPackage-&gt;GetTID() != FTD_TID_ReqUserLogin)   8    &#123;   9        if (!IsSessionLogin(pSession-&gt;GetSessionID()))  10        &#123;  11            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;客户未登录&quot;);  12            return 0;  13        &#125;  14    &#125;  1516    CalcFlux(pSession, pFTDCPackage-&gt;Length());  //统计流量  1718    REPORT_EVENT(LOG_DEBUG, &quot;Front/Fgateway&quot;, &quot;登录请求%0x&quot;,19                  pFTDCPackage-&gt;GetTID());   2021    int nRet = 0;  22    switch(pFTDCPackage-&gt;GetTID())   23    &#123;  2425    case FTD_TID_ReqUserLogin:  26        ///huwp：20070608：检查过高版本的API将被禁止登录  27        if (pFTDCPackage-&gt;GetVersion()&gt;FTD_VERSION)  28        &#123;  29            SendErrorRsp(pFTDCPackage, pSession, 1,30                         &quot;Too High FTD Version&quot;);  31            return 0;  32        &#125;  33        nRet = OnReqUserLogin(pFTDCPackage,34                             (CFTDCSession *)pSession);  35        FTDRequestIndex.incValue();  36        break;  37    case FTD_TID_ReqCheckUserLogin:  38        nRet = OnReqCheckUserLogin(pFTDCPackage, 39                                  (CFTDCSession *)pSession);  40        FTDRequestIndex.incValue();  41        break;  42    case FTD_TID_ReqSubscribeTopic:  43        nRet = OnReqSubscribeTopic(pFTDCPackage, 44                                  (CFTDCSession *)pSession);  45        FTDRequestIndex.incValue();  46        break;    47    &#125;  4849    return 0;  50&#125;\n\n当有某个socket上有数据可读时，接着接收该socket上的数据，对接收到的数据进行解包，然后调用CalcFlux(pSession, pFTDCPackage-&gt;Length())进行流量统计：\n1234567891011121314 1void CFrontEngine::CalcFlux(CSession *pSession, const int nFlux)   2&#123;   3    TFrontSessionInfo *pSessionInfo = m_mapSessionInfo.Find(pSession-&gt;GetSessionID());   4    if (pSessionInfo != NULL)   5    &#123;   6        //流量控制改为计数   7        pSessionInfo-&gt;nCommFlux ++;    8        ///若流量超过规定，则挂起该会话的读操作   9        if (pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux)  10        &#123;  11            pSession-&gt;SuspendRead(true);  12        &#125;  13    &#125;  14&#125; \n\n该函数会先让某个连接会话（Session）处理的包数量递增，接着判断是否超过最大包数量，则设置读挂起标志：\n12341void CSession::SuspendRead(bool bSuspend)  2&#123;  3    m_bSuspendRead = bSuspend;  4&#125;  \n\n这样下次将会从检测的socket列表中排除该socket：\n1234567891011121314151617181920212223242526272829 1void CEpollReactor::RegisterIO(CEventHandler *pEventHandler)   2&#123;   3    int nReadID, nWriteID;   4    pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);   5    if (nWriteID != 0 &amp;&amp; nReadID ==0)   6    &#123;   7        nReadID = nWriteID;   8    &#125;   9    if (nReadID != 0)  10    &#123;  11        m_mapEventHandlerId[pEventHandler] = nReadID;  12        struct epoll_event ev;  13        ev.data.ptr = pEventHandler;  14        if(epoll_ctl(m_fdEpoll, EPOLL_CTL_ADD, nReadID, &amp;ev) != 0)  15        &#123;  16            perror(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);  17        &#125;  18    &#125;  19&#125;  202122void CSession::GetIds(int *pReadId, int *pWriteId)  23&#123;  24    m_pChannelProtocol-&gt;GetIds(pReadId,pWriteId);  25    if (m_bSuspendRead)  26    &#123;  27        *pReadId = 0;  28    &#125;  29&#125;\n\n也就是说不再检测该socket上是否有数据可读。然后在定时器里1秒后重置该标志，这样这个socket上有数据的话又可以重新检测到了：\n123456789101112131415161718192021222324252627282930313233343536 1const int SESSION_CHECK_TIMER_ID    = 9;   2const int SESSION_CHECK_INTERVAL    = 1000;   3 4 5SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);   6 7 8void CFrontEngine::OnTimer(int nIDEvent)   9&#123;  10    if (nIDEvent == SESSION_CHECK_TIMER_ID)  11    &#123;  12        CSessionMap::iterator itor = m_mapSession.Begin();  13        while (!itor.IsEnd())  14        &#123;  15            TFrontSessionInfo *pFind = m_mapSessionInfo.Find((*itor)-&gt;GetSessionID());  16            if (pFind != NULL)  17            &#123;  18                CheckSession(*itor, pFind);  19            &#125;  20            itor++;  21        &#125;  22    &#125;  23&#125;  2425void CFrontEngine::CheckSession(CSession *pSession,26                                TFrontSessionInfo *pSessionInfo)  27&#123;  28    ///重新开始计算流量  29    pSessionInfo-&gt;nCommFlux -= pSessionInfo-&gt;nMaxCommFlux;  30    if (pSessionInfo-&gt;nCommFlux &lt; 0)  31    &#123;  32        pSessionInfo-&gt;nCommFlux = 0;  33    &#125;  34    ///若流量超过规定，则挂起该会话的读操作  35    pSession-&gt;SuspendRead(pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux);36&#125;\n\n这就相当与饭店里面先给某一桌客人上一些菜，让他们先吃着，等上了一些菜之后不会再给这桌继续上菜了，而是给其它空桌上菜，大家都吃上后，继续回来给原先的桌子继续上菜。实际上我们的饭店都是这么做的。上面的例子是单服务流量控制的实现的一个非常好的思路，它保证了每个客户端都能均衡地得到服务，而不是一些客户端等很久才有响应。\n3\n另外加快服务器处理速度的策略可能就是缓存了，缓存实际上是以空间换取时间的策略。对于一些反复使用的，但是不经常改变的信息，如果从原始地点加载这些信息就比较耗时的数据（比如从磁盘中、从数据库中），我们就可以使用缓存。\n所以时下像redis、leveldb、fastdb等各种内存数据库大行其道。我在flamingo中用户的基本信息都是缓存在聊天服务程序中的，而文件服务启动时会去加载指定目录里面的所有程序名称，这些文件的名称都是md5，为该文件内容的md5。这样当客户端上传了新文件请求时，如果其传上来的文件md5已经位于缓存中，则表明该文件在服务器上已经存在，这个时候服务器就不必再接收该文件了，而是告诉客户端文件已经上传成功了。\n说了这么多，一般来说，一个服务器的架构，往往更多取决于其具体的业务，我们要在结合当前的情况来实际去组织铺排，没有一套系统是万能的。多思考，多实践，多总结，相信很快你也能拥有很不错的架构能力。\n鉴于笔者能力和经验有限，文中难免有错漏之处，欢迎提意见。 交流QQ群：49114021\n本系列完\n系列目录\n第01篇 主线程与工作线程的分工\n第02篇 Reactor模式\n第03篇 一个服务器程序的架构介绍\n第04篇 如何将socket设置为非阻塞模式\n第05篇 如何编写高性能日志\n第06篇 关于网络编程的一些实用技巧和细节\n第07篇 开源一款即时通讯软件的源码\n第08篇 高性能服务器架构设计总结1\n第09篇 高性能服务器架构设计总结2\n第10篇 高性能服务器架构设计总结3\n第11篇 高性能服务器架构设计总结4\n欢迎关注公众号『easyserverdev』。如果有任何技术或者职业方面的问题需要我提供帮助，可通过这个公众号与我取得联系，此公众号不仅分享高性能服务器开发经验和故事，同时也免费为广大技术朋友提供技术答疑和职业解惑，您有任何问题都可以在微信公众号直接留言，我会尽快回复您。\n\n","slug":"转载/高性能服务器框架设计/高性能服务器架构设计总结","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"c++,高性能服务器框架设计","author_index":"阿木大叔"},{"id":"6f9f848d419f584cbff23ed4ace411b4","title":"【转载】Linuxtcpdump使用介绍","content":"Linux tcpdump 使用介绍tcpdump 是 Linux 系统提供一个非常强大的抓包工具，熟练使用它，对我们排查网络问题非常有用。如果你的机器上还没有安装，可以使用如下命令安装：\n1yum install tcpdump\n\n如果要使用 tcpdump 命令必须具有 sudo 权限。\ntcpdump 常用的选项有：\n\n-i 指定要捕获的目标网卡名，网卡名可以使用前面章节中介绍的 ifconfig 命令获得；如果要抓所有网卡的上的包，可以使用 any 关键字。\n1234## 抓取网卡ens33上的包tcpdump -i ens33## 抓取所有网卡上的包tcpdump -i any\n\n-X 以 ASCII 和十六进制的形式输出捕获的数据包内容，减去链路层的包头信息；**-XX** 以 ASCII 和十六进制的形式输出捕获的数据包内容，包括链路层的包头信息。\n\n-n 不要将 ip 地址显示成别名的形式；**-nn** 不要将 ip 地址和端口以别名的形式显示。\n\n-S 以绝对值显示包的 ISN 号（包序列号），默认以上一包的偏移量显示。\n\n-vv 抓包的信息详细地显示；**-vvv** 抓包的信息更详细地显示。\n\n-w 将抓取的包的原始信息（不解析，也不输出）写入文件中，后跟文件名：\n1tcpdump -i any -w filename  \n\n-r 从利用 -w 选项保存的包文件中读取数据包信息。\n\n\n除了可以使用选项以外，tcpdump 还支持各种数据包过滤的表达式，常见的形式如下：\n123456789101112131415## 仅显示经过端口 8888 上的数据包（包括tcp:8888和udp:8888）tcpdump -i any &#x27;port 8888&#x27;## 仅显示经过端口是 tcp:8888 上的数据包tcpdump -i any &#x27;tcp port 8888&#x27;## 仅显示从源端口是 tcp:8888 的数据包tcpdump -i any &#x27;tcp src port 8888&#x27;## 仅显示源端口是 tcp:8888 或目标端口是 udp:9999 的包 tcpdump -i any &#x27;tcp src port 8888 or udp dst port 9999&#x27;## 仅显示地址是127.0.0.1 且源端口是 tcp:9999 的包 ，以 ASCII 和十六进制显示详细输出，## 不显示 ip 地址和端口号的别名tcpdump -i any &#x27;src host 127.0.0.1 and tcp src port 9999&#x27; -XX -nn -vv\n\n下面我们通过三个具体的操作实例来演示一下使用 tcpdump 的抓包过程。\n实例一 ：连接一个正常的侦听端口\n假设我的服务器端的地址是 127.0.0.0.1:12345，使用 nc 命令在一个 shell 窗口创建一个服务器程序并在这个地址上进行侦听。\n1nc –v -l 127.0.0.0.112345\n\n效果如下图所示：\n\n在另外一个 shell 窗口开启 tcpdump 抓包：\n1tcpdump -i any &#x27;port 12345&#x27; -XX -nn -vv\n\n效果如下：\n\n然后再开一个 shell 窗口，利用 nc 命令创建一个客户端去连接服务器：\n1nc -v 127.0.0.1 12345\n\n效果如下：\n\n我们抓到的包如下：\n\n由于我们没有在客户端和服务器之间发送任何消息，其实抓到的包就是 TCP 连接的三次握手数据包，分析如下：\n三次握手过程是客户端先给服务器发送一个 SYN，然后服务器应答一个 SYN + ACK，应答的序列号是递增 1 的，表示应答哪个请求，即从 4004096087 递增到 4004096088，接着客户端再应答一个 ACK。这个时候，我们发现发包序列号和应答序列号都变成 1了，这是 tcpdump 使用相对序号，我们加上 -S 选项后就变成绝对序列号了。\n我们按 Ctrl + C 中断 tcpdump 抓包过程，并停止用 nc 开启的客户端和服务器程序，然后在前面的 tcpdump 命令后面加上 -S 选项重新开启抓包，使用命令如下：\n1tcpdump -i any &#x27;port 12345&#x27; -XX -nn -vv -S\n\n然后再按顺序用 nc 命令再次启动下服务器和客户端程序。再次得到抓包结果：\n\n这次得到的包的序号就是绝对序号了。\n实例二：连接一个不存在的侦听端口\n实例一演示的是正常的 TCP 连接三次握手过程捕获到的数据包。假如我们连接的服务器 ip 地址存在，但监听端口号不存在，我们看下 tcpdump 抓包结果。除了在一个 shell 窗口启动一个 tcpdump 抓包监测，在另外一个 shell 窗口用 nc 命令去连接一个不存在的侦听端口即可。\n\n抓包数据如下：\n\n这个时候客户端发送 SYN，服务器应答 ACK+RST，这个应答包会导致客户端的 connect 连接失败返回。\n实例三：连接一个很遥远的 ip，或者网络繁忙的情形\n实际情形中，还存在一种情况就是客户端访问一个很遥远的 ip，或者网络繁忙，服务器对客户端发送的 TCP 三次握手的网络 SYN 报文没有应答，会出现什么情况呢？\n我们通过设置防火墙规则来模拟一下这种情况。使用 iptables -F 先将防火墙的已有规则都清理掉，然后给防火墙的 INPUT 链上增加一个规则：丢弃本地网卡 lo（也就是 127.0.0.1 这个回环地址）上的所有 SYN 包。\n12iptables -Fiptables -I INPUT -p tcp --syn -i lo -j DROP\n\n\n\n如果读者对 CentOS 的防火墙 iptables 命令有兴趣，可以使用 man iptables 在 man 手册中查看更详细的帮助。\n\n在开启 tcpdump 抓包之后和设置防火墙规则之后，利用 nc 命令去连接 127.0.0.1:12345 这个地址。整个过程操作效果图如下：\n\n接着，我们得到 tcpdump 抓到的数据包如下：\n\n通过抓包数据我们可以看到：如果连接不上，一共重试了 5 次，重试的时间间隔是 1 秒，2秒，4秒，8秒，16秒，最后返回超时失败。这个重试次数在 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries 内核参数中设置，默认为 6 。\n\nTCP 四次挥手与三次握手基本上类似，这里就不贴出 tcpdump 抓包的详情了，强烈建议不熟悉这块的读者实际练习一遍。\n\n","slug":"转载/学习资料/Linuxtcpdump使用介绍","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"e29cafb5ee3b6ecc425a0d63d3989d66","title":"【转载】Linux网络故障排查的瑞士军刀","content":"Linux 网络故障排查的瑞士军刀nc 即 netcat 命令，这个工具在排查网络故障时非常有用，功能非常强大，因而被业绩称为网络界的“瑞士军刀”，请读者务必掌握。默认系统是没有这个命令的，你需要安装一下，安装方法：\n1yum install nc\n\nnc 命令常见的用法是模拟一个服务器程序被其他客户端连接，或者模拟一个客户端连接其他服务器，连接之后就可以进行数据收发。我们来逐一介绍一下：\n\n模拟一个服务器程序\n使用 -l 选项（单词 listen 的第一个字母）在某个 ip 地址和端口号上开启一个侦听服务，以便让其他客户端连接。通常为了显示更详细的信息，会带上 -v 选项。\n示例如下：\n123[root@iZ238vnojlyZ ~]# nc -v -l 127.0.0.1 6000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on 127.0.0.1:6000\n\n这样就在 6000 端口开启了一个侦听服务器，我们可以通过 127.0.0.1:6000 去连接上去；如果你的机器可以被外网访问，你可以使用 0.0.0.0 这样的侦听地址，示例：\n123[root@iZ238vnojlyZ ~]# nc -v -l 0.0.0.0 6000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on 0.0.0.0:6000\n\n模拟一个客户端程序\n用 nc 命令模拟一个客户端程序时，我们不需要使用 -l 选项，直接写上 ip 地址（或域名，nc 命令可以自动解析域名）和端口号即可，示例如下：\n1234## 连接百度 web 服务器[root@iZ238vnojlyZ ~]# nc -v www.baidu.com 80Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Connected to 115.239.211.112:80.\n\n输出提示我们成功连接上百度 Web 服务器。\n\n\n我们知道客户端连接服务器一般都是操作系统随机分配一个可用的端口号连接到服务器上去，使用 nc 命令作为客户端时可以使用 -p 选项指定使用哪个端口号连接服务器，例如，我们希望通过本地 5555 端口连接百度的 Web 服务器，可以这么输入：\n123[root@iZ238vnojlyZ ~]# nc -v -p 5555 www.baidu.com 80Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Connected to 115.239.211.112:80.\n\n再开一个 shell 窗口，我们使用上文中介绍的 lsof 命令验证一下，是否确实通过 5555 端口连接上了百度 Web 服务器。\n12[root@iZ238vnojlyZ ~]# lsof -Pni | grep ncnc        32610    root    3u  IPv4 113369437      0t0  TCP 120.55.94.78:5555-&gt;115.239.211.112:80 (ESTABLISHED)\n\n结果确实如我们所期望的。\n当然，当使用 nc 命令与对端建立连接后，我们可以发送消息。下面通过一个具体的例子来演示一下这个过程\n\n使用 nc -v -l 0.0.0.0 6000 模拟一个侦听服务，再新建一个 shell 窗口利用 nc -v 127.0.0.1 6000 模拟一个客户端程序连接刚才的服务器。\n此时在客户端和服务器就可以相互发消息了。我们可以达到一个简化版的 IM 软件聊天效果：\n\n客户端效果：\n\n服务器端效果：\n\n\n果你在使用 nc 命令发消息时不小心输入错误，可以使用 Ctrl + Backspace 键删除。\n\nnc 命令默认会将 \\n 作为每条消息的结束标志，如果你指定了 -C 选项，将会使用 \\r\\n 作为消息结束标志。\nnc 命令不仅可以发消息，同时也能发文件。我们也来演示一下：\n需要注意的是是接收文件的一方是服务器端，发送文件的一方是客户端。\n\n服务器端命令：\n1nc -l ip地址 端口号 &gt; 接收的文件名\n\n客户端命令：\n1nc ip地址 端口号 &lt; 发送的文件名\n\n服务器端效果：\n\n客户端效果：\n\n\n意：这里客户端发送一个文件叫 index.html，服务器端以文件名 xxx.html 来保存，也就是说服务器端保存接收的文件名时不一定要使用客户端发送的文件名。\n\n根据上面的介绍，当我们需要调试我们自己的服务器或者客户端程序时，又不想自己开发相应的对端，我们就可以使用 nc 命令去模拟。\n当然，nc 命令非常强大，其功能远非本节介绍的这些，读者如果有兴趣可以去 nc 的 man 手册上获取更多的信息。\n","slug":"转载/学习资料/Linux网络故障排查的瑞士军刀","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"c9d344dfed244a58bff8099c6790dfe5","title":"【转载】从抓包的角度分析connect函数的连接过程","content":"从抓包的角度分析connect()函数的连接过程这篇文章主要是从tcp连接建立的角度来分析客户端程序如何利用connect函数和服务端程序建立tcp连接的，了解connect函数在建立连接的过程中底层协议栈做了哪些事情。\ntcp三次握手在正式介绍connect函数时，我们先来看一下tcp三次握手的过程，下面这个实验是客户端通过telnet远程登录服务端的例子，telnet协议是基于tcp协议，我们可以通过wireshark抓包工具看到客户端和服务端之间三次握手的过程，12.1.1.1是客户端的ip地址，12.1.1.2是服务端的ip地址。\n\n下面是我们通过wireshark抓取到的tcp三次握手的数据包：\n\n我们看到客户端远程登录服务端时，首先发送了一个SYN报文，其中目标端口为23（远程登录telnet协议使用23端口），初始序号seq &#x3D; 0，并设置自己的窗口rwnd &#x3D; 4128（rwnd是一个对端通告的接收窗口，用于流量控制）。\n然后服务端回复了一个SYN + ACK报文，初始序号seq &#x3D; 0，ack &#x3D; 1（在前一个包的seq基础上加1），同时也设置自己的窗口rwnd &#x3D; 4128。\n然后客户端收到服务端的SYN + ACK报文时，回复了一个ACK报文，表示确认建立tcp连接，序号为seq &#x3D; 1， **ack &#x3D; 1**（在前一个包的seq基础上加1）*， 设置窗口rwnd &#x3D; 4128*，此时客户端和服务端之间已经建立tcp连接。\nconnect函数前面我们在介绍tcp三次握手的时候说过，客户端在跟服务端建立tcp连接时，通常是由客户端主动向目标服务端发起tcp连接建立请求，服务端被动接受tcp连接请求；同时服务端也会发起tcp连接建立请求，表示服务端希望和客户端建立连接，然后客户端会接受连接并发送一个确认，这样双方就已经建立好连接，可以开始通信。\n这里说明一下：可能有的小伙伴会感到疑惑，为啥服务端也要跟客户端建立连接呢？其实这跟tcp采用全双工通信的方式有关。对于全双工通信，简单来说就是两端可以同时收发数据，如下图所示：\n\n我们再回到正题，那么在网络编程中，肯定也有对应的函数做到跟上面一样的事情，没错，就是connect（连接）。顾名思义，connect函数就是用于客户端程序和服务端程序建立tcp连接的。\n一般来说，客户端使用connect函数跟服务端建立连接，肯定要指定一个ip地址和端口号（相当于客户端的身份标识），要不然服务端都不知道你是谁？凭什么跟你建立连接。同时还得指明服务端的ip地址和端口号，也就是说，你要跟谁建立连接。\nconnect函数原型：\n1int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n\n参数说明：sockfd：客户端的套接字文件描述符addr：要连接的套接字地址，这是一个传入参数，指定了要连接的套接字地址信息（例如IP地址和端口号）addrlen：是一个传入参数，参数addr的大小，即sizeof(addr)\n返回值说明：连接建立成功返回0，失败返回-1并设置errno\nconnect函数在建立tcp连接的过程中用到了一个非常重要的队列，那就是未决连接队列，这个队列用来管理tcp的连接，包括已完成三次握手的tcp连接和未完成三次握手的tcp连接，下面我们就来详细介绍一下未决连接队列。\n未决连接队列未决连接队列是指服务器接收到客户端的连接请求，但是尚未被处理（也就是未被accept，后面会说）的连接，可以理解为未决连接队列是一个容器，这个容器存储着这些尚未被处理的链接。\n当一个客户端进程使用 connect 函数发起请求后，服务器进程就会收到连接请求，然后检查未决连接队列是否有空位，如果未决队列满了，就会拒绝连接，那么客户端调用的connect 函数返回失败。\n如果未决连接队列有空位，就将该连接加入未决连接队列。当 connect 函数成功返回后，表明tcp的“三次握手”连接已完成，此时accept函数获取到一个客户端连接并返回。\n\n在上图中，在未决连接队列中又分为2个队列：\n未完成队列（未决队列）：即客户端已经发出SYN报文并到达服务器，但是在tcp三次握手连接完成之前，这些套接字处于SYN_RCVD状态，服务器会将这些套接字加入到未完成队列。\n已完成队列：即刚刚完成tcp三次握手的tcp连接，这些套接字处于ESTABLISHED状态，服务器会将这些套接字加入到已完成队列。\n我们来看一下连接建立的具体过程，如图所示：\n\n服务端首先调用listen函数监听客户端的连接请求，然后调用accept函数阻塞等待取出未决连接队列中的客户端连接，如果未决连接队列一直为空，这意味着没有客户端和服务器建立连接，那么accept就会一直阻塞。\n当客户端一调用connect函数发起连接时，如果完成tcp三次握手，那么accept函数会取出一个客户端连接（注意：是已经建立好的连接）然后立即返回。\n上面就是客户端和服务端在网络中的状态变迁的具体过程，前面我们在学习tcp三次握手的过程中还知道，服务端和客户端在建立连接的时候会设置自己的一个接收缓冲区窗口rwnd的大小。\n服务端在发送SYN + ACK数据报文时会设置并告知对方自己的接收缓冲区窗口大小，客户端在发送ACK数据报文时也会设置并告知对方自己的接收缓冲区窗口大小。\n注意，accept函数调用成功，返回的是一个已经完成tcp三次握手的客户端连接。如果在三次握手的过程中(最后一步)，服务端没有接收到客户端的ACK，则说明三次握手还没有建立完成，accept函数依然会阻塞。\n关于tcp三次握手连接建立的几种状态：SYN_SENT，SYN_RCVD，ESTABLISHED。SYN_SENT：当客户端调用connect函数向服务端发送SYN包时，客户端就会进入 SYN_SENT状态，并且还会等待服务器发送第二个SYN + ACK包，因此SYN_SENT状态就是表示客户端已经发送SYN包。\nSYN_RCVD：当服务端接收到客户端发送的SYN包并确认时，服务端就会进入 SYN_RCVD状态，这是tcp三次握手建立的一个很短暂的中间状态，一般很难看到， SYN_RCVD状态表示服务端已经确认收到客户端发送的SYN包。\nESTABLISHED：该状态表示tcp三次握手连接建立完成。\n对于这两个队列需要注意几点注意：\n1. 未完成队列和已完成队列的总和不超过listen函数的backlog参数的大小。listen函数的签名如下：\n1int listen(int sockfd, int backlog);\n\n2. 一旦该连接的tcp三次握手完成，就会从未完成队列加入到已完成队列中\n3. 如果未决连接队列已满，当又接收到一个客户端SYN时，服务端的tcp将会忽略该SYN，也就是不会理客户端的SYN，但是服务端并不会发送RST报文，原因是：客户端tcp可以重传SYN，并期望在超时前未决连接队列找到空位与服务端建立连接，这当然是我们所希望看到的。如果服务端直接发送一个RST的话，那么客户端的connect函数将会立即返回一个错误，而不会让tcp有机会重传SYN，显然我们也并不希望这样做。\n但是不排除有些linux实现在未决连接队列满时，的确会发送RST。但是这种做法是不正确的，因此我们最好忽略这种情况，处理这种额外情况的代码也会降低客户端程序的健壮性。\nconnect函数出错情况由于connect函数是在建立tcp连接成功或失败才返回，返回成功的情况本文上面已经介绍过了。这里我们介绍connect函数返回失败的几种情况：第一种当客户端发送了SYN报文后，没有收到确认则返回ETIMEDOUT错误，值得注意的是，失败一次并不会马上返回ETIMEDOUT错误。即当你调用了connect函数，客户端发送了一个SYN报文，没有收到确认就等6s后再发一个SYN报文，还没有收到就等24s再发一个（不同的linux系统设置的时间可能有所不同，这里以BSD系统为主）。这个时间是累加的，如果总共等了75s后还是没收到确认，那么客户端将返回ETIMEDOUT错误。\n对于linux系统，改变这个系统上限值也比较容易，由于需要改变系统配置参数，你需要root权限。相关的命令是sysctl net.ipv4.tcp_syn_retries(针对于ipv4)。在设置该值时还是要比较保守的，因为每次syn包重试的间隔都会增大(比如BSD类的系统实现中间隔会以2到3倍增加)，所有tcp_syn_retries的一个微小变化对connect超时时间的影响都非常大，不过扩大这个值也不会有什么坏处，因为你代码中设置的超时值都能够生效。但是如果代码中没有设置connect的超时值，那么connect就会阻塞很久，你发现对端机器down掉的间隔就更长。作者建议设置这个值到6或者7，最多8。6对应的connect超时为45s，7对应90s，8对应190s。\n你能通过以下命令修改该值:\n1sysctl -w net.ipv4.tcp_syn_retries=6\n\n查看该值的命令是:\n1sysctl net.ipv4.tcp_syn_retries\n\n如果希望重启后生效，将net.ipv4.tcp_syn_retries &#x3D; 6放入**&#x2F;etc&#x2F;sysctl.conf**中。\n这种情况一般是发生在服务端的可能性比较大，也就是服务端当前所处网络环境流量负载过高，网络拥塞了，然后服务端收到了客户端的SYN报文却来不及响应，或者发送的响应报文在网络传输过程中老是丢失，导致客户端迟迟收不到确认，最后返回ETIMEDOUT错误。\n我们可以简单复现一下这种情况，这个实验是基于CentOS系统进行的，具体过程如下所示：\n\n首先通过iptables -F把Centos上的防火墙规则清理掉，然后再通过iptables -I INPUT -p tcp –syn -i lo -j DROP命令把本地的所有SYN包都过滤掉（模拟服务端当前网络不稳定）。\n\n执行以下命令：\n121iptables -F2iptables -I INPUT -p tcp --syn -i lo -j DROP\n\n\n然后通过nc命令向本地的环回地址127.0.0.1发起tcp连接请求（相当于自己跟自己发起tcp连接），来模拟客户端跟服务端发起tcp连接，但是服务器端就是不响应，最后导致客户端的tcp连接建立请求超时，并终止tcp连接。\n \n\n然后再通过tcpdump工具把客户端和服务端建立tcp连接过程中的数据报都抓取下来，由于我们设置的服务器侦听端口号是10086，这里我们可以通过tcpdump -i any port 10086命令来过滤所有网卡的10086端口的数据包。\n \n 如上图所示，localhost.39299代表客户端，localhost.10086代表服务端，客户端总共向服务端发送了6个SYN报文，这6个SYN包的间隔时间分别是1s，2s，4s，8s，16s，这些时间累积加起来总共为31s，其实客户端在发送最后一个SYN报文时还等待了一段时间，然后才超时。也就是说，客户端在发送了第一个SYN报文时，会设置了一个计时器并开始计时，在最后一个SYN报文还没收到服务端的确认时，这个计时器就会超时，然后关闭tcp连接。\n\n\n第二种客户端连接一个服务器没有侦听的端口。\n过程是：客户端发送了一个SYN报文后，然后服务端回复了一个RST报文，说明这是一个异常的tcp连接，服务端发送了RST报文重置这个异常的tcp连接。\n这种情况一般为拒绝连接请求，比如：客户端想和服务端建立tcp连接，但是客户端的连接请求中使用了一个不存在或没有侦听的端口（比如：这个端口超出65535的范围），那么服务端就可以发送RST报文段拒绝这个请求。\n\n拒绝连接一般是由服务器主动发起的，因为客户端发起请求连接携带的目的端口，可能服务器并没有开启LISTEN状态。因此服务器在收到这样的报文段后会发送一个RST报文段，在这个报文里把RST和ACK都置为1，它确认了SYN报文段并同时重置了该tcp连接，然后服务器等待另一个连接。客户端在收到RST+ACK报文段后就会进入CLOSED状态。\n这里以通过20000不存在的端口远程登录为例：\n\ntcpdump抓取到的数据包如下：\n1234113:35:08.609549 IP 192.168.98.137.49057 &gt; 192.168.0.102.dnp: Flags [S], seq 2919679902, win 14600, options [mss 1460,sackOK,TS val 39134059 ecr 0,nop,wscale 6], length 0213:35:09.610018 IP 192.168.98.137.49057 &gt; 192.168.0.102.dnp: Flags [S], seq 2919679902, win 14600, options [mss 1460,sackOK,TS val 39135059 ecr 0,nop,wscale 6], length 0313:35:09.610115 IP 192.168.0.102.dnp &gt; 192.168.98.137.49057: Flags [R.], seq 1766537774, ack 2919679903, win 64240, length 0413:35:10.610188 IP 192.168.0.102.dnp &gt; 192.168.98.137.49057: Flags [R.], seq 3482791532, ack 1, win 64240, length 0\n\n通过分析tcpdump工具抓取的数据发现，RST报文段不携带数据。\n第三种如果客户端调用connect函数向服务端发送了一个SYN报文，这个SYN报文在网络传输过程中经过某个路由器时，正好这个路由器出问题了，缺少到达目的地的路由，不能把这个SYN报文转发给目的地址，那么该路由器会丢弃这个SYN报文，并同时给客户端发送一个Destination unreachable（主机不可达）的ICMP差错报文。客户端的linux内核会保存这个Destination unreachable的ICMP差错报文，同时按第一种情况继续发送SYN报文，如果在规定的时间超时后还没收到服务端的响应报文，那么linux内核会把保存的ICMP差错报文作为EHOSTUNREACH或ENETUNREACH错误返回给客户端的应用进程。\n下面的这个实验就是用来说明第三种情况，帮助理解，大家能看明白就行了，可以不用去做这个实验，当然，有兴趣的同学可以去模拟一下。\n\n然后client远程登录server成功。\n\n上图中没有指定telnet端口号，使用默认端口号23。\n这是抓取到的数据包，client在远程登录server时，发起了SYN连接请求。\n\n现在我们来模拟client设备出故障，删除R1设备到server的路由信息\n1no ip route 12.1.3.0 255.255.255.0 12.1.2.2\n\nclient再登录server时就会失败，我们从抓取到的数据包可以发现，client发送了一个SYN报文，然后R1设备收到这个SYN报文时，发现自己不能到达server，于是会把这个SYN报文丢弃掉，并向client发送了一个目标主机不可达的ICMP差错报文，于是client发送了RST报文来关闭这条异常的tcp连接。\n\n学习知识不仅要知其然也要知其所以然，这是我想通过这篇文章传达的一个理念，文中一步步的实验探索体现了学习知识动手实践的重要性，这是非常值得提倡的。\n","slug":"转载/学习资料/从抓包的角度分析connect函数的连接过程","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"a6f27f59fbfda9509fed1c4003d071f5","title":"【转载】做Java或者C++开发都应该知道的lsof命令","content":"做 Java 或者 C++ 开发都应该知道的 lsof 命令lsof 命令是 Linux 系统的扩展工具，它的含义是 list opened filedesciptor （列出已经打开的文件描述符），在 Linux 系统中，所有的与资源句柄相关的东西都可以统一抽象成文件描述符（filedescriptor，简称 fd）。一个文件句柄是一个 fd，一个 socket 对象也可以称之为 fd 等等。\n默认情况下，系统是不存在这个命令的，你需要安装一下，使用如下命令安装：\n1yum install lsof\n\n我们来看一下这个命令的使用效果：\n12345678910111213141516171819202122COMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAMEsystemd       1          root  cwd       DIR              202,1      4096          2 /nscd        453   469    nscd    8u  netlink                          0t0      11017 ROUTEnscd        453   470    nscd  cwd       DIR              202,1      4096          2 /nscd        453   470    nscd  rtd       DIR              202,1      4096          2 /nscd        453   470    nscd  txt       REG              202,1    180272     146455 /usr/sbin/nscdnscd        453   470    nscd  mem       REG              202,1    217032     401548 /var/db/nscd/hostsnscd        453   470    nscd  mem       REG              202,1     90664     132818 /usr/lib64/libz.so.1.2.7nscd        453   470    nscd  mem       REG              202,1     68192     133155 /usr/lib64/libbz2.so.1.0.6nscd        453   470    nscd  mem       REG              202,1    153192     133002 /usr/lib64/liblzma.so.5.0.99nscd        453   470    nscd  mem       REG              202,1     91496     133088 nscd        453   471    nscd    5u  a_inode                0,9         0       4796 [eventpoll]nscd        453   471    nscd    6r      REG              202,1    217032     401548 /var/db/nscd/hostsnscd        453   471    nscd    7u     unix 0xffff880037497440       0t0      11015 /var/run/nscd/socketnscd        453   471    nscd    8u  netlink                          0t0      11017 ROUTEimgserver   611       zhangyl  cwd       DIR              202,1      4096    1059054 /home/zhangyl/flamingoserverimgserver   611       zhangyl  rtd       DIR              202,1      4096          2 /imgserver   611       zhangyl  txt       REG              202,1   4788917    1057044 /home/zhangyl/flamingoserver/imgserverimgserver   611       zhangyl   24u  a_inode                0,9         0       4796 [eventfd]imgserver   611       zhangyl   25u     IPv4           55707643       0t0        TCP *:commtact-http (LISTEN)imgserver   611       zhangyl   26r      CHR                1,3       0t0       4800 /dev/nullimgserver   611   613 zhangyl   32w      REG              202,1    131072    2754609 /home/zhangyl/flamingoserver/imgcache/258bfb8945288a117d98d440986d7a03\n\n结果显示中列出了各个进程打开的各种 fd 类型，对于 Uinx Socket，lsof 命令会显示出其详细的路径，打开的文件 fd 亦是如此。\n使用 lsof 命令有三点需要注意：\n\n默认情况下，lsof 的输出比较多，我们可以使用 grep 命令过滤我们想要查看的进程打开的 fd 信息，如：\n1lsof -i | grep myapp\n\n或者使用 lsof -p pid 也能过滤出指定的进程打开的 fd 信息：\n12345678910111213141516171819202122[root@iZ238vnojlyZ ~]# lsof -p 26621COMMAND     PID    USER   FD      TYPE   DEVICE SIZE/OFF    NODE NAMEchatserve 26621 zhangyl  cwd       DIR    202,1     4096 1059054 /home/zhangyl/flamingoserverchatserve 26621 zhangyl  rtd       DIR    202,1     4096       2 /chatserve 26621 zhangyl  txt       REG    202,1  8027035 1051942 /home/zhangyl/flamingoserver/chatserverchatserve 26621 zhangyl  mem       REG    202,1    61928  141417 /usr/lib64/libnss_files-2.17.sochatserve 26621 zhangyl  mem       REG    202,1    44096  143235 /usr/lib64/librt-2.17.sochatserve 26621 zhangyl  mem       REG    202,1    19520  137064 /usr/lib64/libdl-2.17.sochatserve 26621 zhangyl  mem       REG    202,1  2112384  132824 /usr/lib64/libc-2.17.sochatserve 26621 zhangyl  mem       REG    202,1   142304  132850 /usr/lib64/libpthread-2.17.sochatserve 26621 zhangyl  mem       REG    202,1    88720  135291 /usr/lib64/libgcc_s-4.8.5-20150702.so.1chatserve 26621 zhangyl  mem       REG    202,1  1141560  137077 /usr/lib64/libm-2.17.sochatserve 26621 zhangyl  mem       REG    202,1   999944  140059 /usr/lib64/libstdc++.so.6.0.19chatserve 26621 zhangyl  mem       REG    202,1  9879756  269001 /usr/lib64/mysql/libmysqlclient.so.20.3.4chatserve 26621 zhangyl  mem       REG    202,1   164440  133622 /usr/lib64/ld-2.17.sochatserve 26621 zhangyl    0u      CHR      1,3      0t0    4800 /dev/nullchatserve 26621 zhangyl    1u      CHR      1,3      0t0    4800 /dev/nullchatserve 26621 zhangyl    2u      CHR      1,3      0t0    4800 /dev/nullchatserve 26621 zhangyl    3u  a_inode      0,9        0    4796 [eventpoll]chatserve 26621 zhangyl    4u  a_inode      0,9        0    4796 [timerfd]chatserve 26621 zhangyl    5u  a_inode      0,9        0    4796 [eventfd]chatserve 26621 zhangyl    7u  a_inode      0,9        0    4796 [eventpoll]\n\nlsof 命令只能查看到当前用户有权限查看到的进程 fd 信息，对于其没有权限的进程，最右边一列会显示 “Permission denied”。如下所示：\n12345678sshd      26759          root  cwd   unknown                              /proc/26759/cwd (readlink: Permission denied)sshd      26759          root  rtd   unknown                              /proc/26759/root (readlink: Permission denied)sshd      26759          root  txt   unknown                              /proc/26759/exe (readlink: Permission denied)sshd      26759          root NOFD                                        /proc/26759/fd (opendir: Permission denied)bash      26761          root  cwd   unknown                              /proc/26761/cwd (readlink: Permission denied)bash      26761          root  rtd   unknown                              /proc/26761/root (readlink: Permission denied)bash      26761          root  txt   unknown                              /proc/26761/exe (readlink: Permission denied)bash      26761          root NOFD                                        /proc/26761/fd (opendir: Permission denied)\n\nlsof 命令第一栏进程名在显示的时候，默认显示前 n 个字符，这样如果我们需要显示完整的进程名以方便过滤的话，可以使用 +c 选项。用法如下：\n12#最左侧的程序名最大显示 15 个字符[zhangyl@iZ238vnojlyZ ~]$ lsof +c 15\n\n当然，如果你设置值太大， lsof 便不会采用你设置的最大值，而是使用默认最大值。\n\n\n上文也介绍了，socket 也是一种 fd，如果需要仅显示系统的网络连接信息，使用的是 -i 选项即可，这个选项可以形象地显示出系统当前的出入连接情况：\n\n看到图中的连接方向了吧？\n当然，和 netstat 命令一样，lsof -i 默认也会显示 ip 地址和端口号的别名，我们只要使用 -n 和 -P 选项就能相对应地显示 ip 地址和端口号了，综合起来就是 lsof -Pni：\n\n","slug":"转载/学习资料/做Java或者C++开发都应该知道的lsof命令","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"70272bd95bde5e7c3c1990babcaab3a0","title":"【转载】利用telnet命令发电子邮件","content":"利用 telnet 命令发电子邮件telnet 命令是我们最常用的网络调试命令之一。如果你的机器上还没有安装 telnet 命令，可以使用如下命令安装一下：\n1yum install telnet \n\n如果一个服务程序对外开启了侦听服务，我们都可以使用 telnet ip port 来连接上去，例如：\n1234[root@localhost ~]# telnet 120.55.94.78 8888Trying 120.55.94.78...Connected to 120.55.94.78.Escape character is &#x27;^]&#x27;.\n\n\n如果不指定端口号，telnet 会使用默认 23 号端口。\n\n反过来说，可以通过 telnet 命令去检测指定 ip 地址和端口号的侦听服务是否存在。知道这点很重要，我们可以利用这个去检测一个服务是否可以正常连接。举个例子，比如某次从某处得到一个代码下载地址，这是一个 svn 地址：svn:&#x2F;&#x2F;120.55.94.78&#x2F;mycode&#x2F;mybook。为了检测这个 svn 服务是否还能正常对外服务，我们可以先用 ping 命令去检测一下到达这个 ip：120.55.94.78 的网络是否畅通：\n1234567891011[root@localhost ~]# ping 120.55.94.78PING 120.55.94.78 (120.55.94.78) 56(84) bytes of data.64 bytes from 120.55.94.78: icmp_seq=1 ttl=128 time=15.3 ms64 bytes from 120.55.94.78: icmp_seq=2 ttl=128 time=14.3 ms64 bytes from 120.55.94.78: icmp_seq=3 ttl=128 time=16.4 ms64 bytes from 120.55.94.78: icmp_seq=4 ttl=128 time=16.1 ms64 bytes from 120.55.94.78: icmp_seq=5 ttl=128 time=15.5 ms^C--- 120.55.94.78 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 4007msrtt min/avg/max/mdev = 14.343/15.568/16.443/0.723 ms\n\n如果网络畅通，我们再用 telnet 去连接上去，由于 svn 服务器使用的默认端口是 3690，我们执行如下命令：\n12345[root@localhost ~]# telnet 120.55.94.78 3690Trying 120.55.94.78...Connected to 120.55.94.78.Escape character is &#x27;^]&#x27;.( success ( 2 2 ( ) ( edit-pipeline svndiff1 absent-entries commit-revprops depth log-revprops atomic-revprops partial-replay ) ) ) \n\n如上所示，证明这个 svn 服务是正常开启对外服务的。反之，如果 telnet 命令连不上，说明这个服务不能被外部网络正常连接，我们就没必要去做进一步的尝试了。\n同样的道理，对于一个 Web 服务，如 baidu.com，由于我们平常都可以通过 www.baidu.com 去访问百度的页面，Web 服务器默认的端口号是 80，我们使用 telnet www.baidu.com 80 应该也可以连接成功的：\n12345678[root@localhost ~]# telnet www.baidu.com 80Trying 115.239.211.112...Connected to www.baidu.com.Escape character is &#x27;^]&#x27;.helloHTTP/1.1 400 Bad RequestConnection closed by foreign host.\n\n我们使用 telnet 命令连接上以后，我们随意发送了一个 hello 消息，由于是非法的 http 请求，被服务器关闭了连接。\ntelnet 命令不仅可以连接某个服务器，还能与服务器进行交互，这通常用于操作一些接受纯文本数据的服务器程序，如 FTP 服务、邮件服务等等。为了演示如何利用 telnet 命令收发数据，我们这里利用 telnet 命令来模拟给某个邮箱发送一封邮件，发送邮件我们通常使用的是 SMTP 协议，该协议默认使用的端口为 25。\n假设我们的发件地址是：&#116;&#x65;&#x73;&#x74;&#x66;&#111;&#x72;&#x6d;&#x79;&#x62;&#111;&#111;&#107;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;，收件地址是：&#x62;&#97;&#x6c;&#108;&#x6f;&#x6f;&#x6e;&#x77;&#106;&#x40;&#113;&#113;&#46;&#x63;&#111;&#109;。\n其中发件地址是一个 163 邮箱，如果你没有的话可以去申请一个，申请后进入邮箱，在设置页面获得网易邮箱的 smtp 服务的服务器地址：\n\n我们得到的地址 smptp 地址是 smtp.163.com，端口号是 25。\n同时，我们需要开启客户端授权，设置一个客户端授权码：\n\n我们这里将授权码设置为 2019hhxxttxs。\n\n早些年很多邮件服务器允许在其他客户端登陆只需要输入正确的邮件服务器地址、用户名和密码就可以了，后来出于安全考虑，很多邮箱采用了授权码机制，在其他第三方客户端登陆该邮箱时需要输入授权码（不是密码），且需要用户主动打开允许第三方客户端登陆的配置选项。\n\n配置完成以后，我们现在就可以利用 telnet 命令连接 163 邮件服务器并发送邮件了，由于在登陆的过程中需要验证用户名和授权码，而且用户名和授权码必须使用 base64 编码之后的，我们先将用户名和授权码的 base64 码准备好，用的时候直接拷贝过去：\n\n\n\n原文\nbase64 码\n\n\n\ntestformybook\ndGVzdGZvcm15Ym9vaw&#x3D;&#x3D;\n\n\n2019hhxxttxs\nMjAxOWhoeHh0dHhz\n\n\n如果你不知道 base64 编码的原理，可以从网上搜索找一个 base64 编解码工具，例如：https://base64.supfree.net/。\n在整个演示过程我们一共需要使用如下 SMTP 协议命令：\n\n\n\n命令\n含义\n\n\n\nhelo\n向 smtp 服务器发送问候信息\n\n\nauth login\n请求登陆验证\n\n\ndata\n请求输入邮件正文\n\n\nSMTP 协议 是文本协议，每一个数据包以 \\r\\n 结束（Windows 系统下默认换行符）。\n我们来看一下演示过程：\n1234567891011121314151617181920212223242526272829[root@localhost ~]# telnet smtp.163.com 25Trying 220.181.12.14...Connected to smtp.163.com.Escape character is &#x27;^]&#x27;.220 163.com Anti-spam GT for Coremail System (163com[20141201])helo 163.com250 OKauth login334 dXNlcm5hbWU6dGVzdGZvcm15Ym9vaw==334 UGFzc3dvcmQ6MjAxOWhoeHh0dHhz235 Authentication successfulmail from: &lt;testformybook@163.com&gt;250 Mail OKrcpt to:  &lt;balloonwj@qq.com&gt;250 Mail OKdata354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;from:testformybook@163.comto: balloonwj@qq.comsubject: TestHello, this is a message from 163..250 Mail OK queued as smtp10,DsCowADHAgQS1IBcwtExJA--.62308S2 1551946998Connection closed by foreign host.[root@localhost ~]# \n\n我们来分析一下上述操作过程：\n\n使用 telnet smtp.163.com 25 连接 163 邮件服务器；连接成功以后，服务器给我们发送了一条欢迎消息：\n1220 163.com Anti-spam GT for Coremail System (163com[20141201])\\r\\n\n\n接着，必须向服务器发送一条问候消息，使用 helo 163.com，当然 163.com 这个是问候内容，可以随意填写，然后回车，最终组成的数据包内容是：\n1helo 163.com\\r\\n\n\n接着服务器会回复一条状态码是 250 的消息，这里是：\n1250 OK\\r\\n\n\n我们再输入命令 auth login 请求验证，然后按回车，实际发送给服务器的是：\n1auth login\\r\\n\n\n服务器应答状态码 334：\n1334 dXNlcm5hbWU6\\r\\n\n\ndXNlcm5hbWU6 是字符串 **username: ** 的 base64 码。\n\n我们输入我们的用户名 testformybook 的 base64 码，然后按回车：\n1dGVzdGZvcm15Ym9vaw==\\r\\n\n\n服务器应答状态码 334：\n1334 UGFzc3dvcmQ6\\r\\n\n\nUGFzc3dvcmQ6 是字符串 Password: 的 base64 码。这里实际上要求我们输入的是上文介绍的授权码，而不是密码。\n\n我们输入 MjAxOWhoeHh0dHhz，并回车：\n1MjAxOWhoeHh0dHhz\\r\\n\n\n服务器提示我们授权成功（应答状态码 235）：\n1235 Authentication successful\\r\\n\n\n接着输入邮件的发件地址和收件地址，服务器也会给我们响应的应答（应答状态码 250）：\n1234mail from: &lt;testformybook@163.com&gt;\\r\\n250 Mail OK\\r\\nrcpt to:  &lt;balloonwj@qq.com&gt;\\r\\n250 Mail OK\\r\\n\n\n接着输入 data 命令设置邮件的主题、正文、对方收到邮件后显示的的发件人信息等：\n12data\\r\\n354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\n\n服务器应答 354，并且提示，如果确定结束输入邮件正文就先按一个回车键，再输入一个点 **.**，再接着回车，这样邮件就发送出去了。\n\n服务器应答 250：\n1250 Mail OK queued as smtp10,DsCowADHAgQS1IBcwtExJA--.62308S2 1551946998\n\n如果我们想退出，输入 quit 或 close 都可以。\n\n\n最终，这封邮件就发出去了，我们去 &#98;&#97;&#x6c;&#x6c;&#111;&#111;&#x6e;&#119;&#106;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d; 这个邮箱查看一下：\n\n\n如果你在实际实验时，对端没有收到邮件，请查看下你的垃圾箱或者邮箱反垃圾邮件设置，有可能被邮箱反垃圾邮件机制给拦截了。\n\n上述在组装 SMTP 协议包时涉及到很多状态码，常见的 SMTP 状态码含义如下：\n1234567891011121314151617181920212223211 帮助返回系统状态214 帮助信息220 服务准备就绪221 关闭连接235 用户验证成功250 请求操作就绪251 用户不在本地，转寄到其他路径334 等待用户输入验证信息354 开始邮件输入421 服务不可用450 操作未执行，邮箱忙451 操作中止，本地错误452 操作未执行，存储空间不足500 命令不可识别或语言错误501 参数语法错误502 命令不支技503 命令顺序错误504 命令参数不支持550 操作未执行，邮箱不可用551 非本地用户552 中止存储空间不足553 操作未执行，邮箱名不正确554 传输失败\n\n\n由于我们使用的开发机器以 Windows 居多，默认情况下，Windows 系统的 telnet 命令是没有开启的，我们可以在【控制面板】- 【程序】- 【程序和功能】- 【打开或关闭Windows功能】中打开telnet功能。如下图所示：\n\n\n","slug":"转载/学习资料/利用telnet命令发电子邮件","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"cc903e63e370e497adde4ee0456deec1","title":"【转载】服务器开发中网络数据分析与故障排查经验漫谈","content":"服务器开发中网络数据分析与故障排查经验漫谈​      \n一、 操作系统提供的网络接口\n为了能更好的排查网络通信问题，我们需要熟悉操作系统提供的以下网络接口函数，列表如下：\n\n\n\n接口函数名称\n接口函数描述\n接口函数签名\n\n\n\nsocket\n创建套接字\nint socket(int domain, int type, int  protocol);\n\n\nconnect\n连接一个服务器地址\nint connect(int sockfd, const struct  sockaddr *addr,          socklen_t addrlen);\n\n\nsend\n发送数据\nssize_t send(int sockfd, const void *buf,  size_t len, int flags);\n\n\nrecv\n收取数据\nssize_t recv(int sockfd, void *buf,  size_t len, int flags);\n\n\naccept\n接收连接\nint accept4(int sockfd, struct sockaddr  *addr,          socklen_t *addrlen, int  flags);\n\n\nshutdown\n关闭收发链路\nint shutdown(int sockfd, int how);\n\n\nclose\n关闭套接字\nint close(int fd);\n\n\nsetsockopt\n设置套接字选项\nint setsockopt(int sockfd, int level, int  optname,           const void *optval,  socklen_t optlen);\n\n\n注意：这里以bekeley提供的标准为例，不包括特定操作系统上特有的接口函数（如Windows平台的WSASend，linux的accept4），也不包括实际与网络数据来往不相关的函数（如select、linux的epoll），这里只讨论与tcp相关的接口函数，像与udp相关的函数sendto&#x2F;recvfrom等函数与此类似。\n下面讨论一下以上函数的一些使用注意事项：\n1 以上函数如果调用出错后，返回值均为-1；但是返回值是-1，不一定代表出错，这还得根据对应的套接字模式（阻塞与非阻塞模式）。\n2 默认使用的socket函数创建的套接字是阻塞模式的，可以调用相关接口函数将其设置为非阻塞模式（Windows平台可以使用ioctlsocket函数，linux平台可以使用fcntl函数，具体设置方法可以参考这里。）。阻塞模式和非阻塞模式的套接字，对服务器的连接服务器和网络数据的收发行为影响很大。详情如下：\n阻塞模式下，connect函数如果不能立刻连上服务器，会导致执行流阻塞在那里一会儿，直到connect连接成功或失败或网络超时；而非阻塞模式下，无论是否连接成功connect将立即返回，此时如果未连接成功，返回值将是-1，错误码是EINPROGRESS，表示连接操作仍然在进行中。Linux平台后续可以通过使用select&#x2F;poll等函数检测该socket是否可写来判断连接是否成功。\n阻塞套接字模式下，send函数如果由于对端tcp窗口太小，不足以将全部数据发送出去，将阻塞执行流，直到出错或超时或者全部发送出去为止；同理recv函数如果当前协议栈系统缓冲区中无数据可读，也会阻塞执行流，直到出错或者超时或者读取到数据。send和recv函数的超时时间可以参考下文关于常用socket选项的介绍。\n非阻塞套接字模式下，如果由于对端tcp窗口太小，不足以将数据发出去，它将立刻返回，不会阻塞执行流，此时返回值为-1，错误码是EAGAIN或EWOULDBLOCK，表示当前数据发不出去，希望你下次再试。但是返回值如果是-1，也可能是真正的出错了，也可能得到错误码EINTR，表示被linux信号中断了，这点需要注意一下。recv函数与send函数情形一样。\n3 send函数虽然名称叫“send”，但是其并不是将数据发送到网络上去，只是将数据从应用层缓冲区中拷贝到协议栈内核缓冲区中，具体什么时候发送到网络上去，与协议栈本身行为有关系（socket选项nagle算法与这个有关系，下文介绍常见套接字选项时会介绍），这点需要特别注意，所以即使send函数返回一个大于0的值n，也不能表明已经有n个字节发送到网络上去了。同样的道理，recv函数也不是从网络上收取数据，只是从协议栈内核缓冲区拷贝数据至应用层缓冲区，并不是真正地从网络上收数据，所以，调用recv时，操作系统的协议栈已经将数据从网络上收到自己的内核缓冲区中了，recv仅仅是一次数据拷贝操作而已。\n4 由于套接字实现是收发全双工的，收和发通道相互独立，不会相互影响，shutdown函数是用来选择关闭socket收发通道中某一路（当然，也可以两路都关闭），其how参数取值一般有三个：SHUT_RD&#x2F;SHUT_WR&#x2F;SHUT_RDWR，SHUT_RD表示关闭收消息链路，即该套接字不能再收取数据，同理SHUT_WR表示关闭套接字发消息链路，但是这里有个问题，有时候我们需要等待缓冲区中数据发送完后再关闭连接怎么办？这里就要用到套接字选项LINGER，关于这个选项请参考下文常见的套接字选项介绍。最后，SHUT_RDWR同时关闭收消息链路和发消息链路。通过上面的分析，我们得出结论，shutdown函数并不会要求操作系统底层回收套接字等资源，真正会回收资源是close函数，这个函数会要求操作系统回收相关套接字资源，并释放对ip地址与端口号二元组的占用，但是由于tcp四次挥手最后一个阶段有个TIME_WAIT状态（关于这个状态下文介绍tcp三次握手和四次回收时会详细介绍），导致与该socket相关的端口号资源不会被立即释放，有时候为了达到释放端口用来复用，我们会设置套接字选项SOL_REUSEPORT（关于这个选项，下文会介绍）。综合起来，我们关闭一个套接字，一般会先调用shutdown函数再调用close函数，这就是所谓的优雅关闭：\n\n5 常见的套接字选项\n严格意义上说套接字选项是有不同层级的（level），如socket级别、TCP级别、IP级别，这里我们不区分具体的级别。\n\nSO_SNDTIMEO与SO_RCVTIMEO\n\n这两个选项用于设置阻塞模式下套接字，SO_SNDTIMEO用于在send数据由于对端tcp窗口太小，发不出去而最大的阻塞时长；SO_RCVTIMEO用于recv函数因接受缓冲区无数据而阻塞的最大阻塞时长。如果你需要获取它们的默认值，请使用getsockopt函数。\n\nTCP_NODELAY\n\n操作系统底层协议栈默认有这样一个机制，为了减少网络通信次数，会将send等函数提交给tcp协议栈的多个小的数据包合并成一个大的数据包，最后再一次性发出去，也就是说，如果你调用send函数往内核协议栈缓冲区拷贝了一个数据，这个数据也许不会马上发到网络上去，而是要等到协议栈缓冲区积累到一定量的数据后才会一次性发出去，我们把这种机制叫做nagle算法。默认打开了这个机制，有时候我们希望关闭这种机制，让send的数据能够立刻发出去，我们可以选择关闭这个算法，这就可以通过设置套接字选项TCP_NODELAY，即关闭nagle算法。\n\nSO_LINGER\n\nlinger这个单词本身的意思，是“暂停、逗留”。这个选项的用处是用于解决，当需要关闭套接字时，协议栈发送缓冲区中尚有未发送出去的数据，等待这些数据发完的最长等待时间。\n\nSO_REUSEADDR&#x2F;SO_REUSEPORT\n\n一个端口，尤其是作为服务器端端口在四次挥手的最后一步，有一个为TIME_WAIT的状态，这个状态一般持续2MSL（MSL，maximum segment life， 最大生存周期，RFC上建议是2分钟）。这个状态存在原因如下：1. 保证发出去的ack能被送达（超时会重发ack）2. 让迟来的报文有足够的时间被丢弃，反过来说，如果不存在这个状态，那么可以立刻复用这个地址和端口号，那么可能会收到老的连接迟来的数据，这显然是不好的。为了立即回收复用端口号，我们可以通过开启套接字SO_REUSEADDR&#x2F;SO_REUSEPORT。\n\nSO_KEEPALIVE\n\n默认情况下，当一个连接长时间没有数据来往，会被系统防火墙之类的服务关闭。为了避免这种现象，尤其是一些需要长连接的应用场景下，我们需要使用心跳包机制，即定时从两端定时发一点数据，这种行为叫做“保活”。而tcp协议栈本身也提供了这种机制，那就是设置套接字SO_KEEPALIVE选项，开启这个选项后，tcp协议栈会定时发送心跳包探针，但是这个默认时间比较长（2个小时），我们可以继续通过相关选项改变这个默认值。\n​      \n二、常用的网络故障排查工具1.ping\nping命令可用于测试网络是否连通。\n2.telnet\n命令使用格式：\n1telnet  ip或域名 port\n\n例如：\n123telnet 120.55.94.78 8888telnet www.baidu.com 80\n\n结合ping和telnet命令我们就可以判断一个服务器地址上的某个端口号是否可以对外提供服务。\n由于我们使用的开发机器以windows居多，默认情况下，windows系统的telnet命令是没有打开的，我们可以在【控制面板】- 【程序】- 【程序和功能】- 【打开或关闭Windows功能】中打开telnet功能。\n\n3.host命令\nhost 命令可以解析域名得到对应的ip地址。例如，我们要得到www.baidu.com这个域名的ip地址，可以输入：\n\n 得到www.google.com的ip地址可以输入：\n\n4 .netstat命令\n常见的选项有：\n-a (all)显示所有选项，netstat默认不显示LISTEN相关\n-t (tcp)仅显示tcp相关选项\n-u (udp)仅显示udp相关选项\n-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)\n-l 仅列出有在 Listen (监听) 的服務状态\n-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)\n-r 显示路由信息，路由表\n-e 显示扩展信息，例如uid等\n-s 按各个协议进行统计 (重要)\n-c 每隔一个固定时间，执行该netstat命令。\n5. lsof命令\nlsof，即list opened filedescriptor，即列出当前操作系统中打开的所有文件描述符，socket也是一种file descriptor，常见的选项是:\n-i 列出系统打开的socket fd\n-P 不要显示端口号别名\n-n 不要显示ip地址别名（如localhost会用127.0.0.1来代替）\n+c w 程序列名称最大可以显示到w个字符。\n常见的选项组合为lsof –i –Pn：\n\n可以看到列出了当前侦听的socket，和连接socket的tcp状态。\n6.pstack\n严格意义上来说，这个不算网络排查故障和调试命令，但是我们可以利用这个命令来查看某个进程的线程数量和线程调用堆栈是否运行正常。指令使用格式：\n1pstack pid\n\n即，pstack 进程号，如：\n\n7.nc命令\n即netcat命令，这个工具在排查网络故障时非常有用，因而被业绩称为网络界的“瑞士军刀”。常见的用法如下：\n\n模拟服务器端在指定ip地址和端口号上侦听\n\n1nc –l 0.0.0.0 8888\n\n\n模拟客户端连接到指定ip地址和端口号\n\n1nc 0.0.0.0 8888\n\n我们知道客户端连接服务器一般都是操作系统随机分配一个可用的端口号连接到服务器上去，这个指令甚至可以指定使用哪个端口号连接，如：\n1nc –p 12345 127.0.0.1 8888\n\n客户端使用端口12345去连接服务器127.0.0.1::8888。\n\n使用nc命令发消息和发文件\n\n客户端\n\n服务器\n\n8 .tcpdump\n这个是linux系统自带的抓包工具，功能非常强大，默认需要开启root权限才能使用。\n\n其常见的选项有：\n-i 指定网卡\n-X –XX 打印十六进制的网络数据包\n-n –nn 不显示ip地址和端口的别名\n-S 以绝对值显示包的ISN号（包序列号）\n常用的过滤条件有如下形式：\n12345tcpdump –i any ‘port 8888’tcpdump –i any ‘tcp port 8888’tcpdump –i any ‘tcp src port 8888’tcpdump –i any ‘tcp src port 8888 and udp dst port 9999’tcpdump -i any &#x27;src host 127.0.0.1 and tcp src port 12345&#x27; -XX -nn -vv\n\n关于tcpdump命令接下来将会以对tcp三次握手和四次挥手的包数据进行抓包来分析。\n三、 tcp三次握手和四次挥手过程解析熟练地掌握tcp三次握手和四次挥手过程的每一个细节是我们排查网络问题的基础。\n\n下面我们来通过tcpdump抓包能实战一下三次握手的过程，假设我的服务器端的地址是 127.0.0.0.1 : 12345，使用nc命令创建一个服务器程序并在这个地址上进行侦听：\n1nc –v -l 127.0.0.0.112345\n\n\n然后在客户端机器上开启tcpdump工具：\n\n然后在客户端使用nc命令创建一个客户端去连接服务器：\n\n我们抓到的包如下：\n\n图片看不清，可以放大来看。上面我们需要注意的是：\n三次握手过程是客户端先给服务器发送一个SYN，然后服务器应答一个SYN+ACK，应答的序列号是递增1的，表示应答哪个请求，即从4004096087递增到4004096088，接着客户端再应答一个ACK。这个时候，我们发现发包序列号和应答序列号都变成1了，这是tcpdump使用相对序号，我们加上-S选项后就变成绝对序列号了。\n\n 这是正常的tcp三次握手，假如我们连接的服务器ip地址存在，但监听端口号并不存在，我们看下tcpdump抓包结果：\n\n这个时候客户端发送SYN，服务器应答ACK+RST：\n\n 这个应答包会导致客户端的connect连接失败。\n还有一种情况就是客户端访问一个很遥远的ip，或者网络繁忙，服务器对客户端发送的网络SYN报文没有应答，会出现什么情况呢？\n\n我们先将防火墙的已有规则都清理掉: iptables -F\n然后给防火墙的INPUT链上增加一个规则，丢弃本地网卡lo（也就是127.0.0.1这个回环地址）上的所有SYN包。\n\n 接着，我们看到tcpdump抓到的数据包如下：\n\n 连接不上，一共重试了5次，重试的时间间隔是1秒，2秒，4秒，8秒，16秒，最后返回失败。这个重试次数在&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries 内核参数中设置，默认为6。\n四次挥手与三次握手基本上类似，这里就不贴出tcpdump抓包的详情了。实际的网络开发中，尤其是高QPS的服务器程序，可能在在服务器程序所在的系统上留下大量非ESTABLISHED的中间状态，如CLOSE_WAIT&#x2F;TIME_WAIT，我们可以使用以下指令来统计这些状态信息：\nnetstat -n | awk ‘&#x2F;^tcp&#x2F; {++S[$NF]} END {for(a in S) print a, S[a]}’ \n得到结果可能类似：\n\n让我们再贴一张tcp三次握手和四次挥手更清晰的图吧。\n\n 下面看下一般比较关心的三种TCP状态\n\nSYN_RECV\n\n服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。有两个相关系统配置：\n1 net.ipv4.tcp_synack_retries，整形，默认值是5\n对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是三次握手机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。通常我们不对这个值进行修改，因为我们希望TCP连接不要因为偶尔的丢包而无法建立。\n2 net.ipv4.tcp_syncookies\n一般服务器都会设置net.ipv4.tcp_syncookies&#x3D;1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。能够有效防范SYN Flood攻击的手段之一，就是SYN Cookie。SYN Cookie原理由D. J. Bernstain和 Eric Schenk发明。SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到SYN包并返回SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。观测服务上SYN_RECV连接个数为：7314，对于一个高并发连接的通讯服务器，这个数字比较正常。\n\nCLOSE_WAIT\n\n发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。\n\nTIME_WAIT\n\n根据三次握手断开连接规定，发起socket主动关闭的一方 socket将进入TIME_WAIT状态。TIME_WAIT状态将持续2MSL。TIME_WAIT状态下的socket不能被回收使用。 具体现象是对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多，严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。和TIME_WAIT状态有关的系统参数有一般由3个，本机设置如下：\n1234567891011net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_fin_timeout，默认60s，减小fin_timeout，减少TIME_WAIT连接数量。net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\n\n我们这里总结一下这些与tcp状态的选项：\n\nnet.ipv4.tcp_syncookies&#x3D;1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookie来处理，可防范少量的SYN攻击。默认为0，表示关闭。\n\nnet.ipv4.tcp_tw_reuse&#x3D;1 表示开启重用。允许将TIME-WAIT套接字重新用于新的TCP连接。默认为0，表示关闭。\n\nnet.ipv4.tcp_tw_recycle&#x3D;1 表示开启TCP连接中TIME-WAIT套接字的快速回收。默认为0，表示关闭。**\n\nnet.ipv4.tcp_fin_timeout&#x3D;30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。\n\nnet.ipv4.tcp_keepalive_time&#x3D;1200 表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时，这里改为20分钟。\n\nnet.ipv4.ip_local_port_range&#x3D;1024 65000 表示向外连接的端口范围。默认值很小：32768～61000，改为1024～65000。\n\nnet.ipv4.tcp_max_syn_backlog&#x3D;8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。\n\nnet.ipv4.tcp_max_tw_buckets&#x3D;5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数 字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。\n\n\n注意\n上文中用红色字体标识出来的两个参数：\n123net.ipv4.tcp_tw_recyclenet.ipv4.tcp_tw_reuse\n\n\n\n在实际linux内核参数调优时并不建议开启。至于原因，我会单独用一篇文章来介绍。\n\n四、 关于跨系统与跨语言之间的网络通信连通问题如何在Java语言中去解析C++的网络数据包，如何在C++中解析Java的网络数据包，对于很多人来说是一件很困难的事情，所以只能变着法子使用第三方的库。其实使用tcpdump工具可以很容易解决与分析。\n首先，我们需要明确字节序列这样一个概念，即我们说的大端编码(big endian)和小端编码(little endian)，x86和x64系列的cpu使用小端编码，而数据在网络上传输，以及Java语言中，使用的是大端编码。那么这是什么意思呢？\n我们举个例子，看一个x64机器上的32位数值在内存中的存储方式：\n\ni 在内存中的地址序列是0x003CF7C4~ 0x003CF7C8，值为40 e2 01 00。\n\n 十六进制0001e240正好等于10进制123456，也就是说小端编码中权重高的的字节值存储在内存地址高（地址值较大）的位置，权重值低的字节值存储在内存地址低（地址值较小）的位置，也就是所谓的高高低低。\n相反，大端编码的规则应该是高低低高，也就是说权值高字节存储在内存地址低的位置，权值低的字节存储在内存地址高的位置。\n所以，如果我们一个C++程序的int32值123456不作转换地传给Java程序，那么Java按照大端编码的形式读出来的值是：十六进制40E20100 &#x3D; 十进制1088553216。\n所以，我们要么在发送方将数据转换成网络字节序（大端编码），要么在接收端再进行转换。\n下面看一下如果C++端传送一个如下数据结构，Java端该如何解析（由于Java中是没有指针的，也无法操作内存地址，导致很多人无从下手），下面利用tcpdump来解决这个问题的思路。\n我们客户端发送的数据包：\n\n其结构体定义如下：\n\n 利用tcpdump抓到的包如下：\n\n放大一点：\n\n 我们白色标识出来就是我们收到的数据包。这里我想说明两点：\n\n如果我们知道发送端发送的字节流，再比照接收端收到的字节流，我们就能检测数据包的完整性，或者利用这个来排查一些问题；\n对于Java程序只要按照这个顺序，先利用java.net.Socket的输出流java.io.DataOutputStream对象readByte、readInt32、readInt32、readBytes、readBytes方法依次读出一个char、int32、int32、16个字节的字节数组、63个字节数组即可，为了还原像int32这样的整形值，我们需要做一些小端编码向大端编码的转换。\n\n参考资料：\n\n《TCP&#x2F;IP详解卷一：协议》\n《TCP&#x2F;IP详解卷二：实现》\n游双《Linux高性能服务器编程》\nhttps://man.cx/?page=iptables(8)\nhttps://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux\nhttps://blog.csdn.net/chinalinuxzend/article/details/1792184\nhttps://www.zhihu.com/question/29212769\nhttps://blog.csdn.net/launch_225/article/details/9211731\nhttps://www.cnblogs.com/splenday/articles/7668589.html\nhttp://man.linuxde.net/ss\nhttp://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/\nhttps://www.cnblogs.com/xkus/p/7463135.html\n\n","slug":"转载/学习资料/服务器开发中网络数据分析与故障排查经验漫谈","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料","author_index":"阿木大叔"},{"id":"f803883e87085e50bdcf47ed5c086db3","title":"【转载】Linuxepoll模型（含LT模式和ET模式详解）","content":"Linux epoll 模型（含LT 模式和 ET 模式详解）综合 select 和 poll 的一些优缺点，Linux 从内核 2.6 版本开始引入了更高效的 epoll 模型，本节我们来详细介绍 epoll 模型。\n要想使用 epoll 模型，必须先需要创建一个 epollfd，这需要使用 epoll_create 函数去创建：\n123#include &lt;sys/epoll.h&gt;int epoll_create(int size);\n\n参数 size 从 Linux 2.6.8 以后就不再使用，但是必须设置一个大于 0 的值。epoll_create 函数调用成功返回一个非负值的 epollfd，调用失败返回 -1。\n有了 epollfd 之后，我们需要将我们需要检测事件的其他 fd 绑定到这个 epollfd 上，或者修改一个已经绑定上去的 fd 的事件类型，或者在不需要时将 fd 从 epollfd 上解绑，这都可以使用 epoll_ctl 函数：\n1int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n\n参数说明：\n\n参数 epfd 即上文提到的 epollfd；\n\n参数 op，操作类型，取值有 EPOLL_CTL_ADD、EPOLL_CTL_MOD 和 EPOLL_CTL_DEL，分别表示向 epollfd 上添加、修改和移除一个其他 fd，当取值是 EPOLL_CTL_DEL，第四个参数 event 忽略不计，可以设置为 NULL；\n\n参数 fd，即需要被操作的 fd；\n\n参数 event，这是一个 epoll_event 结构体的地址，epoll_event 结构体定义如下：\n12345struct epoll_event&#123;  uint32_t     events;      /* 需要检测的 fd 事件，取值与 poll 函数一样 */  epoll_data_t data;        /* 用户自定义数据 */&#125;;\n\nepoll_event 结构体的 data 字段的类型是 epoll_data_t，我们可以利用这个字段设置一个自己的自定义数据，它本质上是一个 Union 对象，在 64 位操作系统中其大小是 8 字节，其定义如下：\n1234567typedef union epoll_data&#123;  void*         ptr;  int          fd;  uint32_t     u32;  uint64_t     u64;&#125; epoll_data_t;\n\n函数返回值：epoll_ctl 调用成功返回 0，调用失败返回 -1，你可以通过 errno 错误码获取具体的错误原因。\n\n\n创建了 epollfd，设置好某个 fd 上需要检测事件并将该 fd 绑定到 epollfd 上去后，我们就可以调用 epoll_wait 检测事件了，epoll_wait 函数签名如下：\n1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n\n参数的形式和 poll 函数很类似，参数 events 是一个 epoll_event 结构数组的首地址，这是一个输出参数，函数调用成功后，events 中存放的是与就绪事件相关 epoll_event 结构体数组；参数 maxevents 是数组元素的个数；timeout 是超时时间，单位是毫秒，如果设置为 0，epoll_wait 会立即返回。\n当 epoll_wait 调用成功会返回有事件的 fd 数目；如果返回 0 表示超时；调用失败返回 -1。\nepoll_wait 使用示例如下：\n1234567891011121314151617181920212223242526272829303132333435while (true)&#123;    epoll_event epoll_events[1024];    int n = epoll_wait(epollfd, epoll_events, 1024, 1000);    if (n &lt; 0)    &#123;        //被信号中断        if (errno == EINTR)            continue;        //出错，退出        break;    &#125;    else if (n == 0)    &#123;        //超时，继续        continue;    &#125;    for (size_t i = 0; i &lt; n; ++i)    &#123;        // 处理可读事件        if (epoll_events[i].events &amp; POLLIN)        &#123;        &#125;        // 处理可写事件        else if (epoll_events[i].events &amp; POLLOUT)        &#123;        &#125;        //处理出错事件        else if (epoll_events[i].events &amp; POLLERR)        &#123;        &#125;    &#125;&#125;\n\nepoll_wait 与 poll 的区别通过前面介绍 poll 与 epoll_wait 函数的介绍，我们可以发现：\nepoll_wait 函数调用完之后，我们可以直接在 event 参数中拿到所有有事件就绪的 fd，直接处理即可（event 参数仅仅是个出参）；而 poll 函数的事件集合调用前后数量都未改变，只不过调用前我们通过 pollfd 结构体的 events 字段设置待检测事件，调用后我们需要通过 pollfd 结构体的 revents 字段去检测就绪的事件（ 参数 fds 既是入参也是出参）。\n举个生活中的例子，某人不断给你一些苹果，这些苹果有生有熟，调用 epoll_wait 相当于：\n121. 你把苹果挨个投入到 epoll 机器中(调用 epoll_ctl);2. 调用 epoll_wait 加工，你直接通过另外一个袋子就能拿到所有熟苹果。\n\n调用 poll 相当于：\n121. 把收到的苹果装入一个袋子里面然后调用 poll 加工；2. 调用结束后，拿到原来的袋子，袋子中还是原来那么多苹果，只不过熟苹果被贴上了标签纸，你还是需要挨个去查看标签纸挑选熟苹果。 \n\n当然，这并不意味着，poll 函数的效率不如 epoll_wait，一般在 fd 数量比较多，但某段时间内，就绪事件 fd 数量较少的情况下，epoll_wait 才会体现出它的优势，也就是说 socket 连接数量较大时而活跃连接较少时 epoll 模型更高效。\nLT 模式和 ET 模式与 poll 的事件宏相比，epoll 新增了一个事件宏 EPOLLET，这就是所谓的边缘触发模式（Edge Trigger，ET），而默认的模式我们称为 水平触发模式（Level Trigger，LT）。这两种模式的区别在于：\n\n对于水平触发模式，一个事件只要有，就会一直触发；\n对于边缘触发模式，只有一个事件从无到有才会触发。\n\n这两个词汇来自电学术语，你可以将 fd 上有数据认为是高电平，没有数据认为是低电平，将 fd 可写认为是高电平，fd 不可写认为是低电平。那么水平模式的触发条件是状态处于高电平，而边缘模式是状态改为高电平，即：\n水平模式的触发条件\n121. 低电平 =&gt; 高电平2. 高电平 =&gt; 高电平\n\n边缘模式的触发条件\n11. 低电平 =&gt; 高电平\n\n说的有点抽象，以 socket 的读事件为例，对于水平模式，只要 socket 上有未读完的数据，就会一直产生 POLLIN 事件；而对于边缘模式，socket 上第一次有数据会触发一次，后续 socket 上存在数据也不会再触发，除非把数据读完后，再次产生数据才会继续触发。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 POLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 POLLOUT 事件。\nsocket 可读事件水平模式触发条件：\n121. socket上无数据 =&gt; socket上有数据2. socket上有数据 =&gt; socket上有数据\n\nsocket 可读事件边缘模式触发条件：\n11. socket上无数据 =&gt; socket上有数据\n\nsocket 可写事件水平模式触发条件：\n121. socket可写   =&gt; socket可写2. socket不可写 =&gt; socket可写\n\nsocket 可写事件边缘模式触发条件：\n11. socket不可写 =&gt; socket可写\n\n也就是说，如果对于一个非阻塞 socket，如果使用 epoll 边缘模式去检测数据是否可读，触发可读事件以后，一定要一次性把 socket 上的数据收取干净才行，也就是一定要循环调用 recv 函数直到 recv 出错，错误码是EWOULDBLOCK（EAGAIN 一样）；如果使用水平模式，则不用，你可以根据业务一次性收取固定的字节数，或者收完为止。边缘模式下收取数据的代码示例如下：\n12345678910111213141516171819202122232425bool TcpSession::RecvEtMode()&#123;    //每次只收取256个字节    char buff[256];    while (true)    &#123;               int nRecv = ::recv(clientfd_, buff, 256, 0);        if (nRecv == -1)        &#123;            if (errno == EWOULDBLOCK)                return true;            else if (errno == EINTR)                continue;            return false;        &#125;        //对端关闭了socket        else if (nRecv == 0)            return false;        inputBuffer_.add(buff, (size_t)nRecv);    &#125;    return true;&#125;\n\n最后，我们来看一个 epoll 模型的完整例子：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/** * 演示 epoll 通信模型，epoll_server.cpp * zhangyl 2019.03.16 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;poll.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;errno.h&gt;int main(int argc, char* argv[])&#123;    //创建一个侦听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1)    &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //将侦听socket设置为非阻塞的    int oldSocketFlag = fcntl(listenfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(listenfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(listenfd);        std::cout &lt;&lt; &quot;set listenfd to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //启动侦听    if (listen(listenfd, SOMAXCONN) == -1)    &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //复用地址和端口号    int on = 1;    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));    setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on));    //创建epollfd    int epollfd = epoll_create(1);    if (epollfd == -1)    &#123;        std::cout &lt;&lt; &quot;create epollfd error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    epoll_event listen_fd_event;    listen_fd_event.events = POLLIN;    listen_fd_event.data.fd = listenfd;    //将侦听socket绑定到epollfd上去    if(epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &amp;listen_fd_event) == -1)    &#123;        std::cout &lt;&lt; &quot;epoll_ctl error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    int n;    while (true)    &#123;               epoll_event epoll_events[1024];        n = epoll_wait(epollfd, epoll_events, 1024, 1000);        if (n &lt; 0)        &#123;            //被信号中断            if (errno == EINTR)                continue;            //出错，退出            break;        &#125;        else if (n == 0)        &#123;            //超时，继续            continue;        &#125;        for (size_t i = 0; i &lt; n; ++i)        &#123;            // 事件可读            if (epoll_events[i].events &amp; POLLIN)            &#123;                if (epoll_events[i].data.fd == listenfd)                &#123;                    //侦听socket，接受新连接                    struct sockaddr_in clientaddr;                    socklen_t clientaddrlen = sizeof(clientaddr);                    //接受客户端连接, 并加入到fds集合中                    int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);                    if (clientfd != -1)                    &#123;                        //将客户端socket设置为非阻塞的                        int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);                        int newSocketFlag = oldSocketFlag | O_NONBLOCK;                        if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)                        &#123;                            close(clientfd);                            std::cout &lt;&lt; &quot;set clientfd to nonblock error.&quot; &lt;&lt; std::endl;                                                &#125;                        else                        &#123;                            epoll_event client_fd_event;                            client_fd_event.events = POLLIN;                            client_fd_event.data.fd = clientfd;                                                     if(epoll_ctl(epollfd, EPOLL_CTL_ADD, clientfd, &amp;client_fd_event) != -1)                            &#123;                                std::cout &lt;&lt; &quot;new client accepted, clientfd: &quot; &lt;&lt; clientfd &lt;&lt; std::endl;                            &#125;                            else                            &#123;                                std::cout &lt;&lt; &quot;add client fd to epollfd error.&quot; &lt;&lt; std::endl;                                close(clientfd);                                                        &#125;                        &#125;                           &#125;                &#125;                else                 &#123;                    //普通clientfd,收取数据                    char buf[64] = &#123; 0 &#125;;                    int m = recv(epoll_events[i].data.fd, buf, 64, 0);                    if (m == 0)                    &#123;                        //对端关闭了连接，从epollfd上移除clientfd                        if(epoll_ctl(epollfd, EPOLL_CTL_DEL, epoll_events[i].data.fd, NULL) != -1)                        &#123;                            std::cout &lt;&lt; &quot;client disconnected, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;                        &#125;                        close(epoll_events[i].data.fd);                    &#125;                    else if (m &lt; 0)                    &#123;                                                                   //出错，从epollfd上移除clientfd                        if (errno != EWOULDBLOCK &amp;&amp; errno != EINTR)                        &#123;                            if(epoll_ctl(epollfd, EPOLL_CTL_DEL, epoll_events[i].data.fd, NULL) != -1)                            &#123;                                std::cout &lt;&lt; &quot;client disconnected, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;                            &#125;                            close(epoll_events[i].data.fd);                        &#125;                    &#125;                    else                    &#123;                        //正常收到数据                        std::cout &lt;&lt; &quot;recv from client: &quot; &lt;&lt; buf &lt;&lt; &quot;, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;                    &#125;                &#125;            &#125;            else if (epoll_events[i].events &amp; POLLERR)            &#123;                //TODO: 暂且不处理            &#125;        &#125;// end  outer-for-loop    &#125;// end  while-loop    //关闭侦听socket    //（理论上应该关闭包括所有clientfd在内的fd，但这里只是为了演示问题，就不写额外的代码来处理啦）    close(listenfd);                return 0;&#125;\n\n编译上述程序生成 epoll_server 并启动，然后使用 nc 命令启动三个客户端给服务器发数据效果如下图所示：\n\n","slug":"转载/网络编程/Linuxepoll模型（含LT模式和ET模式详解）","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"2a3c3c9ace4b4758d78bedda5e2402e0","title":"【转载】TCP协议如何解决粘包、半包问题","content":"TCP 协议如何解决粘包、半包问题一  TCP 协议是流式协议很多读者从接触网络知识以来，应该听说过这句话：TCP 协议是流式协议。那么这句话到底是什么意思呢？所谓流式协议，即协议的内容是像流水一样的字节流，内容与内容之间没有明确的分界标志，需要我们人为地去给这些协议划分边界。\n举个例子，A 与 B 进行 TCP 通信，A 先后给 B 发送了一个 100 字节和 200 字节的数据包，那么 B 是如何收到呢？B 可能先收到 100 字节，再收到 200 字节；也可能先收到 50 字节，再收到 250 字节；或者先收到 100 字节，再收到 100 字节，再收到 200 字节；或者先收到 20 字节，再收到 20 字节，再收到 60 字节，再收到 100 字节，再收到 50 字节，再收到 50 字节……\n不知道读者看出规律没有？规律就是 A 一共给 B 发送了 300 字节，B 可能以一次或者多次任意形式的总数为 300 字节收到。假设 A 给 B 发送的 100 字节和 200 字节分别都是一个数据包，对于发送端 A 来说，这个是可以区分的，但是对于 B 来说，如果不人为规定多长为一个数据包，B 每次是不知道应该把收到的数据中多少字节作为一个有效的数据包的。而规定每次把多少数据当成一个包就是协议格式规范的内容之一。\n经常会有新手写出类似下面这样的代码：\n发送端：\n1234//...省略创建socket，建立连接等部分不相关的逻辑...char buf[] = &quot;the quick brown fox jumps over a lazy dog.&quot;;int n = send(socket, buf, strlen(buf), 0);//...省略出错处理逻辑...\n\n接收端：\n12345//省略创建socket，建立连接等部分不相关的逻辑...char recvBuf[50] = &#123; 0 &#125;;int n = recv(socket, recvBuf, 50, 0);//省略出错处理逻辑...printf(&quot;recvBuf: %s&quot;, recvBuf);\n\n为了专注问题本身的讨论，我这里省略掉了建立连接和部分错误处理的逻辑。上述代码中发送端给接收端发送了一串字符”the quick brown fox jumps over a lazy dog.“，接收端收到后将其打印出来。\n类似这样的代码在本机一般会工作的很好，接收端也如期打印出来预料的字符串，但是一放到局域网或者公网环境就出问题了，即接收端可能打印出来字符串并不完整；如果发送端连续多次发送字符串，接收端会打印出来的字符串不完整或出现乱码。不完整的原因很好理解，即对端某次收到的数据小于完整字符串的长度，recvBuf 数组开始被清空成 0，收到部分字符串后，该字符串的末尾仍然是 0，printf 函数寻找以 0 为结束标志的字符结束输出；乱码的原因是如果某次收入的数据不仅包含一个完整的字符串，还包含下一个字符串部分内容，那么 recvBuf 数组将会被填满，printf 函数输出时仍然会寻找以 0 为结束标志的字符结束输出，这样读取的内存就越界了，一直找到为止，而越界后的内存可能是一些不可读字符，显示出来后就乱码了。\n我举这个例子希望你明白 能对TCP 协议是流式协议有一个直观的认识。正因为如此，所以我们需要人为地在发送端和接收端规定每一次的字节流边界，以便接收端知道从什么位置取出多少字节来当成一个数据包去解析，这就是我们设计网络通信协议格式的要做的工作之一。\n二 如何解决粘包问题网络通信程序实际开发中，或者技术面试时，面试官通常会问的比较多的一个问题是：网络通信时，如何解决粘包？\n\n有的面试官可能会这么问：网络通信时，如何解决粘包、丢包或者包乱序问题？这个问题其实是面试官在考察面试者的网络基础知识，如果是 TCP 协议，在大多数场景下，是不存在丢包和包乱序问题的，TCP 通信是可靠通信方式，TCP 协议栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发到目的地；如果是 UDP 协议，如果不能接受少量丢包，那就要自己在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了（例如 RTP协议、RUDP 协议）。所以，问题拆解后，只剩下如何解决粘包的问题。\n\n先来解释一下什么是粘包，所谓粘包就是连续给对端发送两个或者两个以上的数据包，对端在一次收取中可能收到的数据包大于 1 个，大于 1 个，可能是几个（包括一个）包加上某个包的部分，或者干脆就是几个完整的包在一起。当然，也可能收到的数据只是一个包的部分，这种情况一般也叫半包。\n无论是半包还是粘包问题，其根源是上文介绍中 TCP 协议是流式数据格式。解决问题的思路还是想办法从收到的数据中把包与包的边界给区分出来。那么如何区分呢？目前主要有三种方法：\n固定包长的数据包\n顾名思义，即每个协议包的长度都是固定的。举个例子，例如我们可以规定每个协议包的大小是 64 个字节，每次收满 64 个字节，就取出来解析（如果不够，就先存起来）。\n这种通信协议的格式简单但灵活性差。如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息，如 \\0（如果不填充特殊内容，如何区分包里面的正常内容与填充信息呢？）；如果包内容超过指定字节数，又得分包分片，需要增加额外处理逻辑——在发送端进行分包分片，在接收端重新组装包片（分包和分片内容在接下来会详细介绍）。\n以指定字符（串）为包的结束标志\n这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上”\\r\\n”（即所谓的 CRLF）表示一个包的结束。对端收到后，每遇到一个”\\r\\n“就把之前的数据当做一个数据包。\n这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。\n包头 + 包体格式\n这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。\n例如：\n12345struct msg_header&#123;  int32_t bodySize;  int32_t cmd;&#125;;\n\n这就是一个典型的包头格式，bodySize 指定了这个包的包体是多大。由于包头大小是固定的（这里是 size(int32_t) + sizeof(int32_t) &#x3D; 8 字节），对端先收取包头大小字节数目（当然，如果不够还是先缓存起来，直到收够为止），然后解析包头，根据包头中指定的包体大小来收取包体，等包体收够了，就组装成一个完整的包来处理。在有些实现中，包头中的 bodySize可能被另外一个叫 packageSize 的字段代替，这个字段的含义是整个包的大小，这个时候，我们只要用 packageSize 减去包头大小（这里是 sizeof(msg_header)）就能算出包体的大小，原理同上。\n\n在使用大多数网络库时，通常你需要根据协议格式自己给数据包分界和解析，一般的网络库不提供这种功能是出于需要支持不同的协议，由于协议的不确定性，因此没法预先提供具体解包代码。当然，这不是绝对的，也有一些网络库提供了这种功能。在 Java Netty 网络框架中，提供了FixedLengthFrameDecoder 类去处理长度是定长的协议包，提供了 DelimiterBasedFrameDecoder 类去处理按特殊字符作为结束符的协议包，提供 ByteToMessageDecoder 去处理自定义格式的协议包（可用来处理包头 + 包体 这种格式的数据包），然而在继承 ByteToMessageDecoder  子类中你需要根据你的协议具体格式重写 decode() 方法来对数据包解包。\n\n这三种包格式，希望读者能在理解其原理和优缺点的基础上深入掌握。\n三 解包与处理在理解了前面介绍的数据包的三种格式后，我们来介绍一下针对上述三种格式的数据包技术上应该如何处理。其处理流程都是一样的，这里我们以包头 + 包体 这种格式的数据包来说明。处理流程如下：\n\n假设我们的包头格式如下：\n12345678//强制一字节对齐#pragma pack(push, 1)//协议头struct msg&#123;       int32_t  bodysize;         //包体大小  &#125;;#pragma pack(pop)\n\n那么上面的流程实现代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546//包最大字节数限制为10M#define MAX_PACKAGE_SIZE    10 * 1024 * 1024void ChatSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)&#123;    while (true)    &#123;        //不够一个包头大小        if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))        &#123;            //LOGI &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);            return;        &#125;        //取包头信息        msg header;        memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));        //包头有错误，立即关闭连接        if (header.bodysize &lt;= 0 || header.bodysize &gt; MAX_PACKAGE_SIZE)        &#123;            //客户端发非法数据包，服务器主动关闭之            LOGE(&quot;Illegal package, bodysize: %lld, close TcpConnection, client: %s&quot;, header.bodysize, conn-&gt;peerAddress().toIpPort().c_str());            conn-&gt;forceClose();            return;        &#125;        //收到的数据不够一个完整的包        if (pBuffer-&gt;readableBytes() &lt; (size_t)header.bodysize + sizeof(msg))            return;        pBuffer-&gt;retrieve(sizeof(msg));        //inbuf用来存放当前要处理的包        std::string inbuf;        inbuf.append(pBuffer-&gt;peek(), header.bodysize);        pBuffer-&gt;retrieve(header.bodysize);                  //解包和业务处理        if (!Process(conn, inbuf.c_str(), inbuf.length()))        &#123;            //客户端发非法数据包，服务器主动关闭之            LOGE(&quot;Process package error, close TcpConnection, client: %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());            conn-&gt;forceClose();            return;        &#125;                  &#125;// end while-loop&#125;\n\n上述流程代码的处理过程和流程图中是一致的，pBuffer 这里是一个自定义的接收缓冲区，这里的代码，已经将收到的数据放入了这个缓冲区，所以判断当前已收取的字节数目只需要使用这个对象的相应方法即可。上述代码有些细节我需要强调一下：\n\n取包头时，你应该拷贝一份数据包头大小的数据出来，而不是从缓冲区 pBuffer 中直接将数据取出来（即取出来的数据从 pBuffer 中移除），这是因为倘若接下来根据包头中的字段得到包体大小时，如果剩余数据不够一个包体大小，你又得把这个包头数据放回缓冲区。为了避免这种不必要的操作，只有缓冲区数据大小够整个包的大小（代码中：header.bodysize + sizeof(msg)）你才需要把整个包大小的数据从缓冲区移除，这也是这里的 pBuffer-&gt;peek() 方法 peek 单词的含义（中文可以翻译成“瞟一眼”或者“偷窥”）。\n通过包头得到包体大小时，你一定要对 bodysize 的数值进行校验，我这里要求 bodysize 必须大于 0 且不大于 10 * 1024 * 1024（即 10 M）。当然，实际开发中，你可以根据你自己的需求要决定 bodysize 的上下限（包体大小是 0 字节的包在某些业务场景下是允许的）。记住，一定要判断这个上下限，因为假设这是一个非法的客户端发来的数据，其 bodysize 设置了一个比较大的数值，例如 1 * 1024 * 1024 * 1024（即 1 G），你的逻辑会让你一直缓存该客户端发来的数据，那么很快你的服务器内存将会被耗尽，操作系统在检测到你的进程占用内存达到一定阈值时会杀死你的进程，导致服务不能再正常对外服务。如果你检测了 bodysize 字段的是否满足你设置的上下限，对于非法的 bodysize，直接关闭这路连接即可。这也是服务的一种自我保护措施，避免因为非法数据包带来的损失。\n不知道你有没有注意到整个判断包头、包体以及处理包的逻辑放在一个 while 循环里面，这是必要的。如果没有这个 while 循环，当你一次性收到多个包时，你只会处理一个，下次接着处理就需要等到新一批数据来临时再次触发这个逻辑。这样造成的结果就是，对端给你发送了多个请求，你最多只能应答一个，后面的应答得等到对端再次给你发送数据时。这就是对粘包逻辑的正确处理。\n\n以上逻辑和代码是最基本的粘包和半包处理机制，也就是所谓的技术上的解包处理逻辑（业务上的解包处理逻辑后面章节再介绍）。希望读者能理解他们，在理解了他们的基础之上，我们可以给解包拓展很多功能，例如，我们再给我们的协议包增加一个支持压缩的功能，我们的包头变成下面这个样子：\n12345678910#pragma pack(push, 1)//协议头struct msg&#123;    char     compressflag;     //压缩标志，如果为1，则启用压缩，反之不启用压缩    int32_t  originsize;       //包体压缩前大小    int32_t  compresssize;     //包体压缩后大小    char     reserved[16];       //保留字段，用于将来拓展&#125;;#pragma pack(pop)\n\n修改后的代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void ChatSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)&#123;    while (true)    &#123;        //不够一个包头大小        if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))        &#123;            //LOGI &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);            return;        &#125;        //取包头信息        msg header;        memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));        //数据包压缩过        if (header.compressflag == PACKAGE_COMPRESSED)        &#123;            //包头有错误，立即关闭连接            if (header.compresssize &lt;= 0 || header.compresssize &gt; MAX_PACKAGE_SIZE ||                header.originsize &lt;= 0 || header.originsize &gt; MAX_PACKAGE_SIZE)            &#123;                //客户端发非法数据包，服务器主动关闭之                LOGE(&quot;Illegal package, compresssize: %lld, originsize: %lld, close TcpConnection, client: %s&quot;,  header.compresssize, header.originsize, conn-&gt;peerAddress().toIpPort().c_str());                conn-&gt;forceClose();                return;            &#125;            //收到的数据不够一个完整的包            if (pBuffer-&gt;readableBytes() &lt; (size_t)header.compresssize + sizeof(msg))                return;            pBuffer-&gt;retrieve(sizeof(msg));            std::string inbuf;            inbuf.append(pBuffer-&gt;peek(), header.compresssize);            pBuffer-&gt;retrieve(header.compresssize);            std::string destbuf;            if (!ZlibUtil::UncompressBuf(inbuf, destbuf, header.originsize))            &#123;                LOGE(&quot;uncompress error, client: %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());                conn-&gt;forceClose();                return;            &#125;            //业务逻辑处理            if (!Process(conn, destbuf.c_str(), destbuf.length()))            &#123;                //客户端发非法数据包，服务器主动关闭之                LOGE(&quot;Process error, close TcpConnection, client: %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());                conn-&gt;forceClose();                return;            &#125;        &#125;        //数据包未压缩        else        &#123;            //包头有错误，立即关闭连接            if (header.originsize &lt;= 0 || header.originsize &gt; MAX_PACKAGE_SIZE)            &#123;                //客户端发非法数据包，服务器主动关闭之                LOGE(&quot;Illegal package, compresssize: %lld, originsize: %lld, close TcpConnection, client: %s&quot;, header.compresssize, header.originsize, conn-&gt;peerAddress().toIpPort().c_str());                conn-&gt;forceClose();                return;            &#125;            //收到的数据不够一个完整的包            if (pBuffer-&gt;readableBytes() &lt; (size_t)header.originsize + sizeof(msg))                return;            pBuffer-&gt;retrieve(sizeof(msg));            std::string inbuf;            inbuf.append(pBuffer-&gt;peek(), header.originsize);            pBuffer-&gt;retrieve(header.originsize);            //业务逻辑处理            if (!Process(conn, inbuf.c_str(), inbuf.length()))            &#123;                //客户端发非法数据包，服务器主动关闭之                LOGE(&quot;Process error, close TcpConnection, client: %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());                conn-&gt;forceClose();                return;            &#125;        &#125;// end else    &#125;// end while-loop&#125;\n\n这段代码先根据包头的压缩标志字段判断包体是否有压缩，如果有压缩，则取出包体大小去解压，解压后的数据才是真正的业务数据。整个程序执行流程图如下：\n\n","slug":"转载/网络编程/TCP协议如何解决粘包、半包问题","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"a48f84a55618baa7dd151ec12f4ef58e","title":"【转载】bind函数重难点解析","content":"bind 函数重难点解析bind 函数如何选择绑定地址bind 函数的基本用法如下：\n123456789struct sockaddr_in bindaddr;bindaddr.sin_family = AF_INET;bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);bindaddr.sin_port = htons(3000);if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)&#123;    std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;    return -1;&#125;\n\n其中 bind 的地址我们使用了一个宏叫 INADDR_ANY ，关于这个宏的解释如下：\n12345678If an application does not care what local address is assigned, specify the constant value INADDR_ANY for an IPv4 local addressor the constant value in6addr_any for an IPv6 local address in the sa_data member of the name parameter. This allows the underlying service provider to use any appropriate network address,potentially simplifying application programming in the presence of multihomed hosts (that is, hosts that have more than one network interface and address).\n\n意译一下：\n123如果应用程序不关心bind绑定的ip地址，可以使用INADDR_ANY(如果是IPv6，则对应in6addr_any)，这样底层的（协议栈）服务会自动选择一个合适的ip地址，这样使在一个有多个网卡机器上选择ip地址问题变得简单。\n\n也就是说 INADDR_ANY 相当于地址 0.0.0.0。可能读者还是不太明白我想表达什么。这里我举个例子，假设我们在一台机器上开发一个服务器程序，使用 bind 函数时，我们有多个ip 地址可以选择。首先，这台机器对外访问的ip地址是120.55.94.78，这台机器在当前局域网的地址是192.168.1.104；同时这台机器有本地回环地址127.0.0.1。\n如果你指向本机上可以访问，那么你 bind 函数中的地址就可以使用127.0.0.1; 如果你的服务只想被局域网内部机器访问，bind 函数的地址可以使用192.168.1.104；如果 希望这个服务可以被公网访问，你就可以使用地址0.0.0.0或 INADDR_ANY。\nbind 函数端口号问题网络通信程序的基本逻辑是客户端连接服务器，即从客户端的地址:端口连接到服务器地址:端口上，以 4.2 小节中的示例程序为例，服务器端的端口号使用 3000，那客户端连接时的端口号是多少呢？TCP 通信双方中一般服务器端端口号是固定的，而客户端端口号是连接发起时由操作系统随机分配的（不会分配已经被占用的端口）。端口号是一个 C short 类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下压力测试程序理论上最多只能发起六万五千多个连接。注意我说的是理论上，在实际情况下，由于当时的操作系统很多端口可能已经被占用，实际可以使用的端口比这个更少，例如，一般规定端口号在1024以下的端口是保留端口，不建议用户程序使用。而对于 Windows 系统，MSDN 甚至明确地说：\n\nOn Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000.Vista 及以后的Windows，可用的动态端口范围是49152～65535，而 Windows Server及更早的系统，可以的动态端口范围是1025~5000。（你可以通过修改注册表来改变这一设置，参考网址：https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind）\n\n如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口，当然服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的ip地址和端口号。\n很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。\n我们用代码来实际验证一下上路所说的，为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。\n\n情形一：客户端代码不绑定端口\n\n修改后的服务器代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * TCP服务器通信基本流程 * zhangyl 2018.12.13 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;int main(int argc, char* argv[])&#123;    //1.创建一个侦听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1)    &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //3.启动侦听    if (listen(listenfd, SOMAXCONN) == -1)    &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //记录所有客户端连接的容器    std::vector&lt;int&gt; clientfds;    while (true)    &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);        //4. 接受客户端连接        int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);        if (clientfd != -1)        &#123;                         char recvBuf[32] = &#123;0&#125;;            //5. 从客户端接受数据            int ret = recv(clientfd, recvBuf, 32, 0);            if (ret &gt; 0)             &#123;                std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;                //6. 将收到的数据原封不动地发给客户端                ret = send(clientfd, recvBuf, strlen(recvBuf), 0);                if (ret != strlen(recvBuf))                    std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                std::cout &lt;&lt; &quot;send data to client successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;            &#125;             else             &#123;                std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;            &#125;            //close(clientfd);            clientfds.push_back(clientfd);        &#125;    &#125;    //7.关闭侦听socket    close(listenfd);    return 0;&#125;\n\n修改后的客户端代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * TCP客户端通信基本流程 * zhangyl 2018.12.13 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //3. 向服务器发送数据    int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);    if (ret != strlen(SEND_DATA))    &#123;        std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;    //4. 从客户端收取数据    char recvBuf[32] = &#123;0&#125;;    ret = recv(clientfd, recvBuf, 32, 0);    if (ret &gt; 0)     &#123;        std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125;     else     &#123;        std::cout &lt;&lt; &quot;recv data error, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125;    //5. 关闭socket    //close(clientfd);    //这里仅仅是为了让客户端程序不退出    while (true)     &#123;        sleep(3);    &#125;    return 0;&#125;\n\n将程序编译好后（编译方法和上文一样），我们先启动server，再启动三个客户端。然后通过 lsof 命令查看当前机器上的 TCP 连接信息，为了更清楚地显示结果，已经将不相关的连接信息去掉了，结果如下所示：\n123456789[root@localhost ~]# lsof -i -PnCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1445 root    3u  IPv4  21568      0t0  TCP *:3000 (LISTEN)server   1445 root    4u  IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)server   1445 root    5u  IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)server   1445 root    6u  IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)client   1447 root    3u  IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)client   1448 root    3u  IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)client   1449 root    3u  IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)\n\n上面的结果显示，server 进程（进程 ID 是 1445）在 3000 端口开启侦听，有三个 client 进程（进程 ID 分别是1447、1448、1449）分别通过端口号 40818、40820、40822 连到 server 进程上的，作为客户端的一方，端口号是系统随机分配的。\n\n情形二：客户端绑定端口号 0\n服务器端代码保持不变，我们修改下客户端代码：\n1234/** * TCP服务器通信基本流程 * zhangyl 2018.12.13 */\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;  //1.创建一个socket  int clientfd = socket(AF_INET, SOCK_STREAM, 0);  if (clientfd == -1)  &#123;      std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;      return -1;  &#125;  struct sockaddr_in bindaddr;  bindaddr.sin_family = AF_INET;  bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);  //将socket绑定到0号端口上去  bindaddr.sin_port = htons(0);  if (bind(clientfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)  &#123;      std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;      return -1;  &#125;  //2.连接服务器  struct sockaddr_in serveraddr;  serveraddr.sin_family = AF_INET;  serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);  serveraddr.sin_port = htons(SERVER_PORT);  if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)  &#123;      std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;      return -1;  &#125;  //3. 向服务器发送数据  int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);  if (ret != strlen(SEND_DATA))  &#123;      std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;      return -1;  &#125;  std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;  //4. 从客户端收取数据  char recvBuf[32] = &#123;0&#125;;  ret = recv(clientfd, recvBuf, 32, 0);  if (ret &gt; 0)   &#123;      std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;  &#125;   else   &#123;      std::cout &lt;&lt; &quot;recv data error, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;  &#125;  //5. 关闭socket  //close(clientfd);  //这里仅仅是为了让客户端程序不退出  while (true)   &#123;      sleep(3);  &#125;  return 0;&#125;\n\n我们再次编译客户端程序，并启动三个 client 进程，然后用 lsof 命令查看机器上的 TCP 连接情况，结果如下所示：\n123456789[root@localhost ~]# lsof -i -PnCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1593 root    3u  IPv4  21807      0t0  TCP *:3000 (LISTEN)server   1593 root    4u  IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)server   1593 root    5u  IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)server   1593 root    6u  IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)client   1595 root    3u  IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)client   1611 root    3u  IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)client   1627 root    3u  IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)\n\n通过上面的结果，我们发现三个 client 进程使用的端口号仍然是系统随机分配的，也就是说绑定 0 号端口和没有绑定效果是一样的。\n\n情形三：客户端绑定一个固定端口\n我们这里使用 20000 端口，当然读者可以根据自己的喜好选择，只要保证所选择的端口号当前没有被其他程序占用即可，服务器代码保持不变，客户端绑定代码中的端口号从 0 改成 20000。这里为了节省篇幅，只贴出修改处的代码：\n12345678910struct sockaddr_in bindaddr;bindaddr.sin_family = AF_INET;bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);//将socket绑定到20000号端口上去bindaddr.sin_port = htons(20000);if (bind(clientfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)&#123;    std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;    return -1;&#125;\n\n再次重新编译程序，先启动一个客户端后，我们看到此时的 TCP 连接状态：\n12345[root@localhost testsocket]# lsof -i -PnCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)server   1676 root    4u  IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)client   1678 root    3u  IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)\n\n通过上面的结果，我们发现 client 进程确实使用 20000 号端口连接到 server 进程上去了。这个时候如果我们再开启一个 client 进程，我们猜想由于端口号 20000 已经被占用，新启动的 client 会由于调用 bind 函数出错而退出，我们实际验证一下：\n123[root@localhost testsocket]# ./client bind socket error.[root@localhost testsocket]# \n\n结果确实和我们预想的一样。\n\n\n在技术面试的时候，有时候面试官会问 TCP 网络通信的客户端程序中的 socket 是否可以调用 bind 函数，相信读到这里，聪明的读者已经有答案了。\n另外，Linux 的 nc 命令有个 -p 选项（字母 p 是小写），这个选项的作用就是 nc 在模拟客户端程序时，可以使用指定端口号连接到服务器程序上去，实现原理相信读者也明白了。我们还是以上面的服务器程序为例，这个我们不用我们的 client 程序，改用 nc 命令来模拟客户端。在 shell 终端输入：\n12345[root@localhost testsocket]# nc -v -p 9999 127.0.0.1 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Connected to 127.0.0.1:3000.My name is zhangxfMy name is zhangxf\n\n-v 选项表示输出 nc 命令连接的详细信息，这里连接成功以后，会输出“**Ncat: Connected to 127.0.0.1:3000.**” 提示已经连接到服务器的 3000 端口上去了。\n-p 选项的参数值是 9999 表示，我们要求 nc 命令本地以端口号 9999 连接服务器，注意不要与端口号 3000 混淆，3000 是服务器的侦听端口号，也就是我们的连接的目标端口号，9999 是我们客户端使用的端口号。我们用 lsof 命令来验证一下我们的 nc 命令是否确实以 9999 端口号连接到 server 进程上去了。\n12345[root@localhost testsocket]# lsof -i -PnCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)server   1676 root    7u  IPv4  22405      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:9999 (ESTABLISHED)nc       2005 root    3u  IPv4  22408      0t0  TCP 127.0.0.1:9999-&gt;127.0.0.1:3000 (ESTABLISHED)\n\n结果确实如我们期望的一致。\n当然，我们用 nc 命令连接上 server 进程以后，我们还给服务器发了一条消息”My name is zhangxf“，server 程序收到消息后把这条消息原封不动地返还给我们，以下是 server 端运行结果：\n1234[root@localhost testsocket]# ./server   recv data from client, data: My name is zhangxfsend data to client successfully, data: My name is zhangxf\n\n关于 lsof 和 nc 命令我们会在后面的系列文章中详细讲解。\n","slug":"转载/网络编程/bind函数重难点解析","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"424888f17e8d4fef03209498cc4923a5","title":"【转载】select函数重难点解析","content":"select 函数重难点解析select 函数是网络通信编程中非常常用的一个函数，因此应该熟练掌握它。虽然它是 BSD 标准之一的 Socket 函数之一，但在 Linux 和 Windows 平台，其行为表现还是有点区别的。我们先来看一下 Linux 平台上的 select 函数。\nLinux 平台下的 select 函数select 函数的作用是检测一组 socket 中某个或某几个是否有“事件”，这里的“事件”一般分为如下三类：\n\n可读事件，一般意味着可以调用 recv 或 read 函数从该 socket 上读取数据；如果该 socket 是侦听 socket（即调用了 bind 函数绑定过 ip 地址和端口号，并调用了 listen 启动侦听的 socket），可读意味着此时可以有新的客户端连接到来，此时可调用 accept 函数接受新连接。\n可写事件，一般意味着此时调用 send 或 write 函数可以将数据“发出去”。\n异常事件，某个 socket 出现异常。\n\n函数签名如下：\n12345int select(int nfds,            fd_set *readfds,           fd_set *writefds,           fd_set *exceptfds,           struct timeval *timeout);\n\n参数说明：\n\n参数 nfds， Linux 下 socket 也称 fd，这个参数的值设置成所有需要使用 select 函数监听的 fd 中最大 fd 值加 1。\n\n参数 readfds，需要监听可读事件的 fd 集合。\n\n参数 writefds，需要监听可写事件的 fd 集合。\n\n参数 exceptfds，需要监听异常事件 fd 集合。\nreadfds、writefds 和 exceptfds 类型都是 fd_set，这是一个结构体信息，其定义位于 &#x2F;usr&#x2F;include&#x2F;sys&#x2F;select.h 中：\n1234567891011121314151617181920212223242526272829/* The fd_set member is required to be an array of longs.  */typedef long int __fd_mask;/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */#undef  __NFDBITS/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */#define __NFDBITS       (8 * (int) sizeof (__fd_mask))#define __FD_ELT(d)     ((d) / __NFDBITS)#define __FD_MASK(d)    ((__fd_mask) 1 &lt;&lt; ((d) % __NFDBITS))/* fd_set for select and pselect.  */typedef struct&#123;  /* XPG4.2 requires this member name.  Otherwise avoid the name     from the global namespace.  */#ifdef __USE_XOPEN  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;fds_bits)#else  // 在我的centOS 7.0 系统中的值：  // __FD_SETSIZE = 1024  //__NFDBITS = 64  __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];     # define __FDS_BITS(set) ((set)-&gt;__fds_bits)#endif&#125; fd_set;/* Maximum number of file descriptors in &#x27;fd_set&#x27;.  */#define FD_SETSIZE              __FD_SETSIZE\n\n我们假设未定义宏 __USE_XOPEN，将上面的代码整理一下：\n1234typedef struct&#123;   long int __fds_bits[16];     &#125; fd_set;\n\n将一个 fd 添加到 fd_set 这个集合中需要使用 FD_SET 宏，其定义如下：\n1void FD_SET(int fd, fd_set *set);\n\n其实现如下：\n1#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)\n\nFD_SET 在内部又是通过宏 __FD_SET 来实现的，**__FD_SET** 的定义如下（位于 &#x2F;usr&#x2F;include&#x2F;bits&#x2F;select.h 中）：\n123456789101112131415161718192021222324252627282930313233343536373839#if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2# if __WORDSIZE == 64#  define __FD_ZERO_STOS &quot;stosq&quot;# else#  define __FD_ZERO_STOS &quot;stosl&quot;# endif# define __FD_ZERO(fdsp) \\do &#123;                                                                        \\  int __d0, __d1;                                                           \\  __asm__ __volatile__ (&quot;cld; rep; &quot; __FD_ZERO_STOS                         \\                        : &quot;=c&quot; (__d0), &quot;=D&quot; (__d1)                          \\                        : &quot;a&quot; (0), &quot;0&quot; (sizeof (fd_set)                     \\                                        / sizeof (__fd_mask)),              \\                          &quot;1&quot; (&amp;__FDS_BITS (fdsp)[0])                       \\                        : &quot;memory&quot;);                                        \\&#125; while (0)#else   /* ! GNU CC *//* We don&#x27;t use `memset&#x27; because this would require a prototype and the array isn&#x27;t too big.  */# define __FD_ZERO(set)  \\do &#123;                                                                        \\  unsigned int __i;                                                         \\  fd_set *__arr = (set);                                                    \\  for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)          \\    __FDS_BITS (__arr)[__i] = 0;                                            \\&#125; while (0)#endif  /* GNU CC */#define __FD_SET(d, set) \\((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))#define __FD_CLR(d, set) \\((void) (__FDS_BITS (set)[__FD_ELT (d)] &amp;= ~__FD_MASK (d)))#define __FD_ISSET(d, set) \\((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)\n\n重点看这一行：\n1((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))\n\n__FD_MASK 和 __FD_ELT 宏在上面的代码中已经给出定义：\n12#define __FD_ELT(d)     ((d) / __NFDBITS)#define __FD_MASK(d)    ((__fd_mask) 1 &lt;&lt; ((d) % __NFDBITS))\n\n__NFDBITS 的值是 64 （8 * 8），也就是说 __FD_MASK (d) 先计算 fd 与 64 的余数 n，然后执行 1 &lt;&lt; n，这一操作实际上是将 fd 的值放在 0～63 这 64 的位置上去，这个位置索引就是 fd 与 64 取模的结果；同理 __FD_ELT(d) 就是计算位置索引值了。举个例子，假设现在 fd 的 值是 57，那么在这 64 个位置的 57 位，其值在 64 个长度的二进制中置位是：\n10000 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n这个值就是 1 &lt;&lt; (57 % 64) 得到的数字。\n但是前面 fd 数组的定义是：\n1234typedef struct&#123;   long int __fds_bits[16];    //可以看成是128 bit的数组 &#125; fd_set;\n\nlong int 占 8 个字节，一个 16 个 long int，如果换成二进制的位(bit)就是 8 * 16 &#x3D; 128， 也就是这个数组只用了低 64 位， 高 64 位并没有使用。这说明在我的机器上，select 函数支持操作的最大 fd 数量是 64。\n同理，如果我们需要从 fd_set 上删除一个 fd，我们可以调用 FD_CLR，其定义如下：\n1void FD_CLR(int fd, fd_set *set);\n\n原理和 FD_SET 相同，即将对应的标志位由1变0即可。\n如果，我们需要将 fd_set 中所有的 fd 都清掉，则使用宏 FD_ZERO：\n1void FD_ZERO(fd_set *set);\n\n当 select 函数返回时， 我们使用 FD_ISSET 宏来判断某个 fd 是否有我们关心的事件，FD_ISSET 宏的定义如下：\n\n\n1int  FD_ISSET(int fd, fd_set *set);\n\nFD_ISSET 宏本质上就是检测对应的位置上是否置 1，实现如下：\n12#define __FD_ISSET(d, set) \\    ((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)\n\n\n提醒一下： __FD_ELT 和 __FD_MASK 宏前文的代码已经给过具体实现了。\n\n\n参数 timeout，超时时间，即在这个参数设定的时间内检测这些 fd 的事件，超过这个时间后 select 函数将立即返回。这是一个 timeval 类型结构体，其定义如下：\n12345struct timeval &#123;  long    tv_sec;         /* seconds */  long    tv_usec;        /* microseconds */&#125;;\n\nselect 函数的总超时时间是 timeout-&gt;tv_sec 和 timeout-&gt;tv_usec 之和， 前者的时间单位是秒，后者的时间单位是微妙。\n\n\n说了这么多理论知识，我们先看一个具体的示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/** * select函数示例，server端, select_server.cpp * zhangyl 2018.12.24 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;sys/time.h&gt;#include &lt;vector&gt;#include &lt;errno.h&gt;//自定义代表无效fd的值#define INVALID_FD -1int main(int argc, char* argv[])&#123;    //创建一个侦听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1)    &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //启动侦听    if (listen(listenfd, SOMAXCONN) == -1)    &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //存储客户端socket的数组    std::vector&lt;int&gt; clientfds;    int maxfd = listenfd;    while (true)     &#123;           fd_set readset;        FD_ZERO(&amp;readset);        //将侦听socket加入到待检测的可读事件中去        FD_SET(listenfd, &amp;readset);        //将客户端fd加入到待检测的可读事件中去        int clientfdslength = clientfds.size();        for (int i = 0; i &lt; clientfdslength; ++i)        &#123;            if (clientfds[i] != INVALID_FD)            &#123;                FD_SET(clientfds[i], &amp;readset);            &#125;        &#125;        timeval tm;        tm.tv_sec = 1;        tm.tv_usec = 0;        //暂且只检测可读事件，不检测可写和异常事件        int ret = select(maxfd + 1, &amp;readset, NULL, NULL, &amp;tm);        if (ret == -1)        &#123;            //出错，退出程序。            if (errno != EINTR)                break;        &#125;        else if (ret == 0)        &#123;            //select 函数超时，下次继续            continue;        &#125; else &#123;            //检测到某个socket有事件            if (FD_ISSET(listenfd, &amp;readset))            &#123;                //侦听socket的可读事件，则表明有新的连接到来                struct sockaddr_in clientaddr;                socklen_t clientaddrlen = sizeof(clientaddr);                //4. 接受客户端连接                int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);                if (clientfd == -1)                                 &#123;                               //接受连接出错，退出程序                    break;                &#125;                //只接受连接，不调用recv收取任何数据                std:: cout &lt;&lt; &quot;accept a client connection, fd: &quot; &lt;&lt; clientfd &lt;&lt; std::endl;                clientfds.push_back(clientfd);                //记录一下最新的最大fd值，以便作为下一轮循环中select的第一个参数                if (clientfd &gt; maxfd)                    maxfd = clientfd;            &#125;             else             &#123;                //假设对端发来的数据长度不超过63个字符                char recvbuf[64];                int clientfdslength = clientfds.size();                for (int i = 0; i &lt; clientfdslength; ++i)                &#123;                    if (clientfds[i] != -1 &amp;&amp; FD_ISSET(clientfds[i], &amp;readset))                    &#123;                                       memset(recvbuf, 0, sizeof(recvbuf));                        //非侦听socket，则接收数据                        int length = recv(clientfds[i], recvbuf, 64, 0);                        if (length &lt;= 0 &amp;&amp; errno != EINTR)                        &#123;                            //收取数据出错了                            std::cout &lt;&lt; &quot;recv data error, clientfd: &quot; &lt;&lt; clientfds[i] &lt;&lt; std::endl;                                                        close(clientfds[i]);                            //不直接删除该元素，将该位置的元素置位-1                            clientfds[i] = INVALID_FD;                            continue;                        &#125;                        std::cout &lt;&lt; &quot;clientfd: &quot; &lt;&lt; clientfds[i] &lt;&lt; &quot;, recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;                                       &#125;                &#125;            &#125;        &#125;    &#125;    //关闭所有客户端socket    int clientfdslength = clientfds.size();    for (int i = 0; i &lt; clientfdslength; ++i)    &#123;        if (clientfds[i] != INVALID_FD)        &#123;            close(clientfds[i]);        &#125;    &#125;    //关闭侦听socket    close(listenfd);    return 0;&#125;\n\n我们编译并运行程序：\n12[root@localhost testsocket]# g++ -g -o select_server select_server.cpp [root@localhost testsocket]# ./select_server \n\n然后，我们再多开几个 shell 窗口，我们这里不再专门编写客户端程序了，我们使用 Linux 下的 nc 指令模拟出两个客户端。\nshell 窗口1，连接成功以后发送字符串 hello123：\n1234[root@localhost ~]# nc -v 127.0.0.1 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Connected to 127.0.0.1:3000.hello123\n\nshell 窗口2，连接成功以后发送字符串 helloworld：\n1234[root@localhost ~]# nc -v 127.0.0.1 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Connected to 127.0.0.1:3000.helloworld\n\n此时服务器端输出结果如下：\n\n注意，由于 nc 发送的数据是按换行符来区分的，每一个数据包默认的换行符以\\n 结束（当然，你可以 -C 选项换成\\r\\n），所以服务器收到数据后，显示出来的数据每一行下面都有一个空白行。\n当断开各个客户端连接时，服务器端 select 函数对各个客户端 fd 检测时，仍然会触发可读事件，此时对这些 fd 调用 recv 函数会返回 0（recv 函数返回0，表明对端关闭了连接，这是一个很重要的知识点，下文我们会有一章节专门介绍这些函数的返回值），服务器端也关闭这些连接就可以了。\n客户端断开连接后，服务器端的运行输出结果：\n\n以上代码是一个简单的服务器程序实现的基本流程，代码虽然简单，但是非常具有典型性和代表性，而且同样适用于客户端网络通信，如果用于客户端的话，只需要用 select 检测连接 socket 就可以了，如果连接 socket 有可读事件，调用 recv 函数来接收数据，剩下的逻辑都是一样的。上面的代码我们画一张流程图如下：\n\n关于上述代码在实际开发中有几个需要注意的事项，这里逐一来说明一下：\n1. select 函数调用前后会修改 readfds、writefds 和 exceptfds 这三个集合中的内容（如果有的话），所以如果您想下次调用 select 复用这个变量，记得在下次调用前再次调用 select 前先使用 FD_ZERO 将集合清零，然后调用 FD_SET 将需要检测事件的 fd 再次添加进去。\n\nselect 函数调用之后，readfds、writefds 和 exceptfds 这三个集合中存放的不是我们之前设置进去的 fd，而是有相关有读写或异常事件的 fd，也就是说 select 函数会修改这三个参数的内容，这也要求我们当一个 fd_set 被 select 函数调用后，这个 fd_set 就已经发生了改变，下次如果我们需要使用它，必须使用 FD_ZERO 宏先清零，再重新将我们关心的 fd 设置进去。这点我们从 FD_ISSET 源码也可以看出来：\n\n12#define __FD_ISSET(d, set) \\   ((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)\n\n如果调用 select 函数之后没有改变 fd_set 集合，那么即使某个 socket 上没有事件，调用 select 函数之后我们用 FD_ISSET 检测，会原路得到原来设置上去的 socket。这是很多初学者在学习 select 函数容易犯的一个错误，我们通过一个示例来验证一下，这次我们把 select 函数用在客户端。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 验证调用select后必须重设fd_set，select_client.cpp * zhangyl 2018.12.24 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000int main(int argc, char* argv[])&#123;    //创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    fd_set readset;    FD_ZERO(&amp;readset);    //将侦听socket加入到待检测的可读事件中去    FD_SET(clientfd, &amp;readset);     timeval tm;    tm.tv_sec = 5;    tm.tv_usec = 0;     int ret;    int count = 0;    fd_set backup_readset;    memcpy(&amp;backup_readset, &amp;readset, sizeof(fd_set));    while (true)    &#123;        if (memcmp(&amp;readset, &amp;backup_readset, sizeof(fd_set)) == 0)        &#123;            std::cout &lt;&lt; &quot;equal&quot; &lt;&lt; std::endl;        &#125;        else        &#123;            std::cout &lt;&lt; &quot;not equal&quot; &lt;&lt; std::endl;        &#125;        //暂且只检测可读事件，不检测可写和异常事件        ret = select(clientfd + 1, &amp;readset, NULL, NULL, &amp;tm);        std::cout &lt;&lt; &quot;tm.tv_sec: &quot; &lt;&lt; tm.tv_sec &lt;&lt; &quot;, tm.tv_usec: &quot; &lt;&lt; tm.tv_usec &lt;&lt; std::endl;        if (ret == -1)        &#123;            //除了被信号中断的情形，其他情况都是出错            if (errno != EINTR)                break;        &#125; else if (ret == 0)&#123;            //select函数超时            std::cout &lt;&lt; &quot;no event in specific time interval, count：&quot; &lt;&lt; count &lt;&lt; std::endl;            ++count;            continue;        &#125; else &#123;            if (FD_ISSET(clientfd, &amp;readset))            &#123;                //检测到可读事件                char recvbuf[32];                memset(recvbuf, 0, sizeof(recvbuf));                //假设对端发数据的时候不超过31个字符。                int n = recv(clientfd, recvbuf, 32, 0);                if (n &lt; 0)                &#123;                    //除了被信号中断的情形，其他情况都是出错                    if (errno != EINTR)                        break;                &#125; else if (n == 0) &#123;                    //对端关闭了连接                    break;                &#125; else &#123;                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;                &#125;            &#125;            else             &#123;                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;            &#125;        &#125;    &#125;           //关闭socket    close(clientfd);    return 0;&#125;\n\n在 shell 窗口输入以下命令编译程序产生可执行文件 select_client：\n1g++ -g -o select_client select_client.cpp\n\n这次产生的是客户端程序，服务器程序我们这里使用 Linux nc 命令来模拟一下，由于客户端连接的是 127.0.0.1:3000 这个地址和端口号，所以我们在另外一个shell 窗口的 nc 命令的参数可以这么写：\n1nc -v -l 0.0.0.0 3000\n\n执行效果如下：接着我们启动客户端 select_client：\n1[root@myaliyun testsocket]# ./select_client \n\n需要注意的是，这里我故意将客户端代码中 select 函数的超时时间设置为5秒，以足够我们在这 5 秒内给客户端发一个数据。如果我们在 5 秒内给客户端发送 hello 字符串：\n\n客户端输出如下：\n123456789101112131415161718[root@myaliyun testsocket]# ./select_client equalrecv data: hello...部分数据省略...not equaltm.tv_sec: 0, tm.tv_usec: 0no event in specific time interval, count：31454not equaltm.tv_sec: 0, tm.tv_usec: 0no event in specific time interval, count：31455not equaltm.tv_sec: 0, tm.tv_usec: 0no event in specific time interval, count：31456not equaltm.tv_sec: 0, tm.tv_usec: 0no event in specific time interval, count：31457...部分输出省略...\n\n除了第一次 select_client 会输出 equal 字样，后面再也没输出，而 select 函数以后的执行结果也是超时，即使此时服务器端再次给客户端发送数据。因此验证了：select 函数执行后，确实会对三个参数的 fd_set 进行修改 。select 函数修改某个 fd_set 集合可以使用如下两张图来说明一下：\n\n\n因此在调用 select 函数以后， 原来位置的的标志位可能已经不复存在，这也就是为什么我们的代码中调用一次 select 函数以后，即使服务器端再次发送数据过来，select 函数也不会再因为存在可读事件而返回了，因为第二次 clientfd 已经不在那个 read_set 中了。因此如果复用这些 fd_set 变量，必须按上文所说的重新清零再重新添加关心的 socket 到集合中去。\n2. select 函数也会修改 timeval 结构体的值，这也要求我们如果像复用这个变量，必须给 timeval 变量重新设置值。\n注意观察上面的例子的输出，我们在调用 select 函数一次之后，变量 tv 的值也被修改了。具体修改成多少，得看系统的表现。当然这种特性却不是跨平台的，在 Linux 系统中是这样的，而在其他操作系统上却不一定是这样（Windows 上就不会修改这个结构体的值），这点在 Linux man 手册 select 函数的说明中说的很清楚：\n12345678On  Linux,  select()  modifies timeout to reflect the amountof time not slept; most other implementations do not do this.(POSIX.1-2001 permits either behavior.)  This causes problems both when Linux code which reads timeout is ported to  other operating systems, and when code is ported to Linux that reusesa struct timeval for multiple select()s in a loop withoutreinitializing it.  Consider timeout to be undefined afterselect() returns.\n\n由于不同系统的实现不一样，man 手册的建议将 select 函数修改 timeval 结构体的值的行为当作是未定义的，言下之意是如果你要下次使用 select 函数复用这个变量时，记得重新赋值。这是 select 函数需要注意的第二个地方。\n3. select 函数的 timeval 结构体的 tv_sec 和 tv_sec 如果两个值设置为 0，即检测事件总时间设置为0，其行为是 select 会检测一下相关集合中的 fd，如果没有需要的事件，则立即返回。\n我们将上述 select_client.cpp 修改一下，修改后的代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 验证select时间参数设置为0，select_client_tv0.cpp * zhangyl 2018.12.25 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000int main(int argc, char* argv[])&#123;    //创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    int ret;    while (true)    &#123;        fd_set readset;        FD_ZERO(&amp;readset);        //将侦听socket加入到待检测的可读事件中去        FD_SET(clientfd, &amp;readset);         timeval tm;        tm.tv_sec = 0;        tm.tv_usec = 0;         //暂且只检测可读事件，不检测可写和异常事件        ret = select(clientfd + 1, &amp;readset, NULL, NULL, &amp;tm);        std::cout &lt;&lt; &quot;tm.tv_sec: &quot; &lt;&lt; tm.tv_sec &lt;&lt; &quot;, tm.tv_usec: &quot; &lt;&lt; tm.tv_usec &lt;&lt; std::endl;        if (ret == -1)        &#123;            //除了被信号中断的情形，其他情况都是出错            if (errno != EINTR)                break;        &#125; else if (ret == 0)&#123;            //select函数超时            std::cout &lt;&lt; &quot;no event in specific time interval.&quot; &lt;&lt; std::endl;            continue;        &#125; else &#123;            if (FD_ISSET(clientfd, &amp;readset))            &#123;                //检测到可读事件                char recvbuf[32];                memset(recvbuf, 0, sizeof(recvbuf));                //假设对端发数据的时候不超过31个字符。                int n = recv(clientfd, recvbuf, 32, 0);                if (n &lt; 0)                &#123;                    //除了被信号中断的情形，其他情况都是出错                    if (errno != EINTR)                        break;                &#125; else if (n == 0) &#123;                    //对端关闭了连接                    break;                &#125; else &#123;                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;                &#125;            &#125;            else             &#123;                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;            &#125;        &#125;    &#125;           //关闭socket    close(clientfd);    return 0;&#125;\n\n执行结果确实如我们预期的，这里 select 函数只是简单地检测一下 clientfd，并不会等待固定的时间，然后立即返回。\n\n4. 如果将 select 函数的 timeval 参数设置为 NULL，则 select 函数会一直阻塞下去，直到我们需要的事件触发。\n我们将上述代码再修改一下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 验证select时间参数设置为NULL，select_client_tvnull.cpp * zhangyl 2018.12.25 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000int main(int argc, char* argv[])&#123;    //创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    int ret;    while (true)    &#123;        fd_set readset;        FD_ZERO(&amp;readset);        //将侦听socket加入到待检测的可读事件中去        FD_SET(clientfd, &amp;readset);         //timeval tm;        //tm.tv_sec = 0;        //tm.tv_usec = 0;           //暂且只检测可读事件，不检测可写和异常事件        ret = select(clientfd + 1, &amp;readset, NULL, NULL, NULL);        if (ret == -1)        &#123;            //除了被信号中断的情形，其他情况都是出错            if (errno != EINTR)                break;        &#125; else if (ret == 0)&#123;            //select函数超时            std::cout &lt;&lt; &quot;no event in specific time interval.&quot; &lt;&lt; std::endl;            continue;        &#125; else &#123;            if (FD_ISSET(clientfd, &amp;readset))            &#123;                //检测到可读事件                char recvbuf[32];                memset(recvbuf, 0, sizeof(recvbuf));                //假设对端发数据的时候不超过31个字符。                int n = recv(clientfd, recvbuf, 32, 0);                if (n &lt; 0)                &#123;                    //除了被信号中断的情形，其他情况都是出错                    if (errno != EINTR)                        break;                &#125; else if (n == 0) &#123;                    //对端关闭了连接                    break;                &#125; else &#123;                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;                &#125;            &#125;            else             &#123;                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;            &#125;        &#125;    &#125;           //关闭socket    close(clientfd);    return 0;&#125;\n\n我们先在另外一个 shell 窗口用 nc 命令模拟一个服务器，监听的 ip 地址和端口号是 0.0.0.0:3000：\n123[root@myaliyun ~]# nc -v -l 0.0.0.0 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on 0.0.0.0:3000\n\n然后回到原来的 shell 窗口，编译上述 select_client_tvnull.cpp，并使用 gdb 运行程序，这次使用 gdb 运行程序的目的是为了当程序“卡”在某个位置时，我们可以使用 Ctrl + C 把程序中断下来看看程序阻塞在哪个函数调用处：\n12345678910111213141516171819202122[root@myaliyun testsocket]# g++ -g -o select_client_tvnull select_client_tvnull.cpp [root@myaliyun testsocket]# gdb select_client_tvnullReading symbols from /root/testsocket/select_client_tvnull...done.(gdb) rStarting program: /root/testsocket/select_client_tvnull ^CProgram received signal SIGINT, Interrupt.0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64 libgcc-4.8.5-16.el7_4.1.x86_64 libstdc++-4.8.5-16.el7_4.1.x86_64(gdb) bt#0  0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6#1  0x0000000000400c75 in main (argc=1, argv=0x7fffffffe5f8) at select_client_tvnull.cpp:51(gdb) cContinuing.recv data: hello^CProgram received signal SIGINT, Interrupt.0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6(gdb) cContinuing.recv data: world\n\n如上输出结果所示，我们使用 gdb 的 r 命令（run）将程序跑起来后，程序卡在某个地方，我们按 Ctrl + C（代码中的 ^C）中断程序后使用 bt 命令查看当前程序的调用堆栈，发现确实阻塞在 select 函数调用处；接着我们在服务器端给客户端发送一个 hello 数据：\n123456[root@myaliyun ~]# nc -v -l 0.0.0.0 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on 0.0.0.0:3000Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:55968.hello\n\n客户端收到数据后，select 函数满足条件，立即返回，并将数据输出来后继续进行下一轮 select 检测，我们使用 Ctrl + C 将程序中断，发现程序又阻塞在 select 调用处；输入 c 命令（continue）让程序继续运行， 此时，我们再用服务器端给客户端发送 world 字符串，select 函数再次返回，并将数据打印出来，然后继续进入下一轮 select 检测，并继续在 select 处阻塞。\n1234567[root@myaliyun ~]# nc -v -l 0.0.0.0 3000Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on 0.0.0.0:3000Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:55968.helloworld\n\n\n\n5. 在 Linux 平台上，select 函数的第一个参数必须设置成需要检测事件的所有 fd 中的最大值加1。所以上文中 select_server.cpp 中，每新产生一个 clientfd，我都会与当前最大的 maxfd 作比较，如果大于当前的 maxfd 则将 maxfd 更新成这个新的最大值。其最终目的是为了在 select 调用时作为第一个参数（加 1）传进去。\n\n在 Windows 平台上，select 函数的第一个值传任意值都可以，Windows 系统本身不使用这个值，只是为了兼容性而保留了这个参数，但是在实际开发中为了兼容跨平台代码，也会按惯例，将这个值设置为最大 socket 加 1。这点请读者注意。\n\n以上是我总结的 Linux 下 select 使用的五个注意事项，希望读者能理解它们。\n","slug":"转载/网络编程/select函数重难点解析","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"fb6fadde5a0ca98e5162a3e35095bf9a","title":"【转载】socket的阻塞模式和非阻塞模式","content":"socket 的阻塞模式和非阻塞模式对 socket 在阻塞和非阻塞模式下的各个函数的行为差别深入的理解是掌握网络编程的基本要求之一，是重点也是难点。\n阻塞和非阻塞模式下，我们常讨论的具有不同行为表现的 socket 函数一般有如下几个，见下表：\n\nconnect\naccept\nsend (Linux 平台上对 socket 进行操作时也包括 write 函数，下文中对 send 函数的讨论也适用于 write 函数)\nrecv (Linux 平台上对 socket 进行操作时也包括 read 函数，下文中对 recv 函数的讨论也适用于 read 函数)\n\n限于文章篇幅，本文只讨论 send 和recv函数，connect 和 accept 函数我们将在该系列的后面文章中讨论。在正式讨论之前，我们先解释一下阻塞模式和非阻塞模式的概念。所谓阻塞模式，就当某个函数“执行成功的条件”当前不能满足时，该函数会阻塞当前执行线程，程序执行流在超时时间到达或“执行成功的条件”满足后恢复继续执行。而非阻塞模式恰恰相反，即使某个函数的“执行成功的条件”不当前不能满足，该函数也不会阻塞当前执行线程，而是立即返回，继续运行执行程序流。如果读者不太明白这两个定义也没关系，后面我们会以具体的示例来讲解这两种模式的区别。\n如何将 socket 设置成非阻塞模式无论是 Windows 还是 Linux 平台，默认创建的 socket 都是阻塞模式的。\n在 Linux 平台上，我们可以使用 fcntl() 函数或 ioctl() 函数给创建的 socket 增加 O_NONBLOCK 标志来将 socket 设置成非阻塞模式。示例代码如下：\n123int oldSocketFlag = fcntl(sockfd, F_GETFL, 0);int newSocketFlag = oldSocketFlag | O_NONBLOCK;fcntl(sockfd, F_SETFL,  newSocketFlag);\n\nioctl() 函数 与 fcntl() 函数使用方式基本一致，这里就不再给出示例代码了。\n当然，Linux 下的 socket() 创建函数也可以直接在创建时将 socket 设置为非阻塞模式，socket() 函数的签名如下：\n1int socket(int domain, int type, int protocol);\n\n给 type 参数增加一个 SOCK_NONBLOCK 标志即可，例如：\n1int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);\n\n不仅如此，Linux 系统下利用 accept() 函数返回的代表与客户端通信的 socket 也提供了一个扩展函数 **accept4()**，直接将 accept 函数返回的 socket 设置成非阻塞的。\n12int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);\n\n只要将 accept4() 函数最后一个参数 flags 设置成 SOCK_NONBLOCK 即可。也就是说以下代码是等价的：\n12345678910socklen_t addrlen = sizeof(clientaddr);int clientfd = accept4(listenfd, &amp;clientaddr, &amp;addrlen, SOCK_NONBLOCK);socklen_t addrlen = sizeof(clientaddr);int clientfd = accept(listenfd, &amp;clientaddr, &amp;addrlen);if (clientfd != -1)&#123;    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    fcntl(clientfd, F_SETFL,  newSocketFlag);&#125;\n\n在 Windows 平台上，可以调用 ioctlsocket() 函数 将 socket 设置成非阻塞模式，ioctlsocket() 签名如下：\n1int ioctlsocket(SOCKET s, long cmd, u_long *argp);\n\n将 cmd 参数设置为 FIONBIO，*argp* 设置为 0 即可将 socket 设置成阻塞模式，而将 argp 设置成非 0 即可设置成非阻塞模式。示例如下：\n1234567//将 socket 设置成非阻塞模式u_long argp = 1;ioctlsocket(s, FIONBIO, &amp;argp);//将 socket 设置成阻塞模式u_long argp = 0;ioctlsocket(s, FIONBIO, &amp;argp);\n\nWindows 平台需要注意一个地方，如果对一个 socket 调用了 WSAAsyncSelect() 或 WSAEventSelect() 函数后，再调用 ioctlsocket() 函数将该 socket 设置为非阻塞模式会失败，你必须先调用 WSAAsyncSelect() 通过将 lEvent 参数为 0 或调用 WSAEventSelect() 通过设置 lNetworkEvents 参数为 0 来清除已经设置的 socket 相关标志位，再次调用 ioctlsocket() 将该 socket 设置成阻塞模式才会成功。因为调用 WSAAsyncSelect() 或WSAEventSelect() 函数会自动将 socket 设置成非阻塞模式。MSDN 上原文（https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-ioctlsocket）如下：\n123The WSAAsyncSelect and WSAEventSelect functions automatically set a socket to nonblocking mode. If WSAAsyncSelect or WSAEventSelect has been issued on a socket, then any attempt to use ioctlsocket to set the socket back to blocking mode will fail with WSAEINVAL.To set the socket back to blocking mode, an application must first disable WSAAsyncSelect by calling WSAAsyncSelect with the lEvent parameter equal to zero, or disable WSAEventSelect by calling WSAEventSelect with the lNetworkEvents parameter equal to zero.\n\n关于 WSAAsyncSelect() 和 WSAEventSelect() 这两个函数，后文中会详细讲解。\n\n注意事项：无论是 Linux 的 fcntl 函数，还是 Windows 的 ioctlsocket，建议读者在实际编码中判断一下函数返回值以确定是否调用成功。\n\nsend 和 recv 函数在阻塞和非阻塞模式下的行为\nsend 和 recv 函数其实名不符实。\nsend 函数本质上并不是往网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区（下文为了叙述方便，我们以“网卡缓冲区”代指）中去，至于什么时候数据会从网卡缓冲区中真正地发到网络中去要根据 TCP&#x2F;IP 协议栈的行为来确定，这种行为涉及到一个叫 nagel 算法和 TCP_NODELAY 的 socket 选项，我们将在《nagle算法与 TCP_NODELAY》章节详细介绍。\nrecv 函数本质上也并不是从网络上收取数据，而只是将内核缓冲区中的数据拷贝到应用程序的缓冲区中，当然拷贝完成以后会将内核缓冲区中该部分数据移除。\n可以用下面一张图来描述上述事实：\n\n通过上图我们知道，不同的程序进行网络通信时，发送的一方会将内核缓冲区的数据通过网络传输给接收方的内核缓冲区。在应用程序 A 与 应用程序 B 建立了 TCP 连接之后，假设应用程序 A 不断调用 send 函数，这样数据会不断拷贝至对应的内核缓冲区中，如果 B 那一端一直不调用 recv 函数，那么 B 的内核缓冲区被填满以后，A 的内核缓冲区也会被填满，此时 A 继续调用 send 函数会是什么结果呢？ 具体的结果取决于该 socket 是否是阻塞模式。我们这里先给出结论：\n\n当 socket 是阻塞模式的，继续调用 send&#x2F;recv 函数会导致程序阻塞在 send&#x2F;recv 调用处。\n当 socket 是非阻塞模式，继续调用 send&#x2F;recv 函数，send&#x2F;recv 函数不会阻塞程序执行流，而是会立即出错返回，我们会得到一个相关的错误码，Linux 平台上该错误码为 EWOULDBLOCK 或 EAGAIN（这两个错误码值相同），Windows 平台上错误码为 WSAEWOULDBLOCK。\n\n我们实际来编写一下代码来验证一下以上说的两种情况。\nsocket 阻塞模式下的 send 行为服务端代码（blocking_server.cpp）如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 验证阻塞模式下send函数的行为，server端 * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;int main(int argc, char* argv[])&#123;    //1.创建一个侦听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1)    &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //3.启动侦听    if (listen(listenfd, SOMAXCONN) == -1)    &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    while (true)    &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);        //4. 接受客户端连接        int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);        if (clientfd != -1)        &#123;                         //只接受连接，不调用recv收取任何数据            std:: cout &lt;&lt; &quot;accept a client connection.&quot; &lt;&lt; std::endl;        &#125;    &#125;    //7.关闭侦听socket    close(listenfd);    return 0;&#125;\n\n客户端代码（blocking_client.cpp）如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 验证阻塞模式下send函数的行为，client端 * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //3. 不断向服务器发送数据，或者出错退出    int count = 0;    while (true)    &#123;        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);        if (ret != strlen(SEND_DATA))        &#123;            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;            break;        &#125;         else        &#123;            count ++;            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;        &#125;    &#125;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n在 shell 中分别编译这两个 cpp 文件得到两个可执行程序 blocking_server 和 blocking_client：\n12g++ -g -o blocking_server blocking_server.cppg++ -g -o blocking_client blocking_client.cpp\n\n我们先启动 blocking_server，然后用 gdb 启动 blocking_client，输入 run 命令让 blocking_client跑起来，blocking_client 会不断地向 blocking_server 发送”helloworld“字符串，每次 send 成功后，会将计数器 count 的值打印出来，计数器会不断增加，程序运行一段时间后，计数器 count 值不再增加且程序不再有输出。操作过程及输出结果如下：\nblocking_server 端：\n12345678910111213141516171819202122[root@localhost testsocket]# ./blocking_server accept a client connection.[root@localhost testsocket]# gdb blocking_clientGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-100.el7_4.1Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /root/testsocket/blocking_client...done.(gdb) run//输出结果太多，省略部分...send data successfully, count = 355384send data successfully, count = 355385send data successfully, count = 355386send data successfully, count = 355387send data successfully, count = 355388send data successfully, count = 355389send data successfully, count = 355390\n\n此时程序不再有输出，说明我们的程序应该“卡在”某个地方，继续按 Ctrl + C 让 gdb 中断下来，输入 bt 命令查看此时的调用堆栈，我们发现我们的程序确实阻塞在 send 函数调用处：\n1234567^CProgram received signal SIGINT, Interrupt.0x00007ffff72f130d in send () from /lib64/libc.so.6(gdb) bt#0  0x00007ffff72f130d in send () from /lib64/libc.so.6#1  0x0000000000400b46 in main (argc=1, argv=0x7fffffffe598) at blocking_client.cpp:41(gdb) \n\n上面的示例验证了如果一端一直发数据，而对端应用层一直不取数据（或收取数据的速度慢于发送速度），则很快两端的内核缓冲区很快就会被填满，导致发送端调用 send 函数被阻塞。这里说的“内核缓冲区” 其实有个专门的名字，即 TCP 窗口。也就是说 socket 阻塞模式下， send 函数在 TCP 窗口太小时的行为是阻塞当前程序执行流（即阻塞 send 函数所在的线程的执行）。\n说点题外话，上面的例子，我们每次发送一个“helloworld”（10个字节），一共发了 355390 次（每次测试的结果略有不同），我们可以粗略地算出 TCP 窗口的大小大约等于 1.7 M左右 （10 * 355390 &#x2F; 2）。\n让我们再深入一点，我们利用 Linux tcpdump 工具来动态看一下这种情形下 TCP 窗口大小的动态变化。需要注意的是，Linux 下使用 tcpdump 这个命令需要有 root 权限。\n我们开启三个 shell 窗口，在第一个窗口先启动 blocking_server 进程，在第二个窗口用 tcpdump 抓经过 TCP 端口 3000 上的数据包：\n123[root@localhost testsocket]# tcpdump -i any -nn -S &#x27;tcp port 3000&#x27;    tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes\n\n接着在第三个 shell 窗口，启动 blocking_client。当 blocking_client 进程不再输出时，我们抓包的结果如下：\n123456789101112131415161718192021222324252627282930313233[root@localhost testsocket]# tcpdump -i any -nn -S &#x27;tcp port 3000&#x27; tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes11:52:35.907381 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [S], seq 1394135076, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 0,nop,wscale 7], length 020:32:21.261484 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [S.], seq 1233000591, ack 1394135077, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 78907688,nop,wscale 7], length 011:52:35.907441 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 011:52:35.907615 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135077:1394135087, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 1011:52:35.907626 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135087, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 011:52:35.907785 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135087:1394135097, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 1011:52:35.907793 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135097, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 011:52:35.907809 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135097:1394135107, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 1011:52:35.907814 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135107, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0...内容太长， 部分省略...11:52:40.075794 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395013717, win 374, options [nop,nop,TS val 78911856 ecr 78911816], length 011:52:40.075829 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395013717:1395030517, ack 1233000592, win 342, options [nop,nop,TS val 78911856 ecr 78911856], length 1680011:52:40.115847 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395030517, win 305, options [nop,nop,TS val 78911896 ecr 78911856], length 011:52:40.115866 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395030517:1395047317, ack 1233000592, win 342, options [nop,nop,TS val 78911896 ecr 78911896], length 1680011:52:40.155703 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395047317, win 174, options [nop,nop,TS val 78911936 ecr 78911896], length 011:52:40.155752 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395047317:1395064117, ack 1233000592, win 342, options [nop,nop,TS val 78911936 ecr 78911936], length 1680011:52:40.195132 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395064117, win 43, options [nop,nop,TS val 78911976 ecr 78911936], length 011:52:40.435748 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395064117:1395069621, ack 1233000592, win 342, options [nop,nop,TS val 78912216 ecr 78911976], length 550411:52:40.435782 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78912216 ecr 78912216], length 011:52:40.670661 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78912451 ecr 78912216], length 011:52:40.670674 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78912451 ecr 78912216], length 011:52:41.141703 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78912922 ecr 78912451], length 011:52:42.083643 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78913864 ecr 78912451], length 011:52:42.083655 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78913864 ecr 78912216], length 011:52:43.967506 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78915748 ecr 78913864], length 011:52:43.967532 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78915748 ecr 78912216], length 011:52:47.739259 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78919520 ecr 78915748], length 011:52:47.739274 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78919520 ecr 78912216], length 011:52:55.275863 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78927056 ecr 78919520], length 011:52:55.275931 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78927056 ecr 78912216], length 0\n\n抓取到的前三个数据包是 blocking_client 与 blocking_server 建立三次握手的过程。\n12311:52:35.907381 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [S], seq 1394135076, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 0,nop,wscale 7], length 020:32:21.261484 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [S.], seq 1233000591, ack 1394135077, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 78907688,nop,wscale 7], length 011:52:35.907441 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0\n\n示意图如下：\n\n当每次 blocking_client 给 blocking_server 发数据以后，blocking_server 会应答 blocking_server，在每次应答的数据包中会带上自己的当前可用 TCP 窗口大小（看上文中结果从 127.0.0.1.3000 &gt; 127.0.0.1.40846方向的数据包的 win 字段大小变化），由于 TCP 流量控制和拥赛控制机制的存在，blocking_server 端的 TCP 窗口大小短期内会慢慢增加，后面随着接收缓冲区中数据积压越来越多， TCP 窗口会慢慢变小，最终变为 0。\n另外，细心的读者如果实际去做一下这个实验会发现一个现象，即当 tcpdump 已经显示对端的 TCP 窗口是 0 时， blocking_client 仍然可以继续发送一段时间的数据，此时的数据已经不是在发往对端，而是逐渐填满到本端的内核发送缓冲区中去了，这也验证了 send 函数实际上是往内核缓冲区中拷贝数据这一行为。\nsocket 非阻塞模式下的 send 行为我们再来验证一下非阻塞 socket 的 send 行为，server 端的代码不变，我们将 blocking_client.cpp 中 socket 设置成非阻塞的，修改后的代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 验证非阻塞模式下send函数的行为，client端，nonblocking_client.cpp * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //3. 不断向服务器发送数据，或者出错退出    int count = 0;    while (true)    &#123;        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);        if (ret == -1)         &#123;            //非阻塞模式下send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK            if (errno == EWOULDBLOCK)            &#123;                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;                continue;            &#125;             else if (errno == EINTR)            &#123;                //如果被信号中断，我们继续重试                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;                continue;            &#125;             else             &#123;                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                break;            &#125;        &#125;        if (ret == 0)        &#123;            //对端关闭了连接，我们也关闭            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;            close(clientfd);            break;        &#125;         else        &#123;            count ++;            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;        &#125;    &#125;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n编译 nonblocking_client.cpp 得到可执行程序 nonblocking_client：\n1g++ -g -o nonblocking_client nonblocking_client.cpp \n\n运行 nonblocking_client，运行一段时间后，由于对端和本端的 TCP 窗口已满，数据发不出去了，但是 send 函数不会阻塞，而是立即返回，返回值是 -1（Windows 系统上 返回 SOCKET_ERROR，这个宏的值也是 -1），此时得到错误码是 EWOULDBLOCK。执行结果如下：\n\nsocket 阻塞模式下的 recv 行为在了解了 send 函数的行为，我们再来看一下阻塞模式下的 recv 函数行为。服务器端代码不需要修改，我们修改一下客户端代码，如果服务器端不给客户端发数据，此时客户端调用 recv 函数执行流会阻塞在 recv 函数调用处。继续修改一下客户端代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 验证阻塞模式下recv函数的行为，client端，blocking_client_recv.cpp * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    //直接调用recv函数，程序会阻塞在recv函数调用处    char recvbuf[32] = &#123;0&#125;;    int ret = recv(clientfd, recvbuf, 32, 0);    if (ret &gt; 0)     &#123;        std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;    &#125;     else     &#123;        std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;    &#125;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n编译 blocking_client_recv.cpp 并使用启动，我们发现程序既没有打印 recv 调用成功的信息也没有调用失败的信息，将程序中断下来，使用 bt 命令查看此时的调用堆栈，发现程序确实阻塞在 recv 函数调用处。\n123456789101112[root@localhost testsocket]# g++ -g -o blocking_client_recv blocking_client_recv.cpp [root@localhost testsocket]# gdb blocking_client_recvReading symbols from /root/testsocket/blocking_client_recv...done.(gdb) rStarting program: /root/testsocket/blocking_client_recv ^CProgram received signal SIGINT, Interrupt.0x00007ffff72f119d in recv () from /lib64/libc.so.6Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64 libgcc-4.8.5-16.el7_4.2.x86_64 libstdc++-4.8.5-16.el7_4.2.x86_64(gdb) bt#0  0x00007ffff72f119d in recv () from /lib64/libc.so.6#1  0x0000000000400b18 in main (argc=1, argv=0x7fffffffe588) at blocking_client_recv.cpp:40\n\nsocket 非阻塞模式下的 recv 行为非阻塞模式下如果当前无数据可读，recv 函数将立即返回，返回值为 -1，错误码为 EWOULDBLOCK。将客户端代码修成一下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 验证阻塞模式下recv函数的行为，client端，blocking_client_recv.cpp * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //直接调用recv函数，程序会阻塞在recv函数调用处    while (true)    &#123;        char recvbuf[32] = &#123;0&#125;;        int ret = recv(clientfd, recvbuf, 32, 0);        if (ret &gt; 0)         &#123;            //收到了数据            std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;        &#125;         else if (ret == 0)        &#123;            //对端关闭了连接            std::cout &lt;&lt; &quot;peer close the socket.&quot; &lt;&lt; std::endl;             break;        &#125;         else if (ret == -1)         &#123;            if (errno == EWOULDBLOCK)            &#123;                std::cout &lt;&lt; &quot;There is no data available now.&quot; &lt;&lt; std::endl;            &#125;             else if (errno == EINTR)             &#123;                //如果被信号中断了，则继续重试recv函数                std::cout &lt;&lt; &quot;recv data interrupted by signal.&quot; &lt;&lt; std::endl;                           &#125; else            &#123;                //真的出错了                break;            &#125;        &#125;    &#125;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n执行结果与我们预期的一模一样， recv 函数在无数据可读的情况下并不会阻塞情绪，所以程序会一直有“**There is no data available now.**”相关的输出。\n\n","slug":"转载/网络编程/socket的阻塞模式和非阻塞模式","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"c646ab357404b495e460a8a7d56a1d77","title":"【转载】connect函数在阻塞和非阻塞模式下的行为","content":"connect 函数在阻塞和非阻塞模式下的行为在 socket 是阻塞模式下 connect 函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务器地址“较远”，连接速度比较慢，connect 函数在连接过程中可能会导致程序阻塞在 connect 函数处好一会儿（如两三秒之久），虽然这一般也不会对依赖于网络通信的程序造成什么影响，但在实际项目中，我们一般倾向使用所谓的异步的 connect 技术，或者叫非阻塞的 connect。这个流程一般有如下步骤：\n1231. 创建socket，并将 socket 设置成非阻塞模式；2. 调用 connect 函数，此时无论 connect 函数是否连接成功会立即返回；如果返回-1并不表示连接出错，如果此时错误码是EINPROGRESS3. 接着调用 select 函数，在指定的时间内判断该 socket 是否可写，如果可写说明连接成功，反之则认为连接失败。\n\n按上述流程编写代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 异步的connect写法，nonblocking_connect.cpp * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    for (;;)    &#123;        int ret = connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));        if (ret == 0)        &#123;            std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;            close(clientfd);            return 0;        &#125;         else if (ret == -1)         &#123;            if (errno == EINTR)            &#123;                //connect 动作被信号中断，重试connect                std::cout &lt;&lt; &quot;connecting interruptted by signal, try again.&quot; &lt;&lt; std::endl;                continue;            &#125; else if (errno == EINPROGRESS)            &#123;                //连接正在尝试中                break;            &#125; else &#123;                //真的出错了，                close(clientfd);                return -1;            &#125;        &#125;    &#125;    fd_set writeset;    FD_ZERO(&amp;writeset);    FD_SET(clientfd, &amp;writeset);    //可以利用tv_sec和tv_usec做更小精度的超时控制    struct timeval tv;    tv.tv_sec = 3;      tv.tv_usec = 0;    if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) == 1)    &#123;        std::cout &lt;&lt; &quot;[select] connect to server successfully.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;[select] connect to server error.&quot; &lt;&lt; std::endl;    &#125;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n为了区别到底是在调用 connect 函数时判断连接成功还是通过 select 函数判断连接成功，我们在后者的输出内容中加上了“**[select]**”标签以示区别。\n我们先用 nc 命令启动一个服务器程序：\n1nc -v -l 0.0.0.0 3000\n\n然后编译客户端程序并执行：\n123[root@localhost testsocket]# g++ -g -o nonblocking_connect nonblocking_connect.cpp [root@localhost testsocket]# ./nonblocking_connect [select] connect to server successfully.\n\n我们把服务器程序关掉，再重新启动一下客户端，这个时候应该会连接失败，程序输出结果如下：\n12[root@localhost testsocket]# ./nonblocking_connect [select] connect to server successfully.\n\n奇怪？为什么连接不上也会得出一样的输出结果？难道程序有问题？这是因为：\n\n在 Windows 系统上，一个 socket 没有建立连接之前，我们使用 select 函数检测其是否可写，能得到正确的结果（不可写），连接成功后检测，会变为可写。所以，上述介绍的异步 connect 写法流程在 Windows 系统上时没有问题的。\n在 Linux 系统上一个 socket 没有建立连接之前，用 select 函数检测其是否可写，你也会得到可写得结果，所以上述流程并不适用于 Linux 系统。正确的做法是，connect 之后，不仅要用 select 检测可写，还要检测此时 socket 是否出错，通过错误码来检测确定是否连接上，错误码为 0 表示连接上，反之为未连接上。完整代码如下：\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Linux 下正确的异步的connect写法，linux_nonblocking_connect.cpp * zhangyl 2018.12.17 */#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    for (;;)    &#123;        int ret = connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));        if (ret == 0)        &#123;            std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;            close(clientfd);            return 0;        &#125;         else if (ret == -1)         &#123;            if (errno == EINTR)            &#123;                //connect 动作被信号中断，重试connect                std::cout &lt;&lt; &quot;connecting interruptted by signal, try again.&quot; &lt;&lt; std::endl;                continue;            &#125; else if (errno == EINPROGRESS)            &#123;                //连接正在尝试中                break;            &#125; else &#123;                //真的出错了，                close(clientfd);                return -1;            &#125;        &#125;    &#125;    fd_set writeset;    FD_ZERO(&amp;writeset);    FD_SET(clientfd, &amp;writeset);    //可以利用tv_sec和tv_usec做更小精度的超时控制    struct timeval tv;    tv.tv_sec = 3;      tv.tv_usec = 0;    if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) != 1)    &#123;        std::cout &lt;&lt; &quot;[select] connect to server error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    int err;    socklen_t len = static_cast&lt;socklen_t&gt;(sizeof err);    if (::getsockopt(clientfd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;len) &lt; 0)    &#123;        close(clientfd);        return -1;    &#125;    if (err == 0)        std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;    else        std::cout &lt;&lt; &quot;connect to server error.&quot; &lt;&lt; std::endl;    //5. 关闭socket    close(clientfd);    return 0;&#125;\n\n\n当然，在实际的项目中，第 3 个步骤中 Linux 平台上你也可以使用 poll 函数来判断 socket 是否可写；在 Windows 平台上你可以使用 WSAEventSelect 或 WSAAsyncSelect 函数判断连接是否成功，关于这三个函数我们将在后面的章节中详细讲解，这里暂且仅以 select 函数为例。\n\n","slug":"转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"f4314c9e2807b5be1e4e59a1606b1819","title":"【转载】服务器开发通信协议设计介绍","content":"服务器开发通信协议设计介绍\n一、选择TCP还是UDP协议由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所以客户端和服务器需要保持长连接状态。另外即时通讯软件一般要求信息准确、有序、完整地到达对端，而这也是TCP协议的特点之一。综合这两个所以这里我们选择TCP协议，而不是UDP协议。\n二、协议的结构由于TCP协议是流式协议，所谓流式协议即通讯的内容是无边界的字节流：如A给B连续发送了三个数据包，每个包的大小都是100个字节，那么B可能会一次性收到300个字节；也可能先收到100个字节，再收到200个字节；也可能先收到100个字节，再收到50个字节，再收到150个字节；或者先收到50个字节，再收到50个字节，再收到50个字节，最后收到150个字节。也就是说，B可能以任何组合形式收到这300个字节。即像水流一样无明确的边界。为了能让对端知道如何给包分界，目前一般有三种做法：\n\n以固定大小字节数目来分界，上文所说的就是属于这种类型，如每个包100个字节，对端每收齐100个字节，就当成一个包来解析；\n以特定符号来分界，如每个包都以特定的字符来结尾（如\\n），当在字节流中读取到该字符时，则表明上一个包到此为止。\n固定包头+包体结构，这种结构中一般包头部分是一个固定字节长度的结构，并且包头中会有一个特定的字段指定包体的大小。这是目前各种网络应用用的最多的一种包格式。\n\n上面三种分包方式各有优缺点，方法1和方法2简单易操作，但是缺点也很明显，就是很不灵活，如方法一当包数据不足指定长度，只能使用占位符如0来凑，比较浪费；方法2中包中不能有包界定符，否则就会引起歧义，也就是要求包内容中不能有某些特殊符号。而方法3虽然解决了方法1和方法2的缺点，但是操作起来就比较麻烦。我们的即时通讯协议就采用第三种分包方式。所以我们的协议包的包头看起来像这样：\n1234struct package_header&#123;    int32_t bodysize;&#125;;\n\n一个应用中，有许多的应用数据，拿我们这里的即时通讯来说，有注册、登录、获取好友列表、好友消息等各种各样的协议数据包，而每个包因为业务内容不一样可能数据内容也不一样，所以各个包可能看起来像下面这样：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct package_header&#123;    int32_t bodysize;&#125;;//登录数据包struct register_package&#123;    package_header header;    //命令号    int32_t cmd;    //注册用户名    char username[16];    //注册密码    char password[16];    //注册昵称    char nickname[16];    //注册手机号    char mobileno[16];&#125;;//登录数据包struct login_package&#123;    package_header header;    //命令号    int32_t cmd;    //登录用户名    char username[16];    //密码    char password[16];    //客户端类型    int32_t clienttype;    //上线类型，如在线、隐身、忙碌、离开等    int32_t onlinetype;&#125;;//获取好友列表struct getfriend_package&#123;    package_header header;    //命令号    int32_t cmd;&#125;;//聊天内容struct chat_package&#123;    package_header header;    //命令号    int32_t cmd;    //发送人userid    int32_t senderid;    //接收人userid    int32_t targetid;    //消息内容    char chatcontent[8192];&#125;;\n\n看到没有？由于每一个业务的内容不一样，定义的结构体也不一样。如果业务比较多的话，我们需要定义各种各样的这种结构体，这简直是一场噩梦。那么有没有什么方法可以避免这个问题呢？有，我受jdk中的流对象的WriteInt32、WriteByte、WriteInt64、WriteString，这样的接口的启发，也发明了一套这样的协议，而且这套协议基本上是通用协议，可用于任何场景。我们的包还是分为包头和包体两部分，包头和上文所说的一样，包体是一个不固定大小的二进制流，其长度由包头中的指定包体长度的字段决定。\n12345678struct package_protocol&#123;    int32_t bodysize;    //注意：C/C++语法不能这么定义结构体，    //这里只是为了说明含义的伪代码    //bodycontent即为一个不固定大小的二进制流    char    binarystream[bodysize];&#125;;\n\n接下来的核心部分就是如何操作这个二进制流，我们将流分为二进制读和二进制写两种流，下面给出接口定义：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//写class BinaryWriteStream&#123;public:    BinaryWriteStream(string* data);    const char* GetData() const;    size_t GetSize() const;    bool WriteCString(const char* str, size_t len);    bool WriteString(const string&amp; str);    bool WriteDouble(double value, bool isNULL = false);    bool WriteInt64(int64_t value, bool isNULL = false);    bool WriteInt32(int32_t i, bool isNULL = false);    bool WriteShort(short i, bool isNULL = false);    bool WriteChar(char c, bool isNULL = false);    size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;    void Flush();    void Clear();private:    string* m_data;&#125;;//读class BinaryReadStream : public IReadStream&#123;private:    const char* const ptr;    const size_t      len;    const char*       cur;    BinaryReadStream(const BinaryReadStream&amp;);    BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);public:    BinaryReadStream(const char* ptr, size_t len);    const char* GetData() const;    size_t GetSize() const;    bool IsEmpty() const;    bool ReadString(string* str, size_t maxlen, size_t&amp; outlen);    bool ReadCString(char* str, size_t strlen, size_t&amp; len);    bool ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen);    bool ReadInt32(int32_t&amp; i);    bool ReadInt64(int64_t&amp; i);    bool ReadShort(short&amp; i);    bool ReadChar(char&amp; c);    size_t ReadAll(char* szBuffer, size_t iLen) const;    bool IsEnd() const;    const char* GetCurrent() const&#123; return cur; &#125;public:    bool ReadLength(size_t &amp; len);    bool ReadLengthWithoutOffset(size_t &amp;headlen, size_t &amp; outlen);&#125;;\n\n这样如果是上文的一个登录数据包，我们只要写成如下形式就可以了：\n123456789std::string outbuf;BinaryWriteStream stream(&amp;outbuf);stream.WriteInt32(cmd);stream.WriteCString(username, 16);stream.WriteCString(password, 16);stream.WriteInt32(clienttype);stream.WriteInt32(onlinetype);//最终数据就存储到outbuf中去了stream.Flush();\n\n接着我们再对端，解得正确的包体后，我们只要按写入的顺序依次读出来即可：\n1234567891011BinaryWriteStream stream(outbuf.c_str(), outbuf.length());int32_t cmd;stream.WriteInt32(cmd);char username[16];stream.ReadCString(username, 16, NULL);char password[16];stream.WriteCString(password, 16, NULL);int32_t clienttype;stream.WriteInt32(clienttype);int32_t onlinetype;stream.WriteInt32(onlinetype);\n\n这里给出BinaryReadStream和BinaryWriteStream的完整实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359//计算校验和unsigned short checksum(const unsigned short *buffer, int size)&#123;    unsigned int cksum = 0;    while (size &gt; 1)    &#123;        cksum += *buffer++;        size -= sizeof(unsigned short);    &#125;    if (size)    &#123;        cksum += *(unsigned char*)buffer;    &#125;    //将32位数转换成16    while (cksum &gt;&gt; 16)        cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xffff);    return (unsigned short)(~cksum);&#125;bool compress_(unsigned int i, char *buf, size_t &amp;len)&#123;    len = 0;    for (int a = 4; a &gt;= 0; a--)    &#123;        char c;        c = i &gt;&gt; (a * 7) &amp; 0x7f;        if (c == 0x00 &amp;&amp; len == 0)            continue;        if (a == 0)            c &amp;= 0x7f;        else            c |= 0x80;        buf[len] = c;        len++;    &#125;    if (len == 0)    &#123;        len++;        buf[0] = 0;    &#125;    //cout &lt;&lt; &quot;compress:&quot; &lt;&lt; i &lt;&lt; endl;    //cout &lt;&lt; &quot;compress len:&quot; &lt;&lt; len &lt;&lt; endl;    return true;&#125;bool uncompress_(char *buf, size_t len, unsigned int &amp;i)&#123;    i = 0;    for (int index = 0; index &lt; (int)len; index++)    &#123;        char c = *(buf + index);        i = i &lt;&lt; 7;        c &amp;= 0x7f;        i |= c;    &#125;    //cout &lt;&lt; &quot;uncompress:&quot; &lt;&lt; i &lt;&lt; endl;    return true;&#125;BinaryReadStream::BinaryReadStream(const char* ptr_, size_t len_)    : ptr(ptr_), len(len_), cur(ptr_)&#123;    cur += BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN;&#125;bool BinaryReadStream::IsEmpty() const&#123;    return len &lt;= BINARY_PACKLEN_LEN_2;&#125;size_t BinaryReadStream::GetSize() const&#123;    return len;&#125;bool BinaryReadStream::ReadCString(char* str, size_t strlen, /* out */ size_t&amp; outlen)&#123;    size_t fieldlen;    size_t headlen;    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;        return false;    &#125;    // user buffer is not enough    if (fieldlen &gt; strlen) &#123;        return false;    &#125;    // 偏移到数据的位置    //cur += BINARY_PACKLEN_LEN_2;        cur += headlen;    if (cur + fieldlen &gt; ptr + len)    &#123;        outlen = 0;        return false;    &#125;    memcpy(str, cur, fieldlen);    outlen = fieldlen;    cur += outlen;    return true;&#125;bool BinaryReadStream::ReadString(string* str, size_t maxlen, size_t&amp; outlen)&#123;    size_t headlen;    size_t fieldlen;    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;        return false;    &#125;    // user buffer is not enough    if (maxlen != 0 &amp;&amp; fieldlen &gt; maxlen) &#123;        return false;    &#125;    // 偏移到数据的位置    //cur += BINARY_PACKLEN_LEN_2;        cur += headlen;    if (cur + fieldlen &gt; ptr + len)    &#123;        outlen = 0;        return false;    &#125;    str-&gt;assign(cur, fieldlen);    outlen = fieldlen;    cur += outlen;    return true;&#125;bool BinaryReadStream::ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen)&#123;    size_t headlen;    size_t fieldlen;    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;        return false;    &#125;    // user buffer is not enough    if (maxlen != 0 &amp;&amp; fieldlen &gt; maxlen) &#123;        return false;    &#125;    // 偏移到数据的位置    //cur += BINARY_PACKLEN_LEN_2;        cur += headlen;    //memcpy(str, cur, fieldlen);    if (cur + fieldlen &gt; ptr + len)    &#123;        outlen = 0;        return false;    &#125;    *str = cur;    outlen = fieldlen;    cur += outlen;    return true;&#125;bool BinaryReadStream::ReadInt32(int32_t&amp; i)&#123;    const int VALUE_SIZE = sizeof(int32_t);    if (cur + VALUE_SIZE &gt; ptr + len)        return false;    memcpy(&amp;i, cur, VALUE_SIZE);    i = ntohl(i);    cur += VALUE_SIZE;    return true;&#125;bool BinaryReadStream::ReadInt64(int64_t&amp; i)&#123;    char int64str[128];    size_t length;    if (!ReadCString(int64str, 128, length))        return false;    i = atoll(int64str);    return true;&#125;bool BinaryReadStream::ReadShort(short&amp; i)&#123;    const int VALUE_SIZE = sizeof(short);    if (cur + VALUE_SIZE &gt; ptr + len) &#123;        return false;    &#125;    memcpy(&amp;i, cur, VALUE_SIZE);    i = ntohs(i);    cur += VALUE_SIZE;    return true;&#125;bool BinaryReadStream::ReadChar(char&amp; c)&#123;    const int VALUE_SIZE = sizeof(char);    if (cur + VALUE_SIZE &gt; ptr + len) &#123;        return false;    &#125;    memcpy(&amp;c, cur, VALUE_SIZE);    cur += VALUE_SIZE;    return true;&#125;bool BinaryReadStream::ReadLength(size_t &amp; outlen)&#123;    size_t headlen;    if (!ReadLengthWithoutOffset(headlen, outlen)) &#123;        return false;    &#125;    //cur += BINARY_PACKLEN_LEN_2;    cur += headlen;    return true;&#125;bool BinaryReadStream::ReadLengthWithoutOffset(size_t&amp; headlen, size_t &amp; outlen)&#123;    headlen = 0;    const char *temp = cur;    char buf[5];    for (size_t i = 0; i&lt;sizeof(buf); i++)    &#123;        memcpy(buf + i, temp, sizeof(char));        temp++;        headlen++;        //if ((buf[i] &gt;&gt; 7 | 0x0) == 0x0)        if ((buf[i] &amp; 0x80) == 0x00)            break;    &#125;    if (cur + headlen &gt; ptr + len)        return false;    unsigned int value;    uncompress_(buf, headlen, value);    outlen = value;    /*if ( cur + BINARY_PACKLEN_LEN_2 &gt; ptr + len ) &#123;    return false;    &#125;    unsigned int tmp;    memcpy(&amp;tmp, cur, sizeof(tmp));    outlen = ntohl(tmp);*/    return true;&#125;bool BinaryReadStream::IsEnd() const&#123;    assert(cur &lt;= ptr + len);    return cur == ptr + len;&#125;const char* BinaryReadStream::GetData() const&#123;    return ptr;&#125;size_t BinaryReadStream::ReadAll(char * szBuffer, size_t iLen) const&#123;    size_t iRealLen = min(iLen, len);    memcpy(szBuffer, ptr, iRealLen);    return iRealLen;&#125;//=================class BinaryWriteStream implementation============//BinaryWriteStream::BinaryWriteStream(string *data) :    m_data(data)&#123;    m_data-&gt;clear();    char str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];    m_data-&gt;append(str, sizeof(str));&#125;bool BinaryWriteStream::WriteCString(const char* str, size_t len)&#123;    char buf[5];    size_t buflen;    compress_(len, buf, buflen);    m_data-&gt;append(buf, sizeof(char)*buflen);    m_data-&gt;append(str, len);    //unsigned int ulen = htonl(len);    //m_data-&gt;append((char*)&amp;ulen,sizeof(ulen));    //m_data-&gt;append(str,len);    return true;&#125;bool BinaryWriteStream::WriteString(const string&amp; str)&#123;    return WriteCString(str.c_str(), str.length());&#125;const char* BinaryWriteStream::GetData() const&#123;    return m_data-&gt;data();&#125;size_t BinaryWriteStream::GetSize() const&#123;    return m_data-&gt;length();&#125;bool BinaryWriteStream::WriteInt32(int32_t i, bool isNULL)&#123;    int32_t i2 = 999999999;    if (isNULL == false)        i2 = htonl(i);    m_data-&gt;append((char*)&amp;i2, sizeof(i2));    return true;&#125;bool BinaryWriteStream::WriteInt64(int64_t value, bool isNULL)&#123;    char int64str[128];    if (isNULL == false)    &#123;    #ifndef _WIN32        sprintf(int64str, &quot;%ld&quot;, value);    #else        sprintf(int64str, &quot;%lld&quot;, value);    #endif        WriteCString(int64str, strlen(int64str));    &#125;    else        WriteCString(int64str, 0);    return true;&#125;bool BinaryWriteStream::WriteShort(short i, bool isNULL)&#123;    short i2 = 0;    if (isNULL == false)        i2 = htons(i);    m_data-&gt;append((char*)&amp;i2, sizeof(i2));    return true;&#125;bool BinaryWriteStream::WriteChar(char c, bool isNULL)&#123;    char c2 = 0;    if (isNULL == false)        c2 = c;    (*m_data) += c2;    return true;&#125;bool BinaryWriteStream::WriteDouble(double value, bool isNULL)&#123;    char   doublestr[128];    if (isNULL == false)    &#123;        sprintf(doublestr, &quot;%f&quot;, value);        WriteCString(doublestr, strlen(doublestr));    &#125;    else        WriteCString(doublestr, 0);    return true;&#125;void BinaryWriteStream::Flush()&#123;    char *ptr = &amp;(*m_data)[0];    unsigned int ulen = htonl(m_data-&gt;length());    memcpy(ptr, &amp;ulen, sizeof(ulen));&#125;void BinaryWriteStream::Clear()&#123;    m_data-&gt;clear();    char str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];    m_data-&gt;append(str, sizeof(str));&#125;\n\n这里详细解释一下上面的实现原理，即如何把各种类型的字段写入这种所谓的流中，或者怎么从这种流中读出各种类型的数据。上文的字段在流中的格式如下图：\n\n这里最简便的方式就是每个字段的长度域都是固定字节数目，如4个字节。但是这里我们并没有这么做，而是使用了一个小小技巧去对字段长度进行了一点压缩。对于字符串类型的字段，我们将表示其字段长度域的整型值（int32类型，4字节）按照其数值的大小压缩成1～5个字节，对于每一个字节，如果我们只用其低7位。最高位为标志位，为1时，表示其左边的还有下一个字节，反之到此结束。例如，对于数字127，我们二进制表示成01111111，由于最高位是0，那么如果字段长度是127及以下，一个字节就可以存储下了。如果一个字段长度大于127，如等于256，对应二进制100000000，那么我们按照刚才的规则，先填充最低字节（从左往右依次是从低到高），由于最低的7位放不下，还有后续高位字节，所以我们在最低字节的最高位上填1，即10000000，接着次高位为00000100，由于次高位后面没有更高位的字节了，所以其最高位为0，组合起来两个字节就是10000000 0000100。对于数字50000，其二进制是1100001101010000，根据每7个一拆的原则是：11 0000110 1010000再加上标志位就是：10000011 10000110 01010000。采用这样一种策略将原来占4个字节的整型值根据数值大小压缩成了1～5个字节（由于我们对数据包最大长度有限制，所以不会出现长度需要占5个字节的情形）。反过来，解析每个字段的长度，就是先取出一个字节，看其最高位是否有标志位，如果有继续取下一个字节当字段长度的一部分继续解析，直到遇到某个字节最高位不为1为止。\n对一个整形压缩和解压缩的部分从上面的代码中摘录如下：\n压缩：\n1234567891011121314151617181920212223242526 1    //将一个四字节的整形数值压缩成1~5个字节 2    bool compress_(unsigned int i, char *buf, size_t &amp;len) 3    &#123; 4        len = 0; 5        for (int a = 4; a &gt;= 0; a--) 6        &#123; 7            char c; 8            c = i &gt;&gt; (a * 7) &amp; 0x7f; 9            if (c == 0x00 &amp;&amp; len == 0)10                continue;11            if (a == 0)12                c &amp;= 0x7f;13            else14                c |= 0x80;15            buf[len] = c;16            len++;17        &#125;18        if (len == 0)19        &#123;20            len++;21            buf[0] = 0;22        &#125;23        //cout &lt;&lt; &quot;compress:&quot; &lt;&lt; i &lt;&lt; endl;24        //cout &lt;&lt; &quot;compress len:&quot; &lt;&lt; len &lt;&lt; endl;25        return true;26    &#125;\n\n解压\n1234567891011121314 1    //将一个1~5个字节的值还原成四字节的整形值 2    bool uncompress_(char *buf, size_t len, unsigned int &amp;i) 3    &#123; 4        i = 0; 5        for (int index = 0; index &lt; (int)len; index++) 6        &#123; 7            char c = *(buf + index); 8            i = i &lt;&lt; 7; 9            c &amp;= 0x7f;10            i |= c;11        &#125;12        //cout &lt;&lt; &quot;uncompress:&quot; &lt;&lt; i &lt;&lt; endl;13        return true;14    &#125;\n\n三、关于跨系统与跨语言之间的网络通信协议解析与识别问题由于我们的即时通讯同时涉及到Java和C++两种编程语言，且有windows、linux、安卓三个平台，而我们为了保障学习的质量和效果，所以我们不用第三跨平台库（其实我们也是在学习如何编写这些跨平台库的原理），所以我们需要学习以下如何在Java语言中去解析C++的网络数据包或者反过来。安卓端发送的数据使用Java语言编写，pc与服务器发送的数据使用C++编写，这里以在Java中解析C++网络数据包为例。 这对于很多人来说是一件很困难的事情，所以只能变着法子使用第三方的库。其实只要你掌握了一定的基础知识，利用一些现成的字节流抓包工具（如tcpdump、wireshark）很容易解决这个问题。我们这里使用tcpdump工具来尝试分析和解决这个问题。首先，我们需要明确字节序列这样一个概念，即我们说的大端编码(big endian)和小端编码(little endian)，x86和x64系列的cpu使用小端编码，而数据在网络上传输，以及Java语言中，使用的是大端编码。那么这是什么意思呢？我们举个例子，看一个x64机器上的32位数值在内存中的存储方式：\n\ni在内存中的地址序列是0x003CF7C4~0x003CF7C8，值为40 e2 01 00。\n\n十六进制0001e240正好等于10进制123456，也就是说小端编码中权重高的的字节值存储在内存地址高（地址值较大）的位置，权重值低的字节值存储在内存地址低（地址值较小）的位置，也就是所谓的高高低低。相反，大端编码的规则应该是高低低高，也就是说权值高字节存储在内存地址低的位置，权值低的字节存储在内存地址高的位置。所以，如果我们一个C++程序的int32值123456不作转换地传给Java程序，那么Java按照大端编码的形式读出来的值是：十六进制40E20100 &#x3D; 十进制1088553216。所以，我们要么在发送方将数据转换成网络字节序（大端编码），要么在接收端再进行转换。\n下面看一下如果C++端传送一个如下数据结构，Java端该如何解析（由于Java中是没有指针的，也无法操作内存地址，导致很多人无从下手），下面利用tcpdump来解决这个问题的思路。我们客户端发送的数据包：\n\n其结构体定义如下：\n\n利用tcpdump抓到的包如下：\n\n放大一点：\n\n我们白色标识出来就是我们收到的数据包。这里我想说明两点：\n\n如果我们知道发送端发送的字节流，再比照接收端收到的字节流，我们就能检测数据包的完整性，或者利用这个来排查一些问题；\n\n对于Java程序只要按照这个顺序，先利用java.net.Socket的输出流java.io.DataOutputStream对象readByte、readInt32、readInt32、readBytes、readBytes方法依次读出一个char、int32、int32、16个字节的字节数组、63个字节数组即可，为了还原像int32这样的整形值，我们需要做一些小端编码向大端编码的转换。\n\n\n","slug":"转载/网络编程/服务器开发通信协议设计介绍","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"e09bb655914509994c8e1511db91931a","title":"【转载】服务器端发数据时，如果对端一直不收，怎么办？","content":"服务器端发数据时，如果对端一直不收，怎么办？这类问题一般出现在跨部门尤其是与外部开发人员合作的时候。假设现在有这样一种情况，我们的服务器提供对外的服务，指定好了协议，然后对外提供服务，客户端由外部人员去开发，由于存在太多的不确定性，如果我们在给对端（客户端）发送数据时，对端因为一些问题（可能是逻辑 bug 或者其他的一些问题）一直不从 socket 系统缓冲区中收取数据，而服务器端可能定期产生一些数据需要发送给客户端，再发了一段时间后，由于 TCP 窗口太小，导致数据发送不出去，这样待发送的数据会在服务器端对应的连接的发送缓冲区中积压，如果我们不做任何处理，很快系统就会因为缓冲区过大内存耗尽，导致服务被系统杀死。\n对于这种情况，我们一般建议从以下几个方面来增加一些防御措施：\n\n设置每路发送连接的发送缓冲区大小上限（如 2 M，或者小于这个值），当某路连接上的数据发送不出去的时候，即将数据存入发送缓冲区时，先判断一下缓冲区最大剩余空间，如果剩余空间已经小于我们要放入的数据大小，也就是说缓冲区中数据大小会超过了我们规定的上限，则认为该连接出现了问题，关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）。示例代码如下：\n12345678910//outputBuffer_为发送缓冲区对象size_t remainingLen = outputBuffer_.remainingBytes();//如果加入到缓冲区中的数据长度超出了发送缓冲区最大剩余量if (remainingLen &lt; dataToAppend.length())&#123;\t\tforceClose()\t\treturn&#125;outputBuffer_.append(static_cast&lt;const char*&gt;(dataToAppend.c_str()), dataToAppend.length());\n\n还有另外一种场景，当有一部分数据已经积压在发送缓冲区了，此后服务器端未产生新的待发送的数据，此时如果不做任何处理，发送缓冲区的数据会一直积压，但是发送缓冲区的数据容量也不会超过上限。如果不做任何处理的话，该数据会一直在缓冲区中积压，白白浪费系统资源。对于这种情况一般我们会设置一个定时器，每隔一段时间（如 3 秒）去检查一下各路连接的发送缓冲区中是否还有数据未发送出去，也就是说如果一个连接超过一定时间内还存在未发送出去的数据，我们也认为该连接出现了问题，我们可以关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）。示例代码如下：\n1234567891011121314151617181920212223242526//每3秒检测一次const int SESSION_CHECK_INTERVAL = 3000;SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);void CSessionManager::OnTimer()&#123;    for (auto iter = m_mapSession.begin(); iter != m_mapSession.end(); ++iter)    &#123;        if (!CheckSession(iter-&gt;value))        &#123;            //关闭session，回收相关的资源            iter-&gt;value-&gt;ForceClose();            iter = m_mapSession.erase(iter);        &#125;    &#125;&#125;void CSessionManager::CheckSession(CSession* pSession)&#123;    if (!pSession-&gt;GetConnection().OutputBuffer.IsEmpty())        return false;    return true;&#125;\n\n上述代码，每隔 3 秒检测所有的 Session 的对应的 Connection 对象，如果发现发送缓冲区非空，说明该连接中发送缓冲区中数据已经驻留 3 秒了，将该连接关闭并清理资源。\n\n\n","slug":"转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"fab0416ed78af2e60e15df3589b08519","title":"【转载】网络通信中收发数据的正确姿势","content":"网络通信中收发数据的正确姿势在网络通信中，我们可能既要通过 socket 去发送数据也要通过 socket 来收取数据。那么一般的网络通信框架是如何收发数据的呢？注意，这里讨论的范围是基于各种 IO 复用函数（select、poll、epoll 等）来判断 socket 读写来收发数据，其他情形比较简单，这里就不提了。\n我们这里以服务器端为例。服务器端接受客户端连接后，产生一个与客户端连接对应的 socket（Linux 下也叫 fd，为了叙述方便，以后称之为 clientfd），我们可以通过这个 clientfd 收取从客户端发来的数据，也可以通过这个 clientfd 将数据发往客户端。但是收与发在操作流程上是有明显的区别的。\n收数据的正确姿势对于收数据，当接受连接成功得到 clientfd 后，我们会将该 clientfd 绑定到相应的 IO 复用函数上并监听其可读事件。不同的 IO 复用函数可读事件标志不一样，例如对于 poll 模型，可读标志是 POLLIN，对于 epoll 模型，可读事件标志是 EPOLLIN。当可读事件触发后，我们调用 recv 函数从 clientfd 上收取数据（这里不考虑出错的情况），根据不同的网络模式我们可能会收取部分，或一次性收完。收取到的数据我们会放入接收缓冲区内，然后做解包操作。这就是收数据的全部“姿势”。对于使用 epoll 的 LT 模式（水平触发模式），我们每次可以只收取部分数据；但是对于 ET 模式（边缘触发模式），我们必须将本次收到的数据全部收完。\n\nET 模式收完的标志是 recv 或者 read 函数的返回值是 -1，错误码是 EWOULDBLOCK，针对 Windows 和 Linux 下区别，前面章节已经详细地说过了。\n\n这就是读数据的全部姿势。流程图如下：\n\n发数据的正确姿势对于发数据，除了 epoll 模型的 ET 模式外，epoll 的 LT 模式或者其他 IO 复用函数，我们通常都不会去注册监听该 clientfd 的可写事件。这是因为，只要对端正常收数据，一般不会出现 TCP 窗口太小导致 send 或 write 函数无法写的问题。因此大多数情况下，clientfd 都是可写的，如果注册了可写事件，会导致一直触发可写事件，而此时不一定有数据需要发送。故而，如果有数据要发送一般都是调用 send 或者 write 函数直接发送，如果发送过程中， send 函数返回 -1，并且错误码是 EWOULDBLOCK 表明由于 TCP 窗口太小数据已经无法写入时，而仍然还剩下部分数据未发送，此时我们才注册监听可写事件，并将剩余的服务存入自定义的发送缓冲区中，等可写事件触发后再接着将发送缓冲区中剩余的数据发送出去，如果仍然有部分数据不能发出去，继续注册可写事件，当已经无数据需要发送时应该立即移除对可写事件的监听。这是目前主流网络库的做法。\n流程图如下：\n\n上述逻辑示例如下：\n直接尝试发送消息处理逻辑：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** *@param data 待发送的数据 *@param len  待发送数据长度 */void TcpConnection::sendMessage(const void* data, size_t len)&#123;        int32_t nwrote = 0;    size_t remaining = len;    bool faultError = false;    if (state_ == kDisconnected)    &#123;        LOGW(&quot;disconnected, give up writing&quot;);        return;    &#125;    // 当前未监听可写事件，且发送缓冲区中没有遗留数据    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)    &#123;        //直接发送数据        nwrote = sockets::write(channel_-&gt;fd(), data, len);              if (nwrote &gt;= 0)        &#123;            remaining = len - nwrote;                   &#125;        else // nwrote &lt; 0        &#123;            nwrote = 0;            //错误码不等于EWOULDBLOCK说明发送出错了            if (errno != EWOULDBLOCK)            &#123;                LOGSYSE(&quot;TcpConnection::sendInLoop&quot;);                if (errno == EPIPE || errno == ECONNRESET)                &#123;                    faultError = true;                &#125;            &#125;        &#125;    &#125;    //发送未出错且还有剩余字节未发出去    if (!faultError &amp;&amp; remaining &gt; 0)    &#123;        //将剩余部分加入发送缓冲区        outputBuffer_.append(static_cast&lt;const char*&gt;(data) + nwrote, remaining);        if (!channel_-&gt;isWriting())        &#123;            //注册可写事件            channel_-&gt;enableWriting();        &#125;    &#125;&#125;\n\n不能全部发出去监听可写事件后，可写事件触发后处理逻辑：\n12345678910111213141516171819202122232425262728//可写事件触发后会调用handleWrite()函数void TcpConnection::handleWrite()&#123;      //将发送缓冲区中的数据发送出去    int32_t n = sockets::write(channel_-&gt;fd(), outputBuffer_.peek(), outputBuffer_.readableBytes());    if (n &gt; 0)    &#123;        //发送多少从发送缓冲区移除多少        outputBuffer_.retrieve(n);        //如果发送缓冲区中已经没有剩余，则移除监听可写事件        if (outputBuffer_.readableBytes() == 0)        &#123;            //移除监听可写事件            channel_-&gt;disableWriting();            if (state_ == kDisconnecting)            &#123;                shutdown();            &#125;        &#125;    &#125;    else    &#123;        //发数据出错处理        LOGSYSE(&quot;TcpConnection::handleWrite&quot;);                   handleClose();    &#125; &#125;\n\n对于 epoll LT 模式注册监听一次可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，不用再次注册可写事件；如果是 epoll 的 ET 模式，注册监听可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，需要再次注册可写事件以便让可写事件下次再次触发（给予再次发数据的机会）。当然，这只是理论上的情况，实际开发中，如果一段数据反复发送都不能完全发送完（例如对端先不收，后面每隔很长时间再收一个字节），我们可以设置一个最大发送次数或最大发送总时间，超过这些限定，我们可以认为对端出了问题，应该立即清空发送缓冲区并关闭连接。\n本节的标题是“收发数据的正确姿势”，其实还可以换一种说法，即“检测网络事件的正确姿势”，这里意指检测一个 fd 的读写事件的区别（对于侦听 fd，只检测可读事件）：\n\n在 select、poll 和 epoll 的 LT 模式下，可以直接设置检测 fd 的可读事件；\n在 select、poll 和 epoll 的 LT 模式下不要直接设置检测 fd 的可写事件，应该先尝试发送数据，因为 TCP 窗口太小发不出去再设置检测 fd 的可写事件，一旦数据发出去应立即取消对可写事件的检测。\n在 epoll 的 ET 模式下，需要发送数据时，每次都要设置检测可写事件。\n\n","slug":"转载/网络编程/网络通信中收发数据的正确姿势","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"12ad89ee9300bed7e58f0d5f1f9116ca","title":"【转载】非阻塞模式下send和recv函数的返回值","content":"非阻塞模式下 send 和 recv 函数的返回值我们来总结一下 send 和 recv 函数的各种返回值意义：\n\n\n\n返回值 n\n返回值含义\n\n\n\n大于 0\n成功发送 n 个字节\n\n\n0\n对端关闭连接\n\n\n小于 0（ -1）\n出错或者被信号中断或者对端 TCP 窗口太小数据发不出去（send）或者当前网卡缓冲区已无数据可收（recv）\n\n\n我们来逐一介绍下这三种情况：\n\n返回值大于 0\n对于 send 和 recv 函数返回值大于 0，表示发送或接收多少字节，需要注意的是，在这种情形下，我们一定要判断下 send 函数的返回值是不是我们期望发送的缓冲区长度，而不是简单判断其返回值大于 0。举个例子：\n123451int n = send(socket, buf, buf_length, 0)；2if (n &gt; 0)3&#123;4  printf(&quot;send data successfully\\n&quot;);5&#125;\n\n很多新手会写出上述代码，虽然返回值 n 大于 0，但是实际情形下，由于对端的 TCP 窗口可能因为缺少一部分字节就满了，所以返回值 n 的值可能在 (0, buf_length] 之间，当 0 &lt; n &lt; buf_length 时，虽然此时 send 函数是调用成功了，但是业务上并不算正确，因为有部分数据并没发出去。你可能在一次测试中测不出 n 不等于 buf_length 的情况，但是不代表实际中不存在。所以，建议要么认为返回值 n 等于 buf_length 才认为正确，要么在一个循环中调用 send 函数，如果数据一次性发不完，记录偏移量，下一次从偏移量处接着发，直到全部发送完为止。\n\n\n1234561  //推荐的方式一2  int n = send(socket, buf, buf_length, 0)；3  if (n == buf_length)4  &#123;5      printf(&quot;send data successfully\\n&quot;);6  &#125;\n\n\n\n123456789101112131415161718192021222324252627282930313233343536 1//推荐的方式二：在一个循环里面根据偏移量发送数据 2bool SendData(const char* buf , int buf_length) 3&#123; 4    //已发送的字节数目 5    int sent_bytes = 0; 6    int ret = 0; 7    while (true) 8    &#123; 9        ret = send(m_hSocket, buf + sent_bytes, buf_length - sent_bytes, 0);10        if (nRet == -1)11        &#123;12            if (errno == EWOULDBLOCK)13            &#123;14                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍15                break;16            &#125;             17            else if (errno == EINTR)18                continue;19            else20                return false;21        &#125;22        else if (nRet == 0)23        &#123;24            return false;25        &#125;2627        sent_bytes += ret;28        if (sent_bytes == buf_length)29            break;3031        //稍稍降低 CPU 的使用率32        usleep(1);33    &#125;3435    return true;36&#125;\n\n\n返回值等于 0\n通常情况下，如果 send 或者 recv 函数返回 0，我们就认为对端关闭了连接，我们这端也关闭连接即可，这是实际开发时最常见的处理逻辑。\n但是，现在还有一种情形就是，假设调用 send 函数传递的数据长度就是 0 呢？send 函数会是什么行为？对端会 recv 到一个 0 字节的数据吗？需要强调的是，在实际开发中，你不应该让你的程序有任何机会去 send 0 字节的数据，这是一种不好的做法。 这里仅仅用于实验性讨论，我们来通过一个例子，来看下 send 一个长度为 0 的数据，send 函数的返回值是什么？对端会 recv 到 0 字节的数据吗？\nserver 端代码：\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 1  /** 2   * 验证recv函数接受0字节的行为，server端，server_recv_zero_bytes.cpp 3   * zhangyl 2018.12.17 4   */ 5  #include &lt;sys/types.h&gt;  6  #include &lt;sys/socket.h&gt; 7  #include &lt;arpa/inet.h&gt; 8  #include &lt;unistd.h&gt; 9  #include &lt;iostream&gt;10  #include &lt;string.h&gt;11  #include &lt;vector&gt;1213  int main(int argc, char* argv[])14  &#123;15      //1.创建一个侦听socket16      int listenfd = socket(AF_INET, SOCK_STREAM, 0);17      if (listenfd == -1)18      &#123;19          std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;20          return -1;21      &#125;2223      //2.初始化服务器地址24      struct sockaddr_in bindaddr;25      bindaddr.sin_family = AF_INET;26      bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);27      bindaddr.sin_port = htons(3000);28      if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)29      &#123;30          std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;31          close(listenfd);32          return -1;33      &#125;3435      //3.启动侦听36      if (listen(listenfd, SOMAXCONN) == -1)37      &#123;38          std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;39          close(listenfd);40          return -1;41      &#125;4243      int clientfd;4445      struct sockaddr_in clientaddr;46      socklen_t clientaddrlen = sizeof(clientaddr);47      //4. 接受客户端连接48      clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);49      if (clientfd != -1)50      &#123;           51          while (true)52          &#123;53              char recvBuf[32] = &#123;0&#125;;54              //5. 从客户端接受数据,客户端没有数据来的时候会在recv函数处阻塞55              int ret = recv(clientfd, recvBuf, 32, 0);56              if (ret &gt; 0) 57              &#123;58                  std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;               59              &#125; 60              else if (ret == 0)61              &#123;62                  std::cout &lt;&lt; &quot;recv 0 byte data.&quot; &lt;&lt; std::endl;63                  continue;64              &#125; 65              else66              &#123;67                  //出错68                  std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;69                  break;70              &#125;71          &#125;               72      &#125;737475      //关闭客户端socket76      close(clientfd);77      //7.关闭侦听socket78      close(listenfd);7980      return 0;81  &#125;\n\n上述代码侦听端口号是 3000，代码 55 行调用了 recv 函数，如果客户端一直没有数据，程序会阻塞在这里。\nclient 端代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 1/** 2 * 验证非阻塞模式下send函数发送0字节的行为，client端，nonblocking_client_send_zero_bytes.cpp 3 * zhangyl 2018.12.17 4 */ 5#include &lt;sys/types.h&gt;  6#include &lt;sys/socket.h&gt; 7#include &lt;arpa/inet.h&gt; 8#include &lt;unistd.h&gt; 9#include &lt;iostream&gt;10#include &lt;string.h&gt;11#include &lt;stdio.h&gt;12#include &lt;fcntl.h&gt;13#include &lt;errno.h&gt;1415#define SERVER_ADDRESS &quot;127.0.0.1&quot;16#define SERVER_PORT     300017#define SEND_DATA       &quot;&quot;1819int main(int argc, char* argv[])20&#123;21    //1.创建一个socket22    int clientfd = socket(AF_INET, SOCK_STREAM, 0);23    if (clientfd == -1)24    &#123;25        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;26        return -1;27    &#125;2829    //2.连接服务器30    struct sockaddr_in serveraddr;31    serveraddr.sin_family = AF_INET;32    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);33    serveraddr.sin_port = htons(SERVER_PORT);34    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)35    &#123;36        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;37        close(clientfd);38        return -1;39    &#125;4041    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，42    //不能在创建时就设置，这样会影响到 connect 函数的行为43    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);44    int newSocketFlag = oldSocketFlag | O_NONBLOCK;45    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)46    &#123;47        close(clientfd);48        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;49        return -1;50    &#125;5152    //3. 不断向服务器发送数据，或者出错退出53    int count = 0;54    while (true)55    &#123;56        //发送 0 字节的数据57        int ret = send(clientfd, SEND_DATA, 0, 0);58        if (ret == -1) 59        &#123;60            //非阻塞模式下send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK61            if (errno == EWOULDBLOCK)62            &#123;63                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;64                continue;65            &#125; 66            else if (errno == EINTR)67            &#123;68                //如果被信号中断，我们继续重试69                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;70                continue;71            &#125; 72            else 73            &#123;74                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;75                break;76            &#125;77        &#125;78        else if (ret == 0)79        &#123;80            //对端关闭了连接，我们也关闭81            std::cout &lt;&lt; &quot;send 0 byte data.&quot; &lt;&lt; std::endl;82        &#125; 83        else84        &#123;85            count ++;86            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;87        &#125;8889        //每三秒发一次90        sleep(3);91    &#125;9293    //5. 关闭socket94    close(clientfd);9596    return 0;97&#125;\n\nclient 端连接服务器成功以后，每隔 3 秒调用 send 一次发送一个 0 字节的数据。除了先启动 server 以外，我们使用 tcpdump 抓一下经过端口 3000 上的数据包，使用如下命令：\n11tcpdump -i any &#x27;tcp port 3000&#x27;\n\n然后启动 client ，我们看下结果：\n\n客户端确实是每隔 3 秒 send 一次数据。此时我们使用 lsof -i -Pn 命令查看连接状态，也是正常的：\n\n然后，tcpdump 抓包结果输出中，除了连接时的三次握手数据包，再也无其他数据包，也就是说，send 函数发送 0 字节数据，client 的协议栈并不会把这些数据发出去。\n1234561[root@localhost ~]# tcpdump -i any &#x27;tcp port 3000&#x27;2tcpdump: verbose output suppressed, use -v or -vv for full protocol decode3listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes417:37:03.028449 IP localhost.48820 &gt; localhost.hbci: Flags [S], seq 1632283330, win 43690, options [mss 65495,sackOK,TS val 201295556 ecr 0,nop,wscale 7], length 0517:37:03.028479 IP localhost.hbci &gt; localhost.48820: Flags [S.], seq 3669336158, ack 1632283331, win 43690, options [mss 65495,sackOK,TS val 201295556 ecr 201295556,nop,wscale 7], length 0617:37:03.028488 IP localhost.48820 &gt; localhost.hbci: Flags [.], ack 1, win 342, options [nop,nop,TS val 201295556 ecr 201295556], length 0\n\n因此，server 端也会一直没有输出，如果你用的是 gdb 启动 server，此时中断下来会发现，server 端由于没有数据会一直阻塞在 recv 函数调用处（55 行）。\n\n上述示例再次验证了，send 一个 0 字节的数据没有任何意思，希望读者在实际开发时，避免写出这样的代码。\n","slug":"转载/网络编程/非阻塞模式下send和recv函数的返回值","date":"2021-05-06T09:27:48.000Z","categories_index":"转载","tags_index":"学习资料,网络编程","author_index":"阿木大叔"},{"id":"3faf2e95846c995629df56586598456a","title":"C++中变量和对象可以存放在内存中的位置","content":"在 C++ 中，变量和对象可以存放在各种不同的内存位置，具体取决于它们的定义方式、生命周期及其类型等因素。以下是常见的 C++ 变量和对象所存放的位置：\n\n自动变量：自动变量是指在程序中使用作用域声明的变量（即局部变量），其值只在相应作用域内有效。这些变量通常被分配在堆栈上（Stack Memory）中，并在函数运行时动态地分配和释放。\n1234void example() &#123;    int x = 10; // 在堆栈中分配整数变量x    // ...&#125;\n\n静态变量：静态变量属于所有实例共享的变量，它们一般在程序开始执行时静态地分配到一个规定的内存位置。全局变量和函数内 static 变量都属于静态变量。全局变量会被分配到数据段中（Data Segment），而函数内 static 变量会被分配到全局或静态变量所在的内存区域中。\n1234int globalVar; // 分配在数据段中的全局变量void example() &#123;    static int localVar; // 函数内静态变量    //   &#125;\n\n动态分配的变量：动态变量是在程序运行期间动态地分配和释放的，通常是由 new 和 delete 或者 malloc() 和 free() 等操作所创建、分配和释放的。动态变量通常被分配到堆（Heap Memory）中。\n123int* ptr = new int(10); // 动态分配一个整型变量// ...delete ptr; // 内存释放\n\n常量和文本字符串：常量被保存在代码段（Code Segment）、全局数据区（Global Data Area）或只读数据区（Read Only Data Segment）。文本字符串保存在 ++ 程序的可执行文件中，并在程序运行时被加载到内存中。\n12const int constantNum = 10; // 定义常量数值const char* str = &quot;hello&quot;; // 文本字符串在代码段中\n\n需要注意的是，C++ 变量所存放的位置不仅取决于它们的类型和定义方式，还可能受到编译器和编译器选项等因素的影响。程序员可以使用调试工具来查看变量的实际内存地址并研究其位置。\n","slug":"C++/C++中变量和对象可以存放在内存中的位置","date":"2018-05-12T05:52:41.000Z","categories_index":"C++基础","tags_index":"C++,网络通信","author_index":"阿木大叔"},{"id":"5ea2af3786de0c1e89d3cfbe74111832","title":"第16节 MFC之SendMessage和PostMessage","content":"\n1、PostMessage会将消息压入窗口所在线程的消息队列，然后返回；而SendMessage则不经过消息队列，SendMessage可认为是直接调用了该窗口的窗口过程，因此在我们需要获得消息处理后的返回值的时候，就要用到SendMessage。    例如：当在程序中指定如下使用：PostMessage（hWnd, WM_MSG,0,0），那么当程序执行到PostMessage的时候，仅将消息WM_MSG压入到创建hWnd所指窗口的那个线程的消息队列，然后程序将继续执行下去，而至于程序什么时候响应该消息，则要看那个线程什么时候得到控制权；    而指定如下使用：SendMessage（hWnd, WM_MSG,0,0），那么当程序执行到该处时，将发生一次跳转：从当前位置，跳转到hWnd的窗口过程中去响应WM_MSG消息，当消息处理结束，窗口过程返回，程序又将从SendMessage后面继续执行，当然，我们可以获得窗口过程对该消息的处理结果，也即取SendMessage的返回值。（这里只是针对单线程）。\n\n\n2、在多线程应用中，PostMessage的用法还是一样，但SendMessage则不同了。如果在线程A中向线程B所创建的一个窗口hWndB发送消息SendMessage（hWndB，WM_MSG，0，0），那么系统将会立即将执行权从线程A切换到线程B，然后在线程B中调用hWndB的窗口过程来处理消息，并且在处理完该消息后，执行权仍然在B手中！这个时候，线程A则暂停在SendMessage处，等待下次线程A获得执行权后才继续执行，并且仍然可以获得消息处理的结果（返回值）。一般，为了避免死锁，在B中对WM_MSG做出处理之前，要加上：if(InSendMessage()) RelpyMessage(lResult)； 即判断：如果该消息是发自另外一个线程，则立即 RelpyMessage，回复消息，参数lResult即是返回值。而如果是在同一个线程内，则InSendMessage()将会返回FALSE。     —百度知道\n\n总而言之，按我的理解，SendMessage和PostMessage都是向窗体发送消息的函数，但是PostMessage发送完消息立刻返回，不会等待消息结果，但SendMessage会等到消息返回结果再执行下一步；\n今天我们通过各例子来试试这两种发送消息的方法；\n\n创建一个界面图标，通过拖动图标到任意的windows窗口上，获取到窗口的句柄，标题，类名；并通过SendMessage或PostMessage发送消息到该窗口，修改窗口标题或关闭窗口；\n\n1. 新建项目新建一个基于对话框项目“day18”，布局如下，自行处理：\n2. 新建类Cday18Dlg成员变量1234HCURSOR m_hCursor;  //定义一个鼠标的指针RECT m_rtCtrl;      //图标的大小BOOL m_bCapturing;   //鼠标捕获HWND m_hWndDest;   //目标窗口的窗口句柄\n\n3.加载鼠标指针及获取图标大小编辑Cday18Dlg::OnInitDialog()初始化函数，在return之前添加如下两行\n12m_hCursor = LoadCursor(NULL, IDC_SIZEALL);GetDlgItem(IDC_PIC)-&gt;GetWindowRect(&amp;m_rtCtrl);\n4.创建鼠标右键点击及释放消息如图，添加OnLButtonDown及OnLButtonUp消息处理函数：编辑OnLButtonDown及OnLButtonUp消息处理函数：\n1234567891011121314void Cday18Dlg::OnLButtonDown(UINT nFlags, CPoint point)&#123;\t// TODO: 在此添加消息处理程序代码和/或调用默认值\tif (point.x &gt;= m_rtCtrl.left \t\t&amp;&amp; point.x &lt;= m_rtCtrl.right \t\t|| point.y &gt;= m_rtCtrl.top \t\t&amp;&amp; point.y &lt;= m_rtCtrl.bottom)\t&#123;\t\tm_bCapturing = TRUE;\t\tSetCapture(); // 开始捕获鼠标\t\tSetCursor(m_hCursor);\t&#125;\tCDialogEx::OnLButtonDown(nFlags, point);&#125;\n代码解释：\n\n1.判断鼠标点击的位置是否在图标上；2.若是，则将开始捕获鼠标标志置位真，并且开始捕获鼠标位置；3.将捕获的鼠标位置设置到成员变量m_hCursor；\n\n12345678910111213141516171819202122void Cday18Dlg::OnLButtonUp(UINT nFlags, CPoint point)&#123;\t// TODO: 在此添加消息处理程序代码和/或调用默认值\tif (m_bCapturing)\t&#123;\t\tReleaseCapture();\t\tm_bCapturing = FALSE;\t\tPOINT pt = point;\t\tClientToScreen(&amp;pt);\t\tm_hWndDest = ::WindowFromPoint(pt);\t\tTCHAR szBuf[MAX_PATH] = &#123;0&#125;;\t\t_stprintf(szBuf,_T(&quot;0x%.8X&quot;),m_hWndDest);\t\tSetDlgItemText(IDC_EDIT_DESTHWND,szBuf);\t\tGetClassName(m_hWndDest,szBuf,MAX_PATH);\t\tSetDlgItemText(IDC_EDIT_DESTCLASS,szBuf);\t\t::SendMessage(m_hWndDest,WM_GETTEXT,MAX_PATH,(LPARAM)szBuf);\t\tSetDlgItemText(IDC_EDIT_DESTTEXT,szBuf);\t&#125;\tCDialogEx::OnLButtonUp(nFlags, point);&#125;\n\n代码解释：\n\n1.判断是否在捕获鼠标；2.若是，释放鼠标捕获，获取当前鼠标的位置；3.通过当前鼠标的位置获取到当前位置的窗口句柄；4.分别获取该窗口的句柄，类名，标题；\n\n效果图：\n5.实现修改目标窗口标题双击“修改标题”按钮，编辑其clicked方法：\n1234567void Cday18Dlg::OnBnClickedBtnSettext()&#123;\t// TODO: 在此添加控件通知处理程序代码\tCString strText;\tGetDlgItemText(IDC_EDIT_DESTTEXT,strText);\t::SendMessage(m_hWndDest,WM_SETTEXT,0,(LPARAM)(LPCTSTR)strText);&#125;\n代码解释：\n\n1.获取文本框中的标题值；2.通过SendMessage方法发送WM_SETTEXT消息修改目标窗口的标题\n\n效果图：\n6.实现关闭目标窗口双击“关闭标题”按钮，编辑其clicked方法：\n123456void Cday18Dlg::OnBnClickedBtnSettext2()&#123;\t// TODO: 在此添加控件通知处理程序代码\t::SendMessage(m_hWndDest,WM_CLOSE,0,0);\t//::PostMessage(m_hWndDest,WM_CLOSE,0,0);&#125;\n代码解释：\n\n1.通过SendMessage方法发送WM_CLOSE消息来关闭目标窗口；\n\n上面我们都是使用SendMessage方法来发送消息，其实我们也可以把SendMessage全部替换成PostMessage，我们来看看效果：我们可以看“窗口标题”获取的值是不对的，这是为什么？我们来看一下获取标题的这段代码：\n123456789101112ReleaseCapture();m_bCapturing = FALSE;POINT pt = point;ClientToScreen(&amp;pt);m_hWndDest = ::WindowFromPoint(pt);TCHAR szBuf[MAX_PATH] = &#123;0&#125;;_stprintf(szBuf,_T(&quot;0x%.8X&quot;),m_hWndDest);SetDlgItemText(IDC_EDIT_DESTHWND,szBuf);GetClassName(m_hWndDest,szBuf,MAX_PATH);SetDlgItemText(IDC_EDIT_DESTCLASS,szBuf);::PostMessage(m_hWndDest,WM_GETTEXT,MAX_PATH,(LPARAM)szBuf);SetDlgItemText(IDC_EDIT_DESTTEXT,szBuf);\n我们看到前面获取窗口句柄，类名都是没问题的，但是到了最后获取标题时出了问题；那是因为PostMessage是不会等待消息的返回结果，发送之后直接往下运行，这时szBuf的值还是前面获取的“窗口类名”，所以导致最后的“窗口标题”内容获取出错，这也很好的证明PostMessage和SendMessage的区别；还有“修改标题”及“关闭窗口”按钮不管是PostMessage和SendMessage方法都不会出错，那是因为我们在这两个按钮方法中都不需要消息的返回值，所以在我们以后的实际使用中一定要考虑清楚需要使用哪种发送消息方法；\n动态效果图：附MFC消息分类及说明：\n窗口消息\nWM_CREATE           创建一个窗口 WM_DESTROY          当一个窗口被破坏时发送 WM_MOVE移动一个窗口 WM_SIZE             改变一个窗口的大小 WM_ACTIVATE一个窗口被激活或失去激活状态 WM_SETFOCUS         一个窗口获得焦点 WM_KILLFOCUS一个窗口失去焦点 WM_ENABLE           一个窗口改变成Enable状态 WM_SETREDRAW设置窗口是否能重画 WM_SETTEXT          应用程序发送此消息来设置一个窗口的文本 WM_GETTEXT应用程序发送此消息来复制对应窗口的文本到缓冲区 WM_GETTEXTLENGTH    得到与一个窗口有关的文本的长度（不包含空字符）WM_PAINT            要求一个窗口重画自己 WM_CLOSE当一个窗口或应用程序要关闭时发送一个信号 WM_QUERYENDSESSION当用户选择结束对话框或程序自己调用ExitWindows函数 WM_QUIT             用来结束程序运行WM_QUERYOPEN        当用户窗口恢复以前的大小位置时，把此消息发送给某个图标 WM_ERASEBKGND当窗口背景必须被擦除时（例在窗口改变大小时） WM_SYSCOLORCHANGE   当系统颜色改变时，发送此消息给所有顶级窗口WM_ENDSESSION       当系统进程发出WM_QUERYENDSESSION消息后，此消息发送给应用程序，通知它对话是否结束WM_SHOWWINDOW       当隐藏或显示窗口是发送此消息给这个窗口 WM_ACTIVATEAPP发此消息给应用程序哪个窗口是激活的，哪个是非激活的 WM_FONTCHANGE       当系统的字体资源库变化时发送此消息给所有顶级窗口WM_TIMECHANGE       当系统的时间变化时发送此消息给所有顶级窗口 WM_CANCELMODE发送此消息来取消某种正在进行的摸态（操作） WM_SETCURSOR如果鼠标引起光标在某个窗口中移动且鼠标输入没有被捕获时，就发消息给某个窗口 WM_MOUSEACTIVATE当光标在某个非激活的窗口中而用户正按着鼠标的某个键发送此消息给当前窗口 WM_CHILDACTIVATE发送此消息给MDI子窗口当用户点击此窗口的标题栏，或当窗口被激活，移动，改变大小 WM_QUEUESYNC此消息由基于计算机的训练程序发送，通过 WH_JOURNALPALYBACK 的 hook 程序分离出用户输入消息WM_GETMINMAXINFO    此消息发送给窗口当它将要改变大小或位置 WM_PAINTICON发送给最小化窗口当它图标将要被重画 WM_ICONERASEBKGND   此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画WM_NEXTDLGCTL       发送此消息给一个对话框程序去更改焦点位置 WM_SPOOLERSTATUS每当打印管理列队增加或减少一条作业时发出此消息 WM_DRAWITEM当button，combobox，listbox，menu的可视外观改变时发送 WM_MEASUREITEM      当button,combo box, list box, list view control, or menu item 被创建时WM_VKEYTOITEM此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息 WM_CHARTOITEM此消息由一个LBS_WANTKEYBOARDINPUT风格的列表框发送给他的所有者来响应WM_CHAR消息 WM_SETFONT当绘制文本时程序发送此消息得到控件要用的颜色 WM_GETFONT          应用程序发送此消息得到当前控件绘制文本的字体WM_SETHOTKEY        应用程序发送此消息让一个窗口与一个热键相关连 WM_GETHOTKEY应用程序发送此消息来判断热键与某个窗口是否有关联 WM_QUERYDRAGICON此消息发送给最小化窗口，当此窗口将要被拖放而它的类中没有定义图标，应用程序能返回一个图标或光标的句柄，当用户拖放图标时系统显示这个图标或光标WM_COMPAREITEM      发送此消息来判定 combobox 或 listbox 新增加的项的相对位置WM_COMPACTING       显示内存已经很少了 WM_WINDOWPOSCHANGING发送此消息给那个窗口的大小和位置将要被改变时，来调用 setwindowpos 函数或其它窗口管理函数WM_WINDOWPOSCHANGED 发送此消息给那个窗口的大小和位置已经被改变时，来调用setwindowpos函数或其它窗口管理函数WM_POWER            当系统将要进入暂停状态时发送此消息 WM_COPYDATA当一个应用程序传递数据给另一个应用程序时发送此消息 WM_CANCELJOURNA     当某个用户取消程序日志激活状态，提交此消息给程序WM_NOTIFY           当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口WM_INPUTLANGCHANGEREQUEST  当用户选择某种输入语言，或输入语言的热键改变 WM_INPUTLANGCHANGE当平台现场已经被改变后发送此消息给受影响的最顶级窗口 WM_TCARD            当程序已经初始化 windows帮助例程时发送此消息给应用程序 WM_HELP此消息显示用户按下了F1，如果某个菜单是激活的，就发送此消息个此窗口关联的菜单，否则就发送给有焦点的窗口，如果当前都没有焦点，就把此消息发送给当前激活的窗口WM_USERCHANGED当用户已经登入或退出后发送此消息给所有的窗口，当用户登入或退出时系统更新用户的具体设置信息，在用户更新设置时系统马上发送此消息WM_NOTIFYFORMAT     公用控件，自定义控件和他们的父窗口通过此消息来判断控件是使用ANSI还是UNICODE结构WM_CONTEXTMENU      当用户某个窗口中点击了一下右键就发送此消息给这个窗口 WM_STYLECHANGING当调用SETWINDOWLONG函数将要改变一个或多个 窗口的风格时发送此消息给那个窗口 WM_STYLECHANGED     当调用SETWINDOWLONG 函数一个或多个 窗口的风格后发送此消息给那个窗口 WM_DISPLAYCHANGE当显示器的分辨率改变后发送此消息给所有的窗口 WM_GETICON此消息发送给某个窗口来返回与某个窗口有关连的大图标或小图标的句柄 WM_SETICON程序发送此消息让一个新的大图标或小图标与某个窗口关联 WM_NCCREATE当某个窗口第一次被创建时，此消息在WM_CREATE消息发送前发送 WM_NCDESTROY此消息通知某个窗口，非客户区正在销毁 WM_NCCALCSIZE       当某个窗口的客户区域必须被核算时发送此消息WM_NCHITTEST        移动鼠标，按住或释放鼠标时发生 WM_NCPAINT程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时 WM_NCACTIVATE此消息发送给某个窗口仅当它的非客户区需要被改变来显示是激活还是非激活状态 WM_GETDLGCODE发送此消息给某个与对话框程序关联的控件。正常情况下，windows 处理所有输入到此控件的箭头键和 TAB 键。通常响应WM_GETDLGCODE 消息，应用程序可以控制一个特定类型的输入和处理这个输入                     WM_NCMOUSEMOVE      当光标在一个窗口的非客户区内移动时发送此消息给这个窗口。非客户区为：窗体的标题栏及窗体的边框 WM_NCLBUTTONDOWN当光标在一个窗口的非客户区同时按下鼠标左键时提交此消息 WM_NCLBUTTONUP当用户释放鼠标左键同时光标某个窗口在非客户区十发送此消息 WM_NCLBUTTONDBLCLK当用户双击鼠标左键同时光标某个窗口在非客户区十发送此消息 WM_NCRBUTTONDOWN当用户按下鼠标右键同时光标又在窗口的非客户区时发送此消息 WM_NCRBUTTONUP当用户释放鼠标右键同时光标又在窗口的非客户区时发送此消息 WM_NCRBUTTONDBLCLK当用户双击鼠标右键同时光标某个窗口在非客户区十发送此消息 WM_NCMBUTTONDOWN当用户按下鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_NCMBUTTONUP当用户释放鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_NCMBUTTONDBLCLK当用户双击鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_KEYFIRST         WM_KEYDOWN 按下一个键WM_KEYUP            释放一个键 WM_CHAR             按下某键，并已发出WM_KEYDOWN，WM_KEYUP消息 WM_DEADCHAR         当用 translatemessage 函数翻译 WM_KEYUP消息时发送此消息给拥有焦点的窗口 WM_SYSKEYDOWN       当用户按住 ALT 键同时按下其它键时提交此消息给拥有焦点的窗口WM_SYSKEYUP         当用户释放一个键同时 ALT 键还按着时提交此消息给拥有焦点的窗口 WM_SYSCHAR当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口 WM_SYSDEADCHAR当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后发送此消息给拥有焦点的窗口 WM_INITDIALOG在一个对话框程序被显示前发送此消息给它，通常用此消息初始化控件和执行其它任务 WM_COMMAND当用户选择一条菜单命令项或当某个控件发送一条消息给它的父窗口，一个快捷键被翻译 WM_SYSCOMMAND当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息 WM_TIMER            发生了定时器事件WM_HSCROLL          当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件WM_VSCROLL          当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件WM_INITMENU当一个菜单将要被激活时发送此消息，它发生在用户菜单条中的某项或按下某个菜单键，它允许程序在显示前更改菜单 WM_INITMENUPOPUP当一个下拉菜单或子菜单将要被激活时发送此消息，它允许程序在它显示前更改菜单，而不要改变全部 WM_MENUSELECT当用户选择一条菜单项时发送此消息给菜单的所有者（一般是窗口） WM_MENUCHAR当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者 WM_ENTERIDLE当一个模态对话框或菜单进入空载状态时发送此消息给它的所有者，一个模态对话框或菜单进入空载状态就是在处理完一条或几条先前的消息后没有消息它的列队中等待WM_CTLCOLORMSGBOX   在 windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色WM_CTLCOLOREDIT     当一个编辑型控件将要被绘制时发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色 WM_CTLCOLORLISTBOX当一个列表框控件将要被绘制前发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色 WM_CTLCOLORBTN当一个按钮控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色WM_CTLCOLORDLG      当一个对话框控件将要被绘制前发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色 WM_CTLCOLORSCROLLBAR当一个滚动条控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色WM_CTLCOLORSTATIC   当一个静态控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色 WM_MOUSEFIRST       移动鼠标时发生WM_MOUSEMOVE        移动鼠标时发生，同WM_MOUSEFIRST WM_LBUTTONDOWN      按下鼠标左键WM_LBUTTONUP        释放鼠标左键 WM_LBUTTONDBLCLK    双击鼠标左键 WM_RBUTTONDOWN按下鼠标右键 WM_RBUTTONUP        释放鼠标右键 WM_RBUTTONDBLCLK    双击鼠标右键WM_MBUTTONDOWN      按下鼠标中键 WM_MBUTTONUP        释放鼠标中键 WM_MBUTTONDBLCLK双击鼠标中键 WM_MOUSEWHEEL       当鼠标轮子转动时发送此消息个当前有焦点的控件\n\n按钮\nBM_CLICK    按钮被点击消息  BM_GETCHECK 可用于复选框&#x2F;单选框。查看是否被选择了  BM_GETSTATE发送此消息，可返回 button 的状态，如是否被选择；是否可用（不可用就变灰了）  BM_SETCHECK如果已经选择了，发送此消息后，变为未选择，就是那个钩没被勾上 BM_SETSTATE 设置 button 被点击状态。\n\n组合框\nCB_ADDSTRING       添加字符串到组合框。  CB_DELETESTRING    删除组合框中的条目，即 item 。CB_GETCOUNT        得到组合框条目 item 的数目。  CB_GETCURSEL返回组合框中被选条目在组合框中的位置，第一条为 0。                   如果没有条目或出错，则返回 -1 。 CB_GETDROPPEDSTATE 发送此消息，可判断组合框的下拉列表是否下拉。                   如果是，返回非零值，不是，则返回 0 。 CB_GETLBTEXT       得到组合框的条目文本。返回值是这个文本的长度。  CB_GETLBTEXTLEN    返回值是条目的文本的长度。CB_INSERTSTRING    插入字符串条目到组合框中。  CB_RESETCONTENT    清空组合框所有条目。CB_SETCURSEL       设置组合框被选条目。  CB_SHOWDROPDOWN    让组合框的下拉列表下拉，即显出所有条目。\n\n编辑框\nEM_CANUNDO             决定上一次操作是否可以 undo（撤消操作）。如果可以，则可发送 EM_UNDO 消息EM_GETFIRSTVISIBLELINE 在多行控件中，找到最上层的可见的行号。此行号是相对于所有行的。EM_GETPASSWORDCHAR     返回密码框的字符集，即查看密码。  EM_GETSEL返回在可编辑控件中，被选择（高亮选择）的字符集的起点和终点的位置，用 SendMessage 的 wParam参数返回起点位置，lParam 返回终点位置  EM_REPLACESEL用不同的字符串替换可编辑控件中的字符串。如果可编辑控件中没有字符串，则此消息变为添加字符串。如果 wParam 为TRUE，则本次操作允许撤消，FALSE 禁止撤消。  EM_SETPASSWORDCHAR     在可编辑控件中设置密码字符集，即用 *代替  EM_UNDO                发送操作撤消消息。    EM_GETLINE获取编辑控件中输入的文字。 EM_LINEFROMCHAR        检索指定字符索引（索引编号从编辑框的第一个字符开始）所在的行索引EM_LINEINDEX           在多行编辑控件中，检索某行首字符在编辑控件中的索引 EM_ERRSPACE编辑控件不能分配足够的内存来满足特定的要求。                       编辑控件的父窗口通过 WM_COMMAND 消息收到此消息。 EM_LIMITTEXT           设置编辑框用户可输入的最大字符数。wParam 为字符数，lParam 不使用(0L)\n\nIP 地址控件\nIPM_CLEARADDRESS       清除 IP 地址控件（IP Address control）的内容IPM_GETADDRESS         从 IP 地址控件获得存储在它中的 IP 地址信息 IPM_ISBLANK决定 IP 地址控件是否可以为空值。即 127.0.0.1 之类的地址为空  IPM_SETADDRESS         在 IP地址控件中设置 IP 地址     IPM_SETFOCUS           在 IP 地址控件中，当需要输入 IP 地址时，使之获得键盘输入焦点  IPM_SETRANGE           设置输入 IP 地址的有效范围\n\nMCI（Media Control Interface)\nMM_MCINOTIFY           该 MM_MCINOTIFY 消息通知应用程序，一个 MCI 设备已完成操作。只有设置了MCI_NOTIFY 标志时，MCI 设备才发送此消息。\n\n菜单\nWM_COMMAND     当用户选择菜单中的项目后,将向窗体发送此消息. 窗体收到此消息后,再决定下一个行为。 WM_INITMENU当菜单准备显示前,向窗体发送此消息, 窗体将初始化菜单项。  WM_SYSCOMMAND  向窗体发送用户点击系统菜单消息.窗体将响应这个消息 ,决定下个行为。\n\n列表框\nLB_ADDSTRING        在条目中添加字符串  LB_DELETESTRING     删除一个条目. 条目序号是从 0开始的.  LB_GETCOUNT         得到条目总数.  LB_GETCURSEL        得到单选的列表框选项条目的序号LB_GETSEL           判断列表框的条目是否被选上, 如果选上了,则返回 &gt;0 的值。否则返回 0 ,表示用户没选择条目LB_GETSELCOUNT      获得可多选的列表框中被选择的条目数  LB_GETSELITEMS返回可多选的列表框中被选条目的序号，可返回数组 LB_GETTEXT          得到列表框中的一个条目的文本LB_GETTEXTLEN       得到列表框中的一个条目的文本的长度  LB_INSERTSTRING在列表框中插入一个条目。如果成功，将返回插入后此条目的序号。  LB_SETCURSEL对单选的列表框，设定用户选择条目的具体值  LB_SETSEL           对多选的列表框，设定用户选择条目的具体值LB_RESETCONTENT     从列表框删除所有项目，wParam 和 lParam 参数均不使用（为 0）LB_SETHORIZONTALEXTENT设定列表框水平滚动范围。如果列表框宽度小于此值，则水平滚动条显现；如果列表框宽度大于等于此值，则水平滚动条是隐藏的。wParam为所设的水平滚动范围（像素），lParam 不使用，为 0。没有返回值 注意：LB_SETHORIZONTALEXTENT消息要起作用，列表框必须定义 WS_HSCROLL 样式 LB_SETTABSTOPS在列表框中设置制表位位置（即每列间距）为了应对 LB_SETTABSTOPS 消息，列表框必须已经拥有 LBS_USETABSTOPS样式。 wParam 指定制表位数量，lParam 为制表位整数数组（各列之间间隔，不必相等）如果 wParam 是 0，lParam 为NULL，默认制表位是 2 个对话框模板单位。如果 wParam 是 1，制表位为 lParam 指定的距离。如果超过 1，制表位将被设置为lParam 中的每个值（wParam 指定数量）\n\n鼠标\nWM_LBUTTONDBLCLK  当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已双击，返回值 0  WM_LBUTTONDOWN当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已点击，返回值 0  WM_LBUTTONUP当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已释放，返回值 0   WM_MBUTTONDBLCLK当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已双击，返回值 0  WM_MBUTTONDOWN当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已点击，返回值 0  WM_MBUTTONUP当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已释放，返回值 0\n\n项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第16节-MFC之SendMessage和PostMessage","date":"2017-11-04T15:33:16.000Z","categories_index":"","tags_index":"","author_index":"阿木大叔"},{"id":"4cba1917e258f58a831088a0ecbb4f93","title":"第15节 MFC之复选框及单选按钮","content":"Windows编程基础–第15节 MFC之复选框及单选按钮1. 新建项目新建一个基于对话框项目“day17”，布局如下，自行处理：\n拖动三个check box和两个radio button到界面上，设置其ID如下：\n\n\n\n控件名\n控件ID\n\n\n\n红色\nIDC_CHECK_RED\n\n\n绿色\nIDC_CHECK_GREEN\n\n\n蓝色\nIDC_CHECK_BLUE\n\n\n矩形\nIDC_RADIO_SQURAE\n\n\n圆形\nIDC_RADIO_CIRC\n\n\n执行“工具”-&gt;“tab键位置”，确保两个radio button的顺序是连续的，如下图：\n\n\n\n\n\n\n\n\n\n\n\n指定第一个radio button（矩形）的Group的值为true，如图:\n2. 添加关联变量添加五个控件的变量，如图：\n12345DDX_Control(pDX, IDC_CHECK_RED, m_chk_red);DDX_Control(pDX, IDC_CHECK_GREEN, m_chk_green);DDX_Control(pDX, IDC_CHECK_BLUE, m_chk_blue);DDX_Control(pDX, IDC_RADIO_SQURAE, m_rd_squ);DDX_Control(pDX, IDC_RADIO_CIRC, m_rd_circ);\n分别添加如上变量；\n3. 开始写代码吧现在我们来让程序运行起来时默认选中圆形；切换到解决方案视图，进入BOOL Cday17Dlg::OnInitDialog()方法：在末尾return前加入这一行：\n1234// TODO: 在此添加额外的初始化代码CheckRadioButton(IDC_RADIO_SQURAE,IDC_RADIO_CIRC,IDC_RADIO_CIRC);return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE\n代码解释：\n\n在IDC_RADIO_SQURAE和IDC_RADIO_CIRC之间选中IDC_RADIO_CIRC\n\n添加五个控件的事件处理方法如图所示：剩下四个都如上添加好；编辑“蓝色”按钮的点击方法：\n12345void Cday17Dlg::OnBnClickedCheckBlue()&#123;\t// TODO: 在此添加控件通知处理程序代码\tInvalidate();&#125;\n代码解释：\n\nInvalidate()让对话框重汇对话框；\n\n添加擦除背景消息（OnEraseBkgnd）事件如图添加OnEraseBkgnd消息处理函数：编辑OnEraseBkgnd函数：\n12345678910111213141516171819202122232425BOOL Cday17Dlg::OnEraseBkgnd(CDC* pDC)&#123;\t// TODO: 在此添加消息处理程序代码和/或调用默认值\tBOOL bRet = CDialogEx::OnEraseBkgnd(pDC);\tint nRed,nGreen,nBlue;\tnRed = m_chk_red.GetCheck() ? 255 : 0;\tnGreen = m_chk_green.GetCheck() ? 255 : 0;\tnBlue = m_chk_blue.GetCheck() ? 255 : 0;\tCOLORREF crFore = RGB(nRed,nGreen,nBlue);\tCBrush brush;\tbrush.CreateSolidBrush(crFore);\tCBrush *pOldBrush = pDC-&gt;SelectObject(&amp;brush);\tRECT rc = &#123;100, 40, 400, 340&#125;;\tif (m_rd_squ.GetCheck())\t&#123;\t\tpDC-&gt;Rectangle(&amp;rc);\t&#125;\telse&#123;\t\tpDC-&gt;Ellipse(&amp;rc);\t&#125;\tpDC-&gt;SelectObject(pOldBrush);\treturn bRet;&#125;\n代码解释：\n\n\n根据颜色按钮的选择状态来选择颜色为255还是0；\n用三个的颜色来创建一个画刷；\n保留旧的画刷；\n创建RECT 对象，即圆形的大小；\n根据形状的radio button来选择化圆形还是矩形；\n还原旧的画刷；\n\n\n实现其他按钮其他按钮就只用调用OnBnClickedCheckBlue()就可以了；\n最终效果图：\n项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第15节-MFC之复选框及单选按钮","date":"2017-11-02T15:00:09.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"236b306ed30598f9de558dada84c87a9","title":"第14节 MFC之文件对话框CFileDialog","content":"第14节 MFC之文件对话框CFileDialog\n今天我们学习两个打开文件对话框、保存文件对话框，应用程序难免需要加载文件，或者打开配置文件等，这就用到打开或者保存对话框，例如windows文本编辑器中保存对话框就属于其中一种：\n\n1. 新建项目新建一个基于对话框项目“day16”，布局如下，自行处理：拖动一个EDIT到界面，并修改如下属性：\n\n\n\n属性\n修改值\n解释\n\n\n\nID\nIDC_EDIT_TXT\n控件ID\n\n\nWant Return\nTRUE\n允许回车\n\n\nMultiline\nTRUE\n允许多行\n\n\nHorizontal Scoll\nTRUE\n水平滚动条\n\n\nVertical Scoll\nTRUE\n垂直滚动条\n\n\n2. 添加菜单资源切换到资源视图，添加菜单资源如下：若不知道怎么添加菜单请参考**Windows编程基础–第10节 MFC菜单 **\n\n注意：菜单选项最后加上&amp;符号可以设置快捷键，如“文件(&amp;F)”，当程序运行时可以通过ALT + F快捷打开文件菜单选项；\n\n将菜单绑定到主界面：\n3. 实现文件打开对话框右击菜单中“打开”选项，选择“添加事件处理处理程序”，添加处理程序，如图：其中行数处理程序名称：OnFileOpen，类列表选择：Cday16Dlg，添加编辑：函数代码如下：\n12345678910111213141516171819202122232425262728void Cday16Dlg::OnFileOpen()&#123;\t// TODO: 在此添加命令处理程序代码\tCFileDialog dlg(TRUE,NULL,NULL,OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST,_T(&quot;文本文件(*.txt)|*.txt|所有文件(*.*)|*.*||&quot;),this);\tdlg.m_ofn.lpstrInitialDir = _T(&quot;C:\\\\&quot;);\tif (dlg.DoModal()  == IDOK)\t&#123;\t\tCStdioFile inFile;\t\tinFile.Open(dlg.GetPathName(),CFile::modeRead);\t\tCString text;\t\tCString temp;\t\twhile(inFile.ReadString(text))\t\t&#123;    \t\t\tGetDlgItemText(IDC_EDIT_TXT,temp);\t\t\tif (temp.GetLength() &gt; 0)\t\t\t&#123;\t\t\t\tSetDlgItemText(IDC_EDIT_TXT,temp +&quot;\\r\\n&quot;+ text);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tSetDlgItemText(IDC_EDIT_TXT,text);\t\t\t&#125;\t\t\t\t\t&#125;\t\tinFile.Close();\t&#125;&#125;\n代码解释：\n\n\n创建一个txt文件对话框；\n如文件对话框确定按钮被点击，则打开文件位置，文件全路径就是dlg.GetPathName()；\n循环读取文件，知道文件读取结束；每读一行就先获取界面文本框的内容加上新读取的文本，重新设置到界面；\n关闭文件\n\n\n这样一个打开文件对话框就完成了，效果图如下：\n3. 实现文件保存对话框右击菜单中“保存”选项，选择“添加事件处理处理程序”，添加处理程序，如图：名称：OnSaveFile，类列表选择：Cday16Dlg，添加编辑：函数代码如下\n12345678910111213141516171819202122void Cday16Dlg::OnSaveFile()&#123;\t// TODO: 在此添加命令处理程序代码\tCFileDialog dlg(FALSE,NULL,NULL,OFN_HIDEREADONLY |OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,_T(&quot;文本文件(*.txt)|*.txt||&quot;),this);\tif (dlg.DoModal()  == IDOK)\t&#123;\t\tCFile file;  //建立一个CFile对象\t\t//打开文件,如果不存在该文件就创建文件\t\tif(!file.Open(dlg.GetPathName(),CFile::modeCreate|CFile::modeWrite))\t\t&#123;\t\t\tAfxMessageBox( &quot;can   not   Create   file! &quot;);\t\t\treturn;\t\t&#125; \t\tCString output;\t\tGetDlgItemText(IDC_EDIT_TXT,output);\t\tfile.Write(output,strlen(output));\t\tfile.Flush();    //将在缓冲区中的字符写入文件中\t\tfile.Close();   //关闭文件\t\tAfxMessageBox( &quot;保存成功！&quot;);\t&#125;&#125;\n代码解释：\n\n\n创建一个txt文件保存对话框；\n如文件对话框确定按钮被点击，则获取文件位置，文件全路径就是dlg.GetPathName()；\n先获取界面文本框的内容，将内容写到文件中；\n关闭文件效果图：\n\n\n好了，这节我们演示了如何创建文件打开和保存对话框，希望对大家有作用，今天就到这了。项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第14节-MFC之文件对话框CFileDialog","date":"2017-11-01T13:49:20.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"33b07364cfa133acbebe1120a6b4e2ef","title":"第13节 MFC之图片控件","content":"第13节 MFC之图片控件这节学习两个控件：\n\n图片控件：  Picture Control\n\n1. 新建项目新建一个基于对话框项目“day15”，布局如下，自行处理：拖动一个Picture Control控件到界面，其实Picture Control就是CStatic 类；\n设置Picture Control的如下属性：\n\n\n\n属性\n修改值\n解释\n\n\n\nID\nIDC_STATIC_IMG\n控件ID\n\n\nType\nBitmap\n设置类型为bitmap位图类型\n\n\n如图：\n\n\n\n\n2.添加Bitmap 位图资源自行下载几张.bmp位图，拷贝到项目的res文件下，然后切换到资源视图，添加Bitmap 资源，如图所示：上传完成之后可以看到已经有三个Bitmap 位图的ID；\n3.显示出位图资源单击Picture Control控件，在属性中找到Image属性，在下拉框中选择我们刚才添加的位图ID就可以成功显示图片了，如图：\n4.动态控制显示图片在界面上添加一个按钮，我么通过按钮来切换界面图片显示：接下来我们添加Picture Control控件的变量m_image，如图:我们来编辑“切换按钮”的点击方法：\n123456void Cday15Dlg::OnBnClickedButtonChange()&#123;\t// TODO: 在此添加控件通知处理程序代码\tHBITMAP phBmp = (HBITMAP)LoadImage(NULL,_T(&quot;.\\\\res\\\\20171031100114614.bmp&quot;),IMAGE_BITMAP,0,0,LR_LOADFROMFILE);\tm_image.SetBitmap(phBmp);&#125;\n代码解释：\n\n\n获取一个位图的句柄2.将其设置到Picture Control控件\n\n\n效果图：\n5.配合CFileDialog 类来选择显示图片我们来编辑“切换按钮”的点击方法：\n12345678910void Cday15Dlg::OnBnClickedButtonChange()&#123;\t// TODO: 在此添加控件通知处理程序代码\tCFileDialog dlg(TRUE,NULL,NULL,OFN_FILEMUSTEXIST,_T(&quot;*.bmp|*.bmp&quot;),this);\tif (dlg.DoModal() == IDOK)\t&#123;\t\tHBITMAP phBmp = (HBITMAP)LoadImage(NULL,dlg.GetPathName(),IMAGE_BITMAP,0,0,LR_LOADFROMFILE);\t\tm_image.SetBitmap(phBmp);\t&#125;&#125;\n代码解释：\n\n\n创建一个.bmp类型的文件打开对话框\n若点击确定按钮，则将选择的.bmp文件显示出来；\n\n\n效果图：\n附Picture Control控件常见属性及方法：\n一、图片控件属性\nPicture Control 属性: Type:Frame &#x2F;&#x2F;框架 Type:Etched Horz水平蚀刻线条 Type:EtchedVert垂真蚀刻线条 Type:Rectangle实心矩形 Type:Bitmap位图 Type:Icon  图标Type:Enhanced Metafile 增强图元 支持wmf格式图片 Type:Owner Draw   自绘图 Color:颜色    Black:黑    Gray:灰色    White:白色    Etched:蚀刻\n\n二、Picture Control 控件类\nCStatic:: SetBitmap Specifies a bitmap to be displayed in the staticcontrol. GetBitmap Retrieves the handle of the bitmap previously setwith SetBitmap.\nSetIcon Specifies an icon to be displayed in the static control.GetIcon Retrieves the handle of the icon previously set with SetIcon.\nSetCursor Specifies a cursor image to be displayed in the staticcontrol. GetCursor Retrieves the handle of the cursor image previouslyset with SetCursor.\nSetEnhMetaFile Specifies an enhanced metafile to be displayed in thestatic control. GetEnhMetaFile Retrieves the handle of the enhancedmetafile previously set with SetEnhMetaFile\n\n项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第13节-MFC之图片控件","date":"2017-10-31T14:37:27.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"38d440139df1f611dc7be067d5f7cb2f","title":"第12节 MFC之树控件CTreeCtrl","content":"\n树形控件（Tree Control）：用来显示一系列项目的层次关系，最典型的例子是显示磁盘上的文件与文件夹。如果有子项目的话，单击树形控件中的项目可以展开或者收缩其子项目。MFC提供了CTreeCtrl类进行支持。\n\n树控件在windows程序中使用相对也是比较多的控件，例如windows资源管理器左边的浏览视图就是个树控件视图：今天我们学习一下使用树控件，实现“添加节点”、“删除节点”、“修改节点”；\n1. 新建项目新建一个基于对话框项目“day14”，布局如下，自行处理：\n\n\n\n控件名\n控件ID\n\n\n\nTree Control\nIDC_TREE_VIEW\n\n\n编辑框\nIDC_EDIT_ADD_MDY\n\n\n添加节点\nIDC_BUTTON_ADD\n\n\n删除节点\nIDC_BUTTON_DEL\n\n\n修改节点\nIDC_BUTTON_MDY\n\n\n2. 设置树控件属性编辑树控件如下属性：\n\n\n\n属性\n修改值\n解释\n\n\n\nHas Buttons\nTRUE\n在父节点旁边显示+或-\n\n\nHas Lines\nTRUE\n在父节点和子节点之间划线\n\n\nLine At root\nTRUE\n在根节点上划线\n\n\n3. 添加树控件变量给树控件添加一个变量“m_tree”，如图：\n4. 实现添加节点按钮函数双击“添加节点”按钮，编辑按钮点击方法：\n123456789101112131415161718192021222324void Cday14Dlg::OnBnClickedButtonAdd()&#123;\t// TODO: 在此添加控件通知处理程序代码\tCString strText;\tGetDlgItemText(IDC_EDIT_ADD_MDY,strText);\tif (strText.GetLength() == 0)\t&#123;\t\tAfxMessageBox(_T(&quot;请输入节点名！&quot;));\t\treturn;\t&#125;\tHTREEITEM hItem = m_tree.GetSelectedItem();\tif(hItem == NULL)&#123;\t\thItem = TVI_ROOT;\t&#125;\tTVINSERTSTRUCT ts =&#123;0&#125;;\tts.hParent = hItem;\tts.hInsertAfter = TVI_LAST;\tts.item.pszText = strText.GetBuffer();\tts.item.mask = TVIF_TEXT;\tHTREEITEM hNewItem = m_tree.InsertItem(&amp;ts);\tm_tree.SelectItem(hNewItem);\tm_tree.EnsureVisible(hNewItem);&#125;\n代码解释：\n\n\n先获取文本框中的值，如果值为空，则提示用户输入；\n获取当前选中的节点，若不存在选中的节点，则获取根节点；\n创建节点结构体，设置其父节点，插入方式，节点内容，内容可见等；\n插入新的节点，并且设置节点保证可见；效果图：\n\n\n5. 实现删除节点按钮函数双击“删除节点”按钮，编辑按钮点击方法：\n12345678910111213void Cday14Dlg::OnBnClickedButtonDel()&#123;\t// TODO: 在此添加控件通知处理程序代码\tHTREEITEM hItem = m_tree.GetSelectedItem();\tif(hItem == NULL)&#123;\t\tAfxMessageBox(_T(&quot;请选择要删除的节点！&quot;));\t\treturn;\t&#125;\tHTREEITEM hParentItem = m_tree.GetParentItem(hItem);\tm_tree.DeleteItem(hItem);\tm_tree.SelectItem(hParentItem);&#125;\n代码解释：\n\n\n获取选中的节点，若没有选中的节点，则提示用户；\n获取选中节点的父节点\n删除选中的节点\n将其父节点设置为选中节点\n\n\n删除前：删除后：\n6. 实现修改节点按钮函数双击“修改节点”按钮，编辑按钮点击方法：\n123456789101112131415161718void Cday14Dlg::OnBnClickedButtonMdy()&#123;\t// TODO: 在此添加控件通知处理程序代码\tHTREEITEM hItem = m_tree.GetSelectedItem();\tif(hItem == NULL)&#123;\t\tAfxMessageBox(_T(&quot;请选择要修改的节点！&quot;));\t\treturn;\t&#125;\tCString strText;\tGetDlgItemText(IDC_EDIT_ADD_MDY,strText);\tif (strText.GetLength() == 0)\t&#123;\t\tAfxMessageBox(_T(&quot;请输入新的节点名！&quot;));\t\treturn;\t&#125;\tm_tree.SetItemText(hItem,strText);&#125;\n代码解释：\n\n\n获取选中的节点，若没有选中的节点，则提示用户；\n先获取文本框中的值，如果值为空，则提示用户输入；3.修改文本名\n\n\n7. 映射节点选择消息我们想实现在点击选择控件是，下方的文本框中自动出现选择节点的文本，那么就要映射节点的选择变化消息：TVN_SELCHANGE，如图添加事件处理函数：编辑事件处理函数：\n123456789101112void Cday14Dlg::OnTvnSelchangedTreeView(NMHDR *pNMHDR, LRESULT *pResult)&#123;\tLPNMTREEVIEW pNMTreeView = reinterpret_cast&lt;LPNMTREEVIEW&gt;(pNMHDR);\t// TODO: 在此添加控件通知处理程序代码\tHTREEITEM hItem = m_tree.GetSelectedItem();\tif(hItem != NULL)&#123;\t\tCString strText = m_tree.GetItemText(hItem);\t\tSetDlgItemText(IDC_EDIT_ADD_MDY, strText);\t&#125;\t*pResult = 0;&#125;\n代码解释：\n\n\n获取选中的节点，若不存在，则略过，不处理；\n获取选中的节点文本，将文本值设置到文本框中；\n\n\n效果图：\n至此，MFC树控件的简单使用已经结束，其实树控件还有很多属性，比如添加图标，这就到以后的实践中再来学习，附树控件常见属性及方法：\n1、树形控件的属性\nTVS_EDITLABELS:允许用户进行节点文本的编辑 TVS_HASBUTTONS:节点左侧添加一个按钮TVS_HASLINES:父节点与子结点出现连线 TVS_LINESATROOT:子节点与根节点之间出现连线TVS_NOTOOLTIPS:结点无动态提示 TVS_SINGLEEXPAND:节点的选中(未选中)t7展开(合拢)同步MFC中以两种形式封装树形控件，一种是树形控件CTreeCtrl，另一种是树形视图控件CTreeView。对于一般的要求，比如在对话框中，使用CTreeCtrl比较方便。在使用树形视图控件时，只需要利用成员函数取得其引用，就可以像树形控件一样方便的使用：CTreeCtrl&amp; GetTreeCtrl( ) const;调用InsertItem函数能够将节点插入树形控件中，并返回插入的项的HTREEITEM。树形控件的插入工作往往是在对话框的OnInitDialog函数中进行，而对于树形视图控件，则是在OnInitUpdate函数中进行。树形控件中的节点数据可以是文本，也可以是图像。节点中使用的图像是和树形控件的图像列表相对应的。在树形控件中使用图像列表是通过使用SetImageList函数来完成。树形控件能产生通告消息，如: TVN_BEGINDRAG开始拖拽 TVN_ITEMEXPANDED节点被展开或收缩其消息映射使用WM_NOTIFI,如： WM_NOTIFI(TVN_BEGINDRAG,IDC_TREECTRL,OnBeginDrag);\n\n2、树形控件TVN_BEGINRDRAG消息的响应\n与树形控件有关的、常用的结构是TVITEM、TVINSERTSTRUCT 、NMTREEVIEW(NM_TREEVIEW)。前两个是用于插入节点时使用，而NMTREEVIEW是与树形控件的通告消息相关的结构。当用鼠标左键拖拽树形控件时，控件会发出TVN_BEGINDRAG通告消息；当用鼠标右键拖拽时，则会发出TVN_BEGINRDRAG通告消息。拖拽树形控件时需要使用到IImageList::BeginDrag函数：IImageList::BeginDrag creates a temporary image list that is used fordragging. In response to subsequent WM_MOUSEMOVE messages, you canmove the drag image by using IImageList::DragMove. To end the dragoperation, you can use IImageList::EndDrag.通常使用CTreeCtrl::CreateDragImage函数创建一个被拖拽节点的图像并返回一个CImageList指针(注意被拖拽的数据节点必须包含图像，否则返回的CImageList指针为空)，然后利用该指针来调用CImageList::BeginDrag函数。除此之外还需要调用CImageList::DragEnter函数锁定、更新窗口，并在指定的位置显示被拖拽的图像：static BOOL PASCAL DragEnter(    CWnd* pWndLock,    CPoint point  );If pWndLock is NULL, this function draws the image in the displaycontext associated with the desktop window, and coordinates arerelative to the upper left corner of the screen.注意BeginDrag函数只是在拖拽开始时创建要拖拽的图像，而DragEnter函数则显示该图像。最后调用CWnd::SetCapture函数使后续所有的鼠标输入都发送到当前的CWnd对象而不管鼠标的位置（因为CImageList::DragEnter函数的第一个参数为NULL时表示在与桌面窗口相关的窗口，可以说就是当前程序的框架窗口，但不包括其他应用程序的窗口上显示被拖拽的图像。因此要使得被拖拽的图像在所有的窗口上而不仅仅是应用程序的框架窗口上显示，就需要调用CWnd::SetCapture函数。一旦调用了SetCapture函数，则在当前应用程序的非框架窗口，包括系统菜单上的鼠标按键动作均被发送到当前CWnd对象，直到调用ReleaseCapture为止）。然后就是在鼠标移动的消息响应函数中调用CImageList::DragMove函数移动被拖拽的图像，使之与鼠标的移动位置同步。最后是调用CImageList::DragShowNolock函数隐藏或显示拖拽的图像，但它并不是必须的，也可以不调用，因此之前已经调用过CImageList::DragEnter函数显示拖拽的图像了。当传递true值显示拖拽的图像时，DragShowNolock在这个过程中不像DragEnter函数一样锁定窗口。值得注意的是，在拖拽节点过程中可以使用CTreeCtrl::HitTest函数判断鼠标滑动过程中所经过的点是否位于树形控件的某一个节点之上，如果是，则返回该树形节点的HTREEITEM。此时可以使用CTreeCtrl::SelectDropTarget函数或CTreeCtrl::SelectItem函数来高亮显示该节点。\n\n3、树形控件的成员函数\nInsertItem函数插入一个节点，并返回新插入的节点的HTREEITEM。ItemHasChildren函数根据给定的HTREEITEM判断该节点是否存在子节点。GetChildItem函数根据给定的HTREEITEM获取该节点下子节点的HTREEITEM，如果没有子节点，则返回NULL。GetNextSiblingItem函数根据给定的HTREEITEM获取该节点的下一个同级节点。EnsureVisible函数在必要的时候滚动视图列表控件使得其至少部分可见。需要注意的是，在使用TVE_COLLAPSE调用Expand收缩树形控件后不能再调用该函数，否则收缩操作将无效。\n\n感伤：WE输了，RNG输了，心碎了。。。项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第12节-MFC之树控件CTreeCtrl","date":"2017-10-30T13:42:36.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"a22fef1c02426fa8030849627dae8132","title":"第11节 MFC之列表控件CListCtrl","content":"Windows编程基础–第11节 MFC之列表控件CListCtrl在MFC程序中列表控件也是使用很频繁的控件，例如windows的资源管理器就可以用列表控件来实现，如下图：列表控件具有以下四种视图：\n\n\n大图标\n小图标\n列表\n详细信息\n\n\n1. 新建项目新建一个基于对话框项目“day13”，布置界面如下，从左侧“工具箱”拖动一个List control到界面，再加上两个按钮及Combo Box，如图：\n\n\n\n控件名\n控件ID\n\n\n\nList control\nIDC_LIST_VIEW\n\n\nCombo Box\nIDC_COMBO2\n\n\n添加行\nIDC_BUTTON_ADD\n\n\n删除行\nIDC_BUTTON_DEL\n\n\n2. 添加列表控件变量单击选中列表控件，右击选择-&gt;“添加变量”，添加变量名为m_list,如下：\n3. 初始化列表控件切换到对话框的初始化函数（OnInitDialog()），我们来给列表控件增加三列，\n1234m_list.ModifyStyle(LVS_TYPEMASK, LVS_REPORT); //设置列表控件样式为详细信息m_list.InsertColumn(0,_T(&quot;第一列&quot;),LVCFMT_LEFT,120);m_list.InsertColumn(1,_T(&quot;第二列&quot;),LVCFMT_LEFT,120);m_list.InsertColumn(2,_T(&quot;第三列&quot;),LVCFMT_LEFT,120);\n4. 添加列表图标自行下载或者制作两个bmp图标，分别为1616，和3232；将图标复制到项目的res资源目录中，切换到资源视图，右击添加资源，导入我们准备好的图标，如图所示：导入好之后我们可以更改位图ID，如图所示：接下来我们在day13.h的头文件中添加两个成员变量：\n12CImageList m_ilLarge;CImageList m_ilSmall; \n分别来对应3232，和1616；然后我们再切换到初始化函数中，添加如下四行代码：\n12345m_ilLarge.Create(IDB_BITMAP_32, 32, 1,RGB(255,0,255));m_ilSmall.Create(IDB_BITMAP_16, 16, 1,RGB(255,0,255));m_list.SetImageList(&amp;m_ilLarge,LVSIL_NORMAL);m_list.SetImageList(&amp;m_ilSmall,LVSIL_SMALL);\n5. 实现添加行按钮函数双击“添加行”按钮，编辑按钮点击方法：\n123456789101112void Cday13Dlg::OnBnClickedButtonAdd()&#123;\t// TODO: 在此添加控件通知处理程序代码\tint nCount = m_list.GetItemCount();\tCString strText;\tstrText.Format(_T(&quot;第%d行，第一列&quot;), nCount + 1);\tm_list.InsertItem(nCount,strText,0);\tstrText.Format(_T(&quot;第%d行，第二列&quot;), nCount + 1);\tm_list.SetItemText(nCount,1,strText);\tstrText.Format(_T(&quot;第%d行，第三列&quot;), nCount + 1);\tm_list.SetItemText(nCount,2,strText);&#125;\n注意，只有添加第一行第一个元素是才是InsertItem，之后的添加都应该是SetItemText，防止出错；\n5. 实现删除行按钮函数双击“删除行”按钮，编辑按钮点击方法：\n123456789101112void Cday13Dlg::OnBnClickedButtonDel()&#123;\t// TODO: 在此添加控件通知处理程序代码\tint nCount = m_list.GetItemCount();\tfor (int i = nCount; i&gt;=0 ; --i)\t&#123;\t\tif (m_list.GetItemState(i,LVIS_SELECTED) == LVIS_SELECTED)\t\t&#123;\t\t\tm_list.DeleteItem(i);\t\t&#125;\t&#125;&#125;\n这样就实现了删除行的按钮，并且所有被选中的行都会被删除，按住Ctrl选中多行，点击删除，所有被选中的行都会被删除；\n6. 实现列表控件的样式切换切换到资源视图，单击Combo Box，打开属性-&gt;data;输入：\n\n大图标;小图标;详细信息;列表;\n\n如图：\n继续编辑Combo Box的属性，选择“控件事件”，添加CBN_Selchange事件，如图：编辑Combo Box的OnCbnSelchangeCombo2处理函数：\n12345678910111213141516171819202122232425void Cday13Dlg::OnCbnSelchangeCombo2()&#123;\t// TODO: 在此添加控件通知处理程序代码\tDWORD dwStyle;\tCComboBox *pView;\tpView = (CComboBox *)GetDlgItem(IDC_COMBO2);\tswitch(pView-&gt;GetCurSel())\t&#123;\tcase 0:\t\tdwStyle = LVS_ICON;\t\tbreak;\tcase 1:\t\tdwStyle = LVS_SMALLICON;\t\tbreak;\tcase 2:\t\tdwStyle = LVS_LIST;\t\tbreak;\tcase 3:\t\tdwStyle = LVS_REPORT;\t\tbreak;\tdefault:\t\treturn;\t&#125;\tm_list.ModifyStyle(LVS_TYPEMASK,dwStyle);&#125;\n很明显，先用GetDlgItem获取Combo Box的对象，然后判断Combo Box的选中的是哪一项，记录选中项的列表类型，最后设置列表属性；\n最后效果图：大图标:小图标：\n列表：详细信息：\n项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;","slug":"MFC/第11节-MFC之列表控件CListCtrl","date":"2017-10-29T13:14:48.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"05174ca29f2b54bcb09b1b16597992ea","title":"工具使用--第2节 HEXO+GitHub 搭建个人博客","content":"今天突然想搭建一个自己的私人博客，但是又不想为此买一台服务器，所以百度了一下，发现可以利用**HEXO+码云 **搭建私人博客，所以就写篇教程，记录一下吧。\n1、环境安装配置1.1 安装node下载地址：https://nodejs.org/en/download/默认安装就好。\n1.2 安装gitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。msysgit的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！（详情可参见  第1节  ）\n1.3 申请GitHub账号 打开https://github.com/，自行申请账号；\n1.4 安装HEXO切换到命令行工具，CMD输入命令安装：\n\nnpm install -g hexo\n\n等待安装完成；不过国内NPM镜像速度极慢，可以安装淘宝的cnpm；\n\nnpm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org\n\n然后使用cnpm来下载HEXO，如下：\n\ncnpm install -g hexo\n\n\n1.5 配置HEXO切换CMD到你希望创建博客项目的目录，然后输入hexo init来初始化一个项目，如：\n\ncd c:&#x2F;workspase&#x2F;bloghexo init\n\n继续输入命令：\n\nhexo generate 或者 hexo g\n\n生成静态页面\n1.6 启动本地服务\nhexo server\n\n可以看到提示Hexo已经运行在http://localhost:4000/上，我们用浏览器打开 http://localhost:4000/看看效果：\n神奇的博客界面就出现了；\n2、配合Github搭建个人博客2.1 登录Github创建一个项目\n登录Github，点击上方的添加项目：我们来添加一个GIT版本仓，点击+号，选择“New repository”，如图：\n打开创建对话框之后，输入repository名，*****.github.io，星号代表你的用户名，记住结尾一定要用.github.io结尾，如果你输入的格式或者用户名不匹配，最后创建的网站可能加载不出css，js等资源，具体原因还没弄清，待以后验证，暂时就按照规范来，如图：其余的默认就好，点击“Create repository”来创建仓库；（我的由于已经创建同名的，所以弹出提示，请无视）\n创建好之后进入创建好的界面，如下：由于我的已经上传过文件，所以你们是没有红框中的内容，不急，接下来我们来看怎么上传文件；\n本地mygit还需要配置ssh秘钥，邮箱等才能和github进行上传，修改等操作；这一步如果没设置过，参见工具使用–第1节 git使用简记\n\n2.2 关联Github和HEXO\n进入我们在 1.5 配置HEXO 创建的HEXO项目目录，打开根目录中的**_config.yml**文件（以记事本文件打开）；在文件最末尾添加如下三行：将其中的repo改为你自己repository地址，你的repository地址在github界面的这里获取，如图：点击“2”处就可以直接复制地址,最后添加的三条就是：\n\n1234deploy:  type: git  repo: https://github.com/AmuUncle/AmuUncle.github.io.git  branch: master\n注意：每项的冒号后都要留一个英文的空格号；2. 在HEXO项目根目录中右击选择“Git Bash Here”3. 生成静态网站并同步到github执行下面两个命令：\n\nhexo g   &#x2F;&#x2F; 生成hexo d   &#x2F;&#x2F; 同步或者直接用：hexo d -g  &#x2F;&#x2F; 在同步前先生成网站\n\n中间可能会让你输入github的账号密码，输入就好：运行结果如下：这样网站就同步到github中了；我们可以刷新github页面。可以看到已经有很多文件了：\n2.3 让网站显示出来我们点击github界面上的Settings按钮，进入设置界面：往下拖动，找到“github pages”选项，点击“Launch Automatic page generator”按钮，开启github pages功能；这时我们就可已输入“https://AmuUncle.github.io”来打开我们创建的blog网站；如下：至此，我们已经成功将网站部署到GITHUB，并且是个人独立博客哦。。。\n3、设置HEXO的主题这里网上很多教程，很简单，很多人推荐NEXT主题，我也用的是这款，功能很齐全，这里我就直接给教程链接了，很详细；\n\nNEXT主题官网，教程非常详细：http://theme-next.iissnan.com/getting-started.htmlHEXO主题类列表：https://hexo.io/themes/\n\n其他主题也差不多配置方法，自己研究吧。。\n4、将域名和github博客地址关联（个人需求）4.1 购买域名我是在阿里云购买的.site域名,很便宜，一年才几块钱，有需要的可以去看看：\n\nhttps://wanwang.aliyun.com/domain/?spm=5176.8076989.763973.3.5a54fa45x7NU0Z\n\n\n4.2 配置域名进入域名解析配置界面，添加一下三项：解析列表：\n\n\n\n方法记录类型\n主机记录\n记录值\n\n\n\nCNAME\nwww\nAmuUncle.github.io\n\n\nA\n@\n192.30.252.154\n\n\nA\n@\n192.30.252.153\n\n\n其中 192.30.252.153和 192.30.252.154 为github的IP地址；域名这边已经配置好，但还没结束，我们再来到HEXO博客的目录，进入source目录，新建一个CNAME文件，没有任何后缀名，编辑内容为：amuuncle.site\n接下来输入：\n\nhexo d -g\n\n重新生成同步网站到github，接下来就是见证奇迹的时候我们到浏览器输入我们的域名，就打开了我们的blog页面，如图（如果打不开，请等待10分钟，因为更改域名解析要十分钟后才能生效）最终效果图，完美，接下来我们就可以自由写个人微博，并且部署到github了，配置好域名之后，不注意根本发现不了你是在github上部署的网站哦。使用如下命令添加一篇博客，然后进入项目的source_posts目录找打创建的md文件，编辑此文件就是在写博客；\n\nhexo new post “工具使用–第2节 HEXO+GitHub 搭建个人博客”\n\n对于md文件的编写，网上有很对教程，我使用的工具是：Haroopad，完全没费，可自行下载。记住写完之后还是要输入：\n\nhexo d -g\n\n来重新生成同步网站到github；\n最后，我的blog地址就是&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;欢饮大家光临指教。\n","slug":"WEB/工具使用-第2节-HEXO-GitHub-搭建个人博客","date":"2017-10-29T06:10:26.000Z","categories_index":"GitHub","tags_index":"HEXO","author_index":"阿木大叔"},{"id":"bc39cd2103ce29a3cc74ae96baf8383f","title":"python selenium 自动化查询上海公交卡余额，并邮件通知","content":"python selenium 自动化查询上海公交卡余额，并邮件通知1、下载python安装。　　https://www.python.org/downloads/release/python-351/2、安装selenium2.1、通过pip 安装    pip install selenium\n2.2、通过下载包安装 ,直接下载selenium包：    https://pypi.python.org/pypi/selenium    解压，cmd进入目录:         python setup.py install\n3 、 安装Chrome driver    下载地址：http://npm.taobao.org/mirrors/chromedriver    下载解压，将 chromedriver.exe 文件放到chrome的安装目录下…\\Google\\Chrome\\Application\\ ,然后设置path环境变量；    \n4、全部代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273\t# coding = utf-8from selenium import webdriverfrom time import sleepimport smtplibimport tracebackfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartcardIDList = [u&quot;u54311******&quot;, u&quot;u728833******&quot;]def sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password):    &#x27;&#x27;&#x27;    @subject:邮件主题    @msg:邮件内容    @toaddrs:收信人的邮箱地址    @fromaddr:发信人的邮箱地址    @smtpaddr:smtp服务地址，可以在邮箱看，比如163邮箱为smtp.163.com    @password:发信人的邮箱密码    &#x27;&#x27;&#x27;    mail_msg = MIMEMultipart()    mail_msg[&#x27;Subject&#x27;] = subject    mail_msg[&#x27;From&#x27;] =fromaddr    mail_msg[&#x27;To&#x27;] = &#x27;,&#x27;.join(toaddrs)    mail_msg.attach(MIMEText(msg, &#x27;html&#x27;, &#x27;utf-8&#x27;))    try:        s = smtplib.SMTP()        s.connect(smtpaddr)  #连接smtp服务器        s.login(fromaddr,password)  #登录邮箱        s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) #发送邮件        s.quit()    except :       print (&quot;Error: unable to send email&quot;)       print (traceback.format_exc())def get_gj_info(cardID):    for i in range(1, 10, 1):        try:            print(&quot;第%d次尝试。。。。&quot; % i)            driver = webdriver.Chrome()            print(&quot;###########&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始打开上海交通网站&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;#########&quot;)            driver.get(&#x27;http://www.sptcc.com/&#x27;)            print(driver.title)            print(&quot;网站打开成功&quot;)            sleep(2)            print(&quot;查询公交卡号:%s&quot; % cardID)            driver.find_element_by_id(&quot;pL1i1&quot;).send_keys(cardID)            driver.find_element_by_css_selector(&quot;a[class=\\&quot;pL1b1\\&quot;]&quot;).click()            sleep(2)            data = driver.find_element_by_css_selector(&quot;p[class=\\&quot;amt\\&quot;]&quot;).text            print(&quot;公交卡 &#123;0&#125;  &#123;1&#125; &quot;.format(cardID, data))            driver.quit()            return &quot;公交卡 &#123;0&#125;  &#123;1&#125; \\n&quot;.format(cardID, data)            break        except:            print(&quot;查询出错。。。，再次尝试。。。&quot;)    print(&quot;##################&gt;&gt;&gt;&gt;&gt;&gt;&gt;退出查询&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;##############&quot;)    return &quot;查询出错。。。&quot;if __name__ == &#x27;__main__&#x27;:    fromaddr = &quot;*******@163.com&quot;    smtpaddr = &quot;smtp.163.com&quot;          # 163邮件smtp服务器地址    toaddrs = [&quot;*******@qq.com&quot;, &quot;*******@163.com&quot;]    gj_info =&#x27;&#x27;    for cardID in cardIDList:        gj_info += get_gj_info(cardID)    subject = gj_info    password = &quot;*******&quot;    msg = gj_info    sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password)\n\n\n\n\n\n\n","slug":"PYTHON/python-selenium-自动化查询上海公交卡余额，并邮件通知","date":"2017-10-28T16:49:43.000Z","categories_index":"PYTHON实战","tags_index":"PYTHON","author_index":"阿木大叔"},{"id":"1af68f9dfe3c7e2933ac93e37e9817a4","title":"工具使用--第1节 git使用简记","content":"工具使用–第1节 git使用简记GIT （分布式版本控制系统）\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。  Git的读音为&#x2F;gɪt&#x2F;。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了Git 上。    — 百度百科\n\n1.安装git这里只说windows版本安装使用，Linux版本等以后再研究；\n1.1  下载msysgitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。**msysgit**的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n2. 配置msysgit在桌面空白处右击，选择“Git Bash here”进入msysgit的控制台，输入一下两条命令，配置全局的用户名和邮箱：\n12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;邮箱地址&quot;\n你的用户名：可以随意设置，但要记住用户名邮箱地址：你的邮箱地址\n3.创建代码仓3.1 进入你想建仓的目录在目录空白处右击选择“Git Bash here”进入msysgit的控制台，输入git init命令把这个目录变成Git可以管理的仓库：\n\n$ git init Initialized empty Git repository in C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;usb_encryption_5.4.0&#x2F;git_demo&#x2F;.git&#x2F;\n\ngit会在此目录创建.git目录，这是Git来跟踪管理版本库的，无需我们来改动，\n4.版本控制我们现在在此目录下来创建一个readme.md文件，随意填写些内容，如下\n4.1 查看版本状态\ngit status\n\n4.2 添加到缓存区1git add readme.md\n\n4.3 提交代码到版本仓1git commit -m &quot;Add readme&quot;\n\n-m 后面跟得是你提交的代码的描述，建议所有提交都应该添加描述。\n暂时先记录这么多，下次再补充完整\n","slug":"WEB/工具使用-第1节-git使用简记","date":"2017-10-28T15:38:48.000Z","categories_index":"git教程","tags_index":"GIT","author_index":"阿木大叔"},{"id":"0686f7c34d3d8d3e03a82f60ca6790dd","title":"第10节 MFC菜单","content":"Windows编程基础–第10节 MFC菜单MFC菜单（CMenu）MFC菜单分为两类：\n\n窗体菜单快捷菜单:又叫弹出菜单，或者上下文菜单\n\n1、创建项目打开vs2010，创建一个基于对话框的项目，项目名“day10”,注意这次主框架中就不要勾选“系统菜单”和“关于框”了，如图：创建好后，删除自动生成的文本控件，如图：\n2、创建系统菜单切换到资源视图，右击我们的项目“day10”，选择添加资源，出现如下界面：\n选择“Menu”点击新建,然后就可以看到我们的项目中Menu目录，这里就存放菜单资源，展开后就可以看到，我们刚添加的菜单ID，双击打开；我们可以直接输入想要添加的菜单选项，如图：我们可以在资源视图右击菜单ID，然后选择属性，修改ID为IDR_MENU_SYSTEM;\n3、显示系统菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表找到MENU属性，下拉框选择刚才创建的IDR_MENU_SYSTEM菜单，如图所示：这时主窗口就和IDR_MENU_SYSTEM菜单关联起来了，运行看看效果：\n4、创建菜单消息事件我们切换到我们创建的菜单界面，来实现菜单中保存选项的处理事件，在“保存”选项上右击，选择“添加事件处理函数”，如下：，出现如下添加事件界面：这里我们类列表中选择Cday10Dlg中创建操作函数，函数名修改为OnMenuSaveClick，点击“添加编辑”，添加处理函数；\n12345void Cday10Dlg::OnMenuSaveClick()&#123;\t// TODO: 在此添加命令处理程序代码\tAfxMessageBox(_T(&quot;文件已保存！&quot;));  &#125;\n运行效果，点击“文件”-&gt;“保存”,此时就会弹窗提示“””文件已保存！”，如图所示：\n5、创建快捷菜单切换资源视图，选择“Menu”点击“插入MENU”,自动打开；我们可以直接输入想要添加的菜单选项，如图：注意：快捷菜单中最上面的“快捷菜单”不会显示，名字可以随意。修改次menu的ID为IDR_MENU_QUICK；\n6、显示快捷菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表上方选择“消息”按钮，找到“WM_OnContextMenu”,选择add OnContextMenu方法，如图所示：\n1234567891011void Cday10Dlg::OnContextMenu(CWnd* pWnd, CPoint point)&#123;\t// TODO: 在此处添加消息处理程序代码\tCMenu menu;\tif(!menu.LoadMenu(IDR_MENU_QUICK))\t&#123;\t\treturn;\t&#125;\tCMenu* pMenu = menu.GetSubMenu(0);\tpMenu-&gt;TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,point.x,point.y,pWnd);&#125;\n这段代码的意思就是：先试图加载IDR_MENU_QUICK菜单，加载成功之后，将菜单显示在鼠标右击（TPM_RIGHTBUTTON），靠左方（TPM_LEFTALIGN）的位置；运行效果：可以看见，菜单已经显示出来；\n7、创建菜单消息事件同步骤4，如图：编辑OnCopy函数，如下：\n12345void Cday10Dlg::OnCopy()&#123;\t// TODO: 在此添加命令处理程序代码\t\tAfxMessageBox(_T(&quot;文件已复制！&quot;));  &#125;\n效果图：\n项目源码可以访问我的码云","slug":"MFC/第10节-MFC菜单","date":"2017-10-28T15:33:24.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"d5ebde1940644a1d236c756a4a2c1627","title":"第9节 MFC对话框控件访问的七种方法（下）","content":"Windows编程基础–第9节 MFC对话框控件访问的七种方法（下）上节学习了MFC访问控件的三种方法，这节我们来学习剩下的四种方法，四种方法分别如下：\n\n第四种把控件和整型变量相关联\n第五种把控件和控件变量相关联\n第六种 SendMessage方法\n第七种SendDlgItemMessage方法\n\n方法四 把控件和整型变量相关联1. 创建项目打开上节用到的day08项目，切换到资源视图，添加一个按钮“方法4”，我们在此按钮上实现方法四，如图所示：\n2. 关联整型变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面：现在我们先选择类别为“value”，然后选择变量类型选择“int”，变量名“m_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：现在我们切换到解决方案视图，可以看见，day08Dlg.h中已经增加了一个类变量，m_Height，day08Dlg.cpp中DoDataExchange也增加该变量的关联方法，将变量 m_Height和IDC_EDIT_SG的输入框关联起来，如下：\n12345void Cday08Dlg::DoDataExchange(CDataExchange* pDX)&#123;\tCDialogEx::DoDataExchange(pDX);\tDDX_Text(pDX, IDC_EDIT_SG, m_Height);&#125;\n还有day08Dlg的构造函数中也对m_Height进行了初始化，如下：\n123456Cday08Dlg::Cday08Dlg(CWnd* pParent /*=NULL*/)\t: CDialogEx(Cday08Dlg::IDD, pParent)\t, m_Height(0)&#123;\tm_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;\n我们可以看到m_Height的初始化值为0，现在我们编译运行程序，可以看到身高输入框中的值就为0，如图：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量int m_Weight,double m_BMI;\n123int m_Height;int m_Weight;double m_BMI;\n\n3.实现按钮事件现在m_Height ，m_Weight ，m_BMI 分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法:\n\nUpdateData(TRUE);   &#x2F;&#x2F;把控件的值关联到变量UpdateData(FALSE);  &#x2F;&#x2F;把变量的值关联到控件\n\n12345678void Cday08Dlg::OnBnClickedButtonFunc4()&#123;\t// TODO: 在此添加控件通知处理程序代码\tUpdateData(TRUE);   //把控件的值关联到变量\tdouble dHeight = m_Height / 100.00;\tm_BMI = m_Weight / (dHeight * dHeight );\tUpdateData(FALSE);  //把变量的值关联到控件&#125;\n编译运行，这时就可以看到点击方法4之后，BMI值就计算出来了，如图：\n方法五 把控件和控件变量相关联1. 添加“方法5”按钮如图：\n1. 关联控件变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面：\n现在我们先选择类别为“control”，变量名“m_edit_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量\tCEdit m_edit_tz, CEdit m_edit_bmi;\n123CEdit m_edit_sg;CEdit m_edit_tz;CEdit m_edit_bmi;\n3.实现按钮事件现在m_edit_sg，m_edit_tz，m_edit_bmi分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法:\n12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc5()&#123;\t// TODO: 在此添加控件通知处理程序代码\tTCHAR tcHeight[10], tcWeight[10] , tcBMI[10];\tm_edit_sg.GetWindowText(tcHeight,10);\tm_edit_tz.GetWindowText(tcWeight,10);\tint nHeight = _ttoi(tcHeight);\tdouble dHeight = nHeight / 100.00;\tint nWeight = _ttoi(tcWeight);\tdouble bmi = nWeight/(dHeight * dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\tm_edit_bmi.SetWindowText(buf);&#125;\n\n方法六 SendMessage方法通过SendMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；\n12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc6()&#123;\t// TODO: 在此添加控件通知处理程序代码\tTCHAR tcHeight[10], tcWeight[10] , tcBMI[10];\t::SendMessage(GetDlgItem(IDC_EDIT_SG)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcHeight);\t::SendMessage(GetDlgItem(IDC_EDIT_TZ)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcWeight);\tint nHeight = _ttoi(tcHeight);\tdouble dHeight = nHeight / 100.00;\tint nWeight = _ttoi(tcWeight);\tdouble bmi = nWeight/(dHeight * dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\t::SendMessage(GetDlgItem(IDC_EDIT_BMI)-&gt;m_hWnd,WM_SETTEXT,10,(LPARAM)buf);&#125;\n方法七 SendDlgItemMessage方法通过SendDlgItemMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；\n1234567891011121314151617void Cday08Dlg::OnBnClickedButtonFunc7()&#123;\t// TODO: 在此添加控件通知处理程序代码\tTCHAR tcHeight[10], tcWeight[10] , tcBMI[10];\tSendDlgItemMessage(IDC_EDIT_SG,WM_GETTEXT,10,(LPARAM)tcHeight);\tSendDlgItemMessage(IDC_EDIT_TZ,WM_GETTEXT,10,(LPARAM)tcWeight);\tint nHeight = _ttoi(tcHeight);\tdouble dHeight = nHeight / 100.00;\tint nWeight = _ttoi(tcWeight);\tdouble bmi = nWeight/(dHeight * dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\tSendDlgItemMessage(IDC_EDIT_BMI,WM_SETTEXT,10,(LPARAM)buf);&#125;\n\n总结，以上七种方法虽然结果相同，但是其内部机制是有所区别的，在我们将来的编程中要根据实际情况来选择合适的方法，最后，我们列举一下这七种方法：\n\n\n\n方法名\n简介\n\n\n\nGetDlgItem()\n获取控件对象\n\n\nGetDlgItemText()\n获取对象文本\n\n\nGetDlgItemInt()\n获取对象整型值\n\n\nDDX_Text(pDX,IDC_EDIT_SG, m_Height);\n把控件和整型变量相关联\n\n\nDDX_Control(pDX,IDC_EDIT_BMI,m_edit_bmi);\n把控件和控件变量相关联\n\n\nSendMessage\n发送WM_GETTEXT消息到控件所在窗口来获取控件文本值\n\n\nSendDlgItemMessage\n发送WM_GETTEXT消息来获取控件文本值\n\n\n项目源码可以访问我的码云","slug":"MFC/第9节-MFC对话框控件访问的七种方法（下）","date":"2017-10-28T15:33:13.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"89acd55286d16d2f969d7ac76f20c8d8","title":"第8节 MFC对话框控件访问的七种方法（上）","content":"Windows编程基础–第8节 MFC对话框控件访问的七种方法（上）MFC对话框控件具有以下三种访问方式(当然还有很多别的访问方式，今天时间紧急，先学这三种)，分别是：\n\n第一种GetDlgItem()-&gt;GetWindowText()GetDlgItem()-&gt;SetWindowText()\n第二种GetDlgItemText()\n\n\n第三种GetDlgItemInt()SetDlgItemInt()\n\n1.新建一个对话框项目参见上节，我们这节采用VS2010编写一个身高体重计算器（BMI），参见 第二节；\n2.布局编辑布局如下：\n\n\n\nEDIT名称\nID\n\n\n\n身高\nIDC_EDIT_SG\n\n\n体重\nIDC_EDIT_TZ\n\n\nBMI\nIDC_EDIT_BMI\n\n\n3.实现方法双击确认按钮，编辑其点击消息处理函数；\n1234567891011void Cday08Dlg::OnBnClickedOk()&#123;\t// TODO: 在此添加控件通知处理程序代码\tint nHeight= GetDlgItemInt(IDC_EDIT_SG,NULL,TRUE);\tdouble dHeight = nHeight / 100.00;\tint nWeight = GetDlgItemInt(IDC_EDIT_TZ,NULL,TRUE);\tdouble bmi = nWeight/(dHeight*dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\tSetDlgItemText(IDC_EDIT_BMI,buf);&#125;\n这里可以看见使用到了GetDlgItemInt，这就是直接获取文本框的值，并返回为整形，然后用sprintf(buf, “%.3f”, bmi);将double类型值转换成字符串，并通过SetDlgItemText将字符串的值设置到ID为IDC_EDIT_BMI的文本框上；\n4.编译运行估计很多人会像我一样，VS2010会报这样的错误：这是因为我们创建的项目的字符集为Unicode，不允许这样转换，这时我们只要将解决方案中右击项目名“day09”-&gt;“属性”-&gt;“配置属性”-&gt;”常规”-&gt;”字符集”-&gt;选择“使用多字节字符集”就好了，如下:这时就可以通过编译，运行结果如下：\n5.其他方法再次编辑“确认”按钮的点击消息处理函数；第二种\n12345678910111213141516void Cday08Dlg::OnBnClickedOk()&#123;\t// TODO: 在此添加控件通知处理程序代码\tTCHAR tcHeight[10], tcWeight[10];\tGetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10);\tGetDlgItem(IDC_EDIT_TZ)-&gt;GetWindowText(tcWeight,10);\tint nHeight = _ttoi(tcHeight);\tdouble dHeight = nHeight / 100.00;\tint nWeight = _ttoi(tcWeight);\t\tdouble bmi = nWeight/(dHeight * dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\tGetDlgItem(IDC_EDIT_BMI)-&gt;SetWindowText(buf);&#125;\n可以看见，这里用到了GetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来获取控件的显示文本；\n第三种\n123456789101112131415void Cday08Dlg::OnBnClickedOk()&#123;\tTCHAR tcHeight[10], tcWeight[10] , tcBMI[10];\tGetDlgItemText(IDC_EDIT_SG,tcHeight,10);\tGetDlgItemText(IDC_EDIT_TZ,tcWeight,10);\tint nHeight = _ttoi(tcHeight);\tdouble dHeight = nHeight / 100.00;\tint nWeight = _ttoi(tcWeight);\t\tdouble bmi = nWeight/(dHeight * dHeight);\tchar buf[28];\tsprintf(buf, &quot;%.3f&quot;, bmi);\tSetDlgItemText(IDC_EDIT_BMI,buf);&#125;\n可以看见，这里直接用到了GetDlgItemText(IDC_EDIT_SG,tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来设置控件的显示文本；\n虽然上面三种方法最终结果是一样的，但是其本质还是有所区别的\n项目源码可以访问我的码云","slug":"MFC/第8节-MFC对话框控件访问的七种方法（上）","date":"2017-10-28T15:32:43.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"b83dba6958730d41cfeb66ec4a2f0efa","title":"第7节 来吧，VS 2010","content":"Windows编程基础–第7节 来吧，VS 2010VS 2010开发第一步\n前面几节我们都是采用VC++ 6.0 作为IDE（集成开发环境），但是由于**VC++ 6.0 **已经过于老旧，目前大多数企业和个人都已经不再使用，而采用vs2005， vs2008， vs2010，vs2015作为MFC程序的开发环境，vs相对vc++6.0具有更友好的界面，及更强大的功能，采用vs开发MFC应用程序更加得心应手。\n1、开始使用VS 20101.1 安装VS 2010参见百度百科\n1.2 创建一个基于对话框项目执行“文件”-&gt;“新建”-&gt;“项目”，选择基于对话框的MFC程序，其他默认就好，基本上和**VC++ 6.0 **创建项目一模一样，如图所示：\n1.3 创建一个字符统计窗口现在我们通过一个小例子来看看VS2010创建MFC程序有什么不同，我们来创建一个字符统计窗口，输入各种字符，最后统计出所有字符个数；设计界面如下，一个文本输入框，一个“统计”按钮，一个文本显示“字符个数”，直接在工具箱中拖动进来就OK，然后拖动大小适中就好，方法同**VC++ 6.0 **没有区别，可以参考上几节内容。注意: 若是右边没有工具箱选项卡，可以通过“视图”-&gt;“工具箱”打开。编译运行，效果图：\n1.3 创建一个字符统计窗口双击“统计”按钮，编辑按钮的点击处理函数，我们来分析一下：\n\n\n获取输入框中文本\n获取输入框中文本的字符个数\n将字符个数显示到静态文本上所以处理函数如下：\n\n\n12345678910void Cday07Dlg::OnBnClickedButtonCount()&#123;\t// TODO: 在此添加控件通知处理程序代码\tCString strInput,strOutput;\tGetDlgItemText(IDC_EDIT_TEXT,strInput);\tint nCount = strInput.GetLength();\tstrOutput.Format(_T(&quot;字符个数：%d &quot;),nCount);\tSetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125;\n1.4 编译运行运行结果图：这是我们发现当我们输入完成是，输入“回车”时，程序就会直接结束，那么我们修改输入框的属性值“Want Return”来允许输入框来接收回车，如图其实这是我们可以发现现在文本框是只能输入一行，显然不够美观，那么我们再修改一下输入框属性：\n\n\nMultiline：允许多行 \nHorizontal Scroll：水平滚动条 \nVertical Scroll:垂直滚动条\n\n\n再次编译运行：现在文本框现在可以输入多行，并且可以任意回车了。有人可能和我一样，发现程序没有关闭按钮，那是因为我在创建的时候取消了系统菜单，我们可以选定对话框主界面，选择属性-&gt;system menu-&gt;TRUE:这是关闭按钮就出现了，可以正常关闭了。\n2、初探VS中消息映射机制2.1 创建EDIT的消息处理函数单击选定输入框，右击选择“添加事件处理程序”，这是可以很直观的看见EDIT的消息列表和要添加到的类，以及添加的处理函数名，现在我们来添加一个EN_CHANGE的消息处理函数，如图所示：单击“添加编辑”来编辑消息处理函数，代码如下：\n12345678910111213141516void Cday07Dlg::OnEnChangeEditText()&#123;\t// TODO:  如果该控件是 RICHEDIT 控件，它将不\t// 发送此通知，除非重写 CDialogEx::OnInitDialog()\t// 函数并调用 CRichEditCtrl().SetEventMask()，\t// 同时将 ENM_CHANGE 标志“或”运算到掩码中。\t// TODO:  在此添加控件通知处理程序代码\tCString strInput,strOutput;\tGetDlgItemText(IDC_EDIT_TEXT,strInput);\tint nCount = strInput.GetLength();\tstrOutput.Format(_T(&quot;字符个数：%d &quot;),nCount);\tSetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125;\n\n2.2 编译运行这是我们可以发现我们在输入框中输入字符时，下方的字符统计数会实时显示，这就是输入文本时，EDIT的EN_CHANGE消息被触发，从而触发其消息处理函数OnEnChangeEditText，导致字符统计数实时更新，效果图如下：\n2.3 MFC消息映射机制流程12345678st=&gt;start: Startop=&gt;operation: 输入框文本变化op2=&gt;operation: 触发EN_CHANGE消息op3=&gt;operation: 调用EN_CHANGE的处理函数OnEnChangeEditTextop4=&gt;operation: 将输入框字符数返回到界面e=&gt;endst-&gt;op-&gt;op2-&gt;op3-&gt;op4-&gt;e\n\n\n\n项目源码可以访问我的码云","slug":"MFC/第7节-来吧，VS-2010","date":"2017-10-28T15:32:25.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"9179eacff46448e05283197250e564aa","title":"第6节 VC++6.0控件说明","content":"Windows编程基础–第6节 VC++6.0控件说明VC++6.0控件工具箱\n\n控件说明\n\n2 图形控件（picture）：常用于显示位图（Bitmap）和图标（Icon）  \n3 静态文本（Static Text）：用来在指定的位置显示特定的字符串，一般用来标识附近另一个控件的内容。显示在静态文本控件中的字符串一般不再改变，但是在需要的时候，也可以通过调用相应的函数来进行设置。MFC提供了CStatic类支持静态控件。  \n4 编辑框（Edit Box）：用来接收用户输入的字符串。通过选择编辑框的选项，编辑框可以接收字符串、数字、密码等；编辑框还可以设置成接收多行字符串的模式；可以自动进行大小写转换。编辑框可能向其父窗口发送多种控件通知，如果用户需要，可以对这些控件通知进行处理。MFC提供了CEdit类支持编辑框控件。  \n5 组成框（Group Box）：用来包围具有逻辑关系的一组控件，在这些控件的周围加上边界和标题。需注意的是，组成框仅仅是在视觉效果上对控件进行“成组”，真正的“成组”工作还需要另外一些工作。 \n6 按钮（Button）：用来接收用户的命令，应用程序在接收到用户命令后，通常需要进行一些后台工作。按钮可以响应单击或双击动作，在按钮接收到鼠标动作后，向其父窗口发送相应的控件通知，用户可以对这些控件通知进行消息映射，从而进行相应的处理。在一个对话框中，可以定义一个默认按钮，这只要选中按钮属性中的“Default”选项。如果在对话框活动的时候按下了Enter键，则等同于单击了默认按钮。MFC提供了CButton类支持按钮控件。\n7 复选框（Check Box）：用来显示某种可能的选择，该项选择是独立的，用户可以选中或取消该选项。在选项被选中的时候核选标记出现，选项被取消时核选标记消失。MFC中由CButton类对核选框进行支持，用户可以通过SetCheck()函数和GetCheck()函数设置或获取核选框当前的状态。 \n8 单选按钮（Radio Button）：用来选择某种可能的选择，与核选框不同，该选项不是独立的。一般是几个单选按钮组成一组，同组中的单选按钮可以有也只能有一个按钮被选中。MFC同样使用CButton类对单选按钮控件进行支持，SetCheck()函数和GetCheck()函数对单选按钮也是适用的。 \n9 组合框（Combo Box）：列表框和编辑框的组合，用户除了可以在列表中对已经存在的选项进行选择外，还可以输入新的选择。MFC提供了CComboBox类对组合框控件进行支持。 \n10 列表框（List Box）：用来选择一系列的可能选择，用户通过滚动条可以在这些选择中浏览。在列表框中，可以进行单项选择，也可以进行多项选择，这取决于用户在控件属性对话框中的设置。MFC提供了CListBox类对列表框控件进行支持。 \n11、12 滚动条（Scroll Bar）：这包括水平滚动条和垂直滚动条，除了在视觉效果上的方向不同外，水平滚动条在被滚动时发生WM_HSCROLL消息，而垂直滚动条在被滚动时发送WM_VSCROLL消息。MFC提供了CScrollBar进行支持。 \n13 微调按钮（Spin Button）：包括一对紧靠在一起的上下箭头，使用微调按钮可以增大或者缩小某个特定的数值。微调按钮往往都需要一个“伙伴”控件，这通常都是一个编辑框。当微调按钮的向上箭头被单击时，编辑框中的数字就增大；反之则减小。MFC提供了CPinButtonCtrl类进行支持。\n14 进度条（Progress）：在进行一项需要占有较长时间的操作时来反应当前的进度。当操作的进度不断前进时，进度条就用特色颜色填充进度条框。用户可以设定进度条的范围和当前位置。MFC提供了CProgressCtrl类进行支持。 \n15 滑块控件（Slider）：通常用来在程序中接受一系列离散的数值。用户可以设置滑块控件的取值范围，并可以为控件加上刻度标记以显示特定位置的含义。MFC提供了CSliderCtrl类进行支持。\n16 热键控制（Hot Key）：热键控件看起来就像一个编辑框，但是在热键控件中能够立刻反应用户刚刚按下的键组合，这在设置程序的热键时特别有用。热键控件只是在“视觉”上显示了按键组合，设置热键的工作还需要用户添加代码完成。MFC提供了CHotKey类进行支持。 \n17 列表控制（List Control）：按一定的排列顺序显示一系列带图标的字符串，列表控件提供了四种显示模式：大图标、小图标、列表和详细信息。用户可以向列表控件中添加新的项，也可以控制列表控件的显示模式。MFC提供了CListCtrl类进行支持。 \n18 树形控件（Tree Control）：用来显示一系列项目的层次关系，最典型的例子是显示磁盘上的文件与文件夹。如果有子项目的话，单击树形控件中的项目可以展开或者收缩其子项目。MFC提供了CTreeCtrl类进行支持。 \n19 属性表控件（Tab Control）：用来包含大量的控件，可以满足用户显示或者获取大量数据的要求。每个属性表又分为好几个属性页，这些属性页由各自的标签进行区分，这些属性页中都可以包容其他控件。在显示属性表的时候，一次只能够显示一个属性页的全部内容，同时显示其他属性页的标签，用户通过单击标签打开相应的属性页。MFC提供了CTabCtrl类进行支持。\n20 动画控件（Animation）：用来播放一段AVI格式的视频剪辑。用户可以控制视频剪辑的播放、停止和定位，但也仅限于这些功能。动画控件设置不能播放音频剪辑，如果用户需要更高层次的视频或者音频的支持，请选用MCIWnd控件。MFC提供了CAnimateCtrl类对动画控件进行支持。\n21 高级编辑框（Rich Edit）：编辑控件功能的扩展。在高级编辑框中，除了简单的输入和编辑字符串外，用户还可以为字符或段落指定特定的格式，用户甚至还可以向高级编辑框中插入OLE项。高级编辑框基本上实现了一个带格式的文本编辑器功能，而只需要用户添加少量的接口。MFC提供了CRichEditCtrl类进行支持。 \n22 日历控件（Month Calender）：看似与真正的日历类似，操作也类似，直观的为用户提供了观察和显示当前日期的途径。MFC提供了CMonthCalCtrl类进行支持。\n23 日期&#x2F;时间选择器（Date Time Picker）：向用户提供了一种直观的选择日期和时间的方法、日期&#x2F;时间选择器在外观上类似于一个组合框，但是当用户单击下拉箭头时就会展开一个日历控件供用户选择，而一旦用户做出了选择，日期&#x2F;时间选择器会自动显示新的日期&#x2F;时间。MFC提供了CDateTimeCtrl类进行支持。\n24 IP地址控件（IP Adress）:IP地址控件用来输入和编辑IP地址。该控件外观类似于一个编辑框，但是可以自动对输入的字符按3个一组进行区分和加间隔圆点。IP地址控件为开发支持Internet技术的程序提供了方便。MFC提供了CIPAddressCtrl类进行支持。\n26 扩展组合框（Extended Combo Box）：在普通组合框的基础上还支持图像列表。即，可以在组合框中显示特定的图标表示相应的选择，而不仅仅是显示文本。MFC提供了CComboBoxEx类进行支持。\n\n\n\n所有控件的公共属性\nID：控件的资源标识。Visiable：控件是否可见。Disabled：控件是否被禁止、被禁止的控件无法接受键盘和鼠标输入。Group：是否从这个空间开始一个新组。Tab stop：在程序中是否可以用【Tab】键切换到这个控件。Help ID：是否给控件分配一个帮助标识，帮助标识基于控件本身的资源标识。Client edge：给控件增加一个凹陷的边界，使整个控件看起来像是凹下去的一样。Static edge：给控件增加一个边界。Modal frame：给控件增加一个3维的框架，与Client edge相反，它是凸出来的。Transparent：拥有此属性的窗口是透明的，它下面的窗口不会被它遮掩住。Accept files：拥有此属性的窗口可以接收拖放文件，如果一个文件被拖动到这个控件上面，控件会收到WM_DROPFILES消息。No parent notify：表示控件不向其父窗口发送WM_PARENTNOTIFY消息。Right aligned text：表示文本右对齐。\ntxt以上属性可通过控件的属性对话框进行设置，在属性对话框中按【F1】键可以查看属性的帮助信息。每一种控件都由一个MFC控件类来管理，当通过资源编辑器在对话框上添加一个控件时，visualC++会自动为控件类生成一个实例，即对象，并调用构造函数，当对话框关闭时，其各个子控件对象被自动销毁。也可以不使用资源编辑器，自己在程序中写代码创建、显示控件并设置控件的属性。所有的控件类都继承自CWnd，控件的某些操作和属性设置需要用到CWnd本身的成员函数，CWnd某些函数经常用来操纵控件和设置控件属性。\nSetWindowText：设置控件上要显示的标题文本，即用来设置控件的caption属性GetWindowText：得到控件的标题文本EnableWindow：设置控件的Disabled属性，即社会自控件是否可以接收键盘和鼠标的输入SetWindowPos：改变窗口的大小、位置和Z轴次序。 MoveWindow：改变窗口的大小和位置GetWindowRec：得到窗口的大小、位置（信息存放在一个矩形结构中）。GetClientRect：得到窗口客户区的大小（信息存放在一个矩形结构中 ） ShowWindow：设置窗口的可见性（即窗口是否可见）SetWindowText&#x2F;GetWindowText还可以用来设置&#x2F;得到对话框的标题文本。\n\n\n转载Button\n按钮窗口（控件）在MFC中使用CButton表示，CButton包含了三种样式的按钮，Push Button，Check Box，Radio Box。所以在利用CButton对象生成按钮窗口时需要指明按钮的风格。\n\n\n创建按钮：BOOL CButton::Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );其中lpszCaption是按钮上显示的文字，dwStyle为按钮风格，除了Windows风格可以使用外（如 WS_CHILD|WS_VISUBLE|WS_BORDER）还有按钮专用的一些风格。\n\n\n· BS_AUTOCHECKBOX 检查框，按钮的状态会自动改变   Same as a check box, except that a check mark appears in the check box when the user selects the box; the check mark disappears the next time the user selects the box.\n\n\n· BS_AUTORADIOBUTTON 圆形选择按钮，按钮的状态会自动改变   Same as a radio button, except that when the user selects it, the button automatically highlights itself and removes the selection from any other radio buttons with the same style in the same group.\n\n\n· BS_AUTO3STATE 允许按钮有三种状态即：选中，未选中，未定   Same as a three-state check box, except that the box changes its state when the user selects it.\n\n\n· BS_CHECKBOX 检查框   Creates a small square that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style).\n\n\n· BS_DEFPUSHBUTTON 默认普通按钮   Creates a button that has a heavy black border. The user can select this button by pressing the ENTER key. This style enables the user to quickly select the most likely option (the default option).\n\n\n· BS_LEFTTEXT 左对齐文字   When combined with a radio-button or check-box style, the text appears on the left side of the radio button or check box.\n\n\n· BS_OWNERDRAW 自绘按钮   Creates an owner-drawn button. The framework calls the DrawItem member function when a visual aspect of the button has changed. This style must be set when using the CBitmapButton class.\n\n\n· BS_PUSHBUTTON 普通按钮   Creates a pushbutton that posts a WM_COMMAND message to the owner window when the user selects the button.\n\n\n· BS_RADIOBUTTON 圆形选择按钮   Creates a small circle that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). Radio buttons are usually used in groups of related but mutually exclusive choices.\n\n\n· BS_3STATE 允许按钮有三种状态即：选中，未选中，未定   Same as a check box, except that the box can be dimmed as well as checked. The dimmed state typically is used to show that a check box has been disabled.\n\n\nrect为窗口所占据的矩形区域，pParentWnd为父窗口指针，nID为该窗口的ID值。\n\n\n获取&#x2F;改变按钮状态：对于检查按钮和圆形按钮可能有两种状态，选中和未选中，如果设置了BS_3STATE或BS_AUTO3STATE风格就可能出现第三种状态：未定，这时按钮显示灰色。通过调用int CButton::GetCheck( ) 得到当前是否被选中，返回0：未选中，1：选中，2：未定。调用void CButton::SetCheck( int nCheck );设置当前选中状态。\n\n\n处理按钮消息：要处理按钮消息需要在父窗口中进行消息映射，映射宏为ON_BN_CLICKED( id, memberFxn )id为按钮的ID值，就是创建时指定的nID值。处理函数原型为afx_msg void memberFxn( );\n\nStatic Box\n静态文本控件的功能比较简单，可作为显示字符串，图标，位图用。创建一个窗口可以使用成员函数： BOOL CStatic::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID &#x3D; 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对静态控件指明专门的风格。\n\n\n· SS_CENTER,SS_LEFT,SS_RIGHT 指明字符显示的对齐方式。\n\n\n· SS_GRAYRECT 显示一个灰色的矩形\n\n\n· SS_NOPREFIX 如果指明该风格，对于字符&amp;将直接显示，否则&amp;将作为转义符，&amp;将不显示而在其后的字符将有下划线，如果需要直接显示&amp;必须使用&amp;&amp;表示。\n\n\n· SS_BITMAP 显示位图\n\n\n· SS_ICON 显示图标\n\n\n· SS_CENTERIMAGE 图象居中显示\n\n\n控制显示的文本利用成员函数SetWindowText&#x2F;GetWindowText用于设置&#x2F;得到当前显示的文本。\n\n\n控制显示的图标利用成员函数SetIcon&#x2F;GetIcon用于设置&#x2F;得到当前显示的图标。\n\n\n控制显示的位图利用成员函数SetBitmap&#x2F;GetBitmap用于设置&#x2F;得到当前显示的位图。下面一段代码演示如何创建一个显示位图的静态窗口并设置位图\n\n\n1CStatic* pstaDis=new CStatic; pstaDis-&gt;Create(&quot;&quot;,WS_CHILD|WS_VISIBLE|SS_BITMAP|SSCENTERIMAGE, CRect(0,0,40,40),pWnd,1); CBitmap bmpLoad; bmpLoad.LoadBitmap(IDB_TEST); pstaDis-&gt;SetBitmap(bmpLoad.Detach());\n\nEdit Box\nEdit窗口是用来接收用户输入最常用的一个控件。创建一个输入窗口可以使用成员函数：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID &#x3D; 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对输入控件指明专门的风格。\n\n\n· ES_AUTOHSCROLL,ES_AUTOVSCROLL 指明输入文字超出显示范围时自动滚动。\n\n\n· ES_CENTER,ES_LEFT,ES_RIGHT 指定对齐方式\n\n\n· ES_MULTILINE 是否允许多行输入\n\n\n· ES_PASSWORD 是否为密码输入框，如果指明该风格则输入的文字显示为*\n\n\n· ES_READONLY 是否为只读\n\n\n· ES_UPPERCASE,ES_LOWERCASE 显示大写&#x2F;小写字符\n\n\n控制显示的文本利用成员函数SetWindowText&#x2F;GetWindowText用于设置&#x2F;得到当前显示的文本。\n\n\n通过GetLimitText&#x2F;SetLimitText可以得到&#x2F;设置在输入框中输入的字符数量。\n\n\n由于在输入时用户可能选择某一段文本，所以通过void CEdit::GetSel( int&amp; nStartChar, int&amp; nEndChar )得到用户选择的字符范围，通过调用void CEdit::SetSel( int nStartChar, int nEndChar, BOOL bNoScroll &#x3D; FALSE )可以设置当前选择的文本范围，如果指定nStartChar&#x3D;0 nEndChar&#x3D;-1则表示选中所有的文本。void ReplaceSel( LPCTSTR lpszNewText, BOOL bCanUndo &#x3D; FALSE )可以将选中的文本替换为指定的文字。\n\n\n此外输入框还有一些和剪贴板有关的功能，void Clear( );删除选中的文本，void Copy( );可将选中的文本送入剪贴板，void Paste( );将剪贴板中内容插入到当前输入框中光标位置，void Cut( );相当于Copy和Clear结合使用。\n\n\n最后介绍一下输入框几种常用的消息映射宏：\n\n\n· ON_EN_CHANGE 输入框中文字更新后产生\n\n\n· ON_EN_ERRSPACE 输入框无法分配内存时产生\n\n\n· ON_EN_KILLFOCUS &#x2F; ON_EN_SETFOCUS 在输入框失去&#x2F;得到输入焦点时产生\n\n\n使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用输入框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。\n\nScroll Bar\nScroll Bar一般不会单独使用，因为SpinCtrl可以取代滚动条的一部分作用，但是如果你需要自己生成派生窗口，滚动条还是会派上一些用场。创建一个滚动条可以使用成员函数： ：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID &#x3D; 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对滚动条指明专门的风格。\n\n\n· SBS_VERT 风格将创建一个垂直的滚动条。\n\n\n· SBS_HORZ 风格将创建一个水平的滚动条。\n\n\n在创建滚动条后需要调用void SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw &#x3D; TRUE )设置滚动范围，int GetScrollPos( )&#x2F;int SetScrollPos( )用来得到和设置当前滚动条的位置。\n\n\nvoid ShowScrollBar( BOOL bShow &#x3D; TRUE );用来显示&#x2F;隐藏滚动条。\n\n\nBOOL EnableScrollBar( UINT nArrowFlags &#x3D; ESB_ENABLE_BOTH )用来设置滚动条上箭头是否为允许状态。nArrowFlags可取以下值：\n\n\n· ESB_ENABLE_BOTH 两个箭头都为允许状态\n\n\n· ESB_DISABLE_LTUP 上&#x2F;左箭头为禁止状态\n\n\n· ESB_DISABLE_RTDN 下&#x2F;右箭头为禁止状态\n\n\n· ESB_DISABLE_BOTH 两个箭头都为禁止状态\n\n\n如果需要在滚动条位置被改变时得到通知，需要在父窗口中定义对消息WM_VSCROLL&#x2F;WM_HSCROLL的映射。方法为在父窗口类中重载afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )&#x2F;afx_msg void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )所使用的消息映射宏为：ON_WM_VSCROLL( ),ON_WM_HSCROLL( )，在映射宏中不需要指明滚动条的ID，因为所有滚动条的滚动消息都由同样的函数处理。在OnHScroll&#x2F;OnVScroll的第三个参数会指明当前滚动条的指针。第一个参数表示滚动条上发生的动作，可取以下值：\n\n\n· SB_TOP&#x2F;SB_BOTTOM 已滚动到顶&#x2F;底部\n\n\n· SB_LINEUP&#x2F;SB_LINEDOWN 向上&#x2F;下滚动一行\n\n\n· SB_PAGEDOWN&#x2F;SB_PAGEUP 向上&#x2F;下滚动一页\n\n\n· SB_THUMBPOSITION&#x2F;SB_THUMBTRACK 滚动条拖动到某一位置，参数nPos指明当前位置（参数&gt;nPos在其它的情况下是无效的）\n\n\n· SB_ENDSCROLL 滚动条拖动完成（用户松开鼠标）\n\nList Box&#x2F;Check List Box\nListBox窗口用来列出一系列的文本，每条文本占一行。创建一个列表窗口可以使用成员函数：BOOL CListBox::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID &#x3D; 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。\n\n\n· LBS_MULTIPLESEL 指明列表框可以同时选择多行\n\n\n· LBS_EXTENDEDSEL 可以通过按下Shift&#x2F;Ctrl键选择多行\n· LBS_SORT 所有的行按照字母顺序进行排序\n在列表框生成后需要向其中加入或是删除行，可以利用：  int AddString( LPCTSTR lpszItem )添加行，  intDeleteString( UINT nIndex )删除指定行，  int InsertString( int nIndex,LPCTSTR lpszItem )将行插入到指定位置。  void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。\n如果需要得到&#x2F;设置当前被选中的行，可以调用int GetCurSel( )&#x2F;int SetCurSel(intiIndex)。如果你指明了选择多行的风格，你就需要先调用int GetSelCount( )得到被选中的行的数量，然后intGetSelItems( int nMaxItems, LPINT rgIndex)得到所有选中的行，参数rgIndex为存放被选中行的数组。通过调用int GetLBText( int nIndex, LPTSTRlpszText )得到列表框内指定行的字符串。\n此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。  int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。\n在MFC4.2版本中添加了CCheckListBox类，该类是由CListBox派生并拥有CListBox的所有功能，不同的是可以在每行前加上一个检查框。必须注意的是在创建时必须指明LBS_OWNERDRAWFIXED或LBS_OWNERDRAWVARIABLE风格。\n通过void SetCheckStyle( UINT nStyle )&#x2F;UINT GetCheckStyle()可以设置&#x2F;得到检查框的风格，关于检查框风格可以参考4.1 Button中介绍。通过void SetCheck( int nIndex,int nCheck )&#x2F;int GetCheck( int nIndex )可以设置和得到某行的检查状态，关于检查框状态可以参考4.1Button中介绍。\n最后介绍一下列表框几种常用的消息映射宏：\n· ON_LBN_DBLCLK 鼠标双击\n· ON_EN_ERRSPACE 输入框无法分配内存时产生\n· ON_EN_KILLFOCUS &#x2F; ON_EN_SETFOCUS 在输入框失去&#x2F;得到输入焦点时产生\n· ON_LBN_SELCHANGE 选择的行发生改变\n使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用列表框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。\n\nCombo Box&#x2F;Combo Box Ex\n组合窗口是由一个输入框和一个列表框组成。创建一个组合窗口可以使用成员函数：  BOOL CListBox::Create( LPCTSTRlpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID&#x3D; 0xffff );  其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。\n· CBS_DROPDOWN 下拉式组合框\n· CBS_DROPDOWNLIST 下拉式组合框，但是输入框内不能进行输入\n· CBS_SIMPLE 输入框和列表框同时被显示\n· LBS_SORT 所有的行按照字母顺序进行排序\n由于组合框内包含了列表框，所以列表框的功能都能够使用，如可以利用：  int AddString( LPCTSTR lpszItem)添加行，  int DeleteString( UINT nIndex )删除指定行，  int InsertString( intnIndex, LPCTSTR lpszItem )将行插入到指定位置。  void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。\n如果需要得到&#x2F;设置当前被选中的行的位置，可以调用int GetCurSel( )&#x2F;int SetCurSel(intiIndex)。通过调用int GetLBText( int nIndex, LPTSTR lpszText )得到列表框内指定行的字符串。\n此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。  int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。\n此外输入框的功能都能够使用，如可以利用：  DWORD GetEditSel( ) &#x2F;BOOL SetEditSel( intnStartChar, int nEndChar )得到或设置输入框中被选中的字符位置。  BOOL LimitText( intnMaxChars )设置输入框中可输入的最大字符数。  输入框的剪贴板功能Copy,Clear,Cut,Paste动可以使用。\n最后介绍一下列表框几种常用的消息映射宏：\n· ON_CBN_DBLCLK 鼠标双击\n· ON_CBN_DROPDOWN 列表框被弹出\n· ON_CBN_KILLFOCUS &#x2F; ON_CBN_SETFOCUS 在输入框失去&#x2F;得到输入焦点时产生\n· ON_CBN_SELCHANGE 列表框中选择的行发生改变\n· ON_CBN_EDITUPDATE 输入框中内容被更新\n使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用组合框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。\n\nTree Ctrl\n树形控件TreeCtrl和下节要讲的列表控件 ListCtrl在系统中大量被使用，例如Windows资源管理器就是一个典型的例子。\n树形控件可以用于树形的结构，其中有一个根接点(Root)然后下面有许多子结点，而每个子结点上有允许有一个或多个或没有子结点。MFC中使用CTreeCtrl类来封装树形控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些树形控件的专用风格：\n· TVS_HASLINES 在父&#x2F;子结点之间绘制连线\n· TVS_LINESATROOT 在根&#x2F;子结点之间绘制连线\n· TVS_HASBUTTONS 在每一个结点前添加一个按钮，用于表示当前结点是否已被展开\n· TVS_EDITLABELS 结点的显示字符可以被编辑\n· TVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点\n· TVS_DISABLEDRAGDROP 不允许Drag&#x2F;Drop\n· TVS_NOTOOLTIPS 不使用ToolTip显示结点的显示字符\n在树形控件中每一个结点都有一个句柄（HTREEITEM），同时添加结点时必须提供的参数是该结点的父结点句柄，（其中根Root结点只有一个，既不可以添加也不可以删除）利用HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent &#x3D; TVI_ROOT,HTREEITEM hInsertAfter &#x3D; TVI_LAST);可以添加一个结点，pszItem为显示的字符，hParent代表父结点的句柄，当前添加的结点会排在hInsertAfter表示的结点的后面，返回值为当前创建的结点的句柄。下面的代码会建立一个如下形式的树形结构：\n+— Parent1 +— Child1_1 +— Child1_2 +— Child1_3 +— Parent2 +— Parent3 &#x2F;假设m_tree为一个CTreeCtrl对象，而且该窗口已经创建&#x2F; HTREEITEM hItem,hSubItem; hItem &#x3D; m_tree.InsertItem(“Parent1”,TVI_ROOT);在根结点上添加Parent1 hSubItem &#x3D; m_tree.InsertItem(“Child1_1”,hItem);&#x2F;&#x2F;在Parent1上添加一个子结点 hSubItem &#x3D;m_tree.InsertItem(“Child1_2”,hItem,hSubItem);&#x2F;&#x2F;在Parent1上添加一个子结点，排在Child1_1后面 hSubItem &#x3D;m_tree.InsertItem(“Child1_3”,hItem,hSubItem); hItem &#x3D;m_tree.InsertItem(“Parent2”,TVI_ROOT,hItem); hItem &#x3D;m_tree.InsertItem(“Parent3”,TVI_ROOT,hItem);\n如果你希望在每个结点前添加一个小图标，就必需先调用CImageList* SetImageList( CImageList *pImageList, int nImageListType);指明当前所使用的ImageList，nImageListType为TVSIL_NORMAL。在调用完成后控件中使用图片以设置的ImageList中图片为准。然后调用  HTREEITEM InsertItem( LPCTSTR lpszItem, intnImage, int nSelectedImage, HTREEITEM hParent &#x3D; TVI_ROOT, HTREEITEMhInsertAfter &#x3D;TVI_LAST);添加结点，nImage为结点没被选中时所使用图片序号，nSelectedImage为结点被选中时所使用图片序号。下面的代码演示了ImageList的设置。\n&#x2F;m_list 为CImageList对象 IDB_TREE 为16(164)的位图，每个图片为1616共4个图标*&#x2F;m_list.Create(IDB_TREE,16,4,RGB(0,0,0));m_tree.SetImageList(&amp;m_list,TVSIL_NORMAL);m_tree.InsertItem(“Parent1”,0,1); &#x2F;&#x2F;添加，选中时显示图标1，未选中时显示图标0\n此外CTreeCtrl还提供了一些函数用于得到&#x2F;修改控件的状态。  HTREEITEM GetSelectedItem();将返回当前选中的结点的句柄。BOOL SelectItem( HTREEITEM hItem );将选中指明结点。  BOOLGetItemImage( HTREEITEM hItem, int&amp; nImage, int&amp; nSelectedImage ) &#x2F;BOOL SetItemImage( HTREEITEM hItem, int nImage, int nSelectedImage)用于得到&#x2F;修改某结点所使用图标索引。  CString GetItemText( HTREEITEM hItem ) &#x2F;BOOLSetItemText( HTREEITEM hItem, LPCTSTR lpszItem );用于得到&#x2F;修改某一结点的显示字符。BOOL DeleteItem( HTREEITEM hItem );用于删除某一结点，BOOL DeleteAllItems();将删除所有结点。\n此外如果想遍历树可以使用下面的函数：  HTREEITEM GetRootItem( );得到根结点。  HTREEITEMGetChildItem( HTREEITEM hItem );得到子结点。  HTREEITEMGetPrevSiblingItem&#x2F;GetNextSiblingItem( HTREEITEM hItem);得到指明结点的上&#x2F;下一个兄弟结点。  HTREEITEM GetParentItem( HTREEITEM hItem );得到父结点。\n树形控件的消息映射使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTree(NMHDR* pNMHDR, LRESULT*pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于树形控件可能取值和对应的数据结构为：\n· TVN_SELCHANGED 在所选中的结点发生改变后发送，所用结构：NMTREEVIEW\n· TVN_ITEMEXPANDED 在某结点被展开后发送，所用结构：NMTREEVIEW\n· TVN_BEGINLABELEDIT 在开始编辑结点字符时发送，所用结构：NMTVDISPINFO\n· TVN_ENDLABELEDIT 在结束编辑结点字符时发送，所用结构：NMTVDISPINFO\n· TVN_GETDISPINFO 在需要得到某结点信息时发送，（如得到结点的显示字符）所用结构：NMTVDISPINFO\n关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。\n关于动态提供结点所显示的字符：首先你在添加结点时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMTVDISPINFO，然后填充其中item.pszText。但是我们通过什么来知道该结点所对应的信息呢，我的做法是在添加结点后设置其lParam参数，然后在提供信息时利用该参数来查找所对应的信息。下面的代码说明了这种方法：\nchar szOut[8][3]&#x3D;{“No.1”,”No.2”,”No.3”}; &#x2F;&#x2F;添加结点 HTREEITEM hItem &#x3D;m_tree.InsertItem(LPSTR_TEXTCALLBACK,…) m_tree.SetItemData(hItem, 0); hItem &#x3D; m_tree.InsertItem(LPSTR_TEXTCALLBACK,…)m_tree.SetItemData(hItem, 1 ); &#x2F;&#x2F;处理消息 voidCParentWnd::OnGetDispInfoTree(NMHDR* pNMHDR, LRESULT* pResult) {TV_DISPINFO* pTVDI &#x3D; (TV_DISPINFO*)pNMHDR;pTVDI-&gt;item.pszText&#x3D;szOut[pTVDI-&gt;item.lParam];&#x2F;&#x2F;通过lParam得到需要显示的字符在数组中的位置 *pResult &#x3D; 0; }\n关于编辑结点的显示字符：首先需要设置树形控件的TVS_EDITLABELS风格，在开始编辑时该控件将会发送TVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送TVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMTVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息：\n&#x2F;&#x2F;处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDR*pNMHDR, LRESULT* pResult) { TV_DISPINFO* pTVDI &#x3D; (TV_DISPINFO*)pNMHDR;if(pTVDI-&gt;item.lParam&#x3D;&#x3D;0);&#x2F;&#x2F;判断是否取消该操作 pResult &#x3D; 1; else pResult &#x3D; 0;} &#x2F;&#x2F;处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDRpNMHDR, LRESULT pResult) { TV_DISPINFO* pTVDI &#x3D; (TV_DISPINFO*)pNMHDR;if(pTVDI-&gt;item.pszText&#x3D;&#x3D;NULL);&#x2F;&#x2F;判断是否已经取消取消编辑m_tree.SetItemText(pTVDI-&gt;item.hItem,pTVDI-&gt;pszText); &#x2F;&#x2F;重置显示字符*pResult &#x3D; 0; }\n上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。\n\nList Ctrl\n列表控件可以看作是功能增强的ListBox，它提供了四种风格，而且可以同时显示一列的多中属性值。MFC中使用CListCtrl类来封装列表控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些列表控件的专用风格：\n· LVS_ICON LVS_SMALLICON LVS_LIST LVS_REPORT这四种风格决定控件的外观，同时只可以选择其中一种，分别对应：大图标显示，小图标显示，列表显示，详细报表显示\n· LVS_EDITLABELS 结点的显示字符可以被编辑，对于报表风格来讲可编辑的只为第一列。\n· LVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点\n· LVS_SINGLESEL 同时只能选中列表中一项\n首先你需要设置列表控件所使用的ImageList，如果你使用大图标显示风格，你就需要以如下形式调用：  CImageList*SetImageList( CImageList* pImageList, LVSIL_NORMAL);如果使用其它三种风格显示而不想显示图标你可以不进行任何设置，否则需要以如下形式调用：  CImageList* SetImageList(CImageList* pImageList, LVSIL_SMALL);\n通过调用 int InsertItem( int nItem, LPCTSTR lpszItem);可以在列表控件中nItem指明位置插入一项，lpszItem为显示字符。除LVS_REPORT风格外其他三种风格都只需要直接调用InsertItem就可以了，但如果使用报表风格就必须先设置列表控件中的列信息。\n通过调用 int InsertColumn( int nCol, LPCTSTR lpszColumnHeading, intnFormat , int nWidth, intnSubItem);可以插入列。iCol为列的位置，从零开始，lpszColumnHeading为显示的列名，nFormat为显示对齐方式，nWidth为显示宽度，nSubItem为分配给该列的列索引。\n在有多列的列表控件中就需要为每一项指明其在每一列中的显示字符，通过调用  BOOL SetItemText( int nItem, intnSubItem, LPTSTR lpszText);可以设置每列的显示字符。nItem为设置的项的位置，nSubItem为列位置，lpszText为显示字符。下面的代码演示了如何设置多列并插入数据：\nm_list.SetImageList(&amp;m_listSmall,LVSIL_SMALL);&#x2F;&#x2F;设置ImageListm_list.InsertColumn(0,”Col 1”,LVCFMT_LEFT,300,0);&#x2F;&#x2F;设置列m_list.InsertColumn(1,”Col 2”,LVCFMT_LEFT,300,1);m_list.InsertColumn(2,”Col 3”,LVCFMT_LEFT,300,2);m_list.InsertItem(0,”Item 1_1”);&#x2F;&#x2F;插入行 m_list.SetItemText(0,1,”Item1_2”);&#x2F;&#x2F;设置该行的不同列的显示字符 m_list.SetItemText(0,2,”Item 1_3”);\n此外CListCtrl还提供了一些函数用于得到&#x2F;修改控件的状态。  COLORREF GetTextColor( )&#x2F;BOOLSetTextColor( COLORREF cr );用于得到&#x2F;设置显示的字符颜色。  COLORREF GetTextBkColor()&#x2F;BOOL SetTextBkColor( COLORREF cr );用于得到&#x2F;设置显示的背景颜色。  voidSetItemCount( int iCount );用于得到添加进列表中项的数量。  BOOL DeleteItem(intnItem);用于删除某一项，BOOL DeleteAllItems( );将删除所有项。  BOOL SetBkImage(HBITMAPhbm, BOOL fTile , int xOffsetPercent, int yOffsetPercent);用于设置背景位图。CString GetItemText( int nItem, int nSubItem );用于得到某项的显示字符。\n列表控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXList(NMHDR* pNMHDR, LRESULT*pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为：\n· LVN_BEGINLABELEDIT 在开始某项编辑字符时发送，所用结构：NMLVDISPINFO\n· LVN_ENDLABELEDIT 在结束某项编辑字符时发送，所用结构：NMLVDISPINFO\n· LVN_GETDISPINFO 在需要得到某项信息时发送，（如得到某项的显示字符）所用结构：NMLVDISPINFO\n关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。\n关于动态提供结点所显示的字符：首先你在项时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMLVDISPINFO，然后填充其中item.pszText。通过item中的iItem,iSubItem可以知道当前显示的为那一项。下面的代码演示了这种方法：\nchar szOut[8][3]&#x3D;{“No.1”,”No.2”,”No.3”}; &#x2F;&#x2F;添加结点m_list.InsertItem(LPSTR_TEXTCALLBACK,…)m_list.InsertItem(LPSTR_TEXTCALLBACK,…) &#x2F;&#x2F;处理消息 voidCParentWnd::OnGetDispInfoList(NMHDR* pNMHDR, LRESULT* pResult) {LV_DISPINFO* pLVDI &#x3D; (LV_DISPINFO*)pNMHDR;pLVDI-&gt;item.pszText&#x3D;szOut[pTVDI-&gt;item.iItem];&#x2F;&#x2F;通过iItem得到需要显示的字符在数组中的位置 *pResult &#x3D; 0; }\n关于编辑某项的显示字符：（在报表风格中只对第一列有效）首先需要设置列表控件的LVS_EDITLABELS风格，在开始编辑时该控件将会发送LVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送LVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMLVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息：\n&#x2F;&#x2F;处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDR*pNMHDR, LRESULT* pResult) { LV_DISPINFO* pLVDI &#x3D; (LV_DISPINFO*)pNMHDR;if(pLVDI-&gt;item.iItem&#x3D;&#x3D;0);&#x2F;&#x2F;判断是否取消该操作 pResult &#x3D; 1; else pResult &#x3D; 0;} &#x2F;&#x2F;处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDRpNMHDR, LRESULT pResult) { LV_DISPINFO* pLVDI &#x3D; (LV_DISPINFO*)pNMHDR;if(pLVDI-&gt;item.pszText&#x3D;&#x3D;NULL);&#x2F;&#x2F;判断是否已经取消取消编辑m_list.SetItemText(pLVDI-&gt;item.iItem,0,pLVDI-&gt;pszText); &#x2F;&#x2F;重置显示字符*pResult &#x3D; 0; }\n上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。\n如何得到当前选中项位置：在列表控件中没有一个类似于ListBox中GetCurSel()的函数，但是可以通过调用GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);得到选中项位置。\n\nTab Ctrl\nTab属性页控件可以在一个窗口中添加不同的页面，然后在页选择发生改变时得到通知。MFC中使用CTabCtrl类来封装属性页控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些属性页控件的专用风格：\nTCS_BUTTONS 使用按钮来表示页选择位置  TCS_MULTILINE 分行显示页选择位置  TCS_SINGLELINE只使用一行显示页选择位置  在控件创建后必需向其中添加页面才可以使用，添加页面的函数为：  BOOL InsertItem( intnItem, LPCTSTR lpszItem);nItem为位置，从零开始，lpszItem为页选择位置上显示的文字。如果你希望在页选择位置处显示一个图标，你可以调用  BOOLInsertItem( int nItem, LPCTSTR lpszItem, int nImage);nImage指明所使用的图片位置。（在此之前必须调用CImageList * SetImageList( CImageList *pImageList );设置正确的ImageList）\n此外CTabCtrl还提供了一些函数用于得到&#x2F;修改控件的状态。  int GetCurSel( )&#x2F;int SetCurSel( intnItem );用于得到&#x2F;设置当前被选中的页位置。  BOOL DeleteItem( int nItem )&#x2F;BOOLDeleteAllItems( );用于删除指定&#x2F;所有页面。  void RemoveImage( int nImage);用于删除某页选择位置上的图标。\n属性页控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTab(NMHDR* pNMHDR, LRESULT*pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为：\nTCN_SELCHANGE 在当前页改变后发送，所用结构：NMHDR  TCN_SELCHANGING在当前页改变时发送可以通过返回TRUE来禁止页面的改变，所用结构：NMHDR\n一般来讲在当前页发生改变时需要隐藏当前的一些子窗口，并显示其它的子窗口。下面的伪代码演示了如何使用属性页控件：CParentWnd::OnCreate(…){m_tab.Create(…);m_tab.InsertItem(0,”Option 1”);m_tab.InsertItem(1,”Option 2”);Create a edit box as the m_tab’s ChildCreate a static box as the m_tab’s Childedit_box.ShowWindow(SW_SHOW); &#x2F;&#x2F; edit box在属性页的第一页static_box.ShowWindow(SW_HIDE); &#x2F;&#x2F; static box在属性页的第二页}void CParentWnd::OnSelectChangeTab(NMHDR* pNMHDR, LRESULT* pResult){&#x2F;&#x2F;处理页选择改变后的消息if(m_tab.GetCurSel()&#x3D;&#x3D;0){&#x2F;&#x2F;根据当前页显示&#x2F;隐藏不同的子窗口edit_box.ShowWindow(SW_SHOW);static_box.ShowWindow(SW_HIDE);}else{&#x2F;&#x2F;edit_box.ShowWindow(SW_HIDE);static_box.ShowWindow(SW_SHOW);}}\n\n\n","slug":"MFC/第6节-VC-6-0控件说明","date":"2017-10-28T15:32:11.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"d41da3519676c2875183fa7ba0389f75","title":"第5节 MFC对话框程序","content":"Windows编程基础–第5节 MFC对话框程序模式对话框\n对话框程序是MFC最重要的组成部分，也是Visual C++中唯一可以可视化设计的窗口程序，对话框主要有两类：\n\n\n模式对话框：必须关闭这个对话框才能继续操作父窗口或者上一级窗口\n非模式对话框:不影响父窗口或者上一级窗口，可继续操作父窗口或者上一级窗口，对话框程序也可以一直保留，无需关闭才能执行下一步；\n\n\n接来下我们先一起学习模式对话框；\n1. 新建项目建立一个MFC的主对话框项目day04，参见上节，添加两个按钮，分别为“关于”，“聊天”，如图所示：\n2. 添加关于对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示：\n3. 添加关于对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如下图所示：单击OK完成创建关联类；\n3. 添加关于按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择关于按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“关于”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include AboutDlg.h”来引入对话框类，然后我们来编辑关于按键方法，创建一个模式对话框；\n123456void CDay04Dlg::OnButtonAbout() &#123;\t// TODO: Add your control notification handler code here\tCAboutDlg dlg;\tdlg.DoModal();&#125;\n效果图：至此，一个模式对话框就创建成功了，我们可以看到，我们必须关闭关于对话框，才能单击主对话框。\n非模式对话框现在我们来创建一个非模式对话框；\n1. 添加聊天对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示：\n2. 添加聊天对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如上面步骤3\n3. 添加聊天按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择聊天按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“聊天”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include “Chat.h””来引入对话框类，然后我们来编辑聊天按键方法，创建一个非模式对话框；\n1234567void CDay04Dlg::OnButtonChat() &#123;\t// TODO: Add your control notification handler code here\tCChat * pDlg = new CChat;\tpDlg-&gt;Create(IDD_DIALOG_CHAT);\tpDlg-&gt;ShowWindow(SW_SHOW);&#125;\n效果图：至此，一个非模式对话框就创建成功了，我们可以看到，我们打开聊天界面后还可以继续操作父窗口中的关于对话框，甚至还可以单击聊天对话框创建多个聊天界面；\n项目源码可以访问我的码云","slug":"MFC/第5节-MFC对话框程序","date":"2017-10-28T15:31:35.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"2f4d7dd6c64cb6ac7562ed9535f84aaa","title":"第4节 MFC消息映射机制","content":"Windows编程基础–第4节 MFC消息映射机制对于MFC程序最重要的响应机制就是消息映射机制，这节我们就来一起尝试一下MFC的消息映射机制。（操作系统：win10 64位 IDE：vc++ 6.0）1、新建一个MFC对话框项目，参见上节，2、编译代码运行，效果图如下：3、现在我们删除对话框上的《确定》和《取消》按钮，如图：4、现在我们添加自己的“OK”和“CANCEL”按钮，接下来我们就来看看“OK”按钮的按下消息是怎么进行处理的？4、执行View-&gt;Class Wizard,打开类向导；（或者直接用ctrl + W）\n此时就能看到我们创建的对话框，OK按钮，CANCEL按钮对象，点击它们可以看见它们分别的拥有的消息，如图：\n5、我们选择Cday03Dlg，MESSAGES选择WM_MOUSEMOVE消息，点击Add Function，下部Member function就会出现与WM_MOUSEMOVE对应的OnMouseMove函数，接下来点击Edit Code，编辑OnMouseMove函数的内容：6、我们来修改OnMouseMove(UINT nFlags, CPoint point) 函数，参数中point为鼠标的坐标位置，我们可以通过point.x, point.y来获取鼠标的位置，nFlags主要是标志一些控制键是否按下，然后MK_LBUTTON、MK_RBUTTON、MK_CONTROL、MK_SHIFT、MK_MBUTTON 分别对应鼠标左键，右键，CTRL ，SHIFT ，鼠标中间（转轮）：\n123456789101112131415161718192021222324252627282930void CDay03Dlg::OnMouseMove(UINT nFlags, CPoint point) &#123;\t// TODO: Add your message handler code here and/or call default\tCString strText;\tstrText.Format(&quot;坐标 x = %d ,y = %d &quot;,point.x, point.y);\tif (nFlags &amp; MK_LBUTTON)\t&#123;\t\tstrText += &quot; 鼠标左键DOWN&quot;;\t&#125;\tif (nFlags &amp; MK_RBUTTON)\t&#123;\t\tstrText += &quot; 鼠标右键DOWN&quot;;\t&#125;\tif (nFlags &amp; MK_CONTROL)\t&#123;\t\tstrText += &quot; CTRL DOWN&quot;;\t&#125;\tif (nFlags &amp; MK_SHIFT)\t&#123;\t\tstrText += &quot; SHIFT DOWN&quot;;\t&#125;\tif (nFlags &amp; MK_MBUTTON)\t&#123;\t\tstrText += &quot; MIDBUTTON DOWN&quot;;\t&#125;\tSetWindowText(strText);  // 设置对话框标题文本\tCDialog::OnMouseMove(nFlags, point);&#125;\n效果图：\n7、同样，我们可以通过类向导分别设置“OK”，“CANCEL”按钮的消息触发函数；\n8、这是我们其实可以看到在day03Dlg.cpp中MESSAGE_MAP总下方就有我们新增的三个MFC消息，并且可以直观的看出是属于哪个控件ID的；\n12345678910BEGIN_MESSAGE_MAP(CDay03Dlg, CDialog)\t//&#123;&#123;AFX_MSG_MAP(CDay03Dlg)\tON_WM_SYSCOMMAND()\tON_WM_PAINT()\tON_WM_QUERYDRAGICON()\tON_WM_MOUSEMOVE()\tON_BN_CLICKED(IDC_BUTTON_OK, OnButtonOk)\tON_BN_CLICKED(IDC_BUTTON_CACEL, OnButtonCacel)\t//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()\n9、接下来我们切换到day03Dlg.h头文件中，所有afx_msg 开头的都是消息对应的处理函数：\n1234567891011// Generated message map functions//&#123;&#123;AFX_MSG(CDay03Dlg)afx_msg void OnSysCommand(UINT nID, LPARAM lParam);afx_msg void OnPaint();afx_msg HCURSOR OnQueryDragIcon();afx_msg void OnMouseMove(UINT nFlags, CPoint point);afx_msg void OnButtonOk();afx_msg void OnDoubleclickedButtonCacel();afx_msg void OnButtonCacel();//&#125;&#125;AFX_MSGDECLARE_MESSAGE_MAP()\n10、由以上例子可以看出，MFC程序的消息映射机制是创建一个与窗口相关联的派生类，用于消息关联的成员函数来接收和处理窗口的消息。在类向导中选择对应的消息，添加与该消息关联的成员函数来处理该消息，这就是MFC的消息映射机制。具体控件或窗口支持哪些消息及消息对应的函数参数等，请参见MSDN；11、最终效果图：\n项目源码可以访问我的码云来fork\n","slug":"MFC/第4节-MFC消息映射机制","date":"2017-10-28T15:30:28.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"436629cc87cd5604a8123cfb0e89982f","title":"第3节 初探MFC","content":"Windows编程基础–第3节 初探MFC\n前言 win32程序属于早期windows软件，已经逐渐被淘汰，但它的设计模式和方法大部分都被MFC所继承，并且MFC开始使用C++语言进行开发，借助C++比C语言的强大特性，使得开发windws程序更加简便、高效，更加多元化。\n创建第一个MFC程序（操作系统：win10 64位 IDE：vc++ 6.0）\n\n\n执行File-&gt;new，选择Project选项卡，选择下面的MFC AppWizard，填写项目名称等，如图：  2）点击 OK 按钮进入下一页，我们先选择简单的Dialog based，然后-&gt;NEXT ，第三页进行是否选择MFC静态库还是共享库等选择，这里我们不作修改，直接点击Finish，完成创建； \n\n 3）现在可以尝试编译，运行打开默认的Dialog界面  4)现在我们往刚才创建的Dialog中添加一些资源控件，如下图：  注意：ListCtrl属性中Stytle-&gt;View选择Report 5） 接下来我们来实现底部三个按钮的方法：    添加按钮\n12345678910111213 void CDay02Dlg::OnAdd() &#123;\t// TODO: Add your control notification handler code here\tCString szNumb,szName,szSala;\tGetDlgItemText(IDC_NUMB,szNumb);\tGetDlgItemText(IDC_NAME,szName);\tGetDlgItemText(IDC_SALA,szSala);\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nCount = pList-&gt;GetItemCount();\tpList-&gt;InsertItem(nCount,szNumb);\tpList-&gt;SetItemText(nCount,1,szName);\tpList-&gt;SetItemText(nCount,2,szSala);&#125;\n先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前总数，在末尾添加一个Iten，并赋值；\ntxt删除按钮123456789101112void CDay02Dlg::OnDel() &#123;\t// TODO: Add your control notification handler code here\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nSel = pList-&gt;GetSelectionMark();\tif(nSel &lt; 0)\t&#123;\t\tAfxMessageBox(&quot;请先选择要删除的员工&quot;);\t\treturn;\t&#125;\tpList-&gt;DeleteItem(nSel);&#125;\n获取ListCtrl的操作句柄后获取到当前选的行数，最后删除改行；\n修改按钮：\n1234567891011121314151617181920void CDay02Dlg::OnMod() &#123;\t// TODO: Add your control notification handler code here\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nSel = pList-&gt;GetSelectionMark();\tif(nSel &lt; 0)\t&#123;\t\tAfxMessageBox(&quot;请先选择要修改的员工&quot;);\t\treturn;\t&#125;\t\tCString szNumb,szName,szSala;\tGetDlgItemText(IDC_NUMB,szNumb);\tGetDlgItemText(IDC_NAME,szName);\tGetDlgItemText(IDC_SALA,szSala);\tpList-&gt;SetItemText(nSel,0,szNumb);\tpList-&gt;SetItemText(nSel,1,szName);\tpList-&gt;SetItemText(nSel,2,szSala);\t&#125;\n先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前选择行数，将获取的szNumb,szName,szSala分别赋值给当前Item的对应位置；\n函数原型如下：BOOL SetItemText( int nItem, int nSubItem, LPTSTR lpszText );用于MFC设置CListCtrl控件中的列表项内容。\nint GetDlgItemText( int nID, CString&amp; rString) nID 指定了要获取其标题的控件的整数标识符。 lpStr 指向要接收控件的标题或文本的缓冲区。 nMaxCount 指定了要拷贝到lpStr的字符串的最大长度（以字节为单位）。如果字符串比nMaxCount要长，它将被截断。 rString 对一个CString对象的引用。\n 3.最终效果图 4. day02.cpp 源码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236\t// day02Dlg.cpp : implementation file//#include &quot;stdafx.h&quot;#include &quot;day02.h&quot;#include &quot;day02Dlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public:\tCAboutDlg();// Dialog Data\t//&#123;&#123;AFX_DATA(CAboutDlg)\tenum &#123; IDD = IDD_ABOUTBOX &#125;;\t//&#125;&#125;AFX_DATA\t// ClassWizard generated virtual function overrides\t//&#123;&#123;AFX_VIRTUAL(CAboutDlg)\tprotected:\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\t//&#125;&#125;AFX_VIRTUAL// Implementationprotected:\t//&#123;&#123;AFX_MSG(CAboutDlg)\t//&#125;&#125;AFX_MSG\tDECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123;\t//&#123;&#123;AFX_DATA_INIT(CAboutDlg)\t//&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123;\tCDialog::DoDataExchange(pDX);\t//&#123;&#123;AFX_DATA_MAP(CAboutDlg)\t//&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\t//&#123;&#123;AFX_MSG_MAP(CAboutDlg)\t\t// No message handlers\t//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg dialogCDay02Dlg::CDay02Dlg(CWnd* pParent /*=NULL*/)\t: CDialog(CDay02Dlg::IDD, pParent)&#123;\t//&#123;&#123;AFX_DATA_INIT(CDay02Dlg)\t\t// NOTE: the ClassWizard will add member initialization here\t//&#125;&#125;AFX_DATA_INIT\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\tm_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CDay02Dlg::DoDataExchange(CDataExchange* pDX)&#123;\tCDialog::DoDataExchange(pDX);\t//&#123;&#123;AFX_DATA_MAP(CDay02Dlg)\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\t//&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CDay02Dlg, CDialog)\t//&#123;&#123;AFX_MSG_MAP(CDay02Dlg)\tON_WM_SYSCOMMAND()\tON_WM_PAINT()\tON_WM_QUERYDRAGICON()\tON_BN_CLICKED(IDC_BUTTON4, OnButtonOK)\tON_BN_CLICKED(IDC_ADD, OnAdd)\tON_BN_CLICKED(IDC_DEL, OnDel)\tON_BN_CLICKED(IDC_MOD, OnMod)\t//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg message handlersBOOL CDay02Dlg::OnInitDialog()&#123;\tCDialog::OnInitDialog();\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tpList-&gt;InsertColumn(0,&quot;学号&quot;,0,100);\tpList-&gt;InsertColumn(1,&quot;姓名&quot;,0,100);\tpList-&gt;InsertColumn(2,&quot;工资&quot;,0,100);\t// Add &quot;About...&quot; menu item to system menu.\t// IDM_ABOUTBOX must be in the system command range.\tASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);\tASSERT(IDM_ABOUTBOX &lt; 0xF000);\tCMenu* pSysMenu = GetSystemMenu(FALSE);\tif (pSysMenu != NULL)\t&#123;\t\tCString strAboutMenu;\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\t\tif (!strAboutMenu.IsEmpty())\t\t&#123;\t\t\tpSysMenu-&gt;AppendMenu(MF_SEPARATOR);\t\t\tpSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\t\t&#125;\t&#125;\t// Set the icon for this dialog.  The framework does this automatically\t//  when the application&#x27;s main window is not a dialog\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\t\t// TODO: Add extra initialization here\t\treturn TRUE;  // return TRUE  unless you set the focus to a control&#125;void CDay02Dlg::OnSysCommand(UINT nID, LPARAM lParam)&#123;\tif ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)\t&#123;\t\tCAboutDlg dlgAbout;\t\tdlgAbout.DoModal();\t&#125;\telse\t&#123;\t\tCDialog::OnSysCommand(nID, lParam);\t&#125;&#125;// If you add a minimize button to your dialog, you will need the code below//  to draw the icon.  For MFC applications using the document/view model,//  this is automatically done for you by the framework.void CDay02Dlg::OnPaint() &#123;\tif (IsIconic())\t&#123;\t\tCPaintDC dc(this); // device context for painting\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\t\t// Center icon in client rectangle\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\t\tCRect rect;\t\tGetClientRect(&amp;rect);\t\tint x = (rect.Width() - cxIcon + 1) / 2;\t\tint y = (rect.Height() - cyIcon + 1) / 2;\t\t// Draw the icon\t\tdc.DrawIcon(x, y, m_hIcon);\t&#125;\telse\t&#123;\t\tCDialog::OnPaint();\t&#125;&#125;// The system calls this to obtain the cursor to display while the user drags//  the minimized window.HCURSOR CDay02Dlg::OnQueryDragIcon()&#123;\treturn (HCURSOR) m_hIcon;&#125;void CDay02Dlg::OnButtonOK() &#123;\t// TODO: Add your control notification handler code here\t&#125;void CDay02Dlg::OnAdd() &#123;\t// TODO: Add your control notification handler code here\tCString szNumb,szName,szSala;\tGetDlgItemText(IDC_NUMB,szNumb);\tGetDlgItemText(IDC_NAME,szName);\tGetDlgItemText(IDC_SALA,szSala);\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nCount = pList-&gt;GetItemCount();\tpList-&gt;InsertItem(nCount,szNumb);\tpList-&gt;SetItemText(nCount,1,szName);\tpList-&gt;SetItemText(nCount,2,szSala);&#125;void CDay02Dlg::OnDel() &#123;\t// TODO: Add your control notification handler code here\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nSel = pList-&gt;GetSelectionMark();\tif(nSel &lt; 0)\t&#123;\t\tAfxMessageBox(&quot;请先选择要删除的员工&quot;);\t\treturn;\t&#125;\tpList-&gt;DeleteItem(nSel);\t&#125;void CDay02Dlg::OnMod() &#123;\t// TODO: Add your control notification handler code here\tCListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST);\tint nSel = pList-&gt;GetSelectionMark();\tif(nSel &lt; 0)\t&#123;\t\tAfxMessageBox(&quot;请先选择要修改的员工&quot;);\t\treturn;\t&#125;\t\tCString szNumb,szName,szSala;\tGetDlgItemText(IDC_NUMB,szNumb);\tGetDlgItemText(IDC_NAME,szName);\tGetDlgItemText(IDC_SALA,szSala);\tpList-&gt;SetItemText(nSel,0,szNumb);\tpList-&gt;SetItemText(nSel,1,szName);\tpList-&gt;SetItemText(nSel,2,szSala);\t&#125;\n\n项目源码可以访问我的码云来fork：\n1https://gitee.com/AmuUncle/MFC_CSDN.git","slug":"MFC/第3节-初探MFC","date":"2017-10-28T15:14:58.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"3f633bfafeec92d57d809cdb658962e5","title":"Windows编程基础--第2节 win32程序资源管理","content":"Windows编程基础–第2节 win32程序资源管理（操作系统：win10 64位 IDE：vc++ 6.0）windows程序都有自己的资源，例如按钮，图标，对话框等等，这节介绍如何使用win32程序资源管理；1、继续使用上节的win32程序demo，执行File-&gt;new添加资源，选择Files选项卡中的Resource Script，填写资源名，如图所示：2、此时项目左侧会出现ResourceView视图，单击ResourceView中的根节点+号，会提示“This file is already open in an editor”，这时候关闭右边的day01.rc，再次打开就可以了；3、在ResourceView节点day01 Resources节点上右击-&gt;Insert,选中Dialog,单击“New”,创建一个对话框资源，创建成功之后如图：4、在新建的对话框上右击选择属性（Properties），会弹出dialog的属性窗口，可以设置一些对话框的相关属性，如图5、接下来我们做一个简单的BMI计算器(体重指数BMI&#x3D;体重&#x2F;身高的平方（国际单位kg&#x2F;㎡）)，拖动三个Edit分别用来显示身高，体重，BMI值，并设置属性ID，分别为：IDC_EDIT_SG、IDC_EDIT_TZ,IDC_EDIT_BMI，如图所示：6、接下来切换到类视图（classView），双击WinMain入口函数，添加对话框语句：\n1DialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC);\n其中IDD_DIALOG_BMI为刚才添加的对话框属性ID，DlGFUNC为对话框的消息处理函数，7、接下来我们添加DlGFUNC函数，如下：\n1234567891011121314151617181920212223242526BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123;\tswitch(uMsg)\t&#123;\tcase WM_COMMAND:\t\tswitch(wParam)\t\t&#123;\t\tcase IDCANCEL:\t\t\tEndDialog(hwnd_dlg,IDCANCEL);\t\t\tbreak;\t\tcase IDOK:\t\t\t&#123;\t\t\t\tint nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE);\t\t\t\tdouble dHeight = nHeight / 100.00;\t\t\t\tint nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE);\t\t\t\tdouble bmi = nWeight/(dHeight*dHeight);\t\t\t\tchar buf[28];\t\t\t\tsprintf(buf, &quot;%.3f&quot;, bmi);\t\t\t\tSetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf);\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\tbreak;\t&#125;\treturn FALSE;&#125;\n其中IDOK，和IDCANCEL为对话框确认按钮和取消按钮所触发消息，IDCANCEL关闭对话框，IDOK消息我们来获取身高和体重Edit中的值，并按照公式体重指数BMI&#x3D;体重&#x2F;身高的平方（国际单位kg&#x2F;㎡）计算BMI,最后将BMI值设置到BMI  Edit中：\n1234567int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE);double dHeight = nHeight / 100.00;int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE);double bmi = nWeight/(dHeight*dHeight);char buf[28];sprintf(buf, &quot;%.3f&quot;, bmi);SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf);\n注意：要在文件头部引用资源头文件：#include “resource.h”最终效果如下：附day01.cpp源码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445// day01.cpp : Defines the entry point for the application.//#include &quot;stdafx.h&quot;#include &quot;resource.h&quot;#include &quot;stdio.h&quot;BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123;\tswitch(uMsg)\t&#123;\tcase WM_COMMAND:\t\tswitch(wParam)\t\t&#123;\t\tcase IDCANCEL:\t\t\tEndDialog(hwnd_dlg,IDCANCEL);\t\t\tbreak;\t\tcase IDOK:\t\t\t&#123;\t\t\t\tint nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE);\t\t\t\tdouble dHeight = nHeight / 100.00;\t\t\t\tint nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE);\t\t\t\tdouble bmi = nWeight/(dHeight*dHeight);\t\t\t\tchar buf[28];\t\t\t\tsprintf(buf, &quot;%.3f&quot;, bmi);\t\t\t\tSetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf);\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\tbreak;\t&#125;\treturn FALSE;&#125;int APIENTRY WinMain(HINSTANCE hInstance,                     HINSTANCE hPrevInstance,                     LPSTR     lpCmdLine,                     int       nCmdShow)&#123; \t// TODO: Place code here.\tDialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC);\treturn 0;&#125;\n后记：    DialogProc是一个窗口过程函数。该函数为一个应用程序定义可与DialogBox函数一起使用的回调函数。它处理发送到一个模态的或无模式对话框的消息。DLGPROC类型定义了一个指向此回调函数的指针。DialogProc函数是应用程序定义函数名的一个占位符。函数原型：\n123456BOOL CALLBACK DialogProc(HWND hwndDlg,UINT UMsg,WPARAM wParam,LPARAM lParam);\n\nhwndDlg指定对话框。uMsg指定消息。wParam指定消息特定的其他信息。Iparam指定消息特定的其他信息。\n项目源码可以访问我的码云来fork：\n1https://gitee.com/AmuUncle/MFC_CSDN.git","slug":"MFC/MFC02","date":"2017-10-28T14:55:13.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"},{"id":"c9371cf78a705f43f8740427c79cb17f","title":"Windows编程基础--第1节  第一个win32软件","content":"Windows编程基础–第1节  第一个win32软件下面新建一个win32程序，来演示win32程序开发的原理（操作系统：win10 64位    IDE：vc++ 6.0） 1、执行File -&gt; new命令，来新建一个工程，如下图：  2、点击 OK按钮，然后选择A simple win32 application，单击Finish完成创建； 3、此时右边项目视图会显示我们刚才创建好的项目，双击Globals下面的WinMain函数  4、现在来新建一个简单的对话框\n1MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OK);\n5、单击状态栏上的 “build”，或者直接按键进行编译，然后单击状态栏的 ！ 来运行程序，或者ctrl+F5;以下是MessageBox的原型：\n123456int WINAPI MessageBox(  HWND hWnd,          // handle of owner window  LPCTSTR lpText,     // address of text in message box  LPCTSTR lpCaption, // address of title of message box  UINT uType          // style of message box);\nhWnd是消息框的拥有窗口。如果此参数为NULL，则消息框没有拥有窗口。lpText为消息框的内容。lpCaption为消息框的标题。uType指定一个决定对话框的内容和行为（按钮、图标、形态及其他）的位标志集。附其它常用属性 \n系统默认图标，可在消息框上显示X错误 MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR?询问 MB_ICONQUESTION!警告 MB_ICONEXCLAMATION and MB_ICONWARNINGi信息 MB_ICONASTERISK and MB_ICONINFORMATION \n按钮的形式 \nMB_OK 默认MB_OKCANCEL 确定取消MB_YESNO 是否MB_YESNOCANCEL 是否取消 \n返回值 \nIDCANCEL 取消被选IDNO 否被选IDOK 确定被选IDYES 是被选6、对照函数说明，我们可以简单根据对话框返回值来执行不同的代码，如图：\n12345678910111213141516171819#include &quot;stdafx.h&quot;int APIENTRY WinMain(HINSTANCE hInstance,                     HINSTANCE hPrevInstance,                     LPSTR     lpCmdLine,                     int       nCmdShow)&#123; \t// TODO: Place code here.\tint ret = MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OKCANCEL );\tif(IDCANCEL == ret)\t&#123;\t\tMessageBox(NULL,&quot;CANCEL is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK);\t&#125;\telse if(IDOK  == ret)\t&#123;\t\tMessageBox(NULL,&quot;OK is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK);\t&#125;\treturn 0;&#125;\n\n\n项目源码可以访问我的码云来fork：\n1https://gitee.com/AmuUncle/MFC_CSDN.git","slug":"MFC/MFC01","date":"2017-10-28T14:42:12.000Z","categories_index":"MFC从入门到放弃","tags_index":"MFC","author_index":"阿木大叔"}]