{"title":"Qt多线程详解","type":"page","uid":"a7158f05b99122115a360a16ef9e5007","text":"Qt多线程详解Qt是一个支持多线程、跨平台的C++框架，旨在帮助开发人员以安全和简单的方式处理并发任务。在这篇博客中，我们将介绍Qt中的多线程概念及其用法。 什么是Qt多线程在计算机科学中，一个线程可以被看作一个轻量级的、可执行的单独进程中的一部分。与传统的单线程程序相比，多线程...","date":"2021-10-04T08:34:06.000Z","updated":"2023-05-19T05:34:19.707Z","comments":true,"path":"api/pages/images/posts/Qt/基础教程/Qt多线程详解.json","covers":null,"excerpt":"","content":"<h1 id=\"Qt多线程详解\"><a href=\"#Qt多线程详解\" class=\"headerlink\" title=\"Qt多线程详解\"></a>Qt多线程详解</h1><p>Qt是一个支持多线程、跨平台的C++框架，旨在帮助开发人员以安全和简单的方式处理并发任务。在这篇博客中，我们将介绍Qt中的多线程概念及其用法。</p>\n<h2 id=\"什么是Qt多线程\"><a href=\"#什么是Qt多线程\" class=\"headerlink\" title=\"什么是Qt多线程\"></a>什么是Qt多线程</h2><p>在计算机科学中，一个线程可以被看作一个轻量级的、可执行的单独进程中的一部分。与传统的单线程程序相比，多线程程序可以同时执行多个任务，并利用现代CPU的多核性能。</p>\n<p>在Qt中，多线程是通过QThread类来实现的。QThread类提供了一种使用线程的通用方法，可以方便地处理各种多线程应用场景。</p>\n<h2 id=\"如何在Qt中使用多线程\"><a href=\"#如何在Qt中使用多线程\" class=\"headerlink\" title=\"如何在Qt中使用多线程\"></a>如何在Qt中使用多线程</h2><p>使用QObject类及其派生的类，如QWidget和QCoreApplication，可以使线程间通信更容易。其中，最常见的方法是使用信号和槽机制，在不同的线程之间发送信号和接收槽。</p>\n<p>使用多线程的基本步骤如下：</p>\n<h3 id=\"步骤1：创建一个自定义线程类\"><a href=\"#步骤1：创建一个自定义线程类\" class=\"headerlink\" title=\"步骤1：创建一个自定义线程类\"></a>步骤1：创建一个自定义线程类</h3><p>您需要继承QThread类或使用QObject类自己创建线程的子类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> : <span class=\"keyword\">public</span> QThread</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在您自己编写的run()函数内定义线程的任务。</p>\n<h3 id=\"步骤2：实例化新线程\"><a href=\"#步骤2：实例化新线程\" class=\"headerlink\" title=\"步骤2：实例化新线程\"></a>步骤2：实例化新线程</h3><p>在主线程中声明MyThread thread实例，并显示运行它：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyThread thread;</span><br><span class=\"line\">thread.<span class=\"built_in\">start</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤3：连接信号和槽\"><a href=\"#步骤3：连接信号和槽\" class=\"headerlink\" title=\"步骤3：连接信号和槽\"></a>步骤3：连接信号和槽</h3><p>多线程程序的关键就是线程之间的通信。通过使用信号（QThread::finished()）将工作线程信号与接收该信号的对象的槽（deleteLater()）连接，可以确保在工作完成后删除工作线程。以下是部分示例代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">connect</span>(&amp;thread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤4：处理线程停止时的异常\"><a href=\"#步骤4：处理线程停止时的异常\" class=\"headerlink\" title=\"步骤4：处理线程停止时的异常\"></a>步骤4：处理线程停止时的异常</h3><p>为了确保在线程停止时应用程序的稳定性，我们需要在线程停止时处理异常。例如，在MyThread类中可以添加以下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MyThread::stop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        stopped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stopped) <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意：您需要根据您的代码适当地添加互斥锁protects来保护共享数据。</p>\n<h2 id=\"Qt多线程的最佳实践\"><a href=\"#Qt多线程的最佳实践\" class=\"headerlink\" title=\"Qt多线程的最佳实践\"></a>Qt多线程的最佳实践</h2><ul>\n<li>避免在GUI线程上进行大量计算。</li>\n<li>确保进程、线程之间的通信由Qt处理，而不是直接访问或更改变量。</li>\n<li>尽可能使用队列来管理线程池，避免过度使用资源。</li>\n<li>需要在不同的线程中保护共享数据。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Qt多线程提供了一种强大的机制来处理并发任务。使用信号和槽机制，您可以轻松地实现各种线程间通信，并通过QObject类来更加容易地管理线程池及其任务。</p>\n<p>在实际应用程序中，确保根据Qt多线程最佳实践来设计代码，会使您写出高效、稳定并且易于维护的程序。</p>\n","count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">Qt多线程详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFQt%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">什么是Qt多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8Qt%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">如何在Qt中使用多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E7%B1%BB\"><span class=\"toc-text\">步骤1：创建一个自定义线程类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B0%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">步骤2：实例化新线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E8%BF%9E%E6%8E%A5%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD\"><span class=\"toc-text\">步骤3：连接信号和槽</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">步骤4：处理线程停止时的异常</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">Qt多线程的最佳实践</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","data":[]}