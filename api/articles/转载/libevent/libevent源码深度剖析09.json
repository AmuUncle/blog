{"title":"【转载】libevent源码深度剖析09","uid":"3ac2d154bc8f115a96c543f8b70be68b","slug":"转载/libevent/libevent源码深度剖析09","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析09.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析09\"><a href=\"#libevent源码深度剖析09\" class=\"headerlink\" title=\"libevent源码深度剖析09\"></a>libevent源码深度剖析09</h1><p><strong>集成定时器事件</strong></p>\n<p>现在再来详细分析libevent中I&#x2F;O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直观和简单很多。Libevent对堆的调整操作做了一些优化，本节还会描述这些优化方法。</p>\n<h3 id=\"1-集成到事件主循环\"><a href=\"#1-集成到事件主循环\" class=\"headerlink\" title=\"1. 集成到事件主循环\"></a>1. 集成到事件主循环</h3><p>因为系统的I&#x2F;O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）<strong>timeout</strong>，即使没有I&#x2F;O事件发生，它们也保证能在timeout时间内返回。<br>那么根据所有Timer事件的最小超时时间来设置系统I&#x2F;O的timeout时间；当系统I&#x2F;O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I&#x2F;O机制中了。<br>具体的代码在源文件event.c的**event_base_loop()**中，现在就对比代码来看看这一处理方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class=\"line\">          // 根据Timer事件计算evsel-&gt;dispatch的最大等待时间</span><br><span class=\"line\">          timeout_next(base, &amp;tv_p);</span><br><span class=\"line\">      &#125; else &#123; </span><br><span class=\"line\">          // 如果还有活动事件，就不要等待，让evsel-&gt;dispatch立即返回</span><br><span class=\"line\">          evutil_timerclear(&amp;tv);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">      // 调用select() or epoll_wait() 等待就绪I/O事件</span><br><span class=\"line\">      res = evsel-&gt;dispatch(base, evbase, tv_p);</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">      // 处理超时事件，将超时事件插入到激活链表中</span><br><span class=\"line\">      timeout_process(base);</span><br></pre></td></tr></table></figure>\n\n<p>**timeout_next()**函数根据堆中具有最小超时值的事件和当前时间来计算等待时间，下面看看代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1static int timeout_next(struct event_base *base, struct timeval **tv_p)&#123;</span><br><span class=\"line\"> 2    struct timeval now;</span><br><span class=\"line\"> 3    struct event *ev;</span><br><span class=\"line\"> 4    struct timeval *tv = *tv_p;</span><br><span class=\"line\"> 5    // 堆的首元素具有最小的超时值</span><br><span class=\"line\"> 6    if ((ev = min_heap_top(&amp;base-&gt;timeheap)) == NULL) &#123;</span><br><span class=\"line\"> 7        // 如果没有定时事件，将等待时间设置为NULL,表示一直阻塞直到有I/O事件发生</span><br><span class=\"line\"> 8        *tv_p = NULL;</span><br><span class=\"line\"> 9        return (0);</span><br><span class=\"line\">10    &#125;</span><br><span class=\"line\">11    // 取得当前时间</span><br><span class=\"line\">12    gettime(base, &amp;now);</span><br><span class=\"line\">13    // 如果超时时间&lt;=当前值，不能等待，需要立即返回</span><br><span class=\"line\">14    if (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) &#123;</span><br><span class=\"line\">15        evutil_timerclear(tv);</span><br><span class=\"line\">16        return (0);</span><br><span class=\"line\">17    &#125;</span><br><span class=\"line\">18    // 计算等待的时间=当前时间-最小的超时时间</span><br><span class=\"line\">19    evutil_timersub(&amp;ev-&gt;ev_timeout, &amp;now, tv);</span><br><span class=\"line\">20    return (0);</span><br><span class=\"line\">21&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-Timer小根堆\"><a href=\"#2-Timer小根堆\" class=\"headerlink\" title=\"2. Timer小根堆\"></a>2. Timer小根堆</h3><p>libevent使用堆来管理Timer事件，其key值就是事件的超时时间，源代码位于文件<strong>min_heap.h</strong>中。<br>所有的数据结构书中都有关于堆的详细介绍，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)。堆是一个完全二叉树，基本存储方式是一个数组。<br>libevent实现的堆还是比较轻巧的，虽然我不喜欢这种编码方式（搞一些复杂的表达式）。轻巧到什么地方呢，就以插入元素为例，来对比说明，下面伪代码中的size表示当前堆的元素个数：</p>\n<p>典型的代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap[size++] = new; // 先放到数组末尾，元素个数+1</span><br><span class=\"line\">// 下面就是shift_up()的代码逻辑，不断的将new向上调整</span><br><span class=\"line\">_child = size;</span><br><span class=\"line\">while(_child&gt;0) // 循环</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _parent = (_child-1)/2; // 计算parent</span><br><span class=\"line\">    if(Heap[_parent].key &lt; Heap[_child].key)</span><br><span class=\"line\">    \tbreak; // 调整结束，跳出循环</span><br><span class=\"line\">    swap(_parent, _child); // 交换parent和child</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而libevent的<strong>heap</strong>代码对这一过程做了优化，在插入新元素时，只是为新元素预留了一个位置<strong>hole</strong>（初始时hole位于数组尾部），但并不立刻将新元素插入到hole上，而是不断向上调整hole的值，将父节点向下调整，最后确认hole就是新元素的所在位置时，才会真正的将新元素插入到hole上，因此在调整过程中就比上面的代码少了一次赋值的操作，代码逻辑是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下面就是shift_up()的代码逻辑，不断的将new的“预留位置”向上调整</span><br><span class=\"line\">_hole = size; // _hole就是为new预留的位置，但并不立刻将new放上</span><br><span class=\"line\">while(_hole&gt;0) // 循环</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _parent = (_hole-1)/2; // 计算parent</span><br><span class=\"line\">    if(Heap[_parent].key &lt; new.key)</span><br><span class=\"line\">        break; // 调整结束，跳出循环</span><br><span class=\"line\">    Heap[_hole] = Heap[_parent]; // 将parent向下调整</span><br><span class=\"line\">    _hole = _parent; // 将_hole调整到_parent</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Heap[_hole] = new; // 调整结束，将new插入到_hole指示的位置</span><br><span class=\"line\">size++; // 元素个数+1</span><br></pre></td></tr></table></figure>\n\n<p>由于每次调整都少做一次赋值操作，在调整路径比较长时，调整效率会比第一种有所提高。libevent中的**min_heap_shift_up_()<strong>函数就是上面逻辑的具体实现，对应的向下调整函数是</strong>min_heap_shift_down_()**。</p>\n<p>举个例子，向一个小根堆3, 5, 8, 7, 12中插入新元素2，使用第一中典型的代码逻辑，其调整过程如下图所示：</p>\n<p><img src=\"/../imgs/libevent9.webp\"></p>\n<p>使用libevent中的堆调整逻辑，调整过程如下图所示：</p>\n<p><img src=\"/../imgs/libevent10.webp\"></p>\n<p>对于删除和元素修改操作，也遵从相同的逻辑，就不再罗嗦了。</p>\n<h3 id=\"3-小节\"><a href=\"#3-小节\" class=\"headerlink\" title=\"3. 小节\"></a>3. 小节</h3><p>通过设置系统I&#x2F;O机制的wait时间，从而简洁的集成Timer事件；主要分析了libevent对堆调整操作的优化。</p>\n","text":"libevent源码深度剖析09集成定时器事件 现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直...","permalink":"/post/转载/libevent/libevent源码深度剖析09","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9009\"><span class=\"toc-text\">libevent源码深度剖析09</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%9B%86%E6%88%90%E5%88%B0%E4%BA%8B%E4%BB%B6%E4%B8%BB%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">1. 集成到事件主循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Timer%E5%B0%8F%E6%A0%B9%E5%A0%86\"><span class=\"toc-text\">2. Timer小根堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">3. 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析08","uid":"c96eddcf717cad02fc0a6f9698a4cec4","slug":"转载/libevent/libevent源码深度剖析08","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析08.json","keywords":null,"cover":[],"text":"libevent源码深度剖析08集成信号处理 现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和S...","permalink":"/post/转载/libevent/libevent源码深度剖析08","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析10","uid":"7d0768b2cfc1e99a9f8dcf0642553217","slug":"转载/libevent/libevent源码深度剖析10","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.353Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析10.json","keywords":null,"cover":null,"text":"libevent源码深度剖析10支持I/O多路复用技术 libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而...","permalink":"/post/转载/libevent/libevent源码深度剖析10","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}