{"title":"【转载】libevent源码深度剖析02","uid":"0b2fd1ebe4476d5c0bbc97c748eb6d3b","slug":"转载/libevent/libevent源码深度剖析02","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.340Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析02.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析02\"><a href=\"#libevent源码深度剖析02\" class=\"headerlink\" title=\"libevent源码深度剖析02\"></a>libevent源码深度剖析02</h1><p>Reactor模式</p>\n<p>前面讲到，整个libevent本身就是一个<strong>Reactor</strong>，因此本节将专门对Reactor模式进行必要的介绍，并列出libevnet中的几个重要组件和Reactor的对应关系，在后面的章节中可能还会提到本节介绍的基本概念。</p>\n<h3 id=\"1-Reactor的事件处理机制\"><a href=\"#1-Reactor的事件处理机制\" class=\"headerlink\" title=\"1. Reactor的事件处理机制\"></a>1. Reactor的事件处理机制</h3><p>首先来回想一下普通函数调用的机制：程序调用某函数?函数执行，程序等待?函数将结果和控制权返回给程序?程序继续处理。</p>\n<p>Reactor释义<strong>“反应堆”</strong>，是一种事件驱动机制。和普通函数调用的不同之处在于：应用程序不是主动的调用某个<strong>API</strong>完成处理，而是恰恰相反，Reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果相应的时间发生，Reactor将主动调用应用程序注册的接口，这些接口又称为<strong>“回调函数”</strong>。使用libevent也是想libevent框架注册相应的事件和回调函数；当这些事件发生时，libevent会调用这些回调函数处理相应的事件（I&#x2F;O读写、定时和信号）。</p>\n<p>用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。</p>\n<p>举个例子：你去应聘某xx公司，面试结束后。</p>\n<p>“普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被据了；</p>\n<p>“Reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被据了；你不用自己打电话去问结果，事实上也不能，你没有HR的留联系方式。</p>\n<h3 id=\"2-Reactor模式的优点\"><a href=\"#2-Reactor模式的优点\" class=\"headerlink\" title=\"2. Reactor模式的优点\"></a>2. Reactor模式的优点</h3><p>Reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点</p>\n<p>1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；</p>\n<p>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销；<br>3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；<br>4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>\n<h3 id=\"3-Reactor模式框架\"><a href=\"#3-Reactor模式框架\" class=\"headerlink\" title=\"3. Reactor模式框架\"></a>3. Reactor模式框架</h3><p>使用Reactor模型，必备的几个组件：<strong>事件源</strong>、<strong>Reactor框架</strong>、<strong>多路复用机制和事件处理程序</strong>，先来看看Reactor模型的整体框架，接下来再对每个组件做逐一说明。</p>\n<p><img src=\"/../imgs/libevent1.webp\"></p>\n<p>1） 事件源<br>Linux上是文件描述符，Windows上就是<strong>Socket</strong>或者<strong>Handle</strong>了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I&#x2F;O事件。</p>\n<p>2） event demultiplexer——事件多路分发机制<br>由操作系统提供的I&#x2F;O多路复用机制，比如<strong>select</strong>和<strong>epoll</strong>。<br>程序首先将其关心的句柄（事件源）及其事件注册到<strong>event demultiplexer</strong>上；<br>当有事件到达时，event demultiplexer会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”；<br>程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。<br>对应到libevent中，依然是select、poll、epoll等，但是libevent使用结构体<strong>eventop</strong>进行了封装，以统一的接口来支持这些I&#x2F;O多路复用机制，达到了对外隐藏底层系统机制的目的。</p>\n<p>3） Reactor——反应器<br>Reactor，是事件管理的接口，内部使用<strong>event demultiplexer</strong>注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。<br>对应到libevent中，就是<strong>event_base</strong>结构体。<br>一个典型的Reactor声明方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Reactor&#123;</span><br><span class=\"line\">    public:</span><br><span class=\"line\">        int register_handler(Event_Handler *pHandler, int event);</span><br><span class=\"line\">        int remove_handler(Event_Handler *pHandler, int event);</span><br><span class=\"line\">        void handle_events(timeval *ptv);</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4） Event Handler——事件处理程序</p>\n<p>事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。<br>对应到libevent中，就是event结构体。<br>下面是两种典型的Event Handler类声明方式，二者互有优缺点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Event_Handler&#123;</span><br><span class=\"line\">    public:</span><br><span class=\"line\">        virtual void handle_read() = 0;</span><br><span class=\"line\">        virtual void handle_write() = 0;</span><br><span class=\"line\">        virtual void handle_timeout() = 0;</span><br><span class=\"line\">        virtual void handle_close() = 0;</span><br><span class=\"line\">        virtual HANDLE get_handle() = 0;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Event_Handler&#123;</span><br><span class=\"line\">    public:</span><br><span class=\"line\">        // events maybe read/write/timeout/close .etc</span><br><span class=\"line\">        virtual void handle_events(int events) = 0;</span><br><span class=\"line\">        virtual HANDLE get_handle() = 0;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"4-Reactor事件处理流程\"><a href=\"#4-Reactor事件处理流程\" class=\"headerlink\" title=\"4. Reactor事件处理流程\"></a>4. Reactor事件处理流程</h3><p>前面说过Reactor将事件流“逆置”了，那么使用Reactor模式后，事件控制流是什么样子呢？<br>可以参见下面的序列图。</p>\n<p><img src=\"/../imgs/libevent2.webp\"></p>\n<h3 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h3><p>上面讲到了Reactor的基本概念、框架和处理流程，对Reactor有个基本清晰的了解后，再来对比看libevent就会更容易理解了，接下来就正式进入到libevent的代码世界了，加油！</p>\n<p>参考资料：<br>Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2</p>\n","text":"libevent源码深度剖析02Reactor模式 前面讲到，整个libevent本身就是一个Reactor，因此本节将专门对Reactor模式进行必要的介绍，...","permalink":"/post/转载/libevent/libevent源码深度剖析02","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9002\"><span class=\"toc-text\">libevent源码深度剖析02</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Reactor%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1. Reactor的事件处理机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Reactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">2. Reactor模式的优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Reactor%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">3. Reactor模式框架</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Reactor%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">4. Reactor事件处理流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">5. 小结</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析01","uid":"8ecb216f8fd8194ddd13637de67a4f14","slug":"转载/libevent/libevent源码深度剖析01","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.339Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析01.json","keywords":null,"cover":null,"text":"libevent源码深度剖析一1. 前言libevent是一个轻量级的开源高性能网络库，使用者众多，研究者更甚，相关文章也不少。写这一系列文章的用意在于，一则分...","permalink":"/post/转载/libevent/libevent源码深度剖析01","photos":[],"count_time":{"symbolsCount":864,"symbolsTime":"1 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析03","uid":"dd54cd62e1387361117c63cf12445709","slug":"转载/libevent/libevent源码深度剖析03","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.340Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析03.json","keywords":null,"cover":[],"text":"libevent源码深度剖析03libevent基本使用场景和事件流程1. 前言学习源代码该从哪里入手？我觉得从程序的基本使用场景和代码的整体处理流程入手是个不...","permalink":"/post/转载/libevent/libevent源码深度剖析03","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}