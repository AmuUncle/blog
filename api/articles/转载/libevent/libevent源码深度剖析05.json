{"title":"【转载】libevent源码深度剖析05","uid":"e23144502108769556e4aa73a855e4ee","slug":"转载/libevent/libevent源码深度剖析05","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.341Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析05.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析05\"><a href=\"#libevent源码深度剖析05\" class=\"headerlink\" title=\"libevent源码深度剖析05\"></a>libevent源码深度剖析05</h1><p><strong>libevent的核心：事件event</strong></p>\n<p>对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及libevent对event的管理<strong>。</strong></p>\n<h3 id=\"1-libevent的核心-event\"><a href=\"#1-libevent的核心-event\" class=\"headerlink\" title=\"1. libevent的核心-event\"></a>1. libevent的核心-event</h3><p>libevent是基于<strong>事件驱动（event-driven）</strong>的，从名字也可以看到event是整个库的核心。event就是Reactor框架中的事件处理程序组件；它提供了函数接口，供Reactor在事件发生时调用，以执行相应的事件处理，通常它会绑定一个有效的句柄。</p>\n<p>首先给出event结构体的声明，它<strong>位于event.h文件</strong>中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct event &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     TAILQ_ENTRY (event) ev_next;</span><br><span class=\"line\"></span><br><span class=\"line\">     TAILQ_ENTRY (event) ev_active_next;</span><br><span class=\"line\"></span><br><span class=\"line\">     TAILQ_ENTRY (event) ev_signal_next;</span><br><span class=\"line\"></span><br><span class=\"line\">     unsigned int min_heap_idx; /* for managing timeouts */</span><br><span class=\"line\"></span><br><span class=\"line\">     struct event_base *ev_base;</span><br><span class=\"line\"></span><br><span class=\"line\">     int ev_fd;</span><br><span class=\"line\"></span><br><span class=\"line\">     short ev_events;</span><br><span class=\"line\"></span><br><span class=\"line\">     short ev_ncalls;</span><br><span class=\"line\"></span><br><span class=\"line\">     short *ev_pncalls; /* Allows deletes in callback */</span><br><span class=\"line\"></span><br><span class=\"line\">     struct timeval ev_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">     int ev_pri;  /* smaller numbers are higher priority */</span><br><span class=\"line\"></span><br><span class=\"line\">     void (*ev_callback)(int, short, void *arg);</span><br><span class=\"line\"></span><br><span class=\"line\">     void *ev_arg;</span><br><span class=\"line\"></span><br><span class=\"line\">     int ev_res;  /* result passed to event callback */</span><br><span class=\"line\"></span><br><span class=\"line\">     int ev_flags;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ev_events：event关注的事件类型</strong>，它可以是以下3种类型：</p>\n<ol>\n<li><p>I&#x2F;O事件： EV_WRITE和EV_READ<br> 定时事件：EV_TIMEOUT<br> 信号： EV_SIGNAL<br> 辅助选项：EV_PERSIST，表明是一个永久事件<br> <strong>Libevent中的定义为：</strong></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define EV_TIMEOUT 0x01</span><br><span class=\"line\"></span><br><span class=\"line\">#define EV_READ  0x02</span><br><span class=\"line\"></span><br><span class=\"line\">#define EV_WRITE 0x04</span><br><span class=\"line\"></span><br><span class=\"line\">#define EV_SIGNAL 0x08</span><br><span class=\"line\"></span><br><span class=\"line\">#define EV_PERSIST 0x10 /* Persistant event */</span><br></pre></td></tr></table></figure>\n\n<p> 可以看出事件类型可以使用“|”运算符进行组合，需要说明的是，信号和I&#x2F;O事件不能同时设置；</p>\n<p> 还可以看出libevent使用event结构体将这3种事件的处理统一起来；</p>\n</li>\n<li><p><strong>ev_next，ev_active_next和ev_signal_next</strong>都是双向链表节点指针；它们是libevent对不同事件类型和在不同的时期，对事件的管理时使用到的字段。<br> libevent使用双向链表保存所有注册的I&#x2F;O和Signal事件</p>\n</li>\n<li><p><strong>ev_next</strong>就是该I&#x2F;O事件在链表中的位置；称此链表为“已注册事件链表”；</p>\n</li>\n<li><p>同样<strong>ev_signal_next</strong>就是signal事件在signal事件链表中的位置；</p>\n</li>\n<li><p><strong>ev_active_next</strong>：libevent将所有的激活事件放入到链表active list中，然后遍历active list执行调度，ev_active_next就指明了event在active list中的位置；</p>\n</li>\n<li><p><strong>min_heap_idx和ev_timeout</strong>，如果是timeout事件，它们是event在小根堆中的索引和超时值，libevent使用小根堆来管理定时事件，这将在后面定时事件处理时专门讲解；</p>\n</li>\n<li><p><strong>ev_base</strong>该事件所属的反应堆实例，这是一个event_base结构体，下一节将会详细讲解；</p>\n</li>\n<li><p><strong>ev_fd</strong>，对于I&#x2F;O事件，是绑定的文件描述符；对于signal事件，是绑定的信号；</p>\n</li>\n<li><p><strong>ev_callback</strong>，event的回调函数，被ev_base调用，执行事件处理程序，这是一个函数指针，原型为：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1void (*ev_callback)(int fd, short events, void *arg)</span><br></pre></td></tr></table></figure>\n\n<p> 其中参数fd对应于ev_fd；events对应于ev_events；arg对应于ev_arg；</p>\n</li>\n<li><p><strong>ev_arg</strong>：void*，表明可以是任意类型的数据，在设置event时指定；</p>\n</li>\n<li><p><strong>eb_flags</strong>：libevent用于标记event信息的字段，表明其当前的状态，可能的值有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1#define EVLIST_TIMEOUT 0x01 // event在time堆中</span><br><span class=\"line\"> 2</span><br><span class=\"line\"> 3#define EVLIST_INSERTED 0x02 // event在已注册事件链表中</span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5#define EVLIST_SIGNAL 0x04 // 未见使用</span><br><span class=\"line\"> 6</span><br><span class=\"line\"> 7#define EVLIST_ACTIVE 0x08 // event在激活链表中</span><br><span class=\"line\"> 8</span><br><span class=\"line\"> 9#define EVLIST_INTERNAL 0x10 // 内部使用标记</span><br><span class=\"line\">10</span><br><span class=\"line\">11#define EVLIST_INIT     0x80 // event已被初始化</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ev_ncalls</strong>：事件就绪执行时，调用ev_callback的次数，通常为1；</p>\n</li>\n<li><p><strong>ev_pncalls</strong>：指针，通常指向ev_ncalls或者为NULL；</p>\n</li>\n<li><p><strong>ev_res</strong>：记录了当前激活事件的类型；</p>\n</li>\n</ol>\n<h3 id=\"2-libevent对event的管理\"><a href=\"#2-libevent对event的管理\" class=\"headerlink\" title=\"2. libevent对event的管理\"></a>2. libevent对event的管理</h3><p>从event结构体中的3个链表节点指针和一个堆索引出发，大体上也能窥出<strong>libevent对event的管理方法</strong>了，可以参见下面的示意图：</p>\n<p><img src=\"/../imgs/libevent4.webp\"></p>\n<ul>\n<li>每次当<strong>有事件event转变为就绪状态</strong>时，libevent就会把它移入到active event list[priority]中，其中priority是event的优先级；</li>\n<li>接着libevent会根据自己的调度策略选择就绪事件，调用其cb_callback()函数执行事件处理；并根据就绪的句柄和事件类型填充cb_callback函数的参数。</li>\n</ul>\n<h3 id=\"3-事件设置的接口函数\"><a href=\"#3-事件设置的接口函数\" class=\"headerlink\" title=\"3. 事件设置的接口函数\"></a>3. 事件设置的接口函数</h3><p>要向libevent<strong>添加一个事件</strong>，需要<strong>首先设置event对象</strong>，这通过调用libevent提供的函数有：event_set(), event_base_set(), event_priority_set()来完成；下面分别进行讲解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void event_set(struct event *ev, int fd, short events, void (*callback)(int, short, void *), void *arg)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>设置事件ev绑定的<strong>文件描述符或者信号</strong>，对于定时事件，设为-1即可；</li>\n<li><strong>设置事件类型</strong>，比如EV_READ|EV_PERSIST, EV_WRITE, EV_SIGNAL等；</li>\n<li><strong>设置</strong>事件的<strong>回调函数以及参数arg</strong>；</li>\n<li>初始化其它字段，比如缺省的event_base和优先级；<br> int event_base_set(struct event_base *base, struct event *ev)<br> 设置event ev将要注册到的event_base；<br> libevent有一个<strong>全局event_base指针current_base</strong>，默认情况下事件ev将被注册到current_base上，使用该函数可以指定不同的event_base；<br> 如果一个进程中存<strong>在多个libevent实例，</strong>则必须要调用该函数为event设置不同的event_base；</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_priority_set(struct event *ev, int pri)</span><br></pre></td></tr></table></figure>\n\n<p><strong>设置event ev的优先级</strong>，没什么可说的，<strong>注意</strong>的一点就是：当ev正处于就绪状态时，不能设置，返回-1。</p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>本节讲述了<strong>libevent的核心event结构，以及libevent支持的事件类型和libevent对event的管理模型</strong>；接下来将会描述libevent的事件处理框架，以及其中使用的重要的结构体event_base。</p>\n","text":"libevent源码深度剖析05libevent的核心：事件event 对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及...","permalink":"/post/转载/libevent/libevent源码深度剖析05","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9005\"><span class=\"toc-text\">libevent源码深度剖析05</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-libevent%E7%9A%84%E6%A0%B8%E5%BF%83-event\"><span class=\"toc-text\">1. libevent的核心-event</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-libevent%E5%AF%B9event%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2. libevent对event的管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BA%8B%E4%BB%B6%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3. 事件设置的接口函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">4. 小结</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析04","uid":"21cc3849aa98d79b1da8af8304100d2a","slug":"转载/libevent/libevent源码深度剖析04","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.341Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析04.json","keywords":null,"cover":null,"text":"libevent源码深度剖析041. 前言详细分析源代码之前，如果能对其代码文件的基本结构有个大概的认识和分类，对于代码的分析将是大有裨益的。本节内容不多，我想...","permalink":"/post/转载/libevent/libevent源码深度剖析04","photos":[],"count_time":{"symbolsCount":935,"symbolsTime":"1 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析06","uid":"1db95bdb6c78dab83e0028f095b96fd6","slug":"转载/libevent/libevent源码深度剖析06","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.350Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析06.json","keywords":null,"cover":null,"text":"libevent源码深度剖析06初见事件处理框架 前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细...","permalink":"/post/转载/libevent/libevent源码深度剖析06","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}