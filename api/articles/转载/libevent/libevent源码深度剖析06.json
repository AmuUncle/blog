{"title":"【转载】libevent源码深度剖析06","uid":"1db95bdb6c78dab83e0028f095b96fd6","slug":"转载/libevent/libevent源码深度剖析06","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.350Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析06.json","keywords":null,"cover":null,"content":"<h1 id=\"libevent源码深度剖析06\"><a href=\"#libevent源码深度剖析06\" class=\"headerlink\" title=\"libevent源码深度剖析06\"></a>libevent源码深度剖析06</h1><p><strong>初见事件处理框架</strong></p>\n<p>前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候<strong>剖析libevent对事件的详细处理流程</strong>了，本节将分析libevent的事件处理框架event_base和libevent注册、删除事件的具体流程，可结合前一节libevent对event的管理。</p>\n<h3 id=\"1-事件处理框架-event-base\"><a href=\"#1-事件处理框架-event-base\" class=\"headerlink\" title=\"1. 事件处理框架-event_base\"></a>1. 事件处理框架-event_base</h3><p>回想Reactor模式的几个基本组件，本节讲解的部分对应于<strong>Reactor框架组件</strong>。在libevent中，这就表现为event_base结构体，结构体声明如下，它<strong>位于event-internal.h文件</strong>中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct event_base &#123;</span><br><span class=\"line\">    const struct eventop *evsel;</span><br><span class=\"line\">    void *evbase;　</span><br><span class=\"line\">    int event_count;  /* counts number of total events */</span><br><span class=\"line\">    int event_count_active; /* counts number of active events */</span><br><span class=\"line\">    int event_gotterm;  /* Set to terminate loop */</span><br><span class=\"line\">    int event_break;  /* Set to terminate loop immediately */</span><br><span class=\"line\">    /* active event management */</span><br><span class=\"line\">    struct event_list **activequeues;</span><br><span class=\"line\">    int nactivequeues;</span><br><span class=\"line\">    /* signal handling info */</span><br><span class=\"line\">    struct evsignal_info sig;</span><br><span class=\"line\">    struct event_list eventqueue;</span><br><span class=\"line\">    struct timeval event_tv;</span><br><span class=\"line\">    struct min_heap timeheap;</span><br><span class=\"line\">    struct timeval tv_cache;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面详细解释一下结构体中各字段的含义。</p>\n<ol>\n<li><p>evsel和evbase这两个字段的设置可能会让人有些迷惑，这里你可以把evsel和evbase看作是类和静态函数的关系，比如添加事件时的调用行为：evsel-&gt;add(evbase, ev)，实际执行操作的是evbase；这相当于class::add(instance, ev)，instance就是class的一个对象实例。<br> evsel指向了全局变量static const struct eventop *eventops[]中的一个；<br> 前面也说过，libevent将系统提供的I&#x2F;O demultiplex机制统一封装成了eventop结构；因此eventops[]包含了select、poll、kequeue和epoll等等其中的若干个全局实例对象。<br> evbase实际上是一个eventop实例对象；<br> 先来看看eventop结构体，它的成员是一系列的函数指针, 在event-internal.h文件中：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct eventop &#123;</span><br><span class=\"line\">    const char *name;</span><br><span class=\"line\">    void *(*init)(struct event_base *); // 初始化</span><br><span class=\"line\">    int (*add)(void *, struct event *); // 注册事件</span><br><span class=\"line\">    int (*del)(void *, struct event *); // 删除事件</span><br><span class=\"line\">    int (*dispatch)(struct event_base *, void *, struct timeval *); // 事件分发</span><br><span class=\"line\">    void (*dealloc)(struct event_base *, void *); // 注销，释放资源</span><br><span class=\"line\">    /* set if we need to reinitialize the event base */</span><br><span class=\"line\">    int need_reinit;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> 也就是说，在libevent中，每种I&#x2F;O demultiplex机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。<br> 比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I&#x2F;O demultiplex机制了，这个在后面会再次提到。</p>\n</li>\n<li><p>activequeues是一个二级指针，前面讲过libevent支持事件优先级，因此你可以把它看作是数组，其中的元素activequeues[priority]是一个链表，链表的每个节点指向一个优先级为priority的就绪事件event。</p>\n</li>\n<li><p>eventqueue，链表，保存了所有的注册事件event的指针。</p>\n</li>\n<li><p>sig是由来管理信号的结构体，将在后面信号处理时专门讲解；</p>\n</li>\n<li><p>timeheap是管理定时事件的小根堆，将在后面定时事件处理时专门讲解；</p>\n</li>\n<li><p>event_tv和tv_cache是libevent用于时间管理的变量，将在后面讲到；<br> 其它各个变量都能因名知意，就不再啰嗦了。</p>\n</li>\n</ol>\n<h3 id=\"2-创建和初始化event-base\"><a href=\"#2-创建和初始化event-base\" class=\"headerlink\" title=\"2. 创建和初始化event_base\"></a>2. 创建和初始化event_base</h3><p>创建一个event_base对象也既是创建了一个新的libevent实例，程序需要通过调用event_init()（内部调用event_base_new函数执行具体操作）函数来创建，该函数同时还对新生成的libevent实例进行了初始化。</p>\n<ul>\n<li>该函数首先为event_base实例申请空间，</li>\n<li>然后初始化timer mini-heap，选择并初始化合适的系统I&#x2F;O 的demultiplexer机制，初始化各事件链表；</li>\n</ul>\n<p>函数还检测了系统的时间设置，为后面的时间管理打下基础。</p>\n<h3 id=\"3-接口函数\"><a href=\"#3-接口函数\" class=\"headerlink\" title=\"3. 接口函数\"></a>3. 接口函数</h3><p>前面提到Reactor框架的作用就是提供事件的注册、注销接口；根据系统提供的事件多路分发机制执行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数来处理事件。<br>Libevent中对应的接口函数主要就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int  event_add(struct event *ev, const struct timeval *timeout);</span><br><span class=\"line\">int  event_del(struct event *ev);</span><br><span class=\"line\">int  event_base_loop(struct event_base *base, int loops);</span><br><span class=\"line\">void event_active(struct event *event, int res, short events);</span><br><span class=\"line\">void event_process_active(struct event_base *base); </span><br></pre></td></tr></table></figure>\n\n<p>本节将按介绍事件注册和删除的代码流程，libevent的事件循环框架将在下一节再具体描述。</p>\n<ul>\n<li>对于<strong>定时事件</strong>，这些函数将调用timer heap管理接口执行插入和删除操作；</li>\n<li>对于<strong>I&#x2F;O和Signal事件</strong>将调用eventopadd和delete接口函数执行插入和删除操作（eventop会对Signal事件调用Signal处理接口执行操作）；</li>\n</ul>\n<p>这些组件将在后面的内容描述。</p>\n<p><strong>1）注册事件</strong><br>函数原型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_add(struct event *ev, const struct timeval *tv)</span><br></pre></td></tr></table></figure>\n\n<p>参数：ev：指向要注册的事件；<br>tv：超时时间；</p>\n<p>e函数将ev注册到ev-&gt;ev_base上，事件类型由ev-&gt;ev_events指明，</p>\n<ul>\n<li>如果注册成功，v将被插入到已注册链表中；</li>\n<li>如果tv不是NULL，则会同时注册定时事件，将ev添加到timer堆上；</li>\n</ul>\n<p>如果其中有一步操作失败，那么函数保证没有事件会被注册，可以讲这相当于一个原子操作。这个函数也体现了libevent细节之处的巧妙设计，且仔细看程序代码，部分有省略，注释直接附在代码中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_add(struct event *ev, const struct timeval *tv) &#123;</span><br><span class=\"line\">\tstruct event_base *base = ev-&gt;ev_base;</span><br><span class=\"line\">\t// 要注册到的event_base</span><br><span class=\"line\">\tconst struct eventop *evsel = base-&gt;evsel;</span><br><span class=\"line\">\tvoid *evbase = base-&gt;evbase;</span><br><span class=\"line\">\t// base使用的系统I/O策略</span><br><span class=\"line\">\t// 新的timer事件，调用timer heap接口在堆上预留一个位置</span><br><span class=\"line\">\t// 注：这样能保证该操作的原子性：</span><br><span class=\"line\">\t// 向系统I/O机制注册可能会失败，而当在堆上预留成功后，</span><br><span class=\"line\">\t// 定时事件的添加将肯定不会失败；</span><br><span class=\"line\">\t// 而预留位置的可能结果是堆扩充，但是内部元素并不会改变</span><br><span class=\"line\">\tif (tv != NULL &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class=\"line\">\t\tif (min_heap_reserve(&amp;base-&gt;timeheap, 1 + min_heap_size(&amp;base-&gt;timeheap)) == -1)</span><br><span class=\"line\">\t\t        \treturn (-1);</span><br><span class=\"line\">\t\t/* ENOMEM == errno */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 如果事件ev不在已注册或者激活链表中，则调用evbase注册事件</span><br><span class=\"line\">\tif ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_SIGNAL)) &amp;&amp; !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE))) &#123;</span><br><span class=\"line\">\t\tres = evsel-&gt;add(evbase, ev);</span><br><span class=\"line\">\t\tif (res != -1) // 注册成功，插入event到已注册链表中</span><br><span class=\"line\">\t\tevent_queue_insert(base, ev, EVLIST_INSERTED);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 准备添加定时事件</span><br><span class=\"line\">\tif (res != -1 &amp;&amp; tv != NULL) &#123;</span><br><span class=\"line\">\t\tstruct timeval now;</span><br><span class=\"line\">\t\t// EVLIST_TIMEOUT表明event已经在定时器堆中了，删除旧的</span><br><span class=\"line\">\t\tif (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class=\"line\">\t\t        \tevent_queue_remove(base, ev, EVLIST_TIMEOUT);</span><br><span class=\"line\">\t\t// 如果事件已经是就绪状态则从激活链表中删除</span><br><span class=\"line\">\t\tif ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp;</span><br><span class=\"line\">\t\t        (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;</span><br><span class=\"line\">\t\t\t// 将ev_callback调用次数设置为0</span><br><span class=\"line\">\t\t\tif (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class=\"line\">\t\t\t\t*ev-&gt;ev_pncalls = 0;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tevent_queue_remove(base, ev, EVLIST_ACTIVE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 计算时间，并插入到timer小根堆中</span><br><span class=\"line\">\t\tgettime(base, &amp;now);</span><br><span class=\"line\">\t\tevutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout);</span><br><span class=\"line\">\t\tevent_queue_insert(base, ev, EVLIST_TIMEOUT);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn (res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>event_queue_insert()负责将事件插入到对应的链表中，下面是程序代码；</li>\n<li>event_queue_remove()负责将事件从对应的链表中删除，这里就不再重复贴代码了；</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void event_queue_insert(struct event_base *base, struct event *ev, int queue) &#123;</span><br><span class=\"line\">\t// ev可能已经在激活列表中了，避免重复插入</span><br><span class=\"line\">\tif (ev-&gt;ev_flags &amp; queue) &#123;</span><br><span class=\"line\">\t\tif (queue &amp; EVLIST_ACTIVE)</span><br><span class=\"line\">\t\t   return;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">\tev-&gt;ev_flags |= queue;</span><br><span class=\"line\">\t// 记录queue标记</span><br><span class=\"line\">\tswitch (queue) &#123;</span><br><span class=\"line\">\t\tcase EVLIST_INSERTED: // I/O或Signal事件，加入已注册事件链表</span><br><span class=\"line\">\t\tTAILQ_INSERT_TAIL(&amp;base-&gt;eventqueue, ev, ev_next);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t\tcase EVLIST_ACTIVE: // 就绪事件，加入激活链表</span><br><span class=\"line\">\t\tbase-&gt;event_count_active++;</span><br><span class=\"line\">\t\tTAILQ_INSERT_TAIL(base-&gt;activequeues[ev-&gt;ev_pri], ev, ev_active_next);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t\tcase EVLIST_TIMEOUT: // 定时事件，加入堆</span><br><span class=\"line\">\t\tmin_heap_push(&amp;base-&gt;timeheap, ev);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）删除事件：</strong><br>函数原型为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_del(struct event *ev);</span><br></pre></td></tr></table></figure>\n\n<p>该函数将删除事件ev</p>\n<ul>\n<li>对于I&#x2F;O事件，从I&#x2F;O 的demultiplexer上将事件注销；</li>\n<li>对于Signal事件，将从Signal事件链表中删除；</li>\n<li>对于定时事件，将从堆上删除；</li>\n</ul>\n<p>同样删除事件的操作则不一定是原子的，比如删除时间事件之后，有可能从系统I&#x2F;O机制中注销会失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_del(struct event *ev) &#123;</span><br><span class=\"line\">\tstruct event_base *base;</span><br><span class=\"line\">\tconst struct eventop *evsel;</span><br><span class=\"line\">\tvoid *evbase;</span><br><span class=\"line\">\t// ev_base为NULL，表明ev没有被注册</span><br><span class=\"line\">\tif (ev-&gt;ev_base == NULL)</span><br><span class=\"line\">\t  return (-1);</span><br><span class=\"line\">\t// 取得ev注册的event_base和eventop指针</span><br><span class=\"line\">\tbase = ev-&gt;ev_base;</span><br><span class=\"line\">\tevsel = base-&gt;evsel;</span><br><span class=\"line\">\tevbase = base-&gt;evbase;</span><br><span class=\"line\">\t// 将ev_callback调用次数设置为</span><br><span class=\"line\">\tif (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123;</span><br><span class=\"line\">\t\t*ev-&gt;ev_pncalls = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 从对应的链表中删除</span><br><span class=\"line\">\tif (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)</span><br><span class=\"line\">\t  event_queue_remove(base, ev, EVLIST_TIMEOUT);</span><br><span class=\"line\">\tif (ev-&gt;ev_flags &amp; EVLIST_ACTIVE)</span><br><span class=\"line\">\t  event_queue_remove(base, ev, EVLIST_ACTIVE);</span><br><span class=\"line\">\tif (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123;</span><br><span class=\"line\">\t\tevent_queue_remove(base, ev, EVLIST_INSERTED);</span><br><span class=\"line\">\t\t// EVLIST_INSERTED表明是I/O或者Signal事件，</span><br><span class=\"line\">\t\t// 需要调用I/O demultiplexer注销事件</span><br><span class=\"line\">\t\treturn (evsel-&gt;del(evbase, ev));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>分析了event_base这一重要结构体，初步看到了libevent对系统的I&#x2F;O demultiplex机制的封装event_op结构，并结合源代码分析了事件的注册和删除处理，下面将会接着分析事件管理框架中的主事件循环部分。</p>\n","text":"libevent源码深度剖析06初见事件处理框架 前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细...","permalink":"/post/转载/libevent/libevent源码深度剖析06","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9006\"><span class=\"toc-text\">libevent源码深度剖析06</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6-event-base\"><span class=\"toc-text\">1. 事件处理框架-event_base</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96event-base\"><span class=\"toc-text\">2. 创建和初始化event_base</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3. 接口函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">4. 小结</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析05","uid":"e23144502108769556e4aa73a855e4ee","slug":"转载/libevent/libevent源码深度剖析05","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.341Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析05.json","keywords":null,"cover":[],"text":"libevent源码深度剖析05libevent的核心：事件event 对事件处理流程有了高层的认识后，本节将详细介绍libevent的核心结构event，以及...","permalink":"/post/转载/libevent/libevent源码深度剖析05","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析07","uid":"2db59a77cabd819a1426d0628461aab7","slug":"转载/libevent/libevent源码深度剖析07","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.351Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析07.json","keywords":null,"cover":[],"text":"libevent源码深度剖析07事件主循环 现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libe...","permalink":"/post/转载/libevent/libevent源码深度剖析07","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}