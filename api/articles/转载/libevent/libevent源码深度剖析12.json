{"title":"【转载】libevent源码深度剖析12","uid":"6ab33ba5c42af5d08609eb8e6d060470","slug":"转载/libevent/libevent源码深度剖析12","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析12.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析12\"><a href=\"#libevent源码深度剖析12\" class=\"headerlink\" title=\"libevent源码深度剖析12\"></a>libevent源码深度剖析12</h1><p><strong>让libevent支持多线程</strong></p>\n<p>libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何在多线程环境中使用libevent，跟源代码并没有太大的关系，纯粹是使用上的技巧。</p>\n<h3 id=\"1-错误使用示例\"><a href=\"#1-错误使用示例\" class=\"headerlink\" title=\"1. 错误使用示例\"></a>1. 错误使用示例</h3><p>在多核的CPU上只使用一个线程始终是对不起CPU的处理能力啊，那好吧，那就多创建几个线程，比如下面的简单服务器场景。<br>1 主线程创建工作线程1；<br>2 接着主线程监听在端口上，等待新的连接；<br>3 在线程1中执行event事件循环，等待事件到来；<br>4 新连接到来，主线程调用libevent接口event_add将新连接注册到libevent上；<br>… …<br>上面的逻辑看起来没什么错误，在很多服务器设计中都可能用到主线程和工作线程的模式….<br>可是就在线程1注册事件时，主线程很可能也在操作事件，比如删除，修改，通过libevent的源代码也能看到，没有同步保护机制，问题麻烦了，看起来不能这样做啊，难道只能使用单线程不成！？</p>\n<h3 id=\"2-支持多线程的几种模式\"><a href=\"#2-支持多线程的几种模式\" class=\"headerlink\" title=\"2. 支持多线程的几种模式\"></a>2. 支持多线程的几种模式</h3><p>libevent并不是线程安全的，但这不代表libevent不支持多线程模式，其实方法在前面已经将signal事件处理时就接触到了，那就是<strong>消息通知机制</strong>。<br>一句话，“你发消息通知我，然后再由我在合适的时间来处理”；<br>说到这就再多说几句，再打个比方，把你自己比作一个工作线程，而你的头是主线程，你有一个消息信箱来接收别人发给你的消息，当时头有个新任务要指派给你。</p>\n<h4 id=\"2-1-暴力抢占\"><a href=\"#2-1-暴力抢占\" class=\"headerlink\" title=\"2.1 暴力抢占\"></a>2.1 暴力抢占</h4><p>那么第一节中使用的多线程方法相当下面的流程：<br>1 当时你正在做事，比如在写文档；<br>2 你的头找到了一个任务，要指派给你，比如帮他搞个PPT，哈；<br>3 头命令你马上搞PPT，你这是不得不停止手头的工作，把PPT搞定了再接着写文档；<br>…</p>\n<h4 id=\"2-2-纯粹的消息通知机制\"><a href=\"#2-2-纯粹的消息通知机制\" class=\"headerlink\" title=\"2.2 纯粹的消息通知机制\"></a>2.2 纯粹的消息通知机制</h4><p>那么基于纯粹的消息通知机制的多线程方式就像下面这样：<br>1 当时你正在写文档；<br>2 你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>3 头发个消息到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>4 你写好文档，接着检查消息发现头有个PPT要你搞定，你开始搞PPT；<br>…<br>第一种的好处是消息可以立即得到处理，但是很方法很粗暴，你必须立即处理这个消息，所以你必须处理好切换问题，省得把文档上的内容不小心写到PPT里。在操作系统的进程通信中，消息队列（消息信箱）都是操作系统维护的，你不必关心。<br>第二种的优点是通过消息通知，切换问题省心了，不过消息是不能立即处理的（基于消息通知机制，这个总是难免的），而且所有的内容都通过消息发送，比如PPT的格式、内容等等信息，这无疑增加了<strong>通信开销</strong>。</p>\n<h4 id=\"2-3-消息通知-同步层\"><a href=\"#2-3-消息通知-同步层\" class=\"headerlink\" title=\"2.3 消息通知+同步层\"></a>2.3 消息通知+同步层</h4><p>有个折中机制可以减少消息通信的开销，就是提取一个同步层，还拿上面的例子来说，你把工作安排都存放在一个工作队列中，而且你能够保证“任何人把新任务扔到这个队列”，“自己取出当前第一个任务”等这些操作都能够保证不会把队列搞乱（其实就是个加锁的队列容器）。<br>再来看看处理过程和上面有什么不同：<br>1 当时你正在写文档；<br>2 你的头找到了一个任务，要指派给你，帮他搞个PPT；<br>2 头有个PPT要你搞定，他把任务push到你的工作队列中，包括了PPT的格式、内容等信息；<br>3 头发个消息（一个字节）到你信箱，有个PPT要帮他搞定，这时你并不鸟他；<br>4 你写好文档，发现有新消息（这预示着有新任务来了），检查工作队列知道头有个PPT要你搞定，你开始搞PPT；<br>…<br>工作队列其实就是一个加锁的容器（队列、链表等等），这个很容易实现实现；而消息通知仅需要一个字节，具体的任务都push到了在工作队列中，因此想比2.2减少了不少通信开销。<br>多线程编程有很多陷阱，线程间资源的同步互斥不是一两句能说得清的，而且出现bug很难跟踪调试；这也有很多的经验和教训，因此如果让我选择，在绝大多数情况下都会选择机制3作为实现多线程的方法。</p>\n<h3 id=\"3-例子——memcached\"><a href=\"#3-例子——memcached\" class=\"headerlink\" title=\"3. 例子——memcached\"></a>3. 例子——memcached</h3><p><strong>Memcached</strong>中的网络部分就是基于libevent完成的，其中的多线程模型就是典型的<strong>消息通知+同步层机制</strong>。下面的图足够说明其多线程模型了，其中有详细的文字说明。</p>\n<p><img src=\"/../imgs/libevent11.webp\"></p>\n<p>注：该图的具体出处忘记了，感谢原作者。</p>\n<h3 id=\"4-小节\"><a href=\"#4-小节\" class=\"headerlink\" title=\"4. 小节\"></a>4. 小节</h3><p>本节更是libevent的使用方面的技巧，讨论了一下如何让libevent支持多线程，以及几种支持多线程的机制，和memcached使用libevent的多线程模型。</p>\n","text":"libevent源码深度剖析12让libevent支持多线程 libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何...","permalink":"/post/转载/libevent/libevent源码深度剖析12","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9012\"><span class=\"toc-text\">libevent源码深度剖析12</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">1. 错误使用示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2. 支持多线程的几种模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E6%9A%B4%E5%8A%9B%E6%8A%A2%E5%8D%A0\"><span class=\"toc-text\">2.1 暴力抢占</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E7%BA%AF%E7%B2%B9%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.2 纯粹的消息通知机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5-%E5%90%8C%E6%AD%A5%E5%B1%82\"><span class=\"toc-text\">2.3 消息通知+同步层</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94memcached\"><span class=\"toc-text\">3. 例子——memcached</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">4. 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析11","uid":"e1ec444aa92c9259448efee0050b6181","slug":"转载/libevent/libevent源码深度剖析11","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析11.json","keywords":null,"cover":null,"text":"libevent源码深度剖析11时间管理 为了支持定时器，libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存...","permalink":"/post/转载/libevent/libevent源码深度剖析11","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析13","uid":"467347dafd8ded07c13ba37241779bf0","slug":"转载/libevent/libevent源码深度剖析13","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.362Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析13.json","keywords":null,"cover":[],"text":"libevent源码深度剖析13libevent信号处理注意点 前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况...","permalink":"/post/转载/libevent/libevent源码深度剖析13","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}