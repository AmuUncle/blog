{"title":"【转载】libevent源码深度剖析08","uid":"c96eddcf717cad02fc0a6f9698a4cec4","slug":"转载/libevent/libevent源码深度剖析08","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析08.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析08\"><a href=\"#libevent源码深度剖析08\" class=\"headerlink\" title=\"libevent源码深度剖析08\"></a>libevent源码深度剖析08</h1><p><strong>集成信号处理</strong></p>\n<p>现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I&#x2F;O事件和Signal以及Timer事件的集成，这一节将分析如何将<strong>Signal</strong>集成到事件主循环的框架中。</p>\n<h3 id=\"1-集成策略——使用socket-pair\"><a href=\"#1-集成策略——使用socket-pair\" class=\"headerlink\" title=\"1. 集成策略——使用socket pair\"></a>1. 集成策略——使用socket pair</h3><p>前一节已经做了足够多的介绍了，基本方法就是采用“消息机制”。在libevent中这是通过socket pair完成的，下面就来详细分析一下。<br>Socket pair就是一个socket对，包含两个socket，一个读socket，一个写socket。工作方式如下图所示：</p>\n<p> <img src=\"/../imgs/libevent6.webp\"></p>\n<p>创建一个socket pair并不是复杂的操作，可以参见下面的流程图，清晰起见，其中忽略了一些错误处理和检查。</p>\n<p><img src=\"/../imgs/libevent7.webp\"></p>\n<p>Libevent提供了辅助函数<strong>evutil_socketpair()<strong>来创建一个</strong>socket pair</strong>，可以结合上面的创建流程来分析该函数。</p>\n<h3 id=\"2-集成到事件主循环——通知event-base\"><a href=\"#2-集成到事件主循环——通知event-base\" class=\"headerlink\" title=\"2. 集成到事件主循环——通知event_base\"></a>2. 集成到事件主循环——通知event_base</h3><p>Socket pair创建好了，可是libevent的事件主循环还是不知道Signal是否发生了啊，看来我们还差了最后一步，那就是：为socket pair的读socket在libevent的<strong>event_base</strong>实例上注册一个<strong>persist</strong>的读事件。<br>这样当向写socket写入数据时，读socket就会得到通知，触发读事件，从而event_base就能相应的得到通知了。<br>前面提到过，Libevent会在事件主循环中检查标记，来确定是否有触发的signal，如果标记被设置就处理这些signal，这段代码在各个具体的I&#x2F;O机制中，以Epoll为例，在**epoll_dispatch()**函数中，代码片段如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = epoll_wait(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout);</span><br><span class=\"line\">    if (res == -1) &#123;</span><br><span class=\"line\">        if (errno != EINTR) &#123;</span><br><span class=\"line\">            event_warn(&quot;epoll_wait&quot;);</span><br><span class=\"line\">            return (-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        evsignal_process(base);// 处理signal事件</span><br><span class=\"line\">        return (0);</span><br><span class=\"line\">    &#125; else if (base-&gt;sig.evsignal_caught) &#123;</span><br><span class=\"line\">        evsignal_process(base);// 处理signal事件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整的处理框架如下所示：</p>\n<p><img src=\"/../imgs/libevent8.webp\"></p>\n<p>注1：libevent中，初始化阶段并不注册读socket的读事件，而是在注册信号阶段才会测试并注册；<br>注2：libevent中，检查I&#x2F;O事件是在各系统I&#x2F;O机制的**dispatch()<strong>函数中完成的，该dispatch()函数在</strong>event_base_loop()**函数中被调用；</p>\n<h3 id=\"3-evsignal-info结构体\"><a href=\"#3-evsignal-info结构体\" class=\"headerlink\" title=\"3. evsignal_info结构体\"></a>3. evsignal_info结构体</h3><p>libevent中Signal事件的管理是通过结构体<strong>evsignal_info</strong>完成的，结构体位于evsignal.h文件中，定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct evsignal_info &#123;</span><br><span class=\"line\">    struct event ev_signal;</span><br><span class=\"line\">    int ev_signal_pair[2];</span><br><span class=\"line\">    int ev_signal_added;</span><br><span class=\"line\">    volatile sig_atomic_t evsignal_caught;</span><br><span class=\"line\">    struct event_list evsigevents[NSIG];</span><br><span class=\"line\">    sig_atomic_t evsigcaught[NSIG];</span><br><span class=\"line\">#ifdef HAVE_SIGACTION</span><br><span class=\"line\">    struct sigaction **sh_old;</span><br><span class=\"line\">#else</span><br><span class=\"line\">    ev_sighandler_t **sh_old;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    int sh_old_max;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面详细介绍一下个字段的含义和作用：<br>1）ev_signal， 为socket pair的读socket向event_base注册读事件时使用的event结构体；<br>2）ev_signal_pair，socket pair对，作用见第一节的介绍；<br>3）ev_signal_added，记录ev_signal事件是否已经注册了；<br>4）evsignal_caught，是否有信号发生的标记；是volatile类型，因为它会在另外的线程中被修改；<br>5）evsigvents[NSIG]，数组，evsigevents[signo]表示注册到信号signo的事件链表；<br>6）evsigcaught[NSIG]，具体记录每个信号触发的次数，evsigcaught[signo]是记录信号signo被触发的次数；<br>7）sh_old记录了原来的signal处理函数指针，当信号signo注册的event被清空时，需要重新设置其处理函数；<br>evsignal_info的初始化包括，创建socket pair，设置ev_signal事件（但并没有注册，而是等到有信号注册时才检查并注册），并将所有标记置零，初始化信号的注册事件链表指针等。</p>\n<h3 id=\"4-注册、注销signal事件\"><a href=\"#4-注册、注销signal事件\" class=\"headerlink\" title=\"4. 注册、注销signal事件\"></a>4. 注册、注销signal事件</h3><p>注册signal事件是通过<strong>evsignal_add(struct event *ev)<strong>函数完成的，libevent对所有的信号注册同一个处理函数</strong>evsignal_handler()<strong>，该函数将在下一段介绍，注册过程如下：<br>1 取得ev要注册到的信号</strong>signo</strong>；<br>2 如果信号signo未被注册，那么就为signo注册信号处理函数<strong>evsignal_handler()<strong>；<br>3 如果事件ev_signal还没哟注册，就注册</strong>ev_signal</strong>事件；<br>4 将事件ev添加到signo的<strong>event</strong>链表中；<br>从signo上注销一个已注册的signal事件就更简单了，直接从其已注册事件的链表中移除即可。如果事件链表已空，那么就恢复旧的处理函数；<br>下面的讲解都以signal()函数为例，sigaction()函数的处理和signal()相似。<br>处理函数evsignal_handler()函数做的事情很简单，就是记录信号的发生次数，并通知event_base有信号触发，需要处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void evsignal_handler(int sig)&#123;</span><br><span class=\"line\">    int save_errno = errno; // 不覆盖原来的错误代码</span><br><span class=\"line\">    if (evsignal_base == NULL) &#123;</span><br><span class=\"line\">        event_warn(&quot;%s: received signal %d, but have no base configured&quot;, __func__, sig);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 记录信号sig的触发次数，并设置event触发标记</span><br><span class=\"line\">    evsignal_base-&gt;sig.evsigcaught[sig]++;</span><br><span class=\"line\">    evsignal_base-&gt;sig.evsignal_caught = 1;</span><br><span class=\"line\">#ifndef HAVE_SIGACTION</span><br><span class=\"line\">    signal(sig, evsignal_handler); // 重新注册信号</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    // 向写socket写一个字节数据，触发event_base的I/O事件，从而通知其有信号触发，需要处理</span><br><span class=\"line\">    send(evsignal_base-&gt;sig.ev_signal_pair[0], &quot;a&quot;, 1, 0);</span><br><span class=\"line\">    errno = save_errno; // 错误代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-小节\"><a href=\"#5-小节\" class=\"headerlink\" title=\"5. 小节\"></a>5. 小节</h3><p>本节介绍了libevent对signal事件的具体处理框架，包括事件注册、删除和socket pair通知机制，以及是如何将Signal事件集成到事件主循环之中的。</p>\n","text":"libevent源码深度剖析08集成信号处理 现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和S...","permalink":"/post/转载/libevent/libevent源码深度剖析08","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9008\"><span class=\"toc-text\">libevent源码深度剖析08</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%9B%86%E6%88%90%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8socket-pair\"><span class=\"toc-text\">1. 集成策略——使用socket pair</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%9B%86%E6%88%90%E5%88%B0%E4%BA%8B%E4%BB%B6%E4%B8%BB%E5%BE%AA%E7%8E%AF%E2%80%94%E2%80%94%E9%80%9A%E7%9F%A5event-base\"><span class=\"toc-text\">2. 集成到事件主循环——通知event_base</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-evsignal-info%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">3. evsignal_info结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%B3%A8%E5%86%8C%E3%80%81%E6%B3%A8%E9%94%80signal%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">4. 注册、注销signal事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">5. 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析07","uid":"2db59a77cabd819a1426d0628461aab7","slug":"转载/libevent/libevent源码深度剖析07","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.351Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析07.json","keywords":null,"cover":[],"text":"libevent源码深度剖析07事件主循环 现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libe...","permalink":"/post/转载/libevent/libevent源码深度剖析07","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析09","uid":"3ac2d154bc8f115a96c543f8b70be68b","slug":"转载/libevent/libevent源码深度剖析09","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析09.json","keywords":null,"cover":[],"text":"libevent源码深度剖析09集成定时器事件 现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直...","permalink":"/post/转载/libevent/libevent源码深度剖析09","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}