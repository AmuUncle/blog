{"title":"【转载】libevent源码深度剖析11","uid":"e1ec444aa92c9259448efee0050b6181","slug":"转载/libevent/libevent源码深度剖析11","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析11.json","keywords":null,"cover":null,"content":"<h1 id=\"libevent源码深度剖析11\"><a href=\"#libevent源码深度剖析11\" class=\"headerlink\" title=\"libevent源码深度剖析11\"></a>libevent源码深度剖析11</h1><p><strong>时间管理</strong></p>\n<p>为了支持定时器，libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存、时间校正和定时器堆的时间值调整等。下面就结合源代码来分析一下。</p>\n<h3 id=\"1-初始化检测\"><a href=\"#1-初始化检测\" class=\"headerlink\" title=\"1. 初始化检测\"></a>1. 初始化检测</h3><p>libevent在初始化时会检测系统时间的类型，通过调用函数*<em>d</em>***etect_monotonic()<strong>完成，它通过调用</strong>clock_gettime()**来检测系统是否支持monotonic时钟类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void detect_monotonic(void)&#123;</span><br><span class=\"line\">#if defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span><br><span class=\"line\">    struct timespec    ts;</span><br><span class=\"line\">    if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) == 0)</span><br><span class=\"line\">        use_monotonic = 1; // 系统支持monotonic时间</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Monotonic时间指示的是系统从boot后到现在所经过的时间，如果系统支持Monotonic时间就将全局变量<strong>use_monotonic</strong>设置为1，设置use_monotonic到底有什么用，这个在后面说到时间校正时就能看出来了。</p>\n<h3 id=\"2-时间缓存\"><a href=\"#2-时间缓存\" class=\"headerlink\" title=\"2. 时间缓存\"></a>2. 时间缓存</h3><p>结构体event_base中的<strong>tv_cache</strong>，用来记录时间缓存。这个还要从函数**gettime()**说起，先来看看该函数的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int gettime(struct event_base *base, struct timeval *tp)&#123;</span><br><span class=\"line\">    // 如果tv_cache时间缓存已设置，就直接使用</span><br><span class=\"line\">    if (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class=\"line\">        *tp = base-&gt;tv_cache;</span><br><span class=\"line\">        return (0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果支持monotonic，就用clock_gettime获取monotonic时间</span><br><span class=\"line\">#if defined(HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span><br><span class=\"line\">    if (use_monotonic) &#123;</span><br><span class=\"line\">        struct timespec    ts;</span><br><span class=\"line\">        if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) == -1)</span><br><span class=\"line\">            return (-1);</span><br><span class=\"line\">        tp-&gt;tv_sec = ts.tv_sec;</span><br><span class=\"line\">        tp-&gt;tv_usec = ts.tv_nsec / 1000;</span><br><span class=\"line\">        return (0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    // 否则只能取得系统当前时间</span><br><span class=\"line\">    return (evutil_gettimeofday(tp, NULL));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果tv_cache已经设置，那么就直接使用缓存的时间；否则需要再次执行系统调用获取系统时间。<br>函数**evutil_gettimeofday()<strong>用来获取当前系统时间，在Linux下其实就是系统调用gettimeofday()；Windows没有提供函数gettimeofday，而是通过调用</strong>_ftime()**来完成的。<br>在每次系统事件循环中，时间缓存tv_cache将会被相应的清空和设置，再次来看看下面event_base_loop的主要代码逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_base_loop(struct event_base *base, int flags)&#123;</span><br><span class=\"line\">    // 清空时间缓存</span><br><span class=\"line\">    base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">    while(!done)&#123;</span><br><span class=\"line\">        timeout_correct(base, &amp;tv); // 时间校正</span><br><span class=\"line\">        // 更新event_tv到tv_cache指示的时间或者当前时间（第一次）</span><br><span class=\"line\">         // event_tv &lt;--- tv_cache</span><br><span class=\"line\">        gettime(base, &amp;base-&gt;event_tv);</span><br><span class=\"line\">        // 清空时间缓存-- 时间点1</span><br><span class=\"line\">        base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">        // 等待I/O事件就绪</span><br><span class=\"line\">        res = evsel-&gt;dispatch(base, evbase, tv_p);</span><br><span class=\"line\">        // 缓存tv_cache存储了当前时间的值-- 时间点2</span><br><span class=\"line\">         // tv_cache &lt;--- now</span><br><span class=\"line\">        gettime(base, &amp;base-&gt;tv_cache);</span><br><span class=\"line\">        // .. 处理就绪事件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 退出时也要清空时间缓存</span><br><span class=\"line\">    base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">    return (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间event_tv指示了<strong>dispatch()<strong>上次返回，也就是I&#x2F;O事件就绪时的时间，第一次进入循环时，由于tv_cache被清空，因此</strong>gettime()<strong>执行系统调用获取当前系统时间；而后将会更新为tv_cache指示的时间。<br>时间tv_cache在</strong>dispatch()<strong>返回后被设置为当前系统时间，因此它缓存了本次I&#x2F;O事件就绪时的时间</strong>（event_tv）</strong>。<br>从代码逻辑里可以看出event_tv取得的是tv_cache上一次的值，因此event_tv应该小于tv_cache的值。<br>设置时间缓存的优点是不必每次获取时间都执行系统调用，这是个相对费时的操作；在上面标注的时间点2到时间点1的这段时间（处理就绪事件时），调用gettime()取得的都是tv_cache缓存的时间。</p>\n<h3 id=\"3-时间校正\"><a href=\"#3-时间校正\" class=\"headerlink\" title=\"3. 时间校正\"></a>3. 时间校正</h3><p>如果系统支持<strong>monotonic</strong>时间，该时间是系统从boot后到现在所经过的时间，因此不需要执行校正。<br>根据前面的代码逻辑，如果系统不支持monotonic时间，用户可能会手动的调整时间，如果时间被向前调整了（MS前面第7部分讲成了向后调整，要改正），比如从5点调整到了3点，那么在时间点2取得的值可能会小于上次的时间，这就需要调整了，下面来看看校正的具体代码，由函数**timeout_correct()**完成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void timeout_correct(struct event_base *base, struct timeval *tv)&#123;</span><br><span class=\"line\">    struct event **pev;</span><br><span class=\"line\">    unsigned int size;</span><br><span class=\"line\">    struct timeval off;</span><br><span class=\"line\">    if (use_monotonic) // monotonic时间就直接返回，无需调整</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    gettime(base, tv); // tv &lt;---tv_cache</span><br><span class=\"line\">    // 根据前面的分析可以知道event_tv应该小于tv_cache</span><br><span class=\"line\">    // 如果tv &lt; event_tv表明用户向前调整时间了，需要校正时间</span><br><span class=\"line\">    if (evutil_timercmp(tv, &amp;base-&gt;event_tv, &gt;=)) &#123;</span><br><span class=\"line\">        base-&gt;event_tv = *tv;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 计算时间差值</span><br><span class=\"line\">    evutil_timersub(&amp;base-&gt;event_tv, tv, &amp;off);</span><br><span class=\"line\">    // 调整定时事件小根堆</span><br><span class=\"line\">    pev = base-&gt;timeheap.p;</span><br><span class=\"line\">    size = base-&gt;timeheap.n;</span><br><span class=\"line\">    for (; size-- &gt; 0; ++pev) &#123;</span><br><span class=\"line\">        struct timeval *ev_tv = &amp;(**pev).ev_timeout;</span><br><span class=\"line\">        evutil_timersub(ev_tv, &amp;off, ev_tv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    base-&gt;event_tv = *tv; // 更新event_tv为tv_cache</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调整小根堆时，因为所有定时事件的时间值都会被减去相同的值，因此虽然堆中元素的时间键值改变了，但是相对关系并没有改变，不会改变堆的整体结构。因此只需要遍历堆中的所有元素，将每个元素的时间键值减去相同的值即可完成调整，不需要重新调整堆的结构。<br>当然调整完后，要将event_tv值重新设置为tv_cache值了。</p>\n<h3 id=\"4-小节\"><a href=\"#4-小节\" class=\"headerlink\" title=\"4. 小节\"></a>4. 小节</h3><p>主要分析了一下libevent对系统时间的处理，时间缓存、时间校正和定时堆的时间值调整等，逻辑还是很简单的，时间的加减、设置等辅助函数则非常简单，主要在头文件evutil.h中，就不再多说了。</p>\n","text":"libevent源码深度剖析11时间管理 为了支持定时器，libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存...","permalink":"/post/转载/libevent/libevent源码深度剖析11","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9011\"><span class=\"toc-text\">libevent源码深度剖析11</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">1. 初始化检测</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%97%B6%E9%97%B4%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2. 时间缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%97%B6%E9%97%B4%E6%A0%A1%E6%AD%A3\"><span class=\"toc-text\">3. 时间校正</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">4. 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析10","uid":"7d0768b2cfc1e99a9f8dcf0642553217","slug":"转载/libevent/libevent源码深度剖析10","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.353Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析10.json","keywords":null,"cover":null,"text":"libevent源码深度剖析10支持I/O多路复用技术 libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而...","permalink":"/post/转载/libevent/libevent源码深度剖析10","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析12","uid":"6ab33ba5c42af5d08609eb8e6d060470","slug":"转载/libevent/libevent源码深度剖析12","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析12.json","keywords":null,"cover":[],"text":"libevent源码深度剖析12让libevent支持多线程 libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何...","permalink":"/post/转载/libevent/libevent源码深度剖析12","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}