{"title":"【转载】libevent源码深度剖析07","uid":"2db59a77cabd819a1426d0628461aab7","slug":"转载/libevent/libevent源码深度剖析07","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.351Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析07.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析07\"><a href=\"#libevent源码深度剖析07\" class=\"headerlink\" title=\"libevent源码深度剖析07\"></a>libevent源码深度剖析07</h1><p><strong>事件主循环</strong></p>\n<p>现在我们已经初步了解了libevent的Reactor组件——<strong>event_base</strong>和<strong>事件管理框架</strong>，接下来就是libevent事件处理的中心部分——<strong>事件主循环</strong>，根据系统提供的事件多路分发机制执行事件循环，对已注册的就绪事件，调用注册事件的回调函数来处理事件。</p>\n<h3 id=\"1-阶段性的胜利\"><a href=\"#1-阶段性的胜利\" class=\"headerlink\" title=\"1. 阶段性的胜利\"></a>1. 阶段性的胜利</h3><p>libevent将I&#x2F;O事件、定时器和信号事件处理很好的结合到了一起，本节也会介绍libevent是如何做到这一点的。<br>在看完本节的内容后，读者应该会对Libevent的基本框架：事件管理和主循环有比较清晰的认识了，并能够把libevent的事件控制流程清晰的串通起来，剩下的就是一些细节的内容了。</p>\n<h3 id=\"2-事件处理主循环\"><a href=\"#2-事件处理主循环\" class=\"headerlink\" title=\"2. 事件处理主循环\"></a>2. 事件处理主循环</h3><p>libevent的事件主循环主要是通过<strong>event_base_loop ()<strong>函数完成的，其主要操作如下面的流程图所示，</strong>event_base_loop</strong>所作的就是持续执行下面的循环。<br> <img src=\"/../imgs/libevent5.webp\"></p>\n<p>清楚了event_base_loop所作的主要操作，就可以对比源代码看个究竟了，代码结构还是相当清晰的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int event_base_loop(struct event_base *base, int flags)&#123;</span><br><span class=\"line\">    const struct eventop *evsel = base-&gt;evsel;</span><br><span class=\"line\">    void *evbase = base-&gt;evbase;</span><br><span class=\"line\">    struct timeval tv;</span><br><span class=\"line\">    struct timeval *tv_p;</span><br><span class=\"line\">    int res, done;</span><br><span class=\"line\">    // 清空时间缓存</span><br><span class=\"line\">    base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">    // evsignal_base是全局变量，在处理signal时，用于指名signal所属的event_base实例</span><br><span class=\"line\">    if (base-&gt;sig.ev_signal_added)</span><br><span class=\"line\">        evsignal_base = base;</span><br><span class=\"line\">    done = 0;</span><br><span class=\"line\">    while (!done) &#123; // 事件主循环</span><br><span class=\"line\">        // 查看是否需要跳出循环，程序可以调用event_loopexit_cb()设置event_gotterm标记</span><br><span class=\"line\">        // 调用event_base_loopbreak()设置event_break标记</span><br><span class=\"line\">        if (base-&gt;event_gotterm) &#123;</span><br><span class=\"line\">            base-&gt;event_gotterm = 0;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (base-&gt;event_break) &#123;</span><br><span class=\"line\">            base-&gt;event_break = 0;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 校正系统时间，如果系统使用的是非MONOTONIC时间，用户可能会向后调整了系统时间</span><br><span class=\"line\">        // 在timeout_correct函数里，比较last wait time和当前时间，如果当前时间&lt; last wait time</span><br><span class=\"line\">        // 表明时间有问题，这是需要更新timer_heap中所有定时事件的超时时间。</span><br><span class=\"line\">        timeout_correct(base, &amp;tv);</span><br><span class=\"line\">        // 根据timer heap中事件的最小超时时间，计算系统I/O demultiplexer的最大等待时间</span><br><span class=\"line\">        tv_p = &amp;tv;</span><br><span class=\"line\">        if (!base-&gt;event_count_active &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class=\"line\">            timeout_next(base, &amp;tv_p);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 依然有未处理的就绪时间，就让I/O demultiplexer立即返回，不必等待</span><br><span class=\"line\">            // 下面会提到，在libevent中，低优先级的就绪事件可能不能立即被处理</span><br><span class=\"line\">            evutil_timerclear(&amp;tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果当前没有注册事件，就退出</span><br><span class=\"line\">        if (!event_haveevents(base)) &#123;</span><br><span class=\"line\">            event_debug((&quot;%s: no events registered.&quot;, __func__));</span><br><span class=\"line\">            return (1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 更新last wait time，并清空time cache</span><br><span class=\"line\">        gettime(base, &amp;base-&gt;event_tv);</span><br><span class=\"line\">        base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">        // 调用系统I/O demultiplexer等待就绪I/O events，可能是epoll_wait，或者select等；</span><br><span class=\"line\">        // 在evsel-&gt;dispatch()中，会把就绪signal event、I/O event插入到激活链表中</span><br><span class=\"line\">        res = evsel-&gt;dispatch(base, evbase, tv_p);</span><br><span class=\"line\">        if (res == -1)</span><br><span class=\"line\">            return (-1);</span><br><span class=\"line\">        // 将time cache赋值为当前系统时间</span><br><span class=\"line\">        gettime(base, &amp;base-&gt;tv_cache);</span><br><span class=\"line\">        // 检查heap中的timer events，将就绪的timer event从heap上删除，并插入到激活链表中</span><br><span class=\"line\">        timeout_process(base);</span><br><span class=\"line\">        // 调用event_process_active()处理激活链表中的就绪event，调用其回调函数执行事件处理</span><br><span class=\"line\">        // 该函数会寻找最高优先级（priority值越小优先级越高）的激活事件链表，</span><br><span class=\"line\">        // 然后处理链表中的所有就绪事件；</span><br><span class=\"line\">        // 因此低优先级的就绪事件可能得不到及时处理；</span><br><span class=\"line\">        if (base-&gt;event_count_active) &#123;</span><br><span class=\"line\">            event_process_active(base);</span><br><span class=\"line\">            if (!base-&gt;event_count_active &amp;&amp; (flags &amp; EVLOOP_ONCE))</span><br><span class=\"line\">                done = 1;</span><br><span class=\"line\">        &#125; else if (flags &amp; EVLOOP_NONBLOCK)</span><br><span class=\"line\">            done = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 循环结束，清空时间缓存</span><br><span class=\"line\">    base-&gt;tv_cache.tv_sec = 0;</span><br><span class=\"line\">    event_debug((&quot;%s: asked to terminate loop.&quot;, __func__));</span><br><span class=\"line\">    return (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-I-O和Timer事件的统一\"><a href=\"#3-I-O和Timer事件的统一\" class=\"headerlink\" title=\"3. I&#x2F;O和Timer事件的统一\"></a>3. I&#x2F;O和Timer事件的统一</h3><p>libevent将Timer和Signal事件都统一到了系统的I&#x2F;O 的<strong>demultiplex</strong>机制中了，相信读者从上面的流程和代码中也能窥出一斑了，下面就再啰嗦一次了。<br>首先将Timer事件融合到系统I&#x2F;O多路复用机制中，还是相当清晰的，因为系统的I&#x2F;O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）<strong>timeout</strong>，即使没有I&#x2F;O事件发生，它们也保证能在timeout时间内返回。<br>那么根据所有Timer事件的最小超时时间来设置系统I&#x2F;O的timeout时间；当系统I&#x2F;O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I&#x2F;O机制中了。<br>这是在Reactor和Proactor模式（主动器模式，比如Windows上的IOCP）中处理Timer事件的经典方法了，ACE采用的也是这种方法，大家可以参考POSA vol2书中的Reactor模式一节。<br>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)；因此变成了管理Timer事件的绝佳人选（当然是非唯一的），libevent就是采用的堆结构。</p>\n<h3 id=\"4-I-O和Signal事件的统一\"><a href=\"#4-I-O和Signal事件的统一\" class=\"headerlink\" title=\"4. I&#x2F;O和Signal事件的统一\"></a>4. I&#x2F;O和Signal事件的统一</h3><p>Signal是异步事件的经典事例，将Signal事件统一到系统的I&#x2F;O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。<br>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I&#x2F;O机制，让其返回，然后再统一和I&#x2F;O事件以及Timer一起处理，不就可以了嘛。是的，这也是libevent中使用的方法。<br>问题的核心在于，当Signal发生时，如何通知系统的I&#x2F;O多路复用机制，这里先买个小关子，放到信号处理一节再详细说明，我想读者肯定也能想出通知的方法，比如使用<strong>pipe</strong>。</p>\n<h3 id=\"5-小节\"><a href=\"#5-小节\" class=\"headerlink\" title=\"5 小节\"></a>5 小节</h3><p>介绍了libevent的事件主循环，描述了libevent是如何处理就绪的I&#x2F;O事件、定时器和信号事件，以及如何将它们无缝的融合到一起。</p>\n","text":"libevent源码深度剖析07事件主循环 现在我们已经初步了解了libevent的Reactor组件——event_base和事件管理框架，接下来就是libe...","permalink":"/post/转载/libevent/libevent源码深度剖析07","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9007\"><span class=\"toc-text\">libevent源码深度剖析07</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%98%B6%E6%AE%B5%E6%80%A7%E7%9A%84%E8%83%9C%E5%88%A9\"><span class=\"toc-text\">1. 阶段性的胜利</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%BB%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">2. 事件处理主循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-I-O%E5%92%8CTimer%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%9F%E4%B8%80\"><span class=\"toc-text\">3. I&#x2F;O和Timer事件的统一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-I-O%E5%92%8CSignal%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%9F%E4%B8%80\"><span class=\"toc-text\">4. I&#x2F;O和Signal事件的统一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">5 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析06","uid":"1db95bdb6c78dab83e0028f095b96fd6","slug":"转载/libevent/libevent源码深度剖析06","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.350Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析06.json","keywords":null,"cover":null,"text":"libevent源码深度剖析06初见事件处理框架 前面已经对libevent的事件处理框架和event结构体做了描述，现在是时候剖析libevent对事件的详细...","permalink":"/post/转载/libevent/libevent源码深度剖析06","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析08","uid":"c96eddcf717cad02fc0a6f9698a4cec4","slug":"转载/libevent/libevent源码深度剖析08","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析08.json","keywords":null,"cover":[],"text":"libevent源码深度剖析08集成信号处理 现在我们已经了解了libevent的基本框架：事件管理框架和事件主循环。上节提到了libevent中I/O事件和S...","permalink":"/post/转载/libevent/libevent源码深度剖析08","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}