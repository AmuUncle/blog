{"title":"【转载】libevent源码深度剖析13","uid":"467347dafd8ded07c13ba37241779bf0","slug":"转载/libevent/libevent源码深度剖析13","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.362Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析13.json","keywords":null,"cover":[],"content":"<h1 id=\"libevent源码深度剖析13\"><a href=\"#libevent源码深度剖析13\" class=\"headerlink\" title=\"libevent源码深度剖析13\"></a>libevent源码深度剖析13</h1><p><strong>libevent信号处理注意点</strong></p>\n<p>前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况需要小心处理，那就是不能在多个 libevent 实例上注册信号事件。依然冠名追加到 libevent 系列。</p>\n<p>以 2 个线程为例，做简单的场景分析。</p>\n<p>1 首先是创建并初始化线程 1 的 libevent 实例 base1 ，线程 1 的 libevent 实例 base2 ；</p>\n<p>2 在 base1 上注册 <strong>SIGALRM</strong> 信号；在 base2 上注册 <strong>SIGINT</strong> 信号；</p>\n<p>3 假设当前 base1 和 base2 上都没有注册其他的事件；</p>\n<p>4 线程 1 和 2 都进入 <strong>event_base_loop</strong> 事件循环：</p>\n<p><img src=\"/../imgs/libevent12.webp\"></p>\n<p>5 假设线程 1 先进入 <strong>event_base_loop</strong> ，并设置 <strong>evsignal_base &#x3D; base1</strong> ；并等待；</p>\n<p>6 接着线程 2 也进入 <strong>event_base_loop</strong> ，并设置 <strong>evsignal_base &#x3D; base2</strong> ；并等待；</p>\n<p> 于是 <strong>evsignal_base</strong> 就指向了 base2 ；</p>\n<p>7 信号 <strong>ALARM</strong> 触发，调用服务例程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void evsignal_handler(int sig)&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       evsignal_base-&gt;sig.evsigcaught[sig]++;</span><br><span class=\"line\">       evsignal_base-&gt;sig.evsignal_caught = 1;</span><br><span class=\"line\">       /* Wake up our notification mechanism */</span><br><span class=\"line\">       send(evsignal_base-&gt;sig.ev_signal_pair[0], &quot;a&quot;, 1, 0);</span><br><span class=\"line\">       ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是 base2 得到通知 ALARM 信号发生了，而实际上 ALARM 是注册在 base1 上的， base2 上的 ALARM 注册 event 是空的，于是处理函数将不能得到调用；因此在 libevent 中，如果需要处理信号，只能将信号注册到一个 libevent 实例上。</p>\n<p>memcached 就没有使用 libevent 提供的 signal 接口，而是直接使用系统提供的原生 API ，看起来这样更简洁。</p>\n<p>libevent源码深度剖析全系列完。</p>\n","text":"libevent源码深度剖析13libevent信号处理注意点 前面讲到了 libevent 实现多线程的方法，然而在多线程的环境中注册信号事件，还是有一些情况...","permalink":"/post/转载/libevent/libevent源码深度剖析13","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9013\"><span class=\"toc-text\">libevent源码深度剖析13</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析12","uid":"6ab33ba5c42af5d08609eb8e6d060470","slug":"转载/libevent/libevent源码深度剖析12","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析12.json","keywords":null,"cover":[],"text":"libevent源码深度剖析12让libevent支持多线程 libevent本身不是多线程安全的，在多核的时代，如何能充分利用CPU的能力呢，这一节来说说如何...","permalink":"/post/转载/libevent/libevent源码深度剖析12","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】业务数据处理一定要单独开线程吗","uid":"c1e8331f572d9e5ea51efac83edeef24","slug":"转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.888Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗.json","keywords":null,"cover":[],"text":"业务数据处理一定要单独开线程吗在 《one thread one loop 思想》一文我们介绍了一个 loop 的主要结构一般如下所示： 12345678whi...","permalink":"/post/转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}