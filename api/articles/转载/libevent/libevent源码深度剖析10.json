{"title":"【转载】libevent源码深度剖析10","uid":"7d0768b2cfc1e99a9f8dcf0642553217","slug":"转载/libevent/libevent源码深度剖析10","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.353Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析10.json","keywords":null,"cover":null,"content":"<h1 id=\"libevent源码深度剖析10\"><a href=\"#libevent源码深度剖析10\" class=\"headerlink\" title=\"libevent源码深度剖析10\"></a>libevent源码深度剖析10</h1><p><strong>支持I&#x2F;O多路复用技术</strong></p>\n<p>libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I&#x2F;O多路复用技术，而这些在Windows、Linux、Unix等不同平台上却各有不同，如何能提供优雅而统一的支持方式，是首要关键的问题，这其实不难，本节就来分析一下。</p>\n<h3 id=\"1-统一的关键\"><a href=\"#1-统一的关键\" class=\"headerlink\" title=\"1. 统一的关键\"></a>1. 统一的关键</h3><p>libevent支持多种I&#x2F;O多路复用技术的关键就在于结构体<strong>eventop</strong>，这个结构体前面也曾提到过，它的成员是一系列的函数指针, 定义在<strong>event-internal.h</strong>文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct eventop &#123;</span><br><span class=\"line\">    const char *name;</span><br><span class=\"line\">    void *(*init)(struct event_base *); // 初始化</span><br><span class=\"line\">    int (*add)(void *, struct event *); // 注册事件</span><br><span class=\"line\">    int (*del)(void *, struct event *); // 删除事件</span><br><span class=\"line\">    int (*dispatch)(struct event_base *, void *, struct timeval *); // 事件分发</span><br><span class=\"line\">    void (*dealloc)(struct event_base *, void *); // 注销，释放资源</span><br><span class=\"line\">    /* set if we need to reinitialize the event base */</span><br><span class=\"line\">    int need_reinit;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> 在libevent中，每种<strong>I&#x2F;O demultiplex</strong>机制的实现都必须提供这五个函数接口，来完成自身的初始化、销毁释放；对事件的注册、注销和分发。<br>比如对于epoll，libevent实现了5个对应的接口函数，并在初始化时并将eventop的5个函数指针指向这5个函数，那么程序就可以使用epoll作为I&#x2F;O demultiplex机制了。</p>\n<h3 id=\"2-设置I-O-demultiplex机制\"><a href=\"#2-设置I-O-demultiplex机制\" class=\"headerlink\" title=\"2. 设置I&#x2F;O demultiplex机制\"></a>2. 设置I&#x2F;O demultiplex机制</h3><p>libevent把所有支持的I&#x2F;O demultiplex机制存储在一个全局静态数组<strong>eventops</strong>中，并在初始化时选择使用何种机制，数组内容根据优先级顺序声明如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* In order of preference */</span><br><span class=\"line\">static const struct eventop *eventops[] = &#123;</span><br><span class=\"line\">#ifdef HAVE_EVENT_PORTS</span><br><span class=\"line\">    &amp;evportops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef HAVE_WORKING_KQUEUE</span><br><span class=\"line\">    &amp;kqops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef HAVE_EPOLL</span><br><span class=\"line\">    &amp;epollops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef HAVE_DEVPOLL</span><br><span class=\"line\">    &amp;devpollops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">    &amp;pollops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef HAVE_SELECT</span><br><span class=\"line\">    &amp;selectops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef WIN32</span><br><span class=\"line\">    &amp;win32ops,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    NULL</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>然后libevent根据系统配置和编译选项决定使用哪一种I&#x2F;O demultiplex机制，这段代码在函数**event_base_new()**中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base-&gt;evbase = NULL;</span><br><span class=\"line\">for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    base-&gt;evsel = eventops[i];</span><br><span class=\"line\">    base-&gt;evbase = base-&gt;evsel-&gt;init(base);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">base-&gt;evbase = NULL;</span><br><span class=\"line\">for (i = 0; eventops[i] &amp;&amp; !base-&gt;evbase; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    base-&gt;evsel = eventops[i];</span><br><span class=\"line\">    base-&gt;evbase = base-&gt;evsel-&gt;init(base);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>可以看出，libevent在编译阶段选择系统的I&#x2F;O demultiplex机制，而不支持在运行阶段根据配置再次选择。</p>\n<p>以Linux下面的epoll为例，实现在源文件<strong>epoll.c</strong>中，eventops对象epollops定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const struct eventop epollops = &#123;</span><br><span class=\"line\">    &quot;epoll&quot;,</span><br><span class=\"line\">    epoll_init,</span><br><span class=\"line\">    epoll_add,</span><br><span class=\"line\">    epoll_del,</span><br><span class=\"line\">    epoll_dispatch,</span><br><span class=\"line\">    epoll_dealloc,</span><br><span class=\"line\">    1 /* need reinit */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>变量epollops中的函数指针具体声明如下，注意到其返回值和参数都和eventop中的定义严格一致，这是函数指针的语法限制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void *epoll_init    (struct event_base *);</span><br><span class=\"line\">static int epoll_add    (void *, struct event *);</span><br><span class=\"line\">static int epoll_del    (void *, struct event *);</span><br><span class=\"line\">static int epoll_dispatch(struct event_base *, void *, struct timeval *);</span><br><span class=\"line\">static void epoll_dealloc    (struct event_base *, void *);</span><br></pre></td></tr></table></figure>\n\n<p>那么如果选择的是epoll，那么调用结构体eventop的<strong>init</strong>和<strong>dispatch</strong>函数指针时，实际调用的函数就是epoll的初始化函数**epoll_init()<strong>和事件分发函数</strong>epoll_dispatch()**了；</p>\n<p><a href=\"http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx\">http://blog.csdn.net/sparkliang/archive/2009/06/09/4254115.aspx</a><br>同样的，上面epollops以及epoll的各种函数都直接定义在了<strong>epoll.c</strong>源文件中，对外都是不可见的。对于libevent的使用者而言，完全不会知道它们的存在，对epoll的使用也是通过eventop来完成的，达到了信息隐藏的目的。</p>\n<h3 id=\"3-小节\"><a href=\"#3-小节\" class=\"headerlink\" title=\"3. 小节\"></a>3. 小节</h3><p>支持多种I&#x2F;O demultiplex机制的方法其实挺简单的，借助于函数指针就OK了。通过对源代码的分析也可以看出，libevent是在编译阶段选择系统的I&#x2F;O demultiplex机制的，而不支持在运行阶段根据配置再次选择。</p>\n","text":"libevent源码深度剖析10支持I/O多路复用技术 libevent的核心是事件驱动、同步非阻塞，为了达到这一目标，必须采用系统提供的I/O多路复用技术，而...","permalink":"/post/转载/libevent/libevent源码深度剖析10","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%9010\"><span class=\"toc-text\">libevent源码深度剖析10</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BB%9F%E4%B8%80%E7%9A%84%E5%85%B3%E9%94%AE\"><span class=\"toc-text\">1. 统一的关键</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E7%BD%AEI-O-demultiplex%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2. 设置I&#x2F;O demultiplex机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B0%8F%E8%8A%82\"><span class=\"toc-text\">3. 小节</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】libevent源码深度剖析09","uid":"3ac2d154bc8f115a96c543f8b70be68b","slug":"转载/libevent/libevent源码深度剖析09","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.352Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析09.json","keywords":null,"cover":[],"text":"libevent源码深度剖析09集成定时器事件 现在再来详细分析libevent中I/O事件和Timer事件的集成，与Signal相比，Timer事件的集成会直...","permalink":"/post/转载/libevent/libevent源码深度剖析09","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】libevent源码深度剖析11","uid":"e1ec444aa92c9259448efee0050b6181","slug":"转载/libevent/libevent源码深度剖析11","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.354Z","comments":true,"path":"api/articles/转载/libevent/libevent源码深度剖析11.json","keywords":null,"cover":null,"text":"libevent源码深度剖析11时间管理 为了支持定时器，libevent必须和系统时间打交道，这一部分的内容也比较简单，主要涉及到时间的加减辅助函数、时间缓存...","permalink":"/post/转载/libevent/libevent源码深度剖析11","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"libevent","slug":"libevent","count":13,"path":"api/tags/libevent.json"},{"name":"源码解析","slug":"源码解析","count":13,"path":"api/tags/源码解析.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}