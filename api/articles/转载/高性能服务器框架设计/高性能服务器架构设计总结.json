{"title":"【转载】高性能服务器架构设计总结","uid":"10a9cf5937dc7bc9f3410b780f114a73","slug":"转载/高性能服务器框架设计/高性能服务器架构设计总结","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.407Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/高性能服务器架构设计总结.json","keywords":null,"cover":[],"content":"<h2 id=\"高性能服务器架构设计总结\"><a href=\"#高性能服务器架构设计总结\" class=\"headerlink\" title=\"高性能服务器架构设计总结\"></a>高性能服务器架构设计总结</h2><p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<p>这篇文章算是对这个系列的一个系统性地总结。我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。</p>\n<p>所谓<strong>高性能</strong>就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；所谓<strong>高并发</strong>，指的是服务器可以同时支持多的客户端连接，且这些客户端在连接期间内会不断与服务器有数据来往。</p>\n<p>这篇文章将从两个方面来介绍，一个是<strong>服务器的框架</strong>，即单个服务器程序的代码组织结构；另外一个是一组服务程序的<strong>如何组织与交互</strong>，即架构。注意：本文以下内容中的客户端是相对概念，指的是连接到当前讨论的服务程序的终端，所以这里的客户端既可能是我们传统意义上的客户端程序，也可能是连接该服务的其他服务器程序。</p>\n<h2 id=\"一、框架篇\"><a href=\"#一、框架篇\" class=\"headerlink\" title=\"一、框架篇\"></a>一、框架篇</h2><p>按上面介绍的思路，我们先从单个服务程序的组织结构开始介绍。</p>\n<h3 id=\"（一）、网络通信\"><a href=\"#（一）、网络通信\" class=\"headerlink\" title=\"（一）、网络通信\"></a>（一）、网络通信</h3><p>既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？</p>\n<p>笔者认为至少要解决以下问题：</p>\n<ol>\n<li>如何检测有新客户端连接？</li>\n<li>如何接受客户端连接？</li>\n<li>如何检测客户端是否有数据发来？</li>\n<li>如何收取客户端发来的数据？</li>\n<li>如何检测连接异常？发现连接异常之后，如何处理？</li>\n<li>如何给客户端发送数据？</li>\n<li>如何在给客户端发完数据后关闭连接？</li>\n</ol>\n<p>稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API。确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是<strong>如何巧妙地组织这些基础的socket API，才是问题的关键</strong>。我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待”就是高效。也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情123456789，另外一部分闲在那里无所事事。说的可能有点抽象，下面我们来举一些例子具体来说明一下。</p>\n<p>比如默认recv函数如果没有数据的时候，线程就会阻塞在那里；<br>默认send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；<br>connect函数默认连接另外一端的时候，也会阻塞在那里；<br>又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。<br>以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的<strong>IO Multiplexing技术（IO复用技术）</strong>。</p>\n<h3 id=\"（二）、几种IO复用机制的比较\"><a href=\"#（二）、几种IO复用机制的比较\" class=\"headerlink\" title=\"（二）、几种IO复用机制的比较\"></a>（二）、几种IO复用机制的比较</h3><p>目前windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP），linux系统支持select、poll、epoll。这里我们不具体介绍每个具体的函数的用法，我们来讨论一点深层次的东西，以上列举的API函数可以分为两个层次：</p>\n<ul>\n<li>层次一 select和poll</li>\n<li>层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll</li>\n</ul>\n<p>为什么这么分呢？先来介绍<strong>第一层次</strong>，select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。这也就是<strong>层次二</strong>的各个函数做的事情，它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，比如WSAAsyncSelect是利用windows消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已。</p>\n<p>比如connect函数连接另外一端，如果连接socket是异步的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。</p>\n<p>所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的<strong>第二个原则：尽量减少做无用功的时间</strong>。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，个人觉得这个可能带来无用。</p>\n<h3 id=\"（三）、检测网络事件的正确姿势\"><a href=\"#（三）、检测网络事件的正确姿势\" class=\"headerlink\" title=\"（三）、检测网络事件的正确姿势\"></a>（三）、检测网络事件的正确姿势</h3><p>根据上面的介绍，第一，为了避免无意义的等待时间，第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。我们的<strong>socket都要设置成异步的。</strong>在此基础上我们回到栏目（一）中提到的七个问题：</p>\n<ol>\n<li><p>如何检测有新客户端连接？</p>\n</li>\n<li><p>如何接受客户端连接？</p>\n<p>默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。</p>\n</li>\n<li><p>如何检测客户端是否有数据发来？</p>\n</li>\n<li><p>如何收取客户端发来的数据？</p>\n<p>同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待。</p>\n<p>至于一次性收多少数据好呢？</p>\n<p>我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了。示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1bool CIUSocket::Recv()  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    int nRet = 0;  </span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5    while(true)  </span><br><span class=\"line\"> 6    &#123;  </span><br><span class=\"line\"> 7        char buff[512];  </span><br><span class=\"line\"> 8        nRet = ::recv(m_hSocket, buff, 512, 0);</span><br><span class=\"line\"> 9     //一旦出现错误就立刻关闭Socket    </span><br><span class=\"line\">10    if(nRet == SOCKET_ERROR)</span><br><span class=\"line\">11    &#123;  </span><br><span class=\"line\">12        if (::WSAGetLastError() == WSAEWOULDBLOCK)  </span><br><span class=\"line\">13           break;   </span><br><span class=\"line\">14        else  </span><br><span class=\"line\">15            return false;  </span><br><span class=\"line\">16    &#125;  </span><br><span class=\"line\">17    else if(nRet &lt; 1)  </span><br><span class=\"line\">18        return false;  </span><br><span class=\"line\">19</span><br><span class=\"line\">20        m_strRecvBuf.append(buff, nRet);  </span><br><span class=\"line\">21</span><br><span class=\"line\">22        ::Sleep(1);  </span><br><span class=\"line\">23    &#125;   </span><br><span class=\"line\">24</span><br><span class=\"line\">25    return true;  </span><br><span class=\"line\">26&#125;  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何检测连接异常？发现连接异常之后，如何处理？</p>\n<p>同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。</p>\n</li>\n<li><p>如何给客户端发送数据？</p>\n<p>给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。首先我们不能像检测数据可读一样检测数据可写，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。所以<strong>正确的做法</strong>是：如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。</p>\n</li>\n<li><p>如何在给客户端发完数据后关闭连接？</p>\n<p>这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。关闭连接的话题，我们再单独开一个小的标题来专门讨论一下。</p>\n</li>\n</ol>\n<h3 id=\"（四）被动关闭连接和主动关闭连接\"><a href=\"#（四）被动关闭连接和主动关闭连接\" class=\"headerlink\" title=\"（四）被动关闭连接和主动关闭连接\"></a>（四）被动关闭连接和主动关闭连接</h3><p>在实际的应用中，<strong>被动关闭连接</strong>是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接。</p>\n<p>而<strong>主动关闭连接</strong>，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。</p>\n<h3 id=\"（五）发送缓冲区和接收缓冲区\"><a href=\"#（五）发送缓冲区和接收缓冲区\" class=\"headerlink\" title=\"（五）发送缓冲区和接收缓冲区\"></a>（五）发送缓冲区和接收缓冲区</h3><p>上面已经介绍了发送缓冲区了，并说明了其存在的意义。接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，</p>\n<ol>\n<li>理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。</li>\n<li>理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如读取磁盘文件，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。</li>\n</ol>\n<p>说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。</p>\n<p><strong>需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个</strong>。这是我们最常见的设计方案。</p>\n<h3 id=\"（六）协议的设计\"><a href=\"#（六）协议的设计\" class=\"headerlink\" title=\"（六）协议的设计\"></a>（六）协议的设计</h3><p>除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。我们知道<strong>tcp&#x2F;ip</strong>协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限。比如A端给B端连续发了三个数据包，每个数据包都是50个字节，B端可能先收到10个字节，再收到140个字节；或者先收到20个字节，再收到20个字节，再收到110个字节；也可能一次性收到150个字节。这150个字节可以以任何字节数目组合和次数被B收到。</p>\n<p>所以我们讨论协议的设计第一个问题就是如何界定包的界线，也就是接收端如何知道每个包数据的大小。目前常用有如下三种方法：</p>\n<ol>\n<li>固定大小，这种方法就是假定每一个包的大小都是固定字节数目，比如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包；</li>\n<li>指定包结束符，比如以一个\\r\\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容；</li>\n<li>指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。</li>\n</ol>\n<p>协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。</p>\n<p>协议要讨论的第三个问题是，根据协议组装的数据包应该尽量小，这样有如下好处：</p>\n<ol>\n<li>第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；</li>\n<li>第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。试想：假如一个股票服务器，如果一只股票的数据包是100个字节或者1000个字节，那100只股票和10000只股票区别呢？</li>\n</ol>\n<p>协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度，比如long型，如果在32位机器上是32位的4个字节，但是如果在64位机器上，就变成了64位8个字节了。这样同样是一个long型，发送方和接收方可能会用不同的长度去解码。所以<strong>建议最好在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，</strong>比如int32,int64等等。下面是一个协议的接口的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1class BinaryReadStream  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    private:  </span><br><span class=\"line\"> 4        const char* const ptr;  </span><br><span class=\"line\"> 5        const size_t      len;  </span><br><span class=\"line\"> 6        const char*       cur;  </span><br><span class=\"line\"> 7        BinaryReadStream(const BinaryReadStream&amp;);  </span><br><span class=\"line\"> 8        BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);  </span><br><span class=\"line\"> 9</span><br><span class=\"line\">10    public:  </span><br><span class=\"line\">11        BinaryReadStream(const char* ptr, size_t len);  </span><br><span class=\"line\">12        virtual const char* GetData() const;  </span><br><span class=\"line\">13        virtual size_t GetSize() const;  </span><br><span class=\"line\">14        bool IsEmpty() const;  </span><br><span class=\"line\">15        bool ReadString(string* str,</span><br><span class=\"line\">16                        size_t maxlen,</span><br><span class=\"line\">17                        size_t&amp; outlen);  </span><br><span class=\"line\">18        bool ReadCString(char* str,  </span><br><span class=\"line\">19                         size_t strlen,</span><br><span class=\"line\">20                         size_t&amp; len);  </span><br><span class=\"line\">21        bool ReadCCString(const char** str,      </span><br><span class=\"line\">22                          size_t maxlen,</span><br><span class=\"line\">23                          size_t&amp; outlen);  </span><br><span class=\"line\">24        bool ReadInt32(int32_t&amp; i);  </span><br><span class=\"line\">25        bool ReadInt64(int64_t&amp; i);  </span><br><span class=\"line\">26        bool ReadShort(short&amp; i);  </span><br><span class=\"line\">27        bool ReadChar(char&amp; c);  </span><br><span class=\"line\">28        size_t ReadAll(char* szBuffer, size_t iLen) const;  </span><br><span class=\"line\">29        bool IsEnd() const;  </span><br><span class=\"line\">30        const char* GetCurrent() const&#123; return cur; &#125;  </span><br><span class=\"line\">31</span><br><span class=\"line\">32    public:  </span><br><span class=\"line\">33        bool ReadLength(size_t &amp; len);  </span><br><span class=\"line\">34        bool ReadLengthWithoutOffset(size_t &amp;headlen,</span><br><span class=\"line\">35                                     size_t &amp; outlen);  </span><br><span class=\"line\">36    &#125;;  </span><br><span class=\"line\">37</span><br><span class=\"line\">38    class BinaryWriteStream  </span><br><span class=\"line\">39    &#123;  </span><br><span class=\"line\">40    public:  </span><br><span class=\"line\">41        BinaryWriteStream(string* data);  </span><br><span class=\"line\">42        virtual const char* GetData() const;  </span><br><span class=\"line\">43        virtual size_t GetSize() const;  </span><br><span class=\"line\">44        bool WriteCString(const char* str, size_t len);  </span><br><span class=\"line\">45        bool WriteString(const string&amp; str);  </span><br><span class=\"line\">46        bool WriteDouble(double value, bool isNULL = false);  </span><br><span class=\"line\">47        bool WriteInt64(int64_t value, bool isNULL = false);  </span><br><span class=\"line\">48        bool WriteInt32(int32_t i, bool isNULL = false);  </span><br><span class=\"line\">49        bool WriteShort(short i, bool isNULL = false);  </span><br><span class=\"line\">50        bool WriteChar(char c, bool isNULL = false);  </span><br><span class=\"line\">51        size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;  </span><br><span class=\"line\">52        void Flush();  </span><br><span class=\"line\">53        void Clear();  </span><br><span class=\"line\">54    private:  </span><br><span class=\"line\">55        string* m_data;  </span><br><span class=\"line\">56   &#125;;  </span><br></pre></td></tr></table></figure>\n\n<p>其中BinaryWriteStream是编码协议的类，BinaryReadStream是解码协议的类。可以按下面这种方式来编码和解码。</p>\n<p>编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1std::string outbuf;  </span><br><span class=\"line\">2BinaryWriteStream writeStream(&amp;outbuf);  </span><br><span class=\"line\">3writeStream.WriteInt32(msg_type_register);  </span><br><span class=\"line\">4writeStream.WriteInt32(m_seq);  </span><br><span class=\"line\">5writeStream.WriteString(retData);  </span><br><span class=\"line\">6writeStream.Flush(); </span><br></pre></td></tr></table></figure>\n\n<p>解码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1BinaryReadStream readStream(strMsg.c_str(),</span><br><span class=\"line\"> 2                            strMsg.length());  </span><br><span class=\"line\"> 3int32_t cmd;  </span><br><span class=\"line\"> 4if (!readStream.ReadInt32(cmd))  </span><br><span class=\"line\"> 5&#123;  </span><br><span class=\"line\"> 6    return false;  </span><br><span class=\"line\"> 7&#125;  </span><br><span class=\"line\"> 8</span><br><span class=\"line\"> 9//int seq;  </span><br><span class=\"line\">10if (!readStream.ReadInt32(m_seq))  </span><br><span class=\"line\">11&#123;  </span><br><span class=\"line\">12    return false;  </span><br><span class=\"line\">13&#125;  </span><br><span class=\"line\">14</span><br><span class=\"line\">15std::string data;  </span><br><span class=\"line\">16size_t datalength;  </span><br><span class=\"line\">17if (!readStream.ReadString(&amp;data, 0, datalength))  </span><br><span class=\"line\">18&#123;  </span><br><span class=\"line\">19    return false;  </span><br><span class=\"line\">20&#125;  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（七）、服务器程序结构的组织\"><a href=\"#（七）、服务器程序结构的组织\" class=\"headerlink\" title=\"（七）、服务器程序结构的组织\"></a>（七）、服务器程序结构的组织</h3><p>上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。根据我的个人经验，目前主流的思想是one thread one loop的策略。通俗点说就是在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑。我们先从最简单地来说，<strong>设定一些线程在一个循环里面做网络通信相关的事情</strong>，伪码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1while(退出标志)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    //IO复用技术检测socket可读事件、出错事件  </span><br><span class=\"line\"> 4    //（如果有数据要发送，则也检测可写事件）  </span><br><span class=\"line\"> 5</span><br><span class=\"line\"> 6    //如果有可读事件，对于侦听socket则接收新连接；  </span><br><span class=\"line\"> 7    //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span><br><span class=\"line\"> 8</span><br><span class=\"line\"> 9    //如果有数据要发送，有可写事件，则发送数据  </span><br><span class=\"line\">10</span><br><span class=\"line\">11    //如果有出错事件，关闭该连接   </span><br><span class=\"line\">12&#125; </span><br></pre></td></tr></table></figure>\n\n<p>&#96; <strong>另外设定一些线程去处理接收到的数据，并解包处理业务逻辑</strong>，这些线程可以认为是业务线程了，伪码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1//从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span><br></pre></td></tr></table></figure>\n\n<p>上面的结构是目前最通用的服务器逻辑结构，但是<strong>能不能再简化一下或者说再综合一下呢？</strong>我们试试，你想过这样的问题没有：假如现在的机器有两个cpu，我们的网络线程数量是2个，业务逻辑线程也是2个，这样可能存在的情况就是：业务线程运行的时候，网络线程并没有运行，它们必须等待，如果是这样的话，干嘛要多建两个线程呢？除了程序结构上可能稍微清楚一点，对程序性能没有任何实质性提高，而且白白浪费cpu时间片在线程上下文切换上。所以，<strong>我们可以将网络线程与业务逻辑线程合并，</strong>合并后的伪码看起来是这样子的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1while(退出标志)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    //IO复用技术检测socket可读事件、出错事件  </span><br><span class=\"line\"> 4    //（如果有数据要发送，则也检测可写事件）  </span><br><span class=\"line\"> 5</span><br><span class=\"line\"> 6    //如果有可读事件，对于侦听socket则接收新连接；  </span><br><span class=\"line\"> 7    //对于普通socket则收取该socket上的数据，</span><br><span class=\"line\"> 8    //收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span><br><span class=\"line\"> 9</span><br><span class=\"line\">10    //如果有数据要发送，有可写事件，则发送数据  </span><br><span class=\"line\">11</span><br><span class=\"line\">12    //如果有出错事件，关闭该连接  </span><br><span class=\"line\">13</span><br><span class=\"line\">14    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span><br><span class=\"line\">15&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>&#96;你没看错，其实就是简单的合并，合并之后和不仅可以达到原来合并前的效果，而且在没有网络IO事件的时候，可以及时处理我们想处理的一些业务逻辑，并且减少了不必要的线程上下文切换时间。</p>\n<p>我们再更进一步，甚至我们可以在这个while循环增加其它的一些任务的处理，比如程序的逻辑任务队列、定时器事件等等，伪码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1while(退出标志)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    //定时器事件处理  </span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5    //IO复用技术检测socket可读事件、出错事件  </span><br><span class=\"line\"> 6    //（如果有数据要发送，则也检测可写事件）  </span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8    //如果有可读事件，对于侦听socket则接收新连接；  </span><br><span class=\"line\"> 9    //对于普通socket则收取该socket上的数据，</span><br><span class=\"line\">10    //收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span><br><span class=\"line\">11</span><br><span class=\"line\">12    //如果有数据要发送，有可写事件，则发送数据  </span><br><span class=\"line\">13</span><br><span class=\"line\">14    //如果有出错事件，关闭该连接  </span><br><span class=\"line\">15</span><br><span class=\"line\">16    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span><br><span class=\"line\">17</span><br><span class=\"line\">18    //程序自定义任务1  </span><br><span class=\"line\">19</span><br><span class=\"line\">20    //程序自定义任务2  </span><br><span class=\"line\">21&#125; </span><br></pre></td></tr></table></figure>\n\n<p>注意：之所以将定时器事件的处理放在网络IO事件的检测之前，是因为避免定时器事件过期时间太长。假如放在后面的话，可能前面的处理耗费了一点时间，等到处理定时器事件时，时间间隔已经过去了不少时间。虽然这样处理，也没法保证定时器事件百分百精确，但是能尽量保证。</p>\n<h2 id=\"（八）高性能服务器架构设计总结2——以flamigo服务器代码为例\"><a href=\"#（八）高性能服务器架构设计总结2——以flamigo服务器代码为例\" class=\"headerlink\" title=\"（八）高性能服务器架构设计总结2——以flamigo服务器代码为例\"></a>（八）高性能服务器架构设计总结2——以flamigo服务器代码为例</h2><p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<p>说了这么多，我们来以flamingo的服务器程序的网络框架设计为例来验证上述介绍的理论。flamingo的网络框架是基于陈硕的muduo库，改成C++11的版本，并修改了一些bug。<strong>在此感谢原作者陈硕</strong>。flamingo的源码可以在这里下载：<a href=\"https://github.com/baloonwj/flamingo%EF%BC%8C%E6%89%93%E4%B8%8D%E5%BC%80github%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%A7%BB%E6%AD%A5csdn%EF%BC%9Ahttp://download.csdn.net/detail/analogous_love/9805797%E3%80%82\">https://github.com/baloonwj/flamingo，打不开github的可以移步csdn：http://download.csdn.net/detail/analogous_love/9805797。</a></p>\n<p>上文介绍的核心线程函数的while循环位于eventloop.cpp中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void EventLoop::loop()  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    assert(!looping_);  </span><br><span class=\"line\"> 4    assertInLoopThread();  </span><br><span class=\"line\"> 5    looping_ = true;  </span><br><span class=\"line\"> 6    quit_ = false;</span><br><span class=\"line\"> 7  // FIXME: what if someone calls quit() before loop() ?  </span><br><span class=\"line\"> 8    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;  </span><br><span class=\"line\"> 9</span><br><span class=\"line\">10    while (!quit_)  </span><br><span class=\"line\">11    &#123;  </span><br><span class=\"line\">12        activeChannels_.clear();  </span><br><span class=\"line\">13        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs,</span><br><span class=\"line\">14                                        &amp;activeChannels_);  </span><br><span class=\"line\">15        ++iteration_;  </span><br><span class=\"line\">16        if (Logger::logLevel() &lt;= Logger::TRACE)  </span><br><span class=\"line\">17        &#123;  </span><br><span class=\"line\">18            printActiveChannels();  </span><br><span class=\"line\">19        &#125;  </span><br><span class=\"line\">20        // TODO sort channel by priority  </span><br><span class=\"line\">21        eventHandling_ = true;  </span><br><span class=\"line\">22        for (ChannelList::iterator it = activeChannels_.begin();  </span><br><span class=\"line\">23            it != activeChannels_.end(); ++it)  </span><br><span class=\"line\">24        &#123;  </span><br><span class=\"line\">25            currentActiveChannel_ = *it;  </span><br><span class=\"line\">26            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);  </span><br><span class=\"line\">27        &#125;  </span><br><span class=\"line\">28        currentActiveChannel_ = NULL;  </span><br><span class=\"line\">29        eventHandling_ = false;  </span><br><span class=\"line\">30        doPendingFunctors();  </span><br><span class=\"line\">31</span><br><span class=\"line\">32        if (frameFunctor_)  </span><br><span class=\"line\">33        &#123;  </span><br><span class=\"line\">34            frameFunctor_();  </span><br><span class=\"line\">35        &#125;         </span><br><span class=\"line\">36    &#125;  </span><br><span class=\"line\">37</span><br><span class=\"line\">38    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;  </span><br><span class=\"line\">39    looping_ = false;  </span><br><span class=\"line\">40&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>poller_-&gt;poll</strong>利用epoll分离网络事件，然后接着处理分离出来的网络事件，每一个客户端socket对应一个连接，即一个TcpConnection和Channel通道对象。**currentActiveChannel_-&gt;handleEvent(pollReturnTime_)**根据是可读、可写、出错事件来调用对应的处理函数，这些函数都是回调函数，程序初始化阶段设置进来的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void Channel::handleEvent(Timestamp receiveTime)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    std::shared_ptr&lt;void&gt; guard;  </span><br><span class=\"line\"> 4    if (tied_)  </span><br><span class=\"line\"> 5    &#123;  </span><br><span class=\"line\"> 6        guard = tie_.lock();  </span><br><span class=\"line\"> 7        if (guard)  </span><br><span class=\"line\"> 8        &#123;  </span><br><span class=\"line\"> 9            handleEventWithGuard(receiveTime);  </span><br><span class=\"line\">10        &#125;  </span><br><span class=\"line\">11    &#125;  </span><br><span class=\"line\">12    else  </span><br><span class=\"line\">13    &#123;  </span><br><span class=\"line\">14        handleEventWithGuard(receiveTime);  </span><br><span class=\"line\">15    &#125;  </span><br><span class=\"line\">16&#125;  </span><br><span class=\"line\">17</span><br><span class=\"line\">18void Channel::handleEventWithGuard(Timestamp receiveTime)  </span><br><span class=\"line\">19&#123;  </span><br><span class=\"line\">20    eventHandling_ = true;  </span><br><span class=\"line\">21    LOG_TRACE &lt;&lt; reventsToString();  </span><br><span class=\"line\">22    if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))  </span><br><span class=\"line\">23    &#123;  </span><br><span class=\"line\">24        if (logHup_)  </span><br><span class=\"line\">25        &#123;  </span><br><span class=\"line\">26            LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLHUP&quot;;  </span><br><span class=\"line\">27        &#125;  </span><br><span class=\"line\">28        if (closeCallback_) closeCallback_();  </span><br><span class=\"line\">29    &#125;  </span><br><span class=\"line\">30</span><br><span class=\"line\">31    if (revents_ &amp; POLLNVAL)  </span><br><span class=\"line\">32    &#123;  </span><br><span class=\"line\">33        LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLNVAL&quot;;  </span><br><span class=\"line\">34    &#125;  </span><br><span class=\"line\">35</span><br><span class=\"line\">36    if (revents_ &amp; (POLLERR | POLLNVAL))  </span><br><span class=\"line\">37    &#123;  </span><br><span class=\"line\">38        if (errorCallback_) errorCallback_();  </span><br><span class=\"line\">39    &#125;  </span><br><span class=\"line\">40    if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))  </span><br><span class=\"line\">41    &#123;  </span><br><span class=\"line\">42        //当是侦听socket时，readCallback_指向Acceptor::handleRead  </span><br><span class=\"line\">43        //当是客户端socket时，调用TcpConnection::handleRead   </span><br><span class=\"line\">44        if (readCallback_) readCallback_(receiveTime);  </span><br><span class=\"line\">45    &#125;  </span><br><span class=\"line\">46    if (revents_ &amp; POLLOUT)  </span><br><span class=\"line\">47    &#123;  </span><br><span class=\"line\">48        //如果是连接状态服的socket，</span><br><span class=\"line\">49        //则writeCallback_指向Connector::handleWrite()  </span><br><span class=\"line\">50        if (writeCallback_) writeCallback_();  </span><br><span class=\"line\">51    &#125;  </span><br><span class=\"line\">52    eventHandling_ = false;  </span><br><span class=\"line\">53&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>当然，这里<strong>利用了Channel对象的“多态性”</strong></p>\n<ul>\n<li>如果是普通socket，可读事件就会调用预先设置的回调函数；</li>\n<li>但是如果是侦听socket，则调用Aceptor对象的handleRead()来接收新连接：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void Acceptor::handleRead()  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\"> 4    InetAddress peerAddr;  </span><br><span class=\"line\"> 5    //FIXME loop until no more  </span><br><span class=\"line\"> 6    int connfd = acceptSocket_.accept(&amp;peerAddr);  </span><br><span class=\"line\"> 7    if (connfd &gt;= 0)  </span><br><span class=\"line\"> 8    &#123;  </span><br><span class=\"line\"> 9        // string hostport = peerAddr.toIpPort();  </span><br><span class=\"line\">10        // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;  </span><br><span class=\"line\">11        //newConnectionCallback_实际指向:</span><br><span class=\"line\">12        //TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)  </span><br><span class=\"line\">13        if (newConnectionCallback_)  </span><br><span class=\"line\">14        &#123;  </span><br><span class=\"line\">15            newConnectionCallback_(connfd, peerAddr);  </span><br><span class=\"line\">16        &#125;  </span><br><span class=\"line\">17        else  </span><br><span class=\"line\">18        &#123;  </span><br><span class=\"line\">19            sockets::close(connfd);  </span><br><span class=\"line\">20        &#125;  </span><br><span class=\"line\">21    &#125;  </span><br><span class=\"line\">22    else  </span><br><span class=\"line\">23    &#123;  </span><br><span class=\"line\">24        LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;  </span><br><span class=\"line\">25        // Read the section named &quot;The special problem of  </span><br><span class=\"line\">26        // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.  </span><br><span class=\"line\">27        // By Marc Lehmann, author of livev.  </span><br><span class=\"line\">28        if (errno == EMFILE)  </span><br><span class=\"line\">29        &#123;  </span><br><span class=\"line\">30            ::close(idleFd_);  </span><br><span class=\"line\">31            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);  </span><br><span class=\"line\">32            ::close(idleFd_);  </span><br><span class=\"line\">33            idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);  </span><br><span class=\"line\">34        &#125;  </span><br><span class=\"line\">35    &#125;  </span><br><span class=\"line\">36&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主循环里面的业务逻辑处理对应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1doPendingFunctors();  </span><br><span class=\"line\"> 2</span><br><span class=\"line\"> 3if (frameFunctor_)  </span><br><span class=\"line\"> 4&#123;  </span><br><span class=\"line\"> 5   frameFunctor_();  </span><br><span class=\"line\"> 6&#125;         </span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8</span><br><span class=\"line\"> 9void EventLoop::doPendingFunctors()  </span><br><span class=\"line\">10&#123;  </span><br><span class=\"line\">11    std::vector&lt;Functor&gt; functors;  </span><br><span class=\"line\">12    callingPendingFunctors_ = true;  </span><br><span class=\"line\">13</span><br><span class=\"line\">14    &#123;  </span><br><span class=\"line\">15        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  </span><br><span class=\"line\">16        functors.swap(pendingFunctors_);  </span><br><span class=\"line\">17    &#125;  </span><br><span class=\"line\">18</span><br><span class=\"line\">19    for (size_t i = 0; i &lt; functors.size(); ++i)  </span><br><span class=\"line\">20    &#123;  </span><br><span class=\"line\">21        functors[i]();  </span><br><span class=\"line\">22    &#125;  </span><br><span class=\"line\">23    callingPendingFunctors_ = false;  </span><br><span class=\"line\">24&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这里增加业务逻辑是增加执行任务的函数指针的，增加的任务保存在成员变量pendingFunctors_中，这个变量是一个函数指针数组（vector对象），执行的时候，调用每个函数就可以了。上面的代码<strong>先利用一个栈变量将成员变量pendingFunctors_里面的函数指针换过来，接下来对这个栈变量进行操作就可以了，这样减少了锁的粒度。</strong></p>\n<p>因为成员变量pendingFunctors_在增加任务的时候，也会被用到，设计到多个线程操作，所以要<strong>加锁</strong>，增加任务的地方是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void EventLoop::queueInLoop(const Functor&amp; cb)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    &#123;  </span><br><span class=\"line\"> 4        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  </span><br><span class=\"line\"> 5        pendingFunctors_.push_back(cb);  </span><br><span class=\"line\"> 6    &#125;  </span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8    if (!isInLoopThread() || callingPendingFunctors_)  </span><br><span class=\"line\"> 9    &#123;  </span><br><span class=\"line\">10        wakeup();  </span><br><span class=\"line\">11    &#125;  </span><br><span class=\"line\">12&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而**frameFunctor_**就更简单了，就是通过设置一个函数指针就可以了。当然这里有个技巧性的东西，即增加任务的时候，为了能够立即执行，使用唤醒机制，通过往一个fd里面写入简单的几个字节，来唤醒epoll，使其立刻返回，因为此时没有其它的socke有事件，这样接下来就执行刚才添加的任务了。</p>\n<p>我们看一下数据收取的逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void TcpConnection::handleRead(Timestamp receiveTime)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\"> 4    int savedErrno = 0;  </span><br><span class=\"line\"> 5    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);  </span><br><span class=\"line\"> 6    if (n &gt; 0)  </span><br><span class=\"line\"> 7    &#123;  </span><br><span class=\"line\"> 8        /*messageCallback_指向</span><br><span class=\"line\"> 9       CTcpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn,</span><br><span class=\"line\">10                           Buffer* pBuffer, </span><br><span class=\"line\">11                           Timestamp receiveTime)*/  </span><br><span class=\"line\">12        messageCallback_(shared_from_this(),</span><br><span class=\"line\">13                         &amp;inputBuffer_, receiveTime);  </span><br><span class=\"line\">14    &#125;  </span><br><span class=\"line\">15    else if (n == 0)  </span><br><span class=\"line\">16    &#123;  </span><br><span class=\"line\">17        handleClose();  </span><br><span class=\"line\">18    &#125;  </span><br><span class=\"line\">19    else  </span><br><span class=\"line\">20    &#123;  </span><br><span class=\"line\">21        errno = savedErrno;  </span><br><span class=\"line\">22        LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;  </span><br><span class=\"line\">23        handleError();  </span><br><span class=\"line\">24    &#125;  </span><br><span class=\"line\">25&#125; </span><br></pre></td></tr></table></figure>\n\n<p>将收到的数据放到接收缓冲区里面，将来我们来解包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void ClientSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    while (true)  </span><br><span class=\"line\"> 4    &#123;  </span><br><span class=\"line\"> 5        //不够一个包头大小  </span><br><span class=\"line\"> 6        if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))  </span><br><span class=\"line\"> 7        &#123;  </span><br><span class=\"line\"> 8            LOG_INFO &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);  </span><br><span class=\"line\"> 9            return;  </span><br><span class=\"line\">10        &#125;  </span><br><span class=\"line\">11</span><br><span class=\"line\">12        //不够一个整包大小  </span><br><span class=\"line\">13        msg header;  </span><br><span class=\"line\">14        memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));  </span><br><span class=\"line\">15        if (pBuffer-&gt;readableBytes() &lt; (size_t)header.packagesize + sizeof(msg))  </span><br><span class=\"line\">16            return;  </span><br><span class=\"line\">17</span><br><span class=\"line\">18        pBuffer-&gt;retrieve(sizeof(msg));  </span><br><span class=\"line\">19        std::string inbuf;  </span><br><span class=\"line\">20        inbuf.append(pBuffer-&gt;peek(), header.packagesize);  </span><br><span class=\"line\">21        pBuffer-&gt;retrieve(header.packagesize);  </span><br><span class=\"line\">22        if (!Process(conn, inbuf.c_str(), inbuf.length()))  </span><br><span class=\"line\">23        &#123;  </span><br><span class=\"line\">24            LOG_WARN &lt;&lt; &quot;Process error, close TcpConnection&quot;;  </span><br><span class=\"line\">25            conn-&gt;forceClose();  </span><br><span class=\"line\">26        &#125;  </span><br><span class=\"line\">27    &#125;// end while-loop  </span><br><span class=\"line\">28</span><br><span class=\"line\">29&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>先<strong>判断接收缓冲区里面的数据是否够一个包头大小</strong>，如果够再判断够不够包头指定的包体大小，如果还是够的话，接着在Process函数里面处理该包。</p>\n<p>再看看发送数据的逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void TcpConnection::sendInLoop(const void* data, </span><br><span class=\"line\"> 2                               size_t len)  </span><br><span class=\"line\"> 3&#123;  </span><br><span class=\"line\"> 4    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\"> 5    ssize_t nwrote = 0;  </span><br><span class=\"line\"> 6    size_t remaining = len;  </span><br><span class=\"line\"> 7    bool faultError = false;  </span><br><span class=\"line\"> 8    if (state_ == kDisconnected)  </span><br><span class=\"line\"> 9    &#123;  </span><br><span class=\"line\">10        LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;  </span><br><span class=\"line\">11        return;  </span><br><span class=\"line\">12    &#125;  </span><br><span class=\"line\">13    // if no thing in output queue, try writing directly  </span><br><span class=\"line\">14    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)  </span><br><span class=\"line\">15    &#123;  </span><br><span class=\"line\">16        nwrote = sockets::write(channel_-&gt;fd(), data, len);  </span><br><span class=\"line\">17        if (nwrote &gt;= 0)  </span><br><span class=\"line\">18        &#123;  </span><br><span class=\"line\">19            remaining = len - nwrote;  </span><br><span class=\"line\">20            if (remaining == 0 &amp;&amp; writeCompleteCallback_)  </span><br><span class=\"line\">21            &#123;  </span><br><span class=\"line\">22                loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, </span><br><span class=\"line\">23                                             shared_from_this()));  </span><br><span class=\"line\">24            &#125;  </span><br><span class=\"line\">25        &#125;  </span><br><span class=\"line\">26        else // nwrote &lt; 0  </span><br><span class=\"line\">27        &#123;  </span><br><span class=\"line\">28            nwrote = 0;  </span><br><span class=\"line\">29            if (errno != EWOULDBLOCK)  </span><br><span class=\"line\">30            &#123;  </span><br><span class=\"line\">31                LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;</span><br><span class=\"line\">32                // FIXME: any others?   </span><br><span class=\"line\">33                if (errno == EPIPE || errno == ECONNRESET)  </span><br><span class=\"line\">34                &#123;  </span><br><span class=\"line\">35                    faultError = true;  </span><br><span class=\"line\">36                &#125;  </span><br><span class=\"line\">37            &#125;  </span><br><span class=\"line\">38        &#125;  </span><br><span class=\"line\">39    &#125;  </span><br><span class=\"line\">40</span><br><span class=\"line\">41    assert(remaining &lt;= len);  </span><br><span class=\"line\">42    if (!faultError &amp;&amp; remaining &gt; 0)  </span><br><span class=\"line\">43    &#123;  </span><br><span class=\"line\">44        size_t oldLen = outputBuffer_.readableBytes();  </span><br><span class=\"line\">45        if (oldLen + remaining &gt;= highWaterMark_                          </span><br><span class=\"line\">46            &amp;&amp; oldLen &lt; highWaterMark_  </span><br><span class=\"line\">47            &amp;&amp; highWaterMarkCallback_)  </span><br><span class=\"line\">48        &#123;  </span><br><span class=\"line\">49            loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_,</span><br><span class=\"line\">50                                         shared_from_this(),</span><br><span class=\"line\">51                                         oldLen + remaining));  </span><br><span class=\"line\">52        &#125;  </span><br><span class=\"line\">53        outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote,</span><br><span class=\"line\">54                             remaining);  </span><br><span class=\"line\">55        if (!channel_-&gt;isWriting())  </span><br><span class=\"line\">56        &#123;  </span><br><span class=\"line\">57            channel_-&gt;enableWriting();  </span><br><span class=\"line\">58        &#125;  </span><br><span class=\"line\">59    &#125;  </span><br><span class=\"line\">60&#125; </span><br></pre></td></tr></table></figure>\n\n<p>如果剩余的数据remaining大于则调用**channel_-&gt;enableWriting();**开始监听可写事件，可写事件处理如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void TcpConnection::handleWrite()  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\"> 4    if (channel_-&gt;isWriting())  </span><br><span class=\"line\"> 5    &#123;  </span><br><span class=\"line\"> 6        ssize_t n = sockets::write(channel_-&gt;fd(),  </span><br><span class=\"line\"> 7            outputBuffer_.peek(),  </span><br><span class=\"line\"> 8            outputBuffer_.readableBytes());  </span><br><span class=\"line\"> 9        if (n &gt; 0)  </span><br><span class=\"line\">10        &#123;  </span><br><span class=\"line\">11            outputBuffer_.retrieve(n);  </span><br><span class=\"line\">12            if (outputBuffer_.readableBytes() == 0)  </span><br><span class=\"line\">13            &#123;  </span><br><span class=\"line\">14                channel_-&gt;disableWriting();  </span><br><span class=\"line\">15                if (writeCompleteCallback_)  </span><br><span class=\"line\">16                &#123;  </span><br><span class=\"line\">17                    loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, </span><br><span class=\"line\">18                                       shared_from_this()));  </span><br><span class=\"line\">19                &#125;   </span><br><span class=\"line\">20                if (state_ == kDisconnecting)  </span><br><span class=\"line\">21                &#123;  </span><br><span class=\"line\">22                    shutdownInLoop();  </span><br><span class=\"line\">23                &#125;  </span><br><span class=\"line\">24            &#125;  </span><br><span class=\"line\">25        &#125;  </span><br><span class=\"line\">26        else  </span><br><span class=\"line\">27        &#123;  </span><br><span class=\"line\">28            LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;  </span><br><span class=\"line\">29            // if (state_ == kDisconnecting)  </span><br><span class=\"line\">30            // &#123;  </span><br><span class=\"line\">31            //   shutdownInLoop();  </span><br><span class=\"line\">32            // &#125;  </span><br><span class=\"line\">33        &#125;  </span><br><span class=\"line\">34    &#125;  </span><br><span class=\"line\">35    else  </span><br><span class=\"line\">36    &#123;  </span><br><span class=\"line\">37        LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()  </span><br><span class=\"line\">38            &lt;&lt; &quot; is down, no more writing&quot;;  </span><br><span class=\"line\">39    &#125;  </span><br><span class=\"line\">40&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果发送完数据以后调用channel_-&gt;disableWriting();移除监听可写事件。</p>\n<p>很多读者可能一直想问，文中不是说解包数据并处理逻辑是业务代码而非网络通信的代码，你这里貌似都混在一起了，其实没有，这里实际的业务代码处理都是框架曾提供的回调函数里面处理的，具体怎么处理，由框架使用者——业务层自己定义。</p>\n<p>总结起来，<strong>实际上就是一个线程函数里一个loop那么点事情</strong>，不信你再看我曾经工作上的一个交易系统项目代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void CEventDispatcher::Run()  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    m_bShouldRun = true;  </span><br><span class=\"line\"> 4    while(m_bShouldRun)  </span><br><span class=\"line\"> 5    &#123;  </span><br><span class=\"line\"> 6        DispatchIOs();        </span><br><span class=\"line\"> 7        SyncTime();  </span><br><span class=\"line\"> 8        CheckTimer();  </span><br><span class=\"line\"> 9        DispatchEvents();  </span><br><span class=\"line\">10    &#125;  </span><br><span class=\"line\">11&#125;  </span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14void CEpollReactor::DispatchIOs()  </span><br><span class=\"line\">15&#123;  </span><br><span class=\"line\">16    DWORD dwSelectTimeOut = SR_DEFAULT_EPOLL_TIMEOUT;  </span><br><span class=\"line\">17    if (HandleOtherTask())  </span><br><span class=\"line\">18    &#123;  </span><br><span class=\"line\">19        dwSelectTimeOut = 0;  </span><br><span class=\"line\">20    &#125;  </span><br><span class=\"line\">21</span><br><span class=\"line\">22    struct epoll_event ev;  </span><br><span class=\"line\">23    CEventHandlerIdMap::iterator itor = m_mapEventHandlerId.begin();  </span><br><span class=\"line\">24    for(; itor!=m_mapEventHandlerId.end(); itor++)  </span><br><span class=\"line\">25    &#123;  </span><br><span class=\"line\">26        CEventHandler *pEventHandler = (CEventHandler *)(*itor).first;  </span><br><span class=\"line\">27        if(pEventHandler == NULL)&#123;  </span><br><span class=\"line\">28            continue;  </span><br><span class=\"line\">29        &#125;  </span><br><span class=\"line\">30        ev.data.ptr = pEventHandler;  </span><br><span class=\"line\">31        ev.events = 0;  </span><br><span class=\"line\">32        int nReadID, nWriteID;  </span><br><span class=\"line\">33        pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);    </span><br><span class=\"line\">34        if (nReadID &gt; 0)  </span><br><span class=\"line\">35        &#123;  </span><br><span class=\"line\">36            ev.events |= EPOLLIN;  </span><br><span class=\"line\">37        &#125;  </span><br><span class=\"line\">38        if (nWriteID &gt; 0)  </span><br><span class=\"line\">39        &#123;  </span><br><span class=\"line\">40            ev.events |= EPOLLOUT;  </span><br><span class=\"line\">41        &#125;  </span><br><span class=\"line\">42</span><br><span class=\"line\">43        epoll_ctl(m_fdEpoll, EPOLL_CTL_MOD, (*itor).second, &amp;ev);  </span><br><span class=\"line\">44    &#125;  </span><br><span class=\"line\">45</span><br><span class=\"line\">46    struct epoll_event events[EPOLL_MAX_EVENTS];  </span><br><span class=\"line\">47</span><br><span class=\"line\">48    int nfds = epoll_wait(m_fdEpoll, events, </span><br><span class=\"line\">49                          EPOLL_MAX_EVENTS, </span><br><span class=\"line\">50                          dwSelectTimeOut/1000);  </span><br><span class=\"line\">51</span><br><span class=\"line\">52    for (int i=0; i&lt;nfds; i++)  </span><br><span class=\"line\">53    &#123;  </span><br><span class=\"line\">54        struct epoll_event &amp;evref = events[i];  </span><br><span class=\"line\">55        CEventHandler *pEventHandler = (CEventHandler *)evref.data.ptr;  </span><br><span class=\"line\">56        if ((evref.events|EPOLLIN)!=0 &amp;&amp; </span><br><span class=\"line\">57             m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  </span><br><span class=\"line\">58        &#123;  </span><br><span class=\"line\">59            pEventHandler-&gt;HandleInput();  </span><br><span class=\"line\">60        &#125;  </span><br><span class=\"line\">61        if ((evref.events|EPOLLOUT)!=0 &amp;&amp;</span><br><span class=\"line\">62             m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  </span><br><span class=\"line\">63        &#123;  </span><br><span class=\"line\">64            pEventHandler-&gt;HandleOutput();  </span><br><span class=\"line\">65        &#125;  </span><br><span class=\"line\">66    &#125;     </span><br><span class=\"line\">67&#125;  </span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70void CEventDispatcher::DispatchEvents()  </span><br><span class=\"line\">71&#123;  </span><br><span class=\"line\">72    CEvent event;  </span><br><span class=\"line\">73    CSyncEvent *pSyncEvent;  </span><br><span class=\"line\">74    while(m_queueEvent.PeekEvent(event))  </span><br><span class=\"line\">75    &#123;  </span><br><span class=\"line\">76        int nRetval;  </span><br><span class=\"line\">77</span><br><span class=\"line\">78        if(event.pEventHandler != NULL)  </span><br><span class=\"line\">79        &#123;  </span><br><span class=\"line\">80            nRetval = event.pEventHandler-&gt;HandleEvent(event.nEventID,</span><br><span class=\"line\">81                                                       event.dwParam,</span><br><span class=\"line\">82                                                       event.pParam);  </span><br><span class=\"line\">83        &#125;  </span><br><span class=\"line\">84        else  </span><br><span class=\"line\">85        &#123;  </span><br><span class=\"line\">86            nRetval = HandleEvent(event.nEventID,</span><br><span class=\"line\">87                                  event.dwParam, </span><br><span class=\"line\">88                                  event.pParam);  </span><br><span class=\"line\">89        &#125;  </span><br><span class=\"line\">90</span><br><span class=\"line\">91        if(event.pAdd != NULL)      //同步消息  </span><br><span class=\"line\">92        &#123;  </span><br><span class=\"line\">93            pSyncEvent=(CSyncEvent *)event.pAdd;  </span><br><span class=\"line\">94            pSyncEvent-&gt;nRetval = nRetval;  </span><br><span class=\"line\">95            pSyncEvent-&gt;sem.UnLock();  </span><br><span class=\"line\">96        &#125;  </span><br><span class=\"line\">97    &#125;  </span><br><span class=\"line\">98&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>再看看蘑菇街开源的TeamTalk的源码（代码下载地址：<a href=\"https://github.com/baloonwj/TeamTalk%EF%BC%89%EF%BC%9A\">https://github.com/baloonwj/TeamTalk）：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void CEventDispatch::StartDispatch(uint32_t wait_timeout)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    fd_set read_set, write_set, excep_set;  </span><br><span class=\"line\"> 4    timeval timeout;  </span><br><span class=\"line\"> 5    timeout.tv_sec = 0;</span><br><span class=\"line\"> 6    // 10 millisecond    </span><br><span class=\"line\"> 7    timeout.tv_usec = wait_timeout * 1000;</span><br><span class=\"line\"> 8</span><br><span class=\"line\"> 9    if(running)  </span><br><span class=\"line\">10        return;  </span><br><span class=\"line\">11    running = true;  </span><br><span class=\"line\">12</span><br><span class=\"line\">13    while (running)  </span><br><span class=\"line\">14   &#123;  </span><br><span class=\"line\">15        _CheckTimer();  </span><br><span class=\"line\">16        _CheckLoop();  </span><br><span class=\"line\">17</span><br><span class=\"line\">18        if (!m_read_set.fd_count &amp;&amp; </span><br><span class=\"line\">19            !m_write_set.fd_count &amp;&amp;</span><br><span class=\"line\">20            !m_excep_set.fd_count)  </span><br><span class=\"line\">21        &#123;  </span><br><span class=\"line\">22            Sleep(MIN_TIMER_DURATION);  </span><br><span class=\"line\">23            continue;  </span><br><span class=\"line\">24        &#125;  </span><br><span class=\"line\">25</span><br><span class=\"line\">26        m_lock.lock();  </span><br><span class=\"line\">27        memcpy(&amp;read_set, &amp;m_read_set, </span><br><span class=\"line\">28               sizeof(fd_set));  </span><br><span class=\"line\">29        memcpy(&amp;write_set, &amp;m_write_set, </span><br><span class=\"line\">30               sizeof(fd_set));  </span><br><span class=\"line\">31        memcpy(&amp;excep_set, &amp;m_excep_set, </span><br><span class=\"line\">32               sizeof(fd_set));  </span><br><span class=\"line\">33        m_lock.unlock();  </span><br><span class=\"line\">34</span><br><span class=\"line\">35        int nfds = select(0, &amp;read_set, </span><br><span class=\"line\">36                          &amp;write_set,</span><br><span class=\"line\">37                          &amp;excep_set,</span><br><span class=\"line\">38                          &amp;timeout);  </span><br><span class=\"line\">39</span><br><span class=\"line\">40        if (nfds == SOCKET_ERROR)  </span><br><span class=\"line\">41        &#123;  </span><br><span class=\"line\">42            log(&quot;select failed, error code: %d&quot;, GetLastError());  </span><br><span class=\"line\">43            Sleep(MIN_TIMER_DURATION);  </span><br><span class=\"line\">44            continue;           // select again  </span><br><span class=\"line\">45        &#125;  </span><br><span class=\"line\">46</span><br><span class=\"line\">47        if (nfds == 0)  </span><br><span class=\"line\">48        &#123;  </span><br><span class=\"line\">49            continue;  </span><br><span class=\"line\">50        &#125;  </span><br><span class=\"line\">51</span><br><span class=\"line\">52        for (u_int i = 0; i &lt; read_set.fd_count; i++)  </span><br><span class=\"line\">53        &#123;  </span><br><span class=\"line\">54            //log(&quot;select return read count=%d\\n&quot;, read_set.fd_count);  </span><br><span class=\"line\">55            SOCKET fd = read_set.fd_array[i];  </span><br><span class=\"line\">56            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span><br><span class=\"line\">57            if (pSocket)  </span><br><span class=\"line\">58            &#123;  </span><br><span class=\"line\">59                pSocket-&gt;OnRead();  </span><br><span class=\"line\">60                pSocket-&gt;ReleaseRef();  </span><br><span class=\"line\">61            &#125;  </span><br><span class=\"line\">62        &#125;  </span><br><span class=\"line\">63</span><br><span class=\"line\">64        for (u_int i = 0; i &lt; write_set.fd_count; i++)  </span><br><span class=\"line\">65        &#123;  </span><br><span class=\"line\">66            //log(&quot;select return write count=%d\\n&quot;, write_set.fd_count);  </span><br><span class=\"line\">67            SOCKET fd = write_set.fd_array[i];  </span><br><span class=\"line\">68            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span><br><span class=\"line\">69            if (pSocket)  </span><br><span class=\"line\">70            &#123;  </span><br><span class=\"line\">71                pSocket-&gt;OnWrite();  </span><br><span class=\"line\">72                pSocket-&gt;ReleaseRef();  </span><br><span class=\"line\">73            &#125;  </span><br><span class=\"line\">74        &#125;  </span><br><span class=\"line\">75</span><br><span class=\"line\">76        for (u_int i = 0; i &lt; excep_set.fd_count; i++)  </span><br><span class=\"line\">77        &#123;  </span><br><span class=\"line\">78            //log(&quot;select return exception count=%d\\n&quot;, excep_set.fd_count);  </span><br><span class=\"line\">79            SOCKET fd = excep_set.fd_array[i];  </span><br><span class=\"line\">80            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span><br><span class=\"line\">81            if (pSocket)  </span><br><span class=\"line\">82            &#123;  </span><br><span class=\"line\">83                pSocket-&gt;OnClose();  </span><br><span class=\"line\">84                pSocket-&gt;ReleaseRef();  </span><br><span class=\"line\">85            &#125;  </span><br><span class=\"line\">86        &#125;  </span><br><span class=\"line\">87</span><br><span class=\"line\">88    &#125;  </span><br><span class=\"line\">89&#125;</span><br></pre></td></tr></table></figure>\n\n<p>****由于公众号文章字数有限，您可以接着阅读下******一篇:**<strong>《服务器端编程心得（八）——高性能服务器架构设计总结3——以flamigo服务器代码为例》。</strong></p>\n<p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<h2 id=\"（八）高性能服务器架构设计总结3——以flamigo服务器代码为例\"><a href=\"#（八）高性能服务器架构设计总结3——以flamigo服务器代码为例\" class=\"headerlink\" title=\"（八）高性能服务器架构设计总结3——以flamigo服务器代码为例\"></a>（八）高性能服务器架构设计总结3——以flamigo服务器代码为例</h2><p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<p>再看filezilla，一款ftp工具的服务器端，它采用的是Windows的<strong>WSAAsyncSelect模型</strong>（代码下载地址：<a href=\"https://github.com/baloonwj/filezilla%EF%BC%89%EF%BC%9A\">https://github.com/baloonwj/filezilla）：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1//Processes event notifications sent by the sockets or the layers  </span><br><span class=\"line\">  2    static LRESULT CALLBACK WindowProc(HWND hWnd,</span><br><span class=\"line\">  3                                       UINT message,</span><br><span class=\"line\">  4                                       WPARAM wParam,</span><br><span class=\"line\">  5                                       LPARAM lParam)  </span><br><span class=\"line\">  6    &#123;  </span><br><span class=\"line\">  7        if (message&gt;=WM_SOCKETEX_NOTIFY)  </span><br><span class=\"line\">  8        &#123;  </span><br><span class=\"line\">  9            //Verify parameters  </span><br><span class=\"line\"> 10            ASSERT(hWnd);  </span><br><span class=\"line\"> 11            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)</span><br><span class=\"line\"> 12                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  </span><br><span class=\"line\"> 13            ASSERT(pWnd);  </span><br><span class=\"line\"> 14            if (!pWnd)  </span><br><span class=\"line\"> 15                return 0;  </span><br><span class=\"line\"> 16            //Index is within socket storage  </span><br><span class=\"line\"> 17            if (message &lt; static_cast&lt;UINT&gt;(WM_SOCKETEX_NOTIFY+pWnd-&gt;m_nWindowDataSize)) </span><br><span class=\"line\"> 18            &#123;  </span><br><span class=\"line\"> 19                //Lookup socket and verify if it&#x27;s valid  </span><br><span class=\"line\"> 20                CAsyncSocketEx *pSocket=pWnd-&gt;m_pAsyncSocketExWindowData[message - WM_SOCKETEX_NOTIFY].m_pSocket;  </span><br><span class=\"line\"> 21                SOCKET hSocket = wParam;  </span><br><span class=\"line\"> 22                if (!pSocket)  </span><br><span class=\"line\"> 23                    return 0;  </span><br><span class=\"line\"> 24                if (hSocket == INVALID_SOCKET)  </span><br><span class=\"line\"> 25                    return 0;  </span><br><span class=\"line\"> 26                if (pSocket-&gt;m_SocketData.hSocket != hSocket)  </span><br><span class=\"line\"> 27                    return 0;  </span><br><span class=\"line\"> 28</span><br><span class=\"line\"> 29                int nEvent = lParam &amp; 0xFFFF;  </span><br><span class=\"line\"> 30                int nErrorCode = lParam &gt;&gt; 16;  </span><br><span class=\"line\"> 31</span><br><span class=\"line\"> 32                //Dispatch notification  </span><br><span class=\"line\"> 33                if (!pSocket-&gt;m_pFirstLayer) &#123;  </span><br><span class=\"line\"> 34                    //Dispatch to CAsyncSocketEx instance  </span><br><span class=\"line\"> 35                    switch (nEvent)  </span><br><span class=\"line\"> 36                    &#123;  </span><br><span class=\"line\"> 37                    case FD_READ:  </span><br><span class=\"line\"> 38#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 39                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\"> 40                        &#123;  </span><br><span class=\"line\"> 41                            pSocket-&gt;m_nPendingEvents |= FD_READ;  </span><br><span class=\"line\"> 42                            break;  </span><br><span class=\"line\"> 43                        &#125;  </span><br><span class=\"line\"> 44                        else if (pSocket-&gt;GetState() == attached)  </span><br><span class=\"line\"> 45                            pSocket-&gt;SetState(connected);  </span><br><span class=\"line\"> 46                        if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\"> 47                            break;  </span><br><span class=\"line\"> 48</span><br><span class=\"line\"> 49                        // Ignore further FD_READ events after FD_CLOSE has been received  </span><br><span class=\"line\"> 50                        if (pSocket-&gt;m_SocketData.onCloseCalled)  </span><br><span class=\"line\"> 51                            break;  </span><br><span class=\"line\"> 52#endif //NOSOCKETSTATES  </span><br><span class=\"line\"> 53</span><br><span class=\"line\"> 54#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 55                        if (nErrorCode)  </span><br><span class=\"line\"> 56                            pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\"> 57#endif //NOSOCKETSTATES  </span><br><span class=\"line\"> 58                        if (pSocket-&gt;m_lEvent &amp; FD_READ) &#123;  </span><br><span class=\"line\"> 59                            pSocket-&gt;OnReceive(nErrorCode);  </span><br><span class=\"line\"> 60                        &#125;  </span><br><span class=\"line\"> 61                        break;  </span><br><span class=\"line\"> 62                    case FD_FORCEREAD: //Forceread does not check if there&#x27;s data waiting  </span><br><span class=\"line\"> 63#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 64                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\"> 65                        &#123;  </span><br><span class=\"line\"> 66                            pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;  </span><br><span class=\"line\"> 67                            break;  </span><br><span class=\"line\"> 68                        &#125;  </span><br><span class=\"line\"> 69                        else if (pSocket-&gt;GetState() == attached)  </span><br><span class=\"line\"> 70                            pSocket-&gt;SetState(connected);  </span><br><span class=\"line\"> 71                        if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\"> 72                            break;  </span><br><span class=\"line\"> 73#endif //NOSOCKETSTATES  </span><br><span class=\"line\"> 74                        if (pSocket-&gt;m_lEvent &amp; FD_READ)  </span><br><span class=\"line\"> 75                        &#123;  </span><br><span class=\"line\"> 76#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 77                            if (nErrorCode)  </span><br><span class=\"line\"> 78                                pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\"> 79#endif //NOSOCKETSTATES  </span><br><span class=\"line\"> 80                            pSocket-&gt;OnReceive(nErrorCode);  </span><br><span class=\"line\"> 81                        &#125;  </span><br><span class=\"line\"> 82                        break;  </span><br><span class=\"line\"> 83                    case FD_WRITE:  </span><br><span class=\"line\"> 84#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 85                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\"> 86                        &#123;  </span><br><span class=\"line\"> 87                            pSocket-&gt;m_nPendingEvents |= FD_WRITE;  </span><br><span class=\"line\"> 88                            break;  </span><br><span class=\"line\"> 89                        &#125;  </span><br><span class=\"line\"> 90                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\"> 91                            pSocket-&gt;SetState(connected);  </span><br><span class=\"line\"> 92                        if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\"> 93                            break;  </span><br><span class=\"line\"> 94#endif //NOSOCKETSTATES  </span><br><span class=\"line\"> 95                        if (pSocket-&gt;m_lEvent &amp; FD_WRITE)  </span><br><span class=\"line\"> 96                        &#123;  </span><br><span class=\"line\"> 97#ifndef NOSOCKETSTATES  </span><br><span class=\"line\"> 98                            if (nErrorCode)  </span><br><span class=\"line\"> 99                                pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\">100#endif //NOSOCKETSTATES  </span><br><span class=\"line\">101                            pSocket-&gt;OnSend(nErrorCode);  </span><br><span class=\"line\">102                        &#125;  </span><br><span class=\"line\">103                        break;  </span><br><span class=\"line\">104                    case FD_CONNECT:  </span><br><span class=\"line\">105#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">106                        if (pSocket-&gt;GetState() == connecting)  </span><br><span class=\"line\">107                        &#123;  </span><br><span class=\"line\">108                            if (nErrorCode &amp;&amp; pSocket-&gt;m_SocketData.nextAddr)  </span><br><span class=\"line\">109                            &#123;  </span><br><span class=\"line\">110                                if (pSocket-&gt;TryNextProtocol())  </span><br><span class=\"line\">111                                    break;  </span><br><span class=\"line\">112                            &#125;  </span><br><span class=\"line\">113                            pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">114                        &#125;  </span><br><span class=\"line\">115                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">116                            pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">117#endif //NOSOCKETSTATES  </span><br><span class=\"line\">118                        if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)  </span><br><span class=\"line\">119                            pSocket-&gt;OnConnect(nErrorCode);  </span><br><span class=\"line\">120#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">121                        if (!nErrorCode)  </span><br><span class=\"line\">122                        &#123;  </span><br><span class=\"line\">123                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp;</span><br><span class=\"line\">124                                 pSocket-&gt;GetState() == connected)  </span><br><span class=\"line\">125                                pSocket-&gt;OnReceive(0);  </span><br><span class=\"line\">126                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp;</span><br><span class=\"line\">127                                 pSocket-&gt;GetState() == connected)  </span><br><span class=\"line\">128                                pSocket-&gt;OnReceive(0);  </span><br><span class=\"line\">129                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp;</span><br><span class=\"line\">130                                 pSocket-&gt;GetState() == connected)  </span><br><span class=\"line\">131                                pSocket-&gt;OnSend(0);  </span><br><span class=\"line\">132                        &#125;  </span><br><span class=\"line\">133                        pSocket-&gt;m_nPendingEvents = 0;  </span><br><span class=\"line\">134#endif  </span><br><span class=\"line\">135                        break;  </span><br><span class=\"line\">136                    case FD_ACCEPT:  </span><br><span class=\"line\">137#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">138                        if (pSocket-&gt;GetState() != listening &amp;&amp;</span><br><span class=\"line\">139                            pSocket-&gt;GetState() != attached)  </span><br><span class=\"line\">140                            break;  </span><br><span class=\"line\">141#endif //NOSOCKETSTATES  </span><br><span class=\"line\">142                        if (pSocket-&gt;m_lEvent &amp; FD_ACCEPT)  </span><br><span class=\"line\">143                            pSocket-&gt;OnAccept(nErrorCode);  </span><br><span class=\"line\">144                        break;  </span><br><span class=\"line\">145                    case FD_CLOSE:  </span><br><span class=\"line\">146#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">147                        if (pSocket-&gt;GetState() != connected &amp;&amp;</span><br><span class=\"line\">148                            pSocket-&gt;GetState() != attached)  </span><br><span class=\"line\">149                            break;  </span><br><span class=\"line\">150</span><br><span class=\"line\">151                        // If there are still bytes left to read,</span><br><span class=\"line\">152                        // call OnReceive instead of  </span><br><span class=\"line\">153                        // OnClose and trigger a new OnClose  </span><br><span class=\"line\">154                        DWORD nBytes = 0;  </span><br><span class=\"line\">155                        if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  </span><br><span class=\"line\">156                        &#123;  </span><br><span class=\"line\">157                            if (nBytes &gt; 0)  </span><br><span class=\"line\">158                            &#123;  </span><br><span class=\"line\">159                                // Just repeat message.  </span><br><span class=\"line\">160                                pSocket-&gt;ResendCloseNotify();  </span><br><span class=\"line\">161                                pSocket-&gt;m_SocketData.onCloseCalled = true;  </span><br><span class=\"line\">162                                pSocket-&gt;OnReceive(WSAESHUTDOWN);  </span><br><span class=\"line\">163                                break;  </span><br><span class=\"line\">164                            &#125;  </span><br><span class=\"line\">165                        &#125;  </span><br><span class=\"line\">166</span><br><span class=\"line\">167                        pSocket-&gt;SetState(nErrorCode ? aborted : closed);  </span><br><span class=\"line\">168#endif //NOSOCKETSTATES  </span><br><span class=\"line\">169                        pSocket-&gt;OnClose(nErrorCode);  </span><br><span class=\"line\">170                        break;  </span><br><span class=\"line\">171                    &#125;  </span><br><span class=\"line\">172                &#125;  </span><br><span class=\"line\">173                else //Dispatch notification to the lowest layer  </span><br><span class=\"line\">174                &#123;  </span><br><span class=\"line\">175                    if (nEvent == FD_READ)  </span><br><span class=\"line\">176                    &#123;  </span><br><span class=\"line\">177                        // Ignore further FD_READ events after FD_CLOSE has been received  </span><br><span class=\"line\">178                        if (pSocket-&gt;m_SocketData.onCloseCalled)  </span><br><span class=\"line\">179                            return 0;  </span><br><span class=\"line\">180</span><br><span class=\"line\">181                        DWORD nBytes;  </span><br><span class=\"line\">182                        if (!pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  </span><br><span class=\"line\">183                            nErrorCode = WSAGetLastError();  </span><br><span class=\"line\">184                        if (pSocket-&gt;m_pLastLayer)  </span><br><span class=\"line\">185                            pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  </span><br><span class=\"line\">186                    &#125;  </span><br><span class=\"line\">187                    else if (nEvent == FD_CLOSE)  </span><br><span class=\"line\">188                    &#123;  </span><br><span class=\"line\">189                        // If there are still bytes left to read,</span><br><span class=\"line\">190                        // call OnReceive instead of  </span><br><span class=\"line\">191                        // OnClose and trigger a new OnClose  </span><br><span class=\"line\">192                        DWORD nBytes = 0;  </span><br><span class=\"line\">193                        if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))  </span><br><span class=\"line\">194                        &#123;  </span><br><span class=\"line\">195                            if (nBytes &gt; 0)  </span><br><span class=\"line\">196                            &#123;  </span><br><span class=\"line\">197                                // Just repeat message.  </span><br><span class=\"line\">198                                pSocket-&gt;ResendCloseNotify();  </span><br><span class=\"line\">199                                if (pSocket-&gt;m_pLastLayer)  </span><br><span class=\"line\">200                                    pSocket-&gt;m_pLastLayer-&gt;CallEvent(FD_READ, 0);  </span><br><span class=\"line\">201                                return 0;  </span><br><span class=\"line\">202                            &#125;  </span><br><span class=\"line\">203                        &#125;  </span><br><span class=\"line\">204                        pSocket-&gt;m_SocketData.onCloseCalled = true;  </span><br><span class=\"line\">205                        if (pSocket-&gt;m_pLastLayer)  </span><br><span class=\"line\">206                            pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  </span><br><span class=\"line\">207                    &#125;  </span><br><span class=\"line\">208                    else if (pSocket-&gt;m_pLastLayer)  </span><br><span class=\"line\">209                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);  </span><br><span class=\"line\">210                &#125;  </span><br><span class=\"line\">211            &#125;  </span><br><span class=\"line\">212            return 0;  </span><br><span class=\"line\">213        &#125;  </span><br><span class=\"line\">214        else if (message == WM_USER) //Notification event sent by a layer  </span><br><span class=\"line\">215        &#123;  </span><br><span class=\"line\">216            //Verify parameters, lookup socket and notification message  </span><br><span class=\"line\">217            //Verify parameters  </span><br><span class=\"line\">218            ASSERT(hWnd);  </span><br><span class=\"line\">219            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)</span><br><span class=\"line\">220                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  </span><br><span class=\"line\">221            ASSERT(pWnd);  </span><br><span class=\"line\">222            if (!pWnd)  </span><br><span class=\"line\">223                return 0;  </span><br><span class=\"line\">224             //Index is within socket storage  </span><br><span class=\"line\">225            if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize))</span><br><span class=\"line\">226            &#123;  </span><br><span class=\"line\">227                return 0;  </span><br><span class=\"line\">228            &#125;  </span><br><span class=\"line\">229</span><br><span class=\"line\">230            CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;  </span><br><span class=\"line\">231            CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = (CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;  </span><br><span class=\"line\">232            if (!pMsg || !pSocket || pSocket-&gt;m_SocketData.hSocket != pMsg-&gt;hSocket)  </span><br><span class=\"line\">233            &#123;  </span><br><span class=\"line\">234                delete pMsg;  </span><br><span class=\"line\">235                return 0;  </span><br><span class=\"line\">236            &#125;  </span><br><span class=\"line\">237            int nEvent=pMsg-&gt;lEvent&amp;0xFFFF;  </span><br><span class=\"line\">238            int nErrorCode=pMsg-&gt;lEvent&gt;&gt;16;  </span><br><span class=\"line\">239</span><br><span class=\"line\">240            //Dispatch to layer  </span><br><span class=\"line\">241            if (pMsg-&gt;pLayer)  </span><br><span class=\"line\">242                pMsg-&gt;pLayer-&gt;CallEvent(nEvent, nErrorCode);  </span><br><span class=\"line\">243            else  </span><br><span class=\"line\">244            &#123;  </span><br><span class=\"line\">245                //Dispatch to CAsyncSocketEx instance  </span><br><span class=\"line\">246                switch (nEvent)  </span><br><span class=\"line\">247                &#123;  </span><br><span class=\"line\">248                case FD_READ:  </span><br><span class=\"line\">249#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">250                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">251                    &#123;  </span><br><span class=\"line\">252                        pSocket-&gt;m_nPendingEvents |= FD_READ;  </span><br><span class=\"line\">253                        break;  </span><br><span class=\"line\">254                    &#125;  </span><br><span class=\"line\">255                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">256                        pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">257                    if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\">258                        break;  </span><br><span class=\"line\">259#endif //NOSOCKETSTATES  </span><br><span class=\"line\">260                    if (pSocket-&gt;m_lEvent &amp; FD_READ)  </span><br><span class=\"line\">261                    &#123;  </span><br><span class=\"line\">262#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">263                        if (nErrorCode)  </span><br><span class=\"line\">264                            pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\">265#endif //NOSOCKETSTATES  </span><br><span class=\"line\">266                        pSocket-&gt;OnReceive(nErrorCode);  </span><br><span class=\"line\">267                    &#125;  </span><br><span class=\"line\">268                    break; </span><br><span class=\"line\">269                //Forceread does not check if there&#x27;s data waiting  </span><br><span class=\"line\">270                case FD_FORCEREAD:  </span><br><span class=\"line\">271#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">272                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">273                    &#123;  </span><br><span class=\"line\">274                        pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;  </span><br><span class=\"line\">275                        break;  </span><br><span class=\"line\">276                    &#125;  </span><br><span class=\"line\">277                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">278                        pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">279                    if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\">280                        break;  </span><br><span class=\"line\">281#endif //NOSOCKETSTATES  </span><br><span class=\"line\">282                    if (pSocket-&gt;m_lEvent &amp; FD_READ)  </span><br><span class=\"line\">283                    &#123;  </span><br><span class=\"line\">284#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">285                        if (nErrorCode)  </span><br><span class=\"line\">286                            pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\">287#endif //NOSOCKETSTATES  </span><br><span class=\"line\">288                        pSocket-&gt;OnReceive(nErrorCode);  </span><br><span class=\"line\">289                    &#125;  </span><br><span class=\"line\">290                    break;  </span><br><span class=\"line\">291                case FD_WRITE:  </span><br><span class=\"line\">292#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">293                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">294                    &#123;  </span><br><span class=\"line\">295                        pSocket-&gt;m_nPendingEvents |= FD_WRITE;  </span><br><span class=\"line\">296                        break;  </span><br><span class=\"line\">297                    &#125;  </span><br><span class=\"line\">298                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">299                        pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">300                    if (pSocket-&gt;GetState() != connected)  </span><br><span class=\"line\">301                        break;  </span><br><span class=\"line\">302#endif //NOSOCKETSTATES  </span><br><span class=\"line\">303                    if (pSocket-&gt;m_lEvent &amp; FD_WRITE)  </span><br><span class=\"line\">304                    &#123;  </span><br><span class=\"line\">305#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">306                        if (nErrorCode)  </span><br><span class=\"line\">307                            pSocket-&gt;SetState(aborted);  </span><br><span class=\"line\">308#endif //NOSOCKETSTATES  </span><br><span class=\"line\">309                        pSocket-&gt;OnSend(nErrorCode);  </span><br><span class=\"line\">310                    &#125;  </span><br><span class=\"line\">311                    break;  </span><br><span class=\"line\">312                case FD_CONNECT:  </span><br><span class=\"line\">313#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">314                    if (pSocket-&gt;GetState() == connecting)  </span><br><span class=\"line\">315                        pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">316                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)  </span><br><span class=\"line\">317                        pSocket-&gt;SetState(connected);  </span><br><span class=\"line\">318#endif //NOSOCKETSTATES  </span><br><span class=\"line\">319                    if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)  </span><br><span class=\"line\">320                        pSocket-&gt;OnConnect(nErrorCode);  </span><br><span class=\"line\">321#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">322                    if (!nErrorCode)  </span><br><span class=\"line\">323                    &#123;  </span><br><span class=\"line\">324                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp;</span><br><span class=\"line\">325                              pSocket-&gt;GetState() == connected) &amp;&amp;</span><br><span class=\"line\">326                              (pSocket-&gt;m_lEvent &amp; FD_READ))  </span><br><span class=\"line\">327                            pSocket-&gt;OnReceive(0);  </span><br><span class=\"line\">328                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp;</span><br><span class=\"line\">329                              pSocket-&gt;GetState() == connected) &amp;&amp;</span><br><span class=\"line\">330                              (pSocket-&gt;m_lEvent &amp; FD_READ))  </span><br><span class=\"line\">331                             pSocket-&gt;OnReceive(0);  </span><br><span class=\"line\">332                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp;</span><br><span class=\"line\">333                              pSocket-&gt;GetState() == connected) &amp;&amp;</span><br><span class=\"line\">334                              (pSocket-&gt;m_lEvent &amp; FD_WRITE))  </span><br><span class=\"line\">335                            pSocket-&gt;OnSend(0);  </span><br><span class=\"line\">336                    &#125;  </span><br><span class=\"line\">337                    pSocket-&gt;m_nPendingEvents = 0;  </span><br><span class=\"line\">338#endif //NOSOCKETSTATES  </span><br><span class=\"line\">339                    break;  </span><br><span class=\"line\">340                case FD_ACCEPT:  </span><br><span class=\"line\">341#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">342                    if ((pSocket-&gt;GetState() == listening || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_ACCEPT))  </span><br><span class=\"line\">343#endif //NOSOCKETSTATES  </span><br><span class=\"line\">344                    &#123;  </span><br><span class=\"line\">345                        pSocket-&gt;OnAccept(nErrorCode);  </span><br><span class=\"line\">346                    &#125;  </span><br><span class=\"line\">347                    break;  </span><br><span class=\"line\">348                case FD_CLOSE:  </span><br><span class=\"line\">349#ifndef NOSOCKETSTATES  </span><br><span class=\"line\">350                    if ((pSocket-&gt;GetState() == connected ||</span><br><span class=\"line\">351                         pSocket-&gt;GetState() == attached) &amp;&amp;</span><br><span class=\"line\">352                         (pSocket-&gt;m_lEvent &amp; FD_CLOSE))  </span><br><span class=\"line\">353                    &#123;  </span><br><span class=\"line\">354                        pSocket-&gt;SetState(nErrorCode?aborted:closed);  </span><br><span class=\"line\">355#else  </span><br><span class=\"line\">356                    &#123;  </span><br><span class=\"line\">357#endif //NOSOCKETSTATES  </span><br><span class=\"line\">358                        pSocket-&gt;OnClose(nErrorCode);  </span><br><span class=\"line\">359                    &#125;  </span><br><span class=\"line\">360                    break;  </span><br><span class=\"line\">361                &#125;  </span><br><span class=\"line\">362            &#125;  </span><br><span class=\"line\">363            delete pMsg;  </span><br><span class=\"line\">364            return 0;  </span><br><span class=\"line\">365        &#125;  </span><br><span class=\"line\">366        else if (message == WM_USER+1)  </span><br><span class=\"line\">367        &#123;  </span><br><span class=\"line\">368            // WSAAsyncGetHostByName reply  </span><br><span class=\"line\">369</span><br><span class=\"line\">370            // Verify parameters  </span><br><span class=\"line\">371            ASSERT(hWnd);  </span><br><span class=\"line\">372            CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)</span><br><span class=\"line\">373                                                GetWindowLongPtr(hWnd, GWLP_USERDATA);  </span><br><span class=\"line\">374            ASSERT(pWnd);  </span><br><span class=\"line\">375            if (!pWnd)  </span><br><span class=\"line\">376                return 0;  </span><br><span class=\"line\">377</span><br><span class=\"line\">378            CAsyncSocketEx *pSocket = NULL;  </span><br><span class=\"line\">379            for (int i = 0; i &lt; pWnd-&gt;m_nWindowDataSize; ++i) &#123;  </span><br><span class=\"line\">380                pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[i].m_pSocket;  </span><br><span class=\"line\">381                if (pSocket &amp;&amp; pSocket-&gt;m_hAsyncGetHostByNameHandle &amp;&amp;  </span><br><span class=\"line\">382                    pSocket-&gt;m_hAsyncGetHostByNameHandle == (HANDLE)wParam &amp;&amp;  </span><br><span class=\"line\">383                    pSocket-&gt;m_pAsyncGetHostByNameBuffer)  </span><br><span class=\"line\">384                    break;  </span><br><span class=\"line\">385            &#125;  </span><br><span class=\"line\">386            if (!pSocket || !pSocket-&gt;m_pAsyncGetHostByNameBuffer)  </span><br><span class=\"line\">387                return 0;  </span><br><span class=\"line\">388</span><br><span class=\"line\">389            int nErrorCode = lParam &gt;&gt; 16;  </span><br><span class=\"line\">390            if (nErrorCode) &#123;  </span><br><span class=\"line\">391                pSocket-&gt;OnConnect(nErrorCode);  </span><br><span class=\"line\">392                return 0;  </span><br><span class=\"line\">393            &#125;  </span><br><span class=\"line\">394</span><br><span class=\"line\">395            SOCKADDR_IN sockAddr&#123;&#125;;  </span><br><span class=\"line\">396            sockAddr.sin_family = AF_INET;  </span><br><span class=\"line\">397            sockAddr.sin_addr.s_addr = ((LPIN_ADDR)((LPHOSTENT)pSocket-&gt;m_pAsyncGetHostByNameBuffer)-&gt;h_addr)-&gt;s_addr;  </span><br><span class=\"line\">398</span><br><span class=\"line\">399            sockAddr.sin_port = htons(pSocket-&gt;m_nAsyncGetHostByNamePort);  </span><br><span class=\"line\">400</span><br><span class=\"line\">401            BOOL res = pSocket-&gt;Connect((SOCKADDR*)&amp;sockAddr, sizeof(sockAddr));  </span><br><span class=\"line\">402            delete [] pSocket-&gt;m_pAsyncGetHostByNameBuffer;  </span><br><span class=\"line\">403            pSocket-&gt;m_pAsyncGetHostByNameBuffer = 0;  </span><br><span class=\"line\">404            pSocket-&gt;m_hAsyncGetHostByNameHandle = 0;  </span><br><span class=\"line\">405</span><br><span class=\"line\">406            if (!res)  </span><br><span class=\"line\">407                if (GetLastError() != WSAEWOULDBLOCK)  </span><br><span class=\"line\">408                    pSocket-&gt;OnConnect(GetLastError());  </span><br><span class=\"line\">409            return 0;  </span><br><span class=\"line\">410        &#125;  </span><br><span class=\"line\">411        else if (message == WM_USER + 2)  </span><br><span class=\"line\">412        &#123;  </span><br><span class=\"line\">413            //Verify parameters, lookup socket and notification message  </span><br><span class=\"line\">414            //Verify parameters  </span><br><span class=\"line\">415            if (!hWnd)  </span><br><span class=\"line\">416                return 0;  </span><br><span class=\"line\">417</span><br><span class=\"line\">418            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)</span><br><span class=\"line\">419                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  </span><br><span class=\"line\">420            if (!pWnd)  </span><br><span class=\"line\">421                return 0;  </span><br><span class=\"line\">422</span><br><span class=\"line\">423            if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage  </span><br><span class=\"line\">424                return 0;  </span><br><span class=\"line\">425</span><br><span class=\"line\">426            CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;  </span><br><span class=\"line\">427            if (!pSocket)  </span><br><span class=\"line\">428                return 0;  </span><br><span class=\"line\">429</span><br><span class=\"line\">430            // Process pending callbacks  </span><br><span class=\"line\">431            std::list&lt;t_callbackMsg&gt; tmp;  </span><br><span class=\"line\">432            tmp.swap(pSocket-&gt;m_pendingCallbacks);  </span><br><span class=\"line\">433            pSocket-&gt;OnLayerCallback(tmp);  </span><br><span class=\"line\">434</span><br><span class=\"line\">435            for (auto &amp; cb : tmp) &#123;  </span><br><span class=\"line\">436                delete [] cb.str;  </span><br><span class=\"line\">437            &#125;  </span><br><span class=\"line\">438        &#125;  </span><br><span class=\"line\">439        else if (message == WM_TIMER)  </span><br><span class=\"line\">440        &#123;  </span><br><span class=\"line\">441            if (wParam != 1)  </span><br><span class=\"line\">442                return 0;  </span><br><span class=\"line\">443</span><br><span class=\"line\">444            ASSERT(hWnd);  </span><br><span class=\"line\">445            CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)</span><br><span class=\"line\">446                                              GetWindowLongPtr(hWnd, GWLP_USERDATA);  </span><br><span class=\"line\">447            ASSERT(pWnd &amp;&amp; pWnd-&gt;m_pThreadData);  </span><br><span class=\"line\">448            if (!pWnd || !pWnd-&gt;m_pThreadData)  </span><br><span class=\"line\">449                return 0;  </span><br><span class=\"line\">450</span><br><span class=\"line\">451            if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())  </span><br><span class=\"line\">452            &#123;  </span><br><span class=\"line\">453                KillTimer(hWnd, 1);  </span><br><span class=\"line\">454                return 0;  </span><br><span class=\"line\">455            &#125;  </span><br><span class=\"line\">456            CAsyncSocketEx* socket = pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.front();  </span><br><span class=\"line\">457            pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.pop_front();  </span><br><span class=\"line\">458            if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())  </span><br><span class=\"line\">459                KillTimer(hWnd, 1);  </span><br><span class=\"line\">460</span><br><span class=\"line\">461            if (socket)  </span><br><span class=\"line\">462                PostMessage(hWnd,</span><br><span class=\"line\">463                            socket-&gt;m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, </span><br><span class=\"line\">464                            socket-&gt;m_SocketData.hSocket,</span><br><span class=\"line\">465                            FD_CLOSE);  </span><br><span class=\"line\">466            return 0;  </span><br><span class=\"line\">467        &#125;  </span><br><span class=\"line\">468        return DefWindowProc(hWnd, message, wParam, lParam);  </span><br><span class=\"line\">469    &#125; </span><br></pre></td></tr></table></figure>\n\n<p>关于单个服务程序的框架，我已经介绍完了，如果你能完全理解我要表达的意思，我相信你也能构建出一套高性能服务程序来。</p>\n<h2 id=\"（八）高性能服务器架构设计总结4——以flamigo服务器代码为例\"><a href=\"#（八）高性能服务器架构设计总结4——以flamigo服务器代码为例\" class=\"headerlink\" title=\"（八）高性能服务器架构设计总结4——以flamigo服务器代码为例\"></a>（八）高性能服务器架构设计总结4——以flamigo服务器代码为例</h2><p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<h2 id=\"二、架构篇\"><a href=\"#二、架构篇\" class=\"headerlink\" title=\"二、架构篇\"></a>二、架构篇</h2><p>一个项目的服务器端往往由很多服务组成，就算单个服务在性能上做到极致，支持的并发数量也是有限的。举个简单的例子，假如一个聊天服务器，每个用户的信息是1k，那对于一个8G的内存的机器，在不考虑其它的情况下8<em>1024</em>1024*1024 &#x2F; 100 &#x3D; 1024，实际有838万，但实际这只是非常理想的情况。<strong>所以我们有时候需要需要某个服务部署多套，就单个服务的实现来讲还是《框架篇》中介绍的</strong>。</p>\n<p>1</p>\n<p>我们举个例子：<img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>这是蘑菇街TeamTalk的服务器架构。</p>\n<p>MsgServer是聊天服务，可以部署多套，每个聊天服务器启动时都会告诉loginSever和routeSever自己的ip地址和端口号，当有用户上线或者下线的时候，MsgServer也会告诉loginSever和routeSever自己上面最新的用户数量和用户id列表。</p>\n<p>现在一个用户需要<strong>登录</strong>，先连接loginServer，loginServer根据记录的各个MsgServer上的用户情况，返回一个最小负载的MsgServer的ip地址和端口号给客户端，客户端再利用这个ip地址和端口号去登录MsgServer。当<strong>聊天</strong>时，位于A MsgServer上的用户给另外一个用户发送消息，如果该用户不在同一个MsgServer上，MsgServer将消息转发给RouteServer，RouteServer根据自己记录的用户id信息找到目标用户所在的MsgServer并转发给对应的MsgServer。</p>\n<p>2</p>\n<p><strong>上面是分布式部署的一个例子，我们再来看另外一个例子。</strong>这个例子是单个服务的策略，实际服务器在处理网络数据的时候，如果同时有多个socket上有数据要处理，可能会出现一直服务前几个socket，直到前几个socket处理完毕后再处理后面几个socket的数据。这就相当于，你去饭店吃饭，大家都点了菜，但是有些桌子上一直在上菜，而有些桌子上一直没有菜。这样肯定不好，我们来看下如何避免这种现象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1int CFtdEngine::HandlePackage(CFTDCPackage *pFTDCPackage,</span><br><span class=\"line\"> 2                              CFTDCSession *pSession)  </span><br><span class=\"line\"> 3&#123;  </span><br><span class=\"line\"> 4    //NET_IO_LOG0(&quot;CFtdEngine::HandlePackage\\n&quot;);  </span><br><span class=\"line\"> 5    FTDC_PACKAGE_DEBUG(pFTDCPackage);  </span><br><span class=\"line\"> 6</span><br><span class=\"line\"> 7    if (pFTDCPackage-&gt;GetTID() != FTD_TID_ReqUserLogin)  </span><br><span class=\"line\"> 8    &#123;  </span><br><span class=\"line\"> 9        if (!IsSessionLogin(pSession-&gt;GetSessionID()))  </span><br><span class=\"line\">10        &#123;  </span><br><span class=\"line\">11            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;客户未登录&quot;);  </span><br><span class=\"line\">12            return 0;  </span><br><span class=\"line\">13        &#125;  </span><br><span class=\"line\">14    &#125;  </span><br><span class=\"line\">15</span><br><span class=\"line\">16    CalcFlux(pSession, pFTDCPackage-&gt;Length());  //统计流量  </span><br><span class=\"line\">17</span><br><span class=\"line\">18    REPORT_EVENT(LOG_DEBUG, &quot;Front/Fgateway&quot;, &quot;登录请求%0x&quot;,</span><br><span class=\"line\">19                  pFTDCPackage-&gt;GetTID());   </span><br><span class=\"line\">20</span><br><span class=\"line\">21    int nRet = 0;  </span><br><span class=\"line\">22    switch(pFTDCPackage-&gt;GetTID())   </span><br><span class=\"line\">23    &#123;  </span><br><span class=\"line\">24</span><br><span class=\"line\">25    case FTD_TID_ReqUserLogin:  </span><br><span class=\"line\">26        ///huwp：20070608：检查过高版本的API将被禁止登录  </span><br><span class=\"line\">27        if (pFTDCPackage-&gt;GetVersion()&gt;FTD_VERSION)  </span><br><span class=\"line\">28        &#123;  </span><br><span class=\"line\">29            SendErrorRsp(pFTDCPackage, pSession, 1,</span><br><span class=\"line\">30                         &quot;Too High FTD Version&quot;);  </span><br><span class=\"line\">31            return 0;  </span><br><span class=\"line\">32        &#125;  </span><br><span class=\"line\">33        nRet = OnReqUserLogin(pFTDCPackage,</span><br><span class=\"line\">34                             (CFTDCSession *)pSession);  </span><br><span class=\"line\">35        FTDRequestIndex.incValue();  </span><br><span class=\"line\">36        break;  </span><br><span class=\"line\">37    case FTD_TID_ReqCheckUserLogin:  </span><br><span class=\"line\">38        nRet = OnReqCheckUserLogin(pFTDCPackage, </span><br><span class=\"line\">39                                  (CFTDCSession *)pSession);  </span><br><span class=\"line\">40        FTDRequestIndex.incValue();  </span><br><span class=\"line\">41        break;  </span><br><span class=\"line\">42    case FTD_TID_ReqSubscribeTopic:  </span><br><span class=\"line\">43        nRet = OnReqSubscribeTopic(pFTDCPackage, </span><br><span class=\"line\">44                                  (CFTDCSession *)pSession);  </span><br><span class=\"line\">45        FTDRequestIndex.incValue();  </span><br><span class=\"line\">46        break;    </span><br><span class=\"line\">47    &#125;  </span><br><span class=\"line\">48</span><br><span class=\"line\">49    return 0;  </span><br><span class=\"line\">50&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<strong>有某个socket上有数据可读时</strong>，接着接收该socket上的数据，对接收到的数据进行解包，然后调用CalcFlux(pSession, pFTDCPackage-&gt;Length())进行流量统计：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void CFrontEngine::CalcFlux(CSession *pSession, const int nFlux)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    TFrontSessionInfo *pSessionInfo = m_mapSessionInfo.Find(pSession-&gt;GetSessionID());  </span><br><span class=\"line\"> 4    if (pSessionInfo != NULL)  </span><br><span class=\"line\"> 5    &#123;  </span><br><span class=\"line\"> 6        //流量控制改为计数  </span><br><span class=\"line\"> 7        pSessionInfo-&gt;nCommFlux ++;   </span><br><span class=\"line\"> 8        ///若流量超过规定，则挂起该会话的读操作  </span><br><span class=\"line\"> 9        if (pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux)  </span><br><span class=\"line\">10        &#123;  </span><br><span class=\"line\">11            pSession-&gt;SuspendRead(true);  </span><br><span class=\"line\">12        &#125;  </span><br><span class=\"line\">13    &#125;  </span><br><span class=\"line\">14&#125; </span><br></pre></td></tr></table></figure>\n\n<p>该函数会先让某个连接会话（Session）处理的包数量递增，接着判断是否超过最大包数量，则<strong>设置读挂起标志</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1void CSession::SuspendRead(bool bSuspend)  </span><br><span class=\"line\">2&#123;  </span><br><span class=\"line\">3    m_bSuspendRead = bSuspend;  </span><br><span class=\"line\">4&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这样下次将会从检测的socket列表中<strong>排除该socket</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1void CEpollReactor::RegisterIO(CEventHandler *pEventHandler)  </span><br><span class=\"line\"> 2&#123;  </span><br><span class=\"line\"> 3    int nReadID, nWriteID;  </span><br><span class=\"line\"> 4    pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);  </span><br><span class=\"line\"> 5    if (nWriteID != 0 &amp;&amp; nReadID ==0)  </span><br><span class=\"line\"> 6    &#123;  </span><br><span class=\"line\"> 7        nReadID = nWriteID;  </span><br><span class=\"line\"> 8    &#125;  </span><br><span class=\"line\"> 9    if (nReadID != 0)  </span><br><span class=\"line\">10    &#123;  </span><br><span class=\"line\">11        m_mapEventHandlerId[pEventHandler] = nReadID;  </span><br><span class=\"line\">12        struct epoll_event ev;  </span><br><span class=\"line\">13        ev.data.ptr = pEventHandler;  </span><br><span class=\"line\">14        if(epoll_ctl(m_fdEpoll, EPOLL_CTL_ADD, nReadID, &amp;ev) != 0)  </span><br><span class=\"line\">15        &#123;  </span><br><span class=\"line\">16            perror(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);  </span><br><span class=\"line\">17        &#125;  </span><br><span class=\"line\">18    &#125;  </span><br><span class=\"line\">19&#125;  </span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22void CSession::GetIds(int *pReadId, int *pWriteId)  </span><br><span class=\"line\">23&#123;  </span><br><span class=\"line\">24    m_pChannelProtocol-&gt;GetIds(pReadId,pWriteId);  </span><br><span class=\"line\">25    if (m_bSuspendRead)  </span><br><span class=\"line\">26    &#123;  </span><br><span class=\"line\">27        *pReadId = 0;  </span><br><span class=\"line\">28    &#125;  </span><br><span class=\"line\">29&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说不再检测该socket上是否有数据可读。然后在定时器里1秒后<strong>重置该标志</strong>，这样这个socket上有数据的话又可以重新检测到了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1const int SESSION_CHECK_TIMER_ID    = 9;  </span><br><span class=\"line\"> 2const int SESSION_CHECK_INTERVAL    = 1000;  </span><br><span class=\"line\"> 3</span><br><span class=\"line\"> 4</span><br><span class=\"line\"> 5SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);  </span><br><span class=\"line\"> 6</span><br><span class=\"line\"> 7</span><br><span class=\"line\"> 8void CFrontEngine::OnTimer(int nIDEvent)  </span><br><span class=\"line\"> 9&#123;  </span><br><span class=\"line\">10    if (nIDEvent == SESSION_CHECK_TIMER_ID)  </span><br><span class=\"line\">11    &#123;  </span><br><span class=\"line\">12        CSessionMap::iterator itor = m_mapSession.Begin();  </span><br><span class=\"line\">13        while (!itor.IsEnd())  </span><br><span class=\"line\">14        &#123;  </span><br><span class=\"line\">15            TFrontSessionInfo *pFind = m_mapSessionInfo.Find((*itor)-&gt;GetSessionID());  </span><br><span class=\"line\">16            if (pFind != NULL)  </span><br><span class=\"line\">17            &#123;  </span><br><span class=\"line\">18                CheckSession(*itor, pFind);  </span><br><span class=\"line\">19            &#125;  </span><br><span class=\"line\">20            itor++;  </span><br><span class=\"line\">21        &#125;  </span><br><span class=\"line\">22    &#125;  </span><br><span class=\"line\">23&#125;  </span><br><span class=\"line\">24</span><br><span class=\"line\">25void CFrontEngine::CheckSession(CSession *pSession,</span><br><span class=\"line\">26                                TFrontSessionInfo *pSessionInfo)  </span><br><span class=\"line\">27&#123;  </span><br><span class=\"line\">28    ///重新开始计算流量  </span><br><span class=\"line\">29    pSessionInfo-&gt;nCommFlux -= pSessionInfo-&gt;nMaxCommFlux;  </span><br><span class=\"line\">30    if (pSessionInfo-&gt;nCommFlux &lt; 0)  </span><br><span class=\"line\">31    &#123;  </span><br><span class=\"line\">32        pSessionInfo-&gt;nCommFlux = 0;  </span><br><span class=\"line\">33    &#125;  </span><br><span class=\"line\">34    ///若流量超过规定，则挂起该会话的读操作  </span><br><span class=\"line\">35    pSession-&gt;SuspendRead(pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux);</span><br><span class=\"line\">36&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就相当与饭店里面先给某一桌客人上一些菜，让他们先吃着，等上了一些菜之后不会再给这桌继续上菜了，而是给其它空桌上菜，大家都吃上后，继续回来给原先的桌子继续上菜。实际上我们的饭店都是这么做的。<strong>上面的例子是单服务流量控制的实现的一个非常好的思路，它保证了每个客户端都能均衡地得到服务，而不是一些客户端等很久才有响应。</strong></p>\n<p>3</p>\n<p>另外加快服务器处理速度的策略可能就是<strong>缓存</strong>了，缓存实际上是以空间换取时间的策略。对于一些反复使用的，但是不经常改变的信息，如果从原始地点加载这些信息就比较耗时的数据（比如从磁盘中、从数据库中），我们就可以使用缓存。</p>\n<p>所以时下像redis、leveldb、fastdb等各种内存数据库大行其道。我在flamingo中用户的基本信息都是缓存在聊天服务程序中的，而文件服务启动时会去加载指定目录里面的所有程序名称，这些文件的名称都是md5，为该文件内容的md5。这样当客户端上传了新文件请求时，如果其传上来的文件md5已经位于缓存中，则表明该文件在服务器上已经存在，这个时候服务器就不必再接收该文件了，而是告诉客户端文件已经上传成功了。</p>\n<p>说了这么多，一般来说，一个服务器的架构，往往更多取决于其具体的业务，我们要在结合当前的情况来实际去组织铺排，没有一套系统是万能的。<strong>多思考，多实践，多总结，相信很快你也能拥有很不错的架构能力。</strong></p>\n<p><strong>鉴于笔者能力和经验有限，文中难免有错漏之处，欢迎提意见。 交流QQ群：49114021</strong></p>\n<p><strong>本系列完</strong></p>\n<p>系列目录</p>\n<p>第01篇 主线程与工作线程的分工</p>\n<p>第02篇 Reactor模式</p>\n<p>第03篇 一个服务器程序的架构介绍</p>\n<p>第04篇 如何将socket设置为非阻塞模式</p>\n<p>第05篇 如何编写高性能日志</p>\n<p>第06篇 关于网络编程的一些实用技巧和细节</p>\n<p>第07篇 开源一款即时通讯软件的源码</p>\n<p>第08篇 高性能服务器架构设计总结1</p>\n<p>第09篇 高性能服务器架构设计总结2</p>\n<p>第10篇 高性能服务器架构设计总结3</p>\n<p>第11篇 高性能服务器架构设计总结4</p>\n<p><strong>欢迎关注公众号『easyserverdev』。如果有任何技术或者职业方面的问题需要我提供帮助，可通过这个公众号与我取得联系，此公众号不仅分享高性能服务器开发经验和故事，同时也免费为广大技术朋友提供技术答疑和职业解惑，您有任何问题都可以在微信公众号直接留言，我会尽快回复您。</strong></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g1auSibZlAkictBtctpBKJzkiakQOTPBFLeRvjib25cL3EAccpH5YKFwhKEuxKVwFTKacWKm5ic6rnB1Ew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n","text":"高性能服务器架构设计总结系列目录 第01篇 主线程与工作线程的分工 第02篇 Reactor模式 第03篇 一个服务器程序的架构介绍 第04篇 如何将socke...","permalink":"/post/转载/高性能服务器框架设计/高性能服务器架构设计总结","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"57 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">高性能服务器架构设计总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%A1%86%E6%9E%B6%E7%AF%87\"><span class=\"toc-text\">一、框架篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">（一）、网络通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81%E5%87%A0%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">（二）、几种IO复用机制的比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">（三）、检测网络事件的正确姿势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E5%9B%9B%EF%BC%89%E8%A2%AB%E5%8A%A8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">（四）被动关闭连接和主动关闭连接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%BA%94%EF%BC%89%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">（五）发送缓冲区和接收缓冲区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E5%85%AD%EF%BC%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">（六）协议的设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%84%E7%BB%87\"><span class=\"toc-text\">（七）、服务器程序结构的组织</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EF%BC%88%E5%85%AB%EF%BC%89%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%932%E2%80%94%E2%80%94%E4%BB%A5flamigo%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">（八）高性能服务器架构设计总结2——以flamigo服务器代码为例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EF%BC%88%E5%85%AB%EF%BC%89%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%933%E2%80%94%E2%80%94%E4%BB%A5flamigo%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">（八）高性能服务器架构设计总结3——以flamigo服务器代码为例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EF%BC%88%E5%85%AB%EF%BC%89%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%934%E2%80%94%E2%80%94%E4%BB%A5flamigo%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">（八）高性能服务器架构设计总结4——以flamigo服务器代码为例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%9E%B6%E6%9E%84%E7%AF%87\"><span class=\"toc-text\">二、架构篇</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】错误码系统的设计","uid":"244b4809351f4fc8c6cac7d22fa4014d","slug":"转载/高性能服务器框架设计/错误码系统的设计","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.887Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/错误码系统的设计.json","keywords":null,"cover":[],"text":"错误码系统的设计 本文介绍服务器开发中一组服务中错误码系统的设计理念与实践，如果读者从来没想过或者没接触过这种设计理念，建议认真体会一下这种设计思路的优点。 错...","permalink":"/post/转载/高性能服务器框架设计/错误码系统的设计","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】Linuxtcpdump使用介绍","uid":"6f9f848d419f584cbff23ed4ace411b4","slug":"转载/学习资料/Linuxtcpdump使用介绍","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/学习资料/Linuxtcpdump使用介绍.json","keywords":null,"cover":[],"text":"Linux tcpdump 使用介绍tcpdump 是 Linux 系统提供一个非常强大的抓包工具，熟练使用它，对我们排查网络问题非常有用。如果你的机器上还没有...","permalink":"/post/转载/学习资料/Linuxtcpdump使用介绍","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}