{"title":"【转载】C++高性能服务器网络框架设计细节","uid":"51dbd98ea18bf4e97e2efcaab62e6cec","slug":"转载/高性能服务器框架设计/C++高性能服务器网络框架设计细节","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.402Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/C++高性能服务器网络框架设计细节.json","keywords":null,"cover":null,"content":"<h1 id=\"C-高性能服务器网络框架设计细节\"><a href=\"#C-高性能服务器网络框架设计细节\" class=\"headerlink\" title=\"C++ 高性能服务器网络框架设计细节\"></a>C++ 高性能服务器网络框架设计细节</h1><p>这篇文章我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。需要注意的是一般大型服务器，其复杂程度在于其业务，而不是在于其代码工程的基本框架。大型服务器一般有多个服务组成，可能会支持CDN，或者支持所谓的“分布式”等，这篇文章不会介绍这些东西，因为不管结构多么复杂的服务器，都是由单个服务器组成的。所以这篇文章的侧重点是讨论单个服务程序的结构，而且这里的结构指的也是单个服务器的网络通信层结构，如果你能真正地理解了我所说的，那么在这个基础的结构上面开展任何业务都是可以的，也可以将这种结构扩展成复杂的多个服务器组，例如“分布式”服务。文中的代码示例虽然是以C++为例，但同样适合Java（我本人也是Java开发者），原理都是一样的，只不过Java可能在基本的操作系统网络通信API的基础上用虚拟机包裹了一层接口而已（Java甚至可能基于一些常用的网络通信框架思想提供了一些现成的API，例如NIO）。有鉴于此，这篇文章不讨论那些大而空、泛泛而谈的技术术语，而是讲的是实实在在的能指导读者在实际工作中实践的编码方案或优化已有编码的方法。另外这里讨论的技术同时涉及windows和linux两个平台。</p>\n<p>所谓高性能就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；所谓高并发，不仅指的是服务器可以同时支持多的客户端连接，而且这些客户端在连接期间内会不断与服务器有数据来往。网络上经常有各种网络库号称单个服务能同时支持百万甚至千万的并发，然后我实际去看了下，结果发现只是能同时支持很多的连接而已。如果一个服务器能单纯地接受ｎ个连接（ｎ可能很大），但是不能有条不紊地处理与这些连接之间的数据来往也没有任何意义，这种服务器框架只是“玩具型”的，对实际生产和应用没有任何意义。</p>\n<p>这篇文章将从两个方面来介绍，一个是服务器中的基础的网络通信部件；另外一个是，如何利用这些基础通信部件整合成一个完整的高效的服务器框架。注意：本文以下内容中的客户端是相对概念，指的是连接到当前讨论的服务程序的终端，所以这里的客户端既可能是我们传统意义上的客户端程序，也可能是连接该服务的其他服务器程序。</p>\n<p>一、网络通信部件<br> 按上面介绍的思路，我们先从服务程序的网络通信部件开始介绍。</p>\n<p>（一）、需要解决的问题<br>既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？目前，网络上有很多网络通信框架，如libevent、boost asio、ACE，但都网络通信的常见的技术手段都大同小异，至少要解决以下问题：</p>\n<ul>\n<li>如何检测有新客户端连接？</li>\n<li>如何接受客户端连接？</li>\n<li>如何检测客户端是否有数据发来？</li>\n<li>如何收取客户端发来的数据？</li>\n<li>如何检测连接异常？发现连接异常之后，如何处理？</li>\n<li>如何给客户端发送数据？</li>\n<li>如何在给客户端发完数据后关闭连接？</li>\n</ul>\n<p>稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API。确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是如何巧妙地组织这些基础的socket API，才是问题的关键。我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样，从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待或者不等待”这一原则就是高效的，也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情123456789，另外一部分闲在那里无所事事。说的可能有点抽象，下面我们来举一些例子具体来说明一下。<br>例如：</p>\n<ul>\n<li>默认情况下，recv函数如果没有数据的时候，线程就会阻塞在那里；</li>\n<li>默认情况下，send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；</li>\n<li>connect函数默认连接另外一端的时候，也会阻塞在那里；</li>\n<li>又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。</li>\n</ul>\n<p>以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的IO Multiplexing技术（IO复用技术）。</p>\n<p>（二）、几种IO复用机制的比较<br>目前windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP），linux系统支持select、poll、epoll。这里我们不具体介绍每个具体的函数的用法，我们来讨论一点深层次的东西，以上列举的API函数可以分为两个层次：</p>\n<ul>\n<li>层次一 select和poll</li>\n<li>层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll</li>\n</ul>\n<p>为什么这么分呢？先来介绍第一层次，select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。这也就是层次二的各个函数做的事情，它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，比如WSAAsyncSelect是利用windows窗口消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已。</p>\n<p>例如，connect函数连接另外一端，如果用于连接socket是非阻塞的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的第二个原则：尽量减少做无用功的时间。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，这里就成了性能的一个瓶颈。</p>\n<p>（三）、检测网络事件的正确姿势<br>根据上面的介绍，第一，为了避免无意义的等待时间，第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。我们的socket都要设置成非阻塞的。在此基础上我们回到栏目（一）中提到的七个问题：</p>\n<ol>\n<li><p>如何检测有新客户端连接？</p>\n</li>\n<li><p>如何接受客户端连接？<br> 默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。\n 　　</p>\n</li>\n<li><p>如何检测客户端是否有数据发来？</p>\n</li>\n<li><p>如何收取客户端发来的数据？<br> 同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待，至于一次性收多少数据好呢？我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了。示例：</p>\n<p> bool CIUSocket::Recv()<br> {<br> int nRet &#x3D; 0;<br> while(true)<br> {<br>     char buff[512];<br>     nRet &#x3D; ::recv(m_hSocket, buff, 512, 0);<br>     if(nRet &#x3D;&#x3D; SOCKET_ERROR)<br>     {<br>         if (::WSAGetLastError() &#x3D;&#x3D; WSAEWOULDBLOCK)<br>            break;<br>         else<br>             return false;<br>     }<br>     else if(nRet &lt; 1)<br>         return false;<br><br>     m_strRecvBuf.append(buff, nRet);<br><br>     ::Sleep(1);<br> }<br><br> return true;<br> }</p>\n</li>\n<li><p>如何检测连接异常？发现连接异常之后，如何处理？<br> 同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。</p>\n</li>\n<li><p>如何给客户端发送数据？<br> 这也是一道常见的网络通信面试题，某一年的腾讯后台开发职位就问到过这样的问题。给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。首先我们不能像注册检测数据可读事件一样一开始就注册检测数据可写事件，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。所以正确的做法是：如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后再设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。\n 　　</p>\n</li>\n<li><p>如何在给客户端发完数据后关闭连接？<br> 这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。当然，你也可以调用shutdown函数来实现所谓的“半关闭”。关于关闭连接的话题，我们再单独开一个小的标题来专门讨论一下。</p>\n</li>\n</ol>\n<p>（四）被动关闭连接和主动关闭连接<br>在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接。</p>\n<p>而主动关闭连接，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。</p>\n<p>（五）发送缓冲区和接收缓冲区<br>上面已经介绍了发送缓冲区了，并说明了其存在的意义。接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如需要进行复杂的运算，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。</p>\n<p>说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。</p>\n<p>需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个。这是我们最常见的设计方案。</p>\n<p>（六）协议的设计<br>除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。我们知道tcp&#x2F;ip协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限。比如A端给B端连续发了三个数据包，每个数据包都是50个字节，B端可能先收到10个字节，再收到140个字节；或者先收到20个字节，再收到20个字节，再收到110个字节；也可能一次性收到150个字节。这150个字节可以以任何字节数目组合和次数被B收到。所以我们讨论协议的设计第一个问题就是如何界定包的界限，也就是接收端如何知道每个包数据的大小。目前常用有如下三种方法：<br>１. 固定大小，这种方法就是假定每一个包的大小都是固定字节数目，例如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包。<br>２. 指定包结束符，例如以一个\\r\\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容。<br>３. 指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。</p>\n<p>协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。</p>\n<p>协议要讨论的第三个问题是，根据协议组装的单个数据包应该尽量小，注意这里指的是单个数据包，这样有如下好处：第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。试想：假如一个股票服务器，如果一只股票的数据包是100个字节或者1000个字节，那同样是10000只股票区别呢？</p>\n<p>协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度，比如long型，在32位机器上是32位4个字节，但是如果在64位机器上，就变成了64位8个字节了。这样同样是一个long型，发送方和接收方可能因为机器位数的不同会用不同的长度去解码。所以建议最好，在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，比如int32、int64等等。下面是一个协议的接口的例子，当然java程序员应该很熟悉这样的接口：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">class BinaryReadStream</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">private:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    const char* const ptr;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    const size_t      len;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    const char*       cur;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    BinaryReadStream(const BinaryReadStream&amp;);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">public:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    BinaryReadStream(const char* ptr, size_t len);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    virtual const char* GetData() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    virtual size_t GetSize() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool IsEmpty() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadString(string* str, size_t maxlen, size_t&amp; outlen);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadCString(char* str, size_t strlen, size_t&amp; len);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadInt32(int32_t&amp; i);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadInt64(int64_t&amp; i);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadShort(short&amp; i);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadChar(char&amp; c);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    size_t ReadAll(char* szBuffer, size_t iLen) const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool IsEnd() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    const char* GetCurrent() const&#123; return cur; &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">public:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadLength(size_t &amp; len);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool ReadLengthWithoutOffset(size_t &amp;headlen, size_t &amp; outlen);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">class BinaryWriteStream</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">public:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    BinaryWriteStream(string* data);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    virtual const char* GetData() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    virtual size_t GetSize() const;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteCString(const char* str, size_t len);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteString(const string&amp; str);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteDouble(double value, bool isNULL = false);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteInt64(int64_t value, bool isNULL = false);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteInt32(int32_t i, bool isNULL = false);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteShort(short i, bool isNULL = false);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    bool WriteChar(char c, bool isNULL = false);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    void Flush();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    void Clear();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">private:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    string* m_data;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;;</span></span></code></pre></div><p>其中BinaryWriteStream是编码协议的类，BinaryReadStream是解码协议的类。可以按下面这种方式来编码和解码。<br>编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string outbuf;</span><br><span class=\"line\">BinaryWriteStream writeStream(&amp;outbuf);</span><br><span class=\"line\">writeStream.WriteInt32(msg_type_register);</span><br><span class=\"line\">writeStream.WriteInt32(m_seq);</span><br><span class=\"line\">writeStream.WriteString(retData);</span><br><span class=\"line\">writeStream.Flush();</span><br></pre></td></tr></table></figure>\n\n<p>解码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryReadStream readStream(strMsg.c_str(), strMsg.length());</span><br><span class=\"line\">int32_t cmd;</span><br><span class=\"line\">if (!readStream.ReadInt32(cmd))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//int seq;</span><br><span class=\"line\">if (!readStream.ReadInt32(m_seq))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::string data;</span><br><span class=\"line\">size_t datalength;</span><br><span class=\"line\">if (!readStream.ReadString(&amp;data, 0, datalength))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>二、服务器程序结构的组织</p>\n<p>上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。根据我的个人经验，目前主流的思想是one thread one loop+reactor模式（也有proactor模式）的策略。通俗点说就是一个线程一个循环，即在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑。我们先从最简单地来说，设定一些线程在一个循环里面做网络通信相关的事情，伪码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(退出标志)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t//IO复用技术检测socket可读事件、出错事件  </span><br><span class=\"line\">\t//（如果有数据要发送，则也检测可写事件）  </span><br><span class=\"line\"></span><br><span class=\"line\">\t//如果有可读事件，对于侦听socket则接收新连接；  </span><br><span class=\"line\">    //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span><br><span class=\"line\"></span><br><span class=\"line\">    //如果有数据要发送，有可写事件，则发送数据  </span><br><span class=\"line\"></span><br><span class=\"line\">    //如果有出错事件，关闭该连接   </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>另外设定一些线程去处理接收到的数据，并解包处理业务逻辑，这些线程可以认为是业务线程了，伪码如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">//从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span></span></code></pre></div><p>上面的结构是目前最通用的服务器逻辑结构，但是能不能再简化一下或者说再综合一下呢？我们试试，你想过这样的问题没有：假如现在的机器有两个cpu（准确的来说应该是两个核），我们的网络线程数量是2个，业务逻辑线程也是2个，这样可能存在的情况就是：业务线程运行的时候，网络线程并没有运行，它们必须等待，如果是这样的话，干嘛要多建两个线程呢？除了程序结构上可能稍微清楚一点，对程序性能没有任何实质性提高，而且白白浪费cpu时间片在线程上下文切换上。所以，我们可以将网络线程与业务逻辑线程合并，合并后的伪码看起来是这样子的：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">while(退出标志)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //IO复用技术检测socket可读事件、出错事件  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //（如果有数据要发送，则也检测可写事件）  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">      </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">　　//如果有可读事件，对于侦听socket则接收新连接；  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">　　//对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">　　//如果有数据要发送，有可写事件，则发送数据  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">　　//如果有出错事件，关闭该连接  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">　　//从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125; </span></span></code></pre></div><p>你没看错，其实就是简单的合并，合并之后和不仅可以达到原来合并前的效果，而且在没有网络IO事件的时候，可以及时处理我们想处理的一些业务逻辑，并且减少了不必要的线程上下文切换时间。</p>\n<p>我们再更进一步，甚至我们可以在这个while循环增加其它的一些任务的处理，比如程序的逻辑任务队列、定时器事件等等，伪码如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">while(退出标志)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //定时器事件处理  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //IO复用技术检测socket可读事件、出错事件  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //（如果有数据要发送，则也检测可写事件）  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //如果有可读事件，对于侦听socket则接收新连接；  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //对于普通socket则收取该socket上的数据，收取的数据存入对应的接收缓冲区，如果出错则关闭连接；  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //如果有数据要发送，有可写事件，则发送数据  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //如果有出错事件，关闭该连接  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //从接收缓冲区中取出数据解包，分解成不同的业务来处理  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //程序自定义任务1  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //程序自定义任务2  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125; </span></span></code></pre></div><p>注意：之所以将定时器事件的处理放在网络IO事件的检测之前，是因为避免定时器事件过期时间太长。假如放在后面的话，可能前面的处理耗费了一点时间，等到处理定时器事件时，时间间隔已经过去了不少时间。虽然这样处理，也没法保证定时器事件百分百精确，但是能尽量保证。当然linux系统下提供eventfd这样的定时器对象，所有的定时器对象就能像处理socket这样的fd一样统一成处理。这也是网络库libevent的思想很像，libevent将socket、定时器、信号封装成统一的对象进行处理。</p>\n<p>说了这么多理论性的东西，我们来一款流行的开源网络库muduo来说明吧（作者：陈硕），原库是基于boost的，我改成了C++11的版本，并修改了一些bug，在此感谢原作者陈硕。</p>\n<p>上文介绍的核心线程函数的while循环位于eventloop.cpp中：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">void EventLoop::loop()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    assert(!looping_);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    assertInLoopThread();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    looping_ = true;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    quit_ = false;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    while (!quit_)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        activeChannels_.clear();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ++iteration_;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (Logger::logLevel() &lt;= Logger::TRACE)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            printActiveChannels();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        // TODO sort channel by priority</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        eventHandling_ = true;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (ChannelList::iterator it = activeChannels_.begin();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            it != activeChannels_.end(); ++it)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            currentActiveChannel_ = *it;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        currentActiveChannel_ = NULL;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        eventHandling_ = false;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        doPendingFunctors();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (frameFunctor_)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            frameFunctor_();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;\t\t</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    looping_ = false;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>poller_-&gt;poll利用epoll分离网络事件，然后接着处理分离出来的网络事件，每一个客户端socket对应一个连接，即一个TcpConnection和Channel通道对象。currentActiveChannel_-&gt;handleEvent(pollReturnTime_)根据是可读、可写、出错事件来调用对应的处理函数，这些函数都是回调函数，程序初始化阶段设置进来的：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">void Channel::handleEvent(Timestamp receiveTime)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::shared_ptr&lt;void&gt; guard;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (tied_)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        guard = tie_.lock();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (guard)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            handleEventWithGuard(receiveTime);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        handleEventWithGuard(receiveTime);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void Channel::handleEventWithGuard(Timestamp receiveTime)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    eventHandling_ = true;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    LOG_TRACE &lt;&lt; reventsToString();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (logHup_)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLHUP&quot;;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (closeCallback_) closeCallback_();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (revents_ &amp; POLLNVAL)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLNVAL&quot;;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (revents_ &amp; (POLLERR | POLLNVAL))  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (errorCallback_) errorCallback_();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //当是侦听socket时，readCallback_指向Acceptor::handleRead  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //当是客户端socket时，调用TcpConnection::handleRead   </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (readCallback_) readCallback_(receiveTime);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (revents_ &amp; POLLOUT)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //如果是连接状态服的socket，则writeCallback_指向Connector::handleWrite()  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (writeCallback_) writeCallback_();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    eventHandling_ = false; </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125; </span></span></code></pre></div><p>当然，这里利用了Channel对象的“多态性”，如果是普通socket，可读事件就会调用预先设置的回调函数；但是如果是侦听socket，则调用Aceptor对象的handleRead()<br>来接收新连接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Acceptor::handleRead()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\">    InetAddress peerAddr;  </span><br><span class=\"line\">    //FIXME loop until no more  </span><br><span class=\"line\">    int connfd = acceptSocket_.accept(&amp;peerAddr);  </span><br><span class=\"line\">    if (connfd &gt;= 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        // string hostport = peerAddr.toIpPort();  </span><br><span class=\"line\">        // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;  </span><br><span class=\"line\">        //newConnectionCallback_实际指向TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)  </span><br><span class=\"line\">        if (newConnectionCallback_)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            newConnectionCallback_(connfd, peerAddr);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            sockets::close(connfd);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;  </span><br><span class=\"line\">        // Read the section named &quot;The special problem of  </span><br><span class=\"line\">        // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.  </span><br><span class=\"line\">        // By Marc Lehmann, author of livev.  </span><br><span class=\"line\">        if (errno == EMFILE)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            ::close(idleFd_);  </span><br><span class=\"line\">            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);  </span><br><span class=\"line\">            ::close(idleFd_);  </span><br><span class=\"line\">            idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>主循环里面的业务逻辑处理对应：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">doPendingFunctors();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">if (frameFunctor_)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">   frameFunctor_();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;       </span></span></code></pre></div><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void EventLoop::doPendingFunctors()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    std::vector&lt;Functor&gt; functors;  </span><br><span class=\"line\">    callingPendingFunctors_ = true; </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  </span><br><span class=\"line\">        functors.swap(pendingFunctors_);  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    for (size_t i = 0; i &lt; functors.size(); ++i)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        functors[i]();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    callingPendingFunctors_ = false;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p> 这里增加业务逻辑是增加执行任务的函数指针的，增加的任务保存在成员变量pendingFunctors_中，这个变量是一个函数指针数组（vector对象），执行的时候，调用每个函数就可以了。上面的代码先利用一个栈变量将成员变量pendingFunctors_里面的函数指针换过来，接下来对这个栈变量进行操作就可以了，这样减少了锁的粒度。因为成员变量pendingFunctors_在增加任务的时候，也会被用到，设计到多个线程操作，所以要加锁，增加任务的地方是：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">void EventLoop::queueInLoop(const Functor&amp; cb)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pendingFunctors_.push_back(cb);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (!isInLoopThread() || callingPendingFunctors_)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        wakeup();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;  </span></span></code></pre></div><p>而frameFunctor_就更简单了，就是通过设置一个函数指针就可以了。当然这里有个技巧性的东西，即增加任务的时候，为了能够立即执行，使用唤醒机制，通过往一个fd里面写入简单的几个字节，来唤醒epoll，使其立刻返回，因为此时没有其它的socke有事件，这样接下来就执行刚才添加的任务了。</p>\n<p>我们看一下数据收取的逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TcpConnection::handleRead(Timestamp receiveTime)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\">    int savedErrno = 0;  </span><br><span class=\"line\">    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);  </span><br><span class=\"line\">    if (n &gt; 0)  </span><br><span class=\"line\">    &#123;    </span><br><span class=\"line\">        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else if (n == 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        handleClose();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        errno = savedErrno;  </span><br><span class=\"line\">        LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;  </span><br><span class=\"line\">        handleError();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>将收到的数据放到接收缓冲区里面，将来我们来解包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ClientSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    while (true)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //不够一个包头大小  </span><br><span class=\"line\">        if (pBuffer-&gt;readableBytes() &lt; (size_t)sizeof(msg))  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            LOG_INFO &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg)=&quot; &lt;&lt; sizeof(msg);  </span><br><span class=\"line\">            return;  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        //不够一个整包大小  </span><br><span class=\"line\">        msg header;  </span><br><span class=\"line\">        memcpy(&amp;header, pBuffer-&gt;peek(), sizeof(msg));  </span><br><span class=\"line\">        if (pBuffer-&gt;readableBytes() &lt; (size_t)header.packagesize + sizeof(msg))  </span><br><span class=\"line\">            return;  </span><br><span class=\"line\"></span><br><span class=\"line\">        pBuffer-&gt;retrieve(sizeof(msg));  </span><br><span class=\"line\">        std::string inbuf;  </span><br><span class=\"line\">        inbuf.append(pBuffer-&gt;peek(), header.packagesize);  </span><br><span class=\"line\">        pBuffer-&gt;retrieve(header.packagesize);  </span><br><span class=\"line\">        if (!Process(conn, inbuf.c_str(), inbuf.length()))  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            LOG_WARN &lt;&lt; &quot;Process error, close TcpConnection&quot;;  </span><br><span class=\"line\">            conn-&gt;forceClose();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;// end while-loop  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>先判断接收缓冲区里面的数据是否够一个包头大小，如果够再判断够不够包头指定的包体大小，如果还是够的话，接着在Process函数里面处理该包。</p>\n<p>再看看发送数据的逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TcpConnection::sendInLoop(const void* data, size_t len)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\">    ssize_t nwrote = 0;  </span><br><span class=\"line\">    size_t remaining = len;  </span><br><span class=\"line\">    bool faultError = false;  </span><br><span class=\"line\">    if (state_ == kDisconnected)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    // if no thing in output queue, try writing directly  </span><br><span class=\"line\">    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        nwrote = sockets::write(channel_-&gt;fd(), data, len);  </span><br><span class=\"line\">        if (nwrote &gt;= 0)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            remaining = len - nwrote;  </span><br><span class=\"line\">            if (remaining == 0 &amp;&amp; writeCompleteCallback_)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else // nwrote &lt; 0  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            nwrote = 0;  </span><br><span class=\"line\">            if (errno != EWOULDBLOCK)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;  </span><br><span class=\"line\">                if (errno == EPIPE || errno == ECONNRESET) // FIXME: any others?  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    faultError = true;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    assert(remaining &lt;= len);  </span><br><span class=\"line\">    if (!faultError &amp;&amp; remaining &gt; 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        size_t oldLen = outputBuffer_.readableBytes();  </span><br><span class=\"line\">        if (oldLen + remaining &gt;= highWaterMark_                          </span><br><span class=\"line\">            &amp;&amp; oldLen &lt; highWaterMark_  </span><br><span class=\"line\">            &amp;&amp; highWaterMarkCallback_)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);  </span><br><span class=\"line\">        if (!channel_-&gt;isWriting())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            channel_-&gt;enableWriting();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>如果剩余的数据remaining大于则调用channel_-&gt;enableWriting();开始监听可写事件，可写事件处理如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TcpConnection::handleWrite()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    loop_-&gt;assertInLoopThread();  </span><br><span class=\"line\">    if (channel_-&gt;isWriting())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        ssize_t n = sockets::write(channel_-&gt;fd(),  </span><br><span class=\"line\">            outputBuffer_.peek(),  </span><br><span class=\"line\">            outputBuffer_.readableBytes());  </span><br><span class=\"line\">        if (n &gt; 0)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            outputBuffer_.retrieve(n);  </span><br><span class=\"line\">            if (outputBuffer_.readableBytes() == 0)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                channel_-&gt;disableWriting();  </span><br><span class=\"line\">                if (writeCompleteCallback_)  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                if (state_ == kDisconnecting)  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    shutdownInLoop();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;  </span><br><span class=\"line\">            // if (state_ == kDisconnecting)  </span><br><span class=\"line\">            // &#123;  </span><br><span class=\"line\">            //   shutdownInLoop();  </span><br><span class=\"line\">            // &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()  </span><br><span class=\"line\">            &lt;&lt; &quot; is down, no more writing&quot;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>如果发送完数据以后调用channel_-&gt;disableWriting();移除监听可写事件。</p>\n<p>很多读者可能一直想问，文中不是说解包数据并处理逻辑是业务代码而非网络通信的代码，你这里貌似都混在一起了，其实没有，这里实际的业务代码处理都是框架曾提供的回调函数里面处理的，具体怎么处理，由框架使用者——业务层自己定义。</p>\n<p>总结起来，实际上就是一个线程函数里一个loop那么点事情，不信你再看我曾经工作上的一个交易系统服务器项目代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CEventDispatcher::Run()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    m_bShouldRun = true;  </span><br><span class=\"line\">    while(m_bShouldRun)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        DispatchIOs();        </span><br><span class=\"line\">        SyncTime();  </span><br><span class=\"line\">        CheckTimer();  </span><br><span class=\"line\">        DispatchEvents();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">void CEpollReactor::DispatchIOs()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    DWORD dwSelectTimeOut = SR_DEFAULT_EPOLL_TIMEOUT;  </span><br><span class=\"line\">    if (HandleOtherTask())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        dwSelectTimeOut = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    struct epoll_event ev;  </span><br><span class=\"line\">    CEventHandlerIdMap::iterator itor = m_mapEventHandlerId.begin();  </span><br><span class=\"line\">    for(; itor!=m_mapEventHandlerId.end(); itor++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        CEventHandler *pEventHandler = (CEventHandler *)(*itor).first;  </span><br><span class=\"line\">        if(pEventHandler == NULL)&#123;  </span><br><span class=\"line\">            continue;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        ev.data.ptr = pEventHandler;  </span><br><span class=\"line\">        ev.events = 0;  </span><br><span class=\"line\">        int nReadID, nWriteID;  </span><br><span class=\"line\">        pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);    </span><br><span class=\"line\">        if (nReadID &gt; 0)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            ev.events |= EPOLLIN;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        if (nWriteID &gt; 0)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            ev.events |= EPOLLOUT;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">        epoll_ctl(m_fdEpoll, EPOLL_CTL_MOD, (*itor).second, &amp;ev);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    struct epoll_event events[EPOLL_MAX_EVENTS];  </span><br><span class=\"line\"></span><br><span class=\"line\">    int nfds = epoll_wait(m_fdEpoll, events, EPOLL_MAX_EVENTS, dwSelectTimeOut/1000);  </span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i=0; i&lt;nfds; i++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        struct epoll_event &amp;evref = events[i];  </span><br><span class=\"line\">        CEventHandler *pEventHandler = (CEventHandler *)evref.data.ptr;  </span><br><span class=\"line\">        if ((evref.events|EPOLLIN)!=0 &amp;&amp; m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            pEventHandler-&gt;HandleInput();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        if ((evref.events|EPOLLOUT)!=0 &amp;&amp; m_mapEventHandlerId.find(pEventHandler)!=m_mapEventHandlerId.end())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            pEventHandler-&gt;HandleOutput();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">void CEventDispatcher::DispatchEvents()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    CEvent event;  </span><br><span class=\"line\">    CSyncEvent *pSyncEvent;  </span><br><span class=\"line\">    while(m_queueEvent.PeekEvent(event))  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        int nRetval; </span><br><span class=\"line\">        if(event.pEventHandler != NULL)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            nRetval = event.pEventHandler-&gt;HandleEvent(event.nEventID, event.dwParam, event.pParam);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            nRetval = HandleEvent(event.nEventID, event.dwParam, event.pParam);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">        if(event.pAdd != NULL)      //同步消息  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            pSyncEvent=(CSyncEvent *)event.pAdd;  </span><br><span class=\"line\">            pSyncEvent-&gt;nRetval = nRetval;  </span><br><span class=\"line\">            pSyncEvent-&gt;sem.UnLock();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看蘑菇街开源的TeamTalk的源码（代码下载地址：<a href=\"https://github.com/baloonwj/TeamTalk%EF%BC%89%EF%BC%9A\">https://github.com/baloonwj/TeamTalk）：</a></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">void CEventDispatch::StartDispatch(uint32_t wait_timeout)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    fd_set read_set, write_set, excep_set;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    timeval timeout;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    timeout.tv_sec = 0;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    timeout.tv_usec = wait_timeout * 1000;  // 10 millisecond </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if(running)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    running = true;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    while (running) </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        _CheckTimer();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        _CheckLoop(); </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!m_read_set.fd_count &amp;&amp; !m_write_set.fd_count &amp;&amp; !m_excep_set.fd_count)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            Sleep(MIN_TIMER_DURATION);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            continue;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        m_lock.lock();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        memcpy(&amp;read_set, &amp;m_read_set, sizeof(fd_set));  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        memcpy(&amp;write_set, &amp;m_write_set, sizeof(fd_set));  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        memcpy(&amp;excep_set, &amp;m_excep_set, sizeof(fd_set));  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        m_lock.unlock();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        int nfds = select(0, &amp;read_set, &amp;write_set, &amp;excep_set, &amp;timeout);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (nfds == SOCKET_ERROR)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            log(&quot;select failed, error code: %d&quot;, GetLastError());  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            Sleep(MIN_TIMER_DURATION);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            continue;           // select again  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (nfds == 0)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            continue;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (u_int i = 0; i &lt; read_set.fd_count; i++)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //log(&quot;select return read count=%d\\n&quot;, read_set.fd_count);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SOCKET fd = read_set.fd_array[i];  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (pSocket)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;OnRead();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;ReleaseRef();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (u_int i = 0; i &lt; write_set.fd_count; i++)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //log(&quot;select return write count=%d\\n&quot;, write_set.fd_count);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SOCKET fd = write_set.fd_array[i];  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (pSocket)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;OnWrite();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;ReleaseRef();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (u_int i = 0; i &lt; excep_set.fd_count; i++)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //log(&quot;select return exception count=%d\\n&quot;, excep_set.fd_count);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SOCKET fd = excep_set.fd_array[i];  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            CBaseSocket* pSocket = FindBaseSocket((net_handle_t)fd);  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (pSocket)  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#123;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;OnClose();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;ReleaseRef();  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;   </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125; </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;  </span></span></code></pre></div><p>再看filezilla，一款ftp工具的服务器端，它采用的是Windows的WSAAsyncSelect模型（代码下载地址：<a href=\"https://github.com/baloonwj/filezilla%EF%BC%89%EF%BC%9A\">https://github.com/baloonwj/filezilla）：</a></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">//Processes event notifications sent by the sockets or the layers</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">static LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (message&gt;=WM_SOCKETEX_NOTIFY)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Verify parameters</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(hWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(pWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pWnd)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (message &lt; static_cast&lt;UINT&gt;(WM_SOCKETEX_NOTIFY+pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //Lookup socket and verify if it&#39;s valid</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            CAsyncSocketEx *pSocket=pWnd-&gt;m_pAsyncSocketExWindowData[message - WM_SOCKETEX_NOTIFY].m_pSocket;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SOCKET hSocket = wParam;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (!pSocket)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (hSocket == INVALID_SOCKET)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (pSocket-&gt;m_SocketData.hSocket != hSocket)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int nEvent = lParam &amp; 0xFFFF;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int nErrorCode = lParam &gt;&gt; 16;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //Dispatch notification</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (!pSocket-&gt;m_pFirstLayer) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                //Dispatch to CAsyncSocketEx instance</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                switch (nEvent)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_READ:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                 #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;m_nPendingEvents |= FD_READ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        else if (pSocket-&gt;GetState() == attached)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            // Ignore further FD_READ events after FD_CLOSE has been received</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_SocketData.onCloseCalled)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                             #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_lEvent &amp; FD_READ) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnReceive(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    case FD_FORCEREAD: //Forceread does not check if there&#39;s data waiting</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        else if (pSocket-&gt;GetState() == attached)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_lEvent &amp; FD_READ)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnReceive(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    case FD_WRITE:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;m_nPendingEvents |= FD_WRITE;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_lEvent &amp; FD_WRITE)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnSend(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    case FD_CONNECT:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() == connecting)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if (nErrorCode &amp;&amp; pSocket-&gt;m_SocketData.nextAddr)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                if (pSocket-&gt;TryNextProtocol())</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnConnect(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (!nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp; pSocket-&gt;GetState() == connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;OnReceive(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp; pSocket-&gt;GetState() == connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;OnReceive(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if ((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp; pSocket-&gt;GetState() == connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;OnSend(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_nPendingEvents = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    case FD_ACCEPT:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() != listening &amp;&amp; pSocket-&gt;GetState() != attached)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;m_lEvent &amp; FD_ACCEPT)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnAccept(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    case FD_CLOSE:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"> #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (pSocket-&gt;GetState() != connected &amp;&amp; pSocket-&gt;GetState() != attached)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            // If there are still bytes left to read, call OnReceive instead of</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    // OnClose and trigger a new OnClose</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    DWORD nBytes = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nBytes &gt; 0)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            // Just repeat message.</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;ResendCloseNotify();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;m_SocketData.onCloseCalled = true;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnReceive(WSAESHUTDOWN);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    pSocket-&gt;SetState(nErrorCode ? aborted : closed);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                     #endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                     pSocket-&gt;OnClose(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            else //Dispatch notification to the lowest layer</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                if (nEvent == FD_READ)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    // Ignore further FD_READ events after FD_CLOSE has been received</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_SocketData.onCloseCalled)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    DWORD nBytes;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (!pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        nErrorCode = WSAGetLastError();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_pLastLayer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                else if (nEvent == FD_CLOSE)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    // If there are still bytes left to read, call OnReceive instead of</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    // OnClose and trigger a new OnClose</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    DWORD nBytes = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (!nErrorCode &amp;&amp; pSocket-&gt;IOCtl(FIONREAD, &amp;nBytes))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nBytes &gt; 0)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            // Just repeat message.</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;ResendCloseNotify();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            if (pSocket-&gt;m_pLastLayer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                                pSocket-&gt;m_pLastLayer-&gt;CallEvent(FD_READ, 0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    pSocket-&gt;m_SocketData.onCloseCalled = true;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_pLastLayer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                else if (pSocket-&gt;m_pLastLayer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    pSocket-&gt;m_pLastLayer-&gt;CallEvent(nEvent, nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else if (message == WM_USER) //Notification event sent by a layer</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Verify parameters, lookup socket and notification message</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Verify parameters</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(hWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(pWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pWnd)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = (CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pMsg || !pSocket || pSocket-&gt;m_SocketData.hSocket != pMsg-&gt;hSocket)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            delete pMsg;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        int nEvent=pMsg-&gt;lEvent&amp;0xFFFF;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        int nErrorCode=pMsg-&gt;lEvent&gt;&gt;16;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Dispatch to layer</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (pMsg-&gt;pLayer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            pMsg-&gt;pLayer-&gt;CallEvent(nEvent, nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        else</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            //Dispatch to CAsyncSocketEx instance</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            switch (nEvent)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            case FD_READ:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            #ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_nPendingEvents |= FD_READ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_lEvent &amp; FD_READ)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnReceive(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_FORCEREAD: //Forceread does not check if there&#39;s data waiting</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_nPendingEvents |= FD_FORCEREAD;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_lEvent &amp; FD_READ)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnReceive(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_WRITE:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() == connecting &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;m_nPendingEvents |= FD_WRITE;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() != connected)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_lEvent &amp; FD_WRITE)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;SetState(aborted);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnSend(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_CONNECT:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;GetState() == connecting)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    else if (pSocket-&gt;GetState() == attached &amp;&amp; !nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(connected);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (pSocket-&gt;m_lEvent &amp; FD_CONNECT)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnConnect(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if (!nErrorCode)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_READ) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_READ))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnReceive(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_FORCEREAD) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_READ))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnReceive(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        if (((pSocket-&gt;m_nPendingEvents&amp;FD_WRITE) &amp;&amp; pSocket-&gt;GetState() == connected) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_WRITE))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                            pSocket-&gt;OnSend(0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    pSocket-&gt;m_nPendingEvents = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_ACCEPT:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if ((pSocket-&gt;GetState() == listening || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_ACCEPT))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnAccept(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                case FD_CLOSE:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#ifndef NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    if ((pSocket-&gt;GetState() == connected || pSocket-&gt;GetState() == attached) &amp;&amp; (pSocket-&gt;m_lEvent &amp; FD_CLOSE))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;SetState(nErrorCode?aborted:closed);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#else</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#endif //NOSOCKETSTATES</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                        pSocket-&gt;OnClose(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                    break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            delete pMsg;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        else if (message == WM_USER+1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            // WSAAsyncGetHostByName reply</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            // Verify parameters</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(hWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(pWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pWnd)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketEx *pSocket = NULL;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (int i = 0; i &lt; pWnd-&gt;m_nWindowDataSize; ++i) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[i].m_pSocket;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (pSocket &amp;&amp; pSocket-&gt;m_hAsyncGetHostByNameHandle &amp;&amp;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;m_hAsyncGetHostByNameHandle == (HANDLE)wParam &amp;&amp;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;m_pAsyncGetHostByNameBuffer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pSocket || !pSocket-&gt;m_pAsyncGetHostByNameBuffer)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        int nErrorCode = lParam &gt;&gt; 16;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (nErrorCode) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            pSocket-&gt;OnConnect(nErrorCode);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        SOCKADDR_IN sockAddr&#123;&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        sockAddr.sin_family = AF_INET;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        sockAddr.sin_addr.s_addr = ((LPIN_ADDR)((LPHOSTENT)pSocket-&gt;m_pAsyncGetHostByNameBuffer)-&gt;h_addr)-&gt;s_addr;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        sockAddr.sin_port = htons(pSocket-&gt;m_nAsyncGetHostByNamePort);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        BOOL res = pSocket-&gt;Connect((SOCKADDR*)&amp;sockAddr, sizeof(sockAddr));</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        delete [] pSocket-&gt;m_pAsyncGetHostByNameBuffer;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pSocket-&gt;m_pAsyncGetHostByNameBuffer = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pSocket-&gt;m_hAsyncGetHostByNameHandle = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!res)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            if (GetLastError() != WSAEWOULDBLOCK)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">                pSocket-&gt;OnConnect(GetLastError());</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else if (message == WM_USER + 2)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Verify parameters, lookup socket and notification message</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        //Verify parameters</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!hWnd)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pWnd)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (wParam &gt;= static_cast&lt;UINT&gt;(pWnd-&gt;m_nWindowDataSize)) //Index is within socket storage</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketEx *pSocket = pWnd-&gt;m_pAsyncSocketExWindowData[wParam].m_pSocket;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pSocket)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        // Process pending callbacks</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        std::list&lt;t_callbackMsg&gt; tmp;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        tmp.swap(pSocket-&gt;m_pendingCallbacks);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pSocket-&gt;OnLayerCallback(tmp);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (auto &amp; cb : tmp) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            delete [] cb.str;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else if (message == WM_TIMER)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (wParam != 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(hWnd);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLongPtr(hWnd, GWLP_USERDATA);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ASSERT(pWnd &amp;&amp; pWnd-&gt;m_pThreadData);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!pWnd || !pWnd-&gt;m_pThreadData)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            KillTimer(hWnd, 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        CAsyncSocketEx* socket = pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.front();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.pop_front();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (pWnd-&gt;m_pThreadData-&gt;layerCloseNotify.empty())</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            KillTimer(hWnd, 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (socket)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            PostMessage(hWnd, socket-&gt;m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, socket-&gt;m_SocketData.hSocket, FD_CLOSE);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return DefWindowProc(hWnd, message, wParam, lParam);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;\t</span></span></code></pre></div><p>上面截取的代码段，如果你对这些项目不是很熟悉的话，估计你也没有任何兴趣去细细看每一行代码逻辑。但是你一定要明白我所说的这个结构的逻辑，基本上目前主流的网络框架都是这套原理。比如filezilla的网络通信层同样也被用在大名鼎鼎的电驴（easyMule）中。</p>\n<p>关于单个服务程序的框架，我已经介绍完了，如果你能完全理解我要表达的意思，我相信你也能构建出一套高性能服务程序来。</p>\n<p>另外，服务器框架也可以在上面的设计思路的基础上增加很多有意思的细节，比如流量控制。举另外 一个我实际做过的项目中的例子吧：</p>\n<p>一般实际项目中，当客户端连接数目比较多的时候，服务器在处理网络数据的时候，如果同时有多个socket上有数据要处理，由于cpu核数有限，根据上面先检测iO事件再处理IO事件可能会出现工作线程一直处理前几个socket的事件，直到前几个socket处理完毕后再处理后面几个socket的数据。这就相当于，你去饭店吃饭，大家都点了菜，但是有些桌子上一直在上菜，而有些桌子上一直没有菜。这样肯定不好，我们来看下如何避免这种现象：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">int CFtdEngine::HandlePackage(CFTDCPackage *pFTDCPackage, CFTDCSession *pSession)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    //NET_IO_LOG0(&quot;CFtdEngine::HandlePackage\\n&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    FTDC_PACKAGE_DEBUG(pFTDCPackage);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (pFTDCPackage-&gt;GetTID() != FTD_TID_ReqUserLogin)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (!IsSessionLogin(pSession-&gt;GetSessionID()))</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;客户未登录&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    CalcFlux(pSession, pFTDCPackage-&gt;Length());\t//统计流量</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    REPORT_EVENT(LOG_DEBUG, &quot;Front/Fgateway&quot;, &quot;登录请求%0x&quot;, pFTDCPackage-&gt;GetTID()); </span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int nRet = 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    switch(pFTDCPackage-&gt;GetTID()) </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    case FTD_TID_ReqUserLogin:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        ///huwp：20070608：检查过高版本的API将被禁止登录</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        if (pFTDCPackage-&gt;GetVersion()&gt;FTD_VERSION)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            SendErrorRsp(pFTDCPackage, pSession, 1, &quot;Too High FTD Version&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        nRet = OnReqUserLogin(pFTDCPackage, (CFTDCSession *)pSession);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        FTDRequestIndex.incValue();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    case FTD_TID_ReqCheckUserLogin:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        nRet = OnReqCheckUserLogin(pFTDCPackage, (CFTDCSession *)pSession);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        FTDRequestIndex.incValue();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        break;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    case FTD_TID_ReqSubscribeTopic:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        nRet = OnReqSubscribeTopic(pFTDCPackage, (CFTDCSession *)pSession);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        FTDRequestIndex.incValue();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        break;\t</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>当有某个socket上有数据可读时，接着接收该socket上的数据，对接收到的数据进行解包，然后调用CalcFlux(pSession, pFTDCPackage-&gt;Length())进行流量统计：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CFrontEngine::CalcFlux(CSession *pSession, const int nFlux)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTFrontSessionInfo *pSessionInfo = m_mapSessionInfo.Find(pSession-&gt;GetSessionID());</span><br><span class=\"line\">\tif (pSessionInfo != NULL)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t//流量控制改为计数</span><br><span class=\"line\">\t\tpSessionInfo-&gt;nCommFlux ++; </span><br><span class=\"line\">\t\t///若流量超过规定，则挂起该会话的读操作</span><br><span class=\"line\">\t\tif (pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpSession-&gt;SuspendRead(true);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数会先让某个连接会话（Session）处理的包数量递增，接着判断是否超过最大包数量，则设置读挂起标志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CSession::SuspendRead(bool bSuspend)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\tm_bSuspendRead = bSuspend;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这样下次将会从检测的socket列表中排除该socket：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CEpollReactor::RegisterIO(CEventHandler *pEventHandler)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    int nReadID, nWriteID;  </span><br><span class=\"line\">    pEventHandler-&gt;GetIds(&amp;nReadID, &amp;nWriteID);  </span><br><span class=\"line\">    if (nWriteID != 0 &amp;&amp; nReadID ==0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        nReadID = nWriteID;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    if (nReadID != 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        m_mapEventHandlerId[pEventHandler] = nReadID;  </span><br><span class=\"line\">        struct epoll_event ev;  </span><br><span class=\"line\">        ev.data.ptr = pEventHandler;  </span><br><span class=\"line\">        if(epoll_ctl(m_fdEpoll, EPOLL_CTL_ADD, nReadID, &amp;ev) != 0)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            perror(&quot;epoll_ctl EPOLL_CTL_ADD&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">void CSession::GetIds(int *pReadId, int *pWriteId)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    m_pChannelProtocol-&gt;GetIds(pReadId,pWriteId);  </span><br><span class=\"line\">    if (m_bSuspendRead)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        *pReadId = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>也就是说不再检测该socket上是否有数据可读。然后在定时器里1秒后重置该标志，这样这个socket上有数据的话又可以重新检测到了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int SESSION_CHECK_TIMER_ID    = 9;  </span><br><span class=\"line\">const int SESSION_CHECK_INTERVAL    = 1000;  </span><br><span class=\"line\"></span><br><span class=\"line\">SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);  </span><br><span class=\"line\"></span><br><span class=\"line\">void CFrontEngine::OnTimer(int nIDEvent)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    if (nIDEvent == SESSION_CHECK_TIMER_ID)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        CSessionMap::iterator itor = m_mapSession.Begin();  </span><br><span class=\"line\">        while (!itor.IsEnd())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            TFrontSessionInfo *pFind = m_mapSessionInfo.Find((*itor)-&gt;GetSessionID());  </span><br><span class=\"line\">            if (pFind != NULL)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                CheckSession(*itor, pFind);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            itor++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">void CFrontEngine::CheckSession(CSession *pSession, TFrontSessionInfo *pSessionInfo)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    ///重新开始计算流量  </span><br><span class=\"line\">    pSessionInfo-&gt;nCommFlux -= pSessionInfo-&gt;nMaxCommFlux;  </span><br><span class=\"line\">    if (pSessionInfo-&gt;nCommFlux &lt; 0)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        pSessionInfo-&gt;nCommFlux = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ///若流量超过规定，则挂起该会话的读操作  </span><br><span class=\"line\">    pSession-&gt;SuspendRead(pSessionInfo-&gt;nCommFlux &gt;= pSessionInfo-&gt;nMaxCommFlux);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>这就相当与饭店里面先给某一桌客人上一些菜，让他们先吃着，等上了一些菜之后不会再给这桌继续上菜了，而是给其它空桌上菜，大家都吃上后，继续回来给原先的桌子继续上菜。实际上我们的饭店都是这么做的。上面的例子是单服务流量控制的实现的一个非常好的思路，它保证了每个客户端都能均衡地得到服务，而不是一些客户端等很久才有响应。当然，这样的技术不能适用于有顺序要求的业务，例如销售系统，这些系统一般是先下单先得到的。</p>\n<p>另外现在的服务器为了加快ＩＯ操作，大量使用缓存技术，缓存实际上是以空间换取时间的策略。对于一些反复使用的，但是不经常改变的信息，如果从原始地点加载这些信息就比较耗时的数据（比如从磁盘中、从数据库中），我们就可以使用缓存。所以时下像redis、leveldb、fastdb等各种内存数据库大行其道。如果你要从事服务器开发，你至少需要掌握它们中的几种。</p>\n<p>　　<br>鉴于笔者能力和经验有限，文中难免有错漏之处，欢迎提意见。</p>\n","text":"C++ 高性能服务器网络框架设计细节这篇文章我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。需要注意的是一般大型服务器，其复杂程度...","permalink":"/post/转载/高性能服务器框架设计/C++高性能服务器网络框架设计细节","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">C++ 高性能服务器网络框架设计细节</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】业务数据处理一定要单独开线程吗","uid":"c1e8331f572d9e5ea51efac83edeef24","slug":"转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.888Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗.json","keywords":null,"cover":[],"text":"业务数据处理一定要单独开线程吗在 《one thread one loop 思想》一文我们介绍了一个 loop 的主要结构一般如下所示： 12345678whi...","permalink":"/post/转载/高性能服务器框架设计/业务数据处理一定要单独开线程吗","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】Reactor模式","uid":"f49eefb0c9add12a3ac803e71934ac10","slug":"转载/高性能服务器框架设计/Reactor模式","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.402Z","comments":true,"path":"api/articles/转载/高性能服务器框架设计/Reactor模式.json","keywords":null,"cover":[],"text":"Reactor模式最近一直在看游双的《高性能Linux服务器编程》一书，下载链接： http://download.csdn.net/detail/analog...","permalink":"/post/转载/高性能服务器框架设计/Reactor模式","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"高性能服务器框架设计","slug":"高性能服务器框架设计","count":10,"path":"api/tags/高性能服务器框架设计.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}