{"title":"【转载】connect函数在阻塞和非阻塞模式下的行为","uid":"c646ab357404b495e460a8a7d56a1d77","slug":"转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.398Z","comments":true,"path":"api/articles/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为.json","keywords":null,"cover":null,"content":"<h2 id=\"connect-函数在阻塞和非阻塞模式下的行为\"><a href=\"#connect-函数在阻塞和非阻塞模式下的行为\" class=\"headerlink\" title=\"connect 函数在阻塞和非阻塞模式下的行为\"></a>connect 函数在阻塞和非阻塞模式下的行为</h2><p>在 socket 是阻塞模式下 connect 函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务器地址“较远”，连接速度比较慢，connect 函数在连接过程中可能会导致程序阻塞在 connect 函数处好一会儿（如两三秒之久），虽然这一般也不会对依赖于网络通信的程序造成什么影响，但在实际项目中，我们一般倾向使用所谓的<strong>异步的 connect</strong> 技术，或者叫<strong>非阻塞的 connect</strong>。这个流程一般有如下步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 创建socket，并将 socket 设置成非阻塞模式；</span><br><span class=\"line\">2. 调用 connect 函数，此时无论 connect 函数是否连接成功会立即返回；如果返回-1并不表示连接出错，如果此时错误码是EINPROGRESS</span><br><span class=\"line\">3. 接着调用 select 函数，在指定的时间内判断该 socket 是否可写，如果可写说明连接成功，反之则认为连接失败。</span><br></pre></td></tr></table></figure>\n\n<p>按上述流程编写代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 异步的connect写法，nonblocking_connect.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，</span><br><span class=\"line\">    //不能在创建时就设置，这样会影响到 connect 函数的行为</span><br><span class=\"line\">    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    for (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int ret = connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));</span><br><span class=\"line\">        if (ret == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            close(clientfd);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else if (ret == -1) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //connect 动作被信号中断，重试connect</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;connecting interruptted by signal, try again.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125; else if (errno == EINPROGRESS)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //连接正在尝试中</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                //真的出错了，</span><br><span class=\"line\">                close(clientfd);</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd_set writeset;</span><br><span class=\"line\">    FD_ZERO(&amp;writeset);</span><br><span class=\"line\">    FD_SET(clientfd, &amp;writeset);</span><br><span class=\"line\">    //可以利用tv_sec和tv_usec做更小精度的超时控制</span><br><span class=\"line\">    struct timeval tv;</span><br><span class=\"line\">    tv.tv_sec = 3;  </span><br><span class=\"line\">    tv.tv_usec = 0;</span><br><span class=\"line\">    if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) == 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;[select] connect to server successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;[select] connect to server error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了区别到底是在调用 connect 函数时判断连接成功还是通过 select 函数判断连接成功，我们在后者的输出内容中加上了“**[select]**”标签以示区别。</p>\n<p>我们先用 <strong>nc</strong> 命令启动一个服务器程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -v -l 0.0.0.0 3000</span><br></pre></td></tr></table></figure>\n\n<p>然后编译客户端程序并执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# g++ -g -o nonblocking_connect nonblocking_connect.cpp </span><br><span class=\"line\">[root@localhost testsocket]# ./nonblocking_connect </span><br><span class=\"line\">[select] connect to server successfully.</span><br></pre></td></tr></table></figure>\n\n<p>我们把服务器程序关掉，再重新启动一下客户端，这个时候应该会连接失败，程序输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# ./nonblocking_connect </span><br><span class=\"line\">[select] connect to server successfully.</span><br></pre></td></tr></table></figure>\n\n<p>奇怪？为什么连接不上也会得出一样的输出结果？难道程序有问题？这是因为：</p>\n<ul>\n<li>在 Windows 系统上，一个 socket 没有建立连接之前，我们使用 select 函数检测其是否可写，能得到正确的结果（不可写），连接成功后检测，会变为可写。所以，上述介绍的异步 <strong>connect</strong> 写法流程在 Windows 系统上时没有问题的。</li>\n<li>在 Linux 系统上一个 socket 没有建立连接之前，用 select 函数检测其是否可写，你也会得到可写得结果，所以上述流程并不适用于 Linux 系统。正确的做法是，connect 之后，不仅要用 <strong>select</strong> 检测可写，还要检测此时 socket 是否出错，通过错误码来检测确定是否连接上，错误码为 0 表示连接上，反之为未连接上。完整代码如下：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Linux 下正确的异步的connect写法，linux_nonblocking_connect.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，</span><br><span class=\"line\">    //不能在创建时就设置，这样会影响到 connect 函数的行为</span><br><span class=\"line\">    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    for (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int ret = connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));</span><br><span class=\"line\">        if (ret == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            close(clientfd);</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else if (ret == -1) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //connect 动作被信号中断，重试connect</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;connecting interruptted by signal, try again.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125; else if (errno == EINPROGRESS)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //连接正在尝试中</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                //真的出错了，</span><br><span class=\"line\">                close(clientfd);</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd_set writeset;</span><br><span class=\"line\">    FD_ZERO(&amp;writeset);</span><br><span class=\"line\">    FD_SET(clientfd, &amp;writeset);</span><br><span class=\"line\">    //可以利用tv_sec和tv_usec做更小精度的超时控制</span><br><span class=\"line\">    struct timeval tv;</span><br><span class=\"line\">    tv.tv_sec = 3;  </span><br><span class=\"line\">    tv.tv_usec = 0;</span><br><span class=\"line\">    if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) != 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;[select] connect to server error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int err;</span><br><span class=\"line\">    socklen_t len = static_cast&lt;socklen_t&gt;(sizeof err);</span><br><span class=\"line\">    if (::getsockopt(clientfd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;len) &lt; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (err == 0)</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect to server error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，在实际的项目中，第 3 个步骤中 Linux 平台上你也可以使用 <strong>poll</strong> 函数来判断 socket 是否可写；在 Windows 平台上你可以使用 <strong>WSAEventSelect</strong> 或 <strong>WSAAsyncSelect</strong> 函数判断连接是否成功，关于这三个函数我们将在后面的章节中详细讲解，这里暂且仅以 <strong>select</strong> 函数为例。</p>\n</blockquote>\n","text":"connect 函数在阻塞和非阻塞模式下的行为在 socket 是阻塞模式下 connect 函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务...","permalink":"/post/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#connect-%E5%87%BD%E6%95%B0%E5%9C%A8%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">connect 函数在阻塞和非阻塞模式下的行为</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】socket的阻塞模式和非阻塞模式","uid":"fb6fadde5a0ca98e5162a3e35095bf9a","slug":"转载/网络编程/socket的阻塞模式和非阻塞模式","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/socket的阻塞模式和非阻塞模式.json","keywords":null,"cover":[],"text":"socket 的阻塞模式和非阻塞模式对 socket 在阻塞和非阻塞模式下的各个函数的行为差别深入的理解是掌握网络编程的基本要求之一，是重点也是难点。 阻塞和非...","permalink":"/post/转载/网络编程/socket的阻塞模式和非阻塞模式","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】服务器开发通信协议设计介绍","uid":"f4314c9e2807b5be1e4e59a1606b1819","slug":"转载/网络编程/服务器开发通信协议设计介绍","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器开发通信协议设计介绍.json","keywords":null,"cover":[],"text":"服务器开发通信协议设计介绍 一、选择TCP还是UDP协议由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所...","permalink":"/post/转载/网络编程/服务器开发通信协议设计介绍","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}