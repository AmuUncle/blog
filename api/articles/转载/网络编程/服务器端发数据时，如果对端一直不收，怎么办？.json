{"title":"【转载】服务器端发数据时，如果对端一直不收，怎么办？","uid":"e09bb655914509994c8e1511db91931a","slug":"转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？.json","keywords":null,"cover":null,"content":"<h2 id=\"服务器端发数据时，如果对端一直不收，怎么办？\"><a href=\"#服务器端发数据时，如果对端一直不收，怎么办？\" class=\"headerlink\" title=\"服务器端发数据时，如果对端一直不收，怎么办？\"></a>服务器端发数据时，如果对端一直不收，怎么办？</h2><p>这类问题一般出现在跨部门尤其是与外部开发人员合作的时候。假设现在有这样一种情况，我们的服务器提供对外的服务，指定好了协议，然后对外提供服务，客户端由外部人员去开发，由于存在太多的不确定性，如果我们在给对端（客户端）发送数据时，对端因为一些问题（可能是逻辑 bug 或者其他的一些问题）一直不从 socket 系统缓冲区中收取数据，而服务器端可能定期产生一些数据需要发送给客户端，再发了一段时间后，由于 TCP 窗口太小，导致数据发送不出去，这样待发送的数据会在服务器端对应的连接的发送缓冲区中积压，如果我们不做任何处理，很快系统就会因为缓冲区过大内存耗尽，导致服务被系统杀死。</p>\n<p>对于这种情况，我们一般建议从以下几个方面来增加一些防御措施：</p>\n<ol>\n<li><p>设置每路发送连接的发送缓冲区大小上限（如 2 M，或者小于这个值），当某路连接上的数据发送不出去的时候，即将数据存入发送缓冲区时，先判断一下缓冲区最大剩余空间，如果剩余空间已经小于我们要放入的数据大小，也就是说缓冲区中数据大小会超过了我们规定的上限，则认为该连接出现了问题，关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）。示例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//outputBuffer_为发送缓冲区对象</span><br><span class=\"line\">size_t remainingLen = outputBuffer_.remainingBytes();</span><br><span class=\"line\">//如果加入到缓冲区中的数据长度超出了发送缓冲区最大剩余量</span><br><span class=\"line\">if (remainingLen &lt; dataToAppend.length())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\tforceClose()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">outputBuffer_.append(static_cast&lt;const char*&gt;(dataToAppend.c_str()), dataToAppend.length());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>还有另外一种场景，当有一部分数据已经积压在发送缓冲区了，此后服务器端未产生新的待发送的数据，此时如果不做任何处理，发送缓冲区的数据会一直积压，但是发送缓冲区的数据容量也不会超过上限。如果不做任何处理的话，该数据会一直在缓冲区中积压，白白浪费系统资源。对于这种情况一般我们会设置一个定时器，每隔一段时间（如 3 秒）去检查一下各路连接的发送缓冲区中是否还有数据未发送出去，也就是说如果一个连接超过一定时间内还存在未发送出去的数据，我们也认为该连接出现了问题，我们可以关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）。示例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//每3秒检测一次</span><br><span class=\"line\">const int SESSION_CHECK_INTERVAL = 3000;</span><br><span class=\"line\"></span><br><span class=\"line\">SetTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);</span><br><span class=\"line\"></span><br><span class=\"line\">void CSessionManager::OnTimer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (auto iter = m_mapSession.begin(); iter != m_mapSession.end(); ++iter)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!CheckSession(iter-&gt;value))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //关闭session，回收相关的资源</span><br><span class=\"line\">            iter-&gt;value-&gt;ForceClose();</span><br><span class=\"line\"></span><br><span class=\"line\">            iter = m_mapSession.erase(iter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void CSessionManager::CheckSession(CSession* pSession)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!pSession-&gt;GetConnection().OutputBuffer.IsEmpty())</span><br><span class=\"line\">        return false;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，每隔 3 秒检测所有的 Session 的对应的 Connection 对象，如果发现发送缓冲区非空，说明该连接中发送缓冲区中数据已经驻留 3 秒了，将该连接关闭并清理资源。</p>\n</li>\n</ol>\n","text":"服务器端发数据时，如果对端一直不收，怎么办？这类问题一般出现在跨部门尤其是与外部开发人员合作的时候。假设现在有这样一种情况，我们的服务器提供对外的服务，指定好了...","permalink":"/post/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AF%B9%E7%AB%AF%E4%B8%80%E7%9B%B4%E4%B8%8D%E6%94%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">服务器端发数据时，如果对端一直不收，怎么办？</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】服务器开发通信协议设计介绍","uid":"f4314c9e2807b5be1e4e59a1606b1819","slug":"转载/网络编程/服务器开发通信协议设计介绍","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器开发通信协议设计介绍.json","keywords":null,"cover":[],"text":"服务器开发通信协议设计介绍 一、选择TCP还是UDP协议由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所...","permalink":"/post/转载/网络编程/服务器开发通信协议设计介绍","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】网络通信中收发数据的正确姿势","uid":"fab0416ed78af2e60e15df3589b08519","slug":"转载/网络编程/网络通信中收发数据的正确姿势","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/网络通信中收发数据的正确姿势.json","keywords":null,"cover":[],"text":"网络通信中收发数据的正确姿势在网络通信中，我们可能既要通过 socket 去发送数据也要通过 socket 来收取数据。那么一般的网络通信框架是如何收发数据的呢...","permalink":"/post/转载/网络编程/网络通信中收发数据的正确姿势","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}