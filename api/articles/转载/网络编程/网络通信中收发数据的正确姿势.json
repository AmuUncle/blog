{"title":"【转载】网络通信中收发数据的正确姿势","uid":"fab0416ed78af2e60e15df3589b08519","slug":"转载/网络编程/网络通信中收发数据的正确姿势","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/网络通信中收发数据的正确姿势.json","keywords":null,"cover":[],"content":"<h2 id=\"网络通信中收发数据的正确姿势\"><a href=\"#网络通信中收发数据的正确姿势\" class=\"headerlink\" title=\"网络通信中收发数据的正确姿势\"></a>网络通信中收发数据的正确姿势</h2><p>在网络通信中，我们可能既要通过 socket 去发送数据也要通过 socket 来收取数据。那么一般的网络通信框架是如何收发数据的呢？注意，这里讨论的范围是基于各种 IO 复用函数（select、poll、epoll 等）来判断 socket 读写来收发数据，其他情形比较简单，这里就不提了。</p>\n<p>我们这里以服务器端为例。服务器端接受客户端连接后，产生一个与客户端连接对应的 socket（Linux 下也叫 fd，为了叙述方便，以后称之为 clientfd），我们可以通过这个 clientfd 收取从客户端发来的数据，也可以通过这个 clientfd 将数据发往客户端。但是收与发在操作流程上是有明显的区别的。</p>\n<h4 id=\"收数据的正确姿势\"><a href=\"#收数据的正确姿势\" class=\"headerlink\" title=\"收数据的正确姿势\"></a>收数据的正确姿势</h4><p>对于收数据，当接受连接成功得到 clientfd 后，我们会将该 clientfd 绑定到相应的 IO 复用函数上并监听其可读事件。不同的 IO 复用函数可读事件标志不一样，例如对于 poll 模型，可读标志是 POLLIN，对于 epoll 模型，可读事件标志是 EPOLLIN。当可读事件触发后，我们调用 recv 函数从 clientfd 上收取数据（这里不考虑出错的情况），根据不同的网络模式我们可能会收取部分，或一次性收完。收取到的数据我们会放入接收缓冲区内，然后做解包操作。这就是收数据的全部“姿势”。对于使用 epoll 的 LT 模式（水平触发模式），我们每次可以只收取部分数据；但是对于 ET 模式（边缘触发模式），我们必须将本次收到的数据全部收完。</p>\n<blockquote>\n<p>ET 模式收完的标志是 recv 或者 read 函数的返回值是 -1，错误码是 EWOULDBLOCK，针对 Windows 和 Linux 下区别，前面章节已经详细地说过了。</p>\n</blockquote>\n<p>这就是读数据的全部姿势。流程图如下：</p>\n<p><img src=\"/../imgs/sendway1.webp\"></p>\n<h4 id=\"发数据的正确姿势\"><a href=\"#发数据的正确姿势\" class=\"headerlink\" title=\"发数据的正确姿势\"></a>发数据的正确姿势</h4><p>对于发数据，除了 epoll 模型的 ET 模式外，epoll 的 LT 模式或者其他 IO 复用函数，我们通常都不会去注册监听该 clientfd 的可写事件。这是因为，只要对端正常收数据，一般不会出现 TCP 窗口太小导致 send 或 write 函数无法写的问题。因此大多数情况下，clientfd 都是可写的，如果注册了可写事件，会导致一直触发可写事件，而此时不一定有数据需要发送。故而，如果有数据要发送一般都是调用 send 或者 write 函数直接发送，如果发送过程中， send 函数返回 -1，并且错误码是 EWOULDBLOCK 表明由于 TCP 窗口太小数据已经无法写入时，而仍然还剩下部分数据未发送，此时我们才注册监听可写事件，并将剩余的服务存入自定义的发送缓冲区中，等可写事件触发后再接着将发送缓冲区中剩余的数据发送出去，如果仍然有部分数据不能发出去，继续注册可写事件，当已经无数据需要发送时应该立即移除对可写事件的监听。这是目前主流网络库的做法。</p>\n<p>流程图如下：</p>\n<p><img src=\"/../imgs/sendway2.webp\"></p>\n<p>上述逻辑示例如下：</p>\n<p><strong>直接尝试发送消息处理逻辑：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *@param data 待发送的数据</span><br><span class=\"line\"> *@param len  待发送数据长度</span><br><span class=\"line\"> */</span><br><span class=\"line\">void TcpConnection::sendMessage(const void* data, size_t len)</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    int32_t nwrote = 0;</span><br><span class=\"line\">    size_t remaining = len;</span><br><span class=\"line\">    bool faultError = false;</span><br><span class=\"line\">    if (state_ == kDisconnected)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LOGW(&quot;disconnected, give up writing&quot;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当前未监听可写事件，且发送缓冲区中没有遗留数据</span><br><span class=\"line\">    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //直接发送数据</span><br><span class=\"line\">        nwrote = sockets::write(channel_-&gt;fd(), data, len);      </span><br><span class=\"line\">        if (nwrote &gt;= 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            remaining = len - nwrote;           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else // nwrote &lt; 0</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nwrote = 0;</span><br><span class=\"line\">            //错误码不等于EWOULDBLOCK说明发送出错了</span><br><span class=\"line\">            if (errno != EWOULDBLOCK)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                LOGSYSE(&quot;TcpConnection::sendInLoop&quot;);</span><br><span class=\"line\">                if (errno == EPIPE || errno == ECONNRESET)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    faultError = true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //发送未出错且还有剩余字节未发出去</span><br><span class=\"line\">    if (!faultError &amp;&amp; remaining &gt; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //将剩余部分加入发送缓冲区</span><br><span class=\"line\">        outputBuffer_.append(static_cast&lt;const char*&gt;(data) + nwrote, remaining);</span><br><span class=\"line\">        if (!channel_-&gt;isWriting())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //注册可写事件</span><br><span class=\"line\">            channel_-&gt;enableWriting();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不能全部发出去监听可写事件后，可写事件触发后处理逻辑：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//可写事件触发后会调用handleWrite()函数</span><br><span class=\"line\">void TcpConnection::handleWrite()</span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    //将发送缓冲区中的数据发送出去</span><br><span class=\"line\">    int32_t n = sockets::write(channel_-&gt;fd(), outputBuffer_.peek(), outputBuffer_.readableBytes());</span><br><span class=\"line\">    if (n &gt; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //发送多少从发送缓冲区移除多少</span><br><span class=\"line\">        outputBuffer_.retrieve(n);</span><br><span class=\"line\">        //如果发送缓冲区中已经没有剩余，则移除监听可写事件</span><br><span class=\"line\">        if (outputBuffer_.readableBytes() == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //移除监听可写事件</span><br><span class=\"line\">            channel_-&gt;disableWriting();</span><br><span class=\"line\"></span><br><span class=\"line\">            if (state_ == kDisconnecting)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                shutdown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //发数据出错处理</span><br><span class=\"line\">        LOGSYSE(&quot;TcpConnection::handleWrite&quot;);           </span><br><span class=\"line\">        handleClose();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于 epoll LT 模式注册监听一次可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，不用再次注册可写事件；如果是 epoll 的 ET 模式，注册监听可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，需要再次注册可写事件以便让可写事件下次再次触发（给予再次发数据的机会）。当然，这只是理论上的情况，实际开发中，如果一段数据反复发送都不能完全发送完（例如对端先不收，后面每隔很长时间再收一个字节），我们可以设置一个最大发送次数或最大发送总时间，超过这些限定，我们可以认为对端出了问题，应该立即清空发送缓冲区并关闭连接。</p>\n<p>本节的标题是“收发数据的正确姿势”，其实还可以换一种说法，即“检测网络事件的正确姿势”，这里意指检测一个 fd 的读写事件的区别（对于侦听 fd，只检测可读事件）：</p>\n<ul>\n<li>在 select、poll 和 epoll 的 LT 模式下，可以直接设置检测 fd 的可读事件；</li>\n<li>在 select、poll 和 epoll 的 LT 模式下不要直接设置检测 fd 的可写事件，应该先尝试发送数据，因为 TCP 窗口太小发不出去再设置检测 fd 的可写事件，一旦数据发出去应立即取消对可写事件的检测。</li>\n<li>在 epoll 的 ET 模式下，需要发送数据时，每次都要设置检测可写事件。</li>\n</ul>\n","text":"网络通信中收发数据的正确姿势在网络通信中，我们可能既要通过 socket 去发送数据也要通过 socket 来收取数据。那么一般的网络通信框架是如何收发数据的呢...","permalink":"/post/转载/网络编程/网络通信中收发数据的正确姿势","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">网络通信中收发数据的正确姿势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">收数据的正确姿势</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">发数据的正确姿势</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】服务器端发数据时，如果对端一直不收，怎么办？","uid":"e09bb655914509994c8e1511db91931a","slug":"转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？.json","keywords":null,"cover":null,"text":"服务器端发数据时，如果对端一直不收，怎么办？这类问题一般出现在跨部门尤其是与外部开发人员合作的时候。假设现在有这样一种情况，我们的服务器提供对外的服务，指定好了...","permalink":"/post/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】非阻塞模式下send和recv函数的返回值","uid":"12ad89ee9300bed7e58f0d5f1f9116ca","slug":"转载/网络编程/非阻塞模式下send和recv函数的返回值","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.915Z","comments":true,"path":"api/articles/转载/网络编程/非阻塞模式下send和recv函数的返回值.json","keywords":null,"cover":[],"text":"非阻塞模式下 send 和 recv 函数的返回值我们来总结一下 send 和 recv 函数的各种返回值意义： 返回值 n 返回值含义 大于 0 成功发送 n...","permalink":"/post/转载/网络编程/非阻塞模式下send和recv函数的返回值","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}