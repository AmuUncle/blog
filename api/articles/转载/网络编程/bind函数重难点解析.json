{"title":"【转载】bind函数重难点解析","uid":"a48f84a55618baa7dd151ec12f4ef58e","slug":"转载/网络编程/bind函数重难点解析","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.398Z","comments":true,"path":"api/articles/转载/网络编程/bind函数重难点解析.json","keywords":null,"cover":null,"content":"<h1 id=\"bind-函数重难点解析\"><a href=\"#bind-函数重难点解析\" class=\"headerlink\" title=\"bind 函数重难点解析\"></a>bind 函数重难点解析</h1><h2 id=\"bind-函数如何选择绑定地址\"><a href=\"#bind-函数如何选择绑定地址\" class=\"headerlink\" title=\"bind 函数如何选择绑定地址\"></a>bind 函数如何选择绑定地址</h2><p>bind 函数的基本用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr_in bindaddr;</span><br><span class=\"line\">bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 bind 的地址我们使用了一个宏叫 <strong>INADDR_ANY</strong> ，关于这个宏的解释如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If an application does not care what local address is assigned, </span><br><span class=\"line\">specify the constant value INADDR_ANY for an IPv4 local address</span><br><span class=\"line\">or the constant value in6addr_any for an IPv6 local address </span><br><span class=\"line\">in the sa_data member of the name parameter. This allows the </span><br><span class=\"line\">underlying service provider to use any appropriate network address,</span><br><span class=\"line\">potentially simplifying application programming in the presence of </span><br><span class=\"line\">multihomed hosts (that is, hosts that have more than one network </span><br><span class=\"line\">interface and address).</span><br></pre></td></tr></table></figure>\n\n<p>意译一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果应用程序不关心bind绑定的ip地址，可以使用INADDR_ANY(如果是IPv6，</span><br><span class=\"line\">则对应in6addr_any)，这样底层的（协议栈）服务会自动选择一个合适的ip地址，</span><br><span class=\"line\">这样使在一个有多个网卡机器上选择ip地址问题变得简单。</span><br></pre></td></tr></table></figure>\n\n<p>也就是说 <strong>INADDR_ANY</strong> 相当于地址 <strong>0.0.0.0</strong>。可能读者还是不太明白我想表达什么。这里我举个例子，假设我们在一台机器上开发一个服务器程序，使用 bind 函数时，我们有多个ip 地址可以选择。首先，这台机器对外访问的ip地址是<strong>120.55.94.78</strong>，这台机器在当前局域网的地址是<strong>192.168.1.104</strong>；同时这台机器有本地回环地址<strong>127.0.0.1</strong>。</p>\n<p>如果你指向本机上可以访问，那么你 bind 函数中的地址就可以使用<strong>127.0.0.1</strong>; 如果你的服务只想被局域网内部机器访问，bind 函数的地址可以使用<strong>192.168.1.104</strong>；如果 希望这个服务可以被公网访问，你就可以使用地址<strong>0.0.0.0</strong>或 <strong>INADDR_ANY</strong>。</p>\n<h2 id=\"bind-函数端口号问题\"><a href=\"#bind-函数端口号问题\" class=\"headerlink\" title=\"bind 函数端口号问题\"></a>bind 函数端口号问题</h2><p>网络通信程序的基本逻辑是客户端连接服务器，即从客户端的<strong>地址:端口</strong>连接到服务器<strong>地址:端口</strong>上，以 4.2 小节中的示例程序为例，服务器端的端口号使用 3000，那客户端连接时的端口号是多少呢？TCP 通信双方中一般服务器端端口号是固定的，而客户端端口号是连接发起时由操作系统随机分配的（不会分配已经被占用的端口）。端口号是一个 C short 类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下压力测试程序理论上最多只能发起六万五千多个连接。注意我说的是理论上，在实际情况下，由于当时的操作系统很多端口可能已经被占用，实际可以使用的端口比这个更少，例如，一般规定端口号在1024以下的端口是保留端口，不建议用户程序使用。而对于 Windows 系统，MSDN 甚至明确地说：</p>\n<blockquote>\n<p>On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000.<br>Vista 及以后的Windows，可用的动态端口范围是49152～65535，而 Windows Server及更早的系统，可以的动态端口范围是1025~5000。（你可以通过修改注册表来改变这一设置，参考网址：<a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind%EF%BC%89\">https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind）</a></p>\n</blockquote>\n<p>如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口，当然服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的ip地址和端口号。</p>\n<p>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。</p>\n<p>我们用代码来实际验证一下上路所说的，为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。</p>\n<ul>\n<li><strong>情形一：客户端代码不绑定端口</strong></li>\n</ul>\n<p>修改后的服务器代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * TCP服务器通信基本流程</span><br><span class=\"line\"> * zhangyl 2018.12.13</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个侦听socket</span><br><span class=\"line\">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (listenfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.初始化服务器地址</span><br><span class=\"line\">    struct sockaddr_in bindaddr;</span><br><span class=\"line\">    bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //3.启动侦听</span><br><span class=\"line\">    if (listen(listenfd, SOMAXCONN) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //记录所有客户端连接的容器</span><br><span class=\"line\">    std::vector&lt;int&gt; clientfds;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        struct sockaddr_in clientaddr;</span><br><span class=\"line\">        socklen_t clientaddrlen = sizeof(clientaddr);</span><br><span class=\"line\">        //4. 接受客户端连接</span><br><span class=\"line\">        int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class=\"line\">        if (clientfd != -1)</span><br><span class=\"line\">        &#123;             </span><br><span class=\"line\">            char recvBuf[32] = &#123;0&#125;;</span><br><span class=\"line\">            //5. 从客户端接受数据</span><br><span class=\"line\">            int ret = recv(clientfd, recvBuf, 32, 0);</span><br><span class=\"line\">            if (ret &gt; 0) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">                //6. 将收到的数据原封不动地发给客户端</span><br><span class=\"line\">                ret = send(clientfd, recvBuf, strlen(recvBuf), 0);</span><br><span class=\"line\">                if (ret != strlen(recvBuf))</span><br><span class=\"line\">                    std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">                std::cout &lt;&lt; &quot;send data to client successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            //close(clientfd);</span><br><span class=\"line\">            clientfds.push_back(clientfd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //7.关闭侦听socket</span><br><span class=\"line\">    close(listenfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后的客户端代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * TCP客户端通信基本流程</span><br><span class=\"line\"> * zhangyl 2018.12.13</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //3. 向服务器发送数据</span><br><span class=\"line\">    int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);</span><br><span class=\"line\">    if (ret != strlen(SEND_DATA))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    //4. 从客户端收取数据</span><br><span class=\"line\">    char recvBuf[32] = &#123;0&#125;;</span><br><span class=\"line\">    ret = recv(clientfd, recvBuf, 32, 0);</span><br><span class=\"line\">    if (ret &gt; 0) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    else </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;recv data error, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    //close(clientfd);</span><br><span class=\"line\">    //这里仅仅是为了让客户端程序不退出</span><br><span class=\"line\">    while (true) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将程序编译好后（编译方法和上文一样），我们先启动server，再启动三个客户端。然后通过 <strong>lsof</strong> 命令查看当前机器上的 TCP 连接信息，为了更清楚地显示结果，已经将不相关的连接信息去掉了，结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# lsof -i -Pn</span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">server   1445 root    3u  IPv4  21568      0t0  TCP *:3000 (LISTEN)</span><br><span class=\"line\">server   1445 root    4u  IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)</span><br><span class=\"line\">server   1445 root    5u  IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)</span><br><span class=\"line\">server   1445 root    6u  IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)</span><br><span class=\"line\">client   1447 root    3u  IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class=\"line\">client   1448 root    3u  IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class=\"line\">client   1449 root    3u  IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n\n<p>上面的结果显示，<strong>server</strong> 进程（进程 ID 是 <strong>1445</strong>）在 <strong>3000</strong> 端口开启侦听，有三个 <strong>client</strong> 进程（进程 ID 分别是<strong>1447</strong>、<strong>1448</strong>、<strong>1449</strong>）分别通过端口号 <strong>40818</strong>、<strong>40820</strong>、<strong>40822</strong> 连到 <strong>server</strong> 进程上的，作为客户端的一方，端口号是系统随机分配的。</p>\n<ul>\n<li><p><strong>情形二：客户端绑定端口号 0</strong></p>\n<p>服务器端代码保持不变，我们修改下客户端代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * TCP服务器通信基本流程</span><br><span class=\"line\"> * zhangyl 2018.12.13</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //1.创建一个socket</span><br><span class=\"line\">  int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">  if (clientfd == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">      return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct sockaddr_in bindaddr;</span><br><span class=\"line\">  bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">  bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">  //将socket绑定到0号端口上去</span><br><span class=\"line\">  bindaddr.sin_port = htons(0);</span><br><span class=\"line\">  if (bind(clientfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">      return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //2.连接服务器</span><br><span class=\"line\">  struct sockaddr_in serveraddr;</span><br><span class=\"line\">  serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">  serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">  serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">  if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">      return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //3. 向服务器发送数据</span><br><span class=\"line\">  int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);</span><br><span class=\"line\">  if (ret != strlen(SEND_DATA))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">      return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  //4. 从客户端收取数据</span><br><span class=\"line\">  char recvBuf[32] = &#123;0&#125;;</span><br><span class=\"line\">  ret = recv(clientfd, recvBuf, 32, 0);</span><br><span class=\"line\">  if (ret &gt; 0) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  else </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      std::cout &lt;&lt; &quot;recv data error, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //5. 关闭socket</span><br><span class=\"line\">  //close(clientfd);</span><br><span class=\"line\">  //这里仅仅是为了让客户端程序不退出</span><br><span class=\"line\">  while (true) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      sleep(3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再次编译客户端程序，并启动三个 <strong>client</strong> 进程，然后用 <strong>lsof</strong> 命令查看机器上的 TCP 连接情况，结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# lsof -i -Pn</span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">server   1593 root    3u  IPv4  21807      0t0  TCP *:3000 (LISTEN)</span><br><span class=\"line\">server   1593 root    4u  IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)</span><br><span class=\"line\">server   1593 root    5u  IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)</span><br><span class=\"line\">server   1593 root    6u  IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)</span><br><span class=\"line\">client   1595 root    3u  IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class=\"line\">client   1611 root    3u  IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class=\"line\">client   1627 root    3u  IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的结果，我们发现三个 <strong>client</strong> 进程使用的端口号仍然是系统随机分配的，也就是说绑定 <strong>0</strong> 号端口和没有绑定效果是一样的。</p>\n</li>\n<li><p><strong>情形三：客户端绑定一个固定端口</strong></p>\n<p>我们这里使用 <strong>20000</strong> 端口，当然读者可以根据自己的喜好选择，只要保证所选择的端口号当前没有被其他程序占用即可，服务器代码保持不变，客户端绑定代码中的端口号从 <strong>0</strong> 改成 <strong>20000</strong>。这里为了节省篇幅，只贴出修改处的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct sockaddr_in bindaddr;</span><br><span class=\"line\">bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">//将socket绑定到20000号端口上去</span><br><span class=\"line\">bindaddr.sin_port = htons(20000);</span><br><span class=\"line\">if (bind(clientfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次重新编译程序，先启动一个客户端后，我们看到此时的 TCP 连接状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# lsof -i -Pn</span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class=\"line\">server   1676 root    4u  IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)</span><br><span class=\"line\">client   1678 root    3u  IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的结果，我们发现 <strong>client</strong> 进程确实使用 <strong>20000</strong> 号端口连接到 <strong>server</strong> 进程上去了。这个时候如果我们再开启一个 <strong>client</strong> 进程，我们猜想由于端口号 <strong>20000</strong> 已经被占用，新启动的 <strong>client</strong> 会由于调用 <strong>bind</strong> 函数出错而退出，我们实际验证一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# ./client </span><br><span class=\"line\">bind socket error.</span><br><span class=\"line\">[root@localhost testsocket]# </span><br></pre></td></tr></table></figure>\n\n<p>结果确实和我们预想的一样。</p>\n</li>\n</ul>\n<p>在技术面试的时候，有时候面试官会问 TCP 网络通信的客户端程序中的 socket 是否可以调用 bind 函数，相信读到这里，聪明的读者已经有答案了。</p>\n<p>另外，Linux 的 <strong>nc</strong> 命令有个 <strong>-p</strong> 选项（字母 <strong>p</strong> 是小写），这个选项的作用就是 <strong>nc</strong> 在模拟客户端程序时，可以使用指定端口号连接到服务器程序上去，实现原理相信读者也明白了。我们还是以上面的服务器程序为例，这个我们不用我们的 <strong>client</strong> 程序，改用 <strong>nc</strong> 命令来模拟客户端。在 <strong>shell</strong> 终端输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# nc -v -p 9999 127.0.0.1 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Connected to 127.0.0.1:3000.</span><br><span class=\"line\">My name is zhangxf</span><br><span class=\"line\">My name is zhangxf</span><br></pre></td></tr></table></figure>\n\n<p><strong>-v</strong> 选项表示输出 <strong>nc</strong> 命令连接的详细信息，这里连接成功以后，会输出“**Ncat: Connected to 127.0.0.1:3000.**” 提示已经连接到服务器的 <strong>3000</strong> 端口上去了。</p>\n<p><strong>-p</strong> 选项的参数值是 <strong>9999</strong> 表示，我们要求 <strong>nc</strong> 命令本地以端口号 <strong>9999</strong> 连接服务器，注意不要与端口号 <strong>3000</strong> 混淆，<strong>3000</strong> 是服务器的侦听端口号，也就是我们的连接的目标端口号，<strong>9999</strong> 是我们客户端使用的端口号。我们用 <strong>lsof</strong> 命令来验证一下我们的 <strong>nc</strong> 命令是否确实以 <strong>9999</strong> 端口号连接到 <strong>server</strong> 进程上去了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# lsof -i -Pn</span><br><span class=\"line\">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class=\"line\">server   1676 root    7u  IPv4  22405      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:9999 (ESTABLISHED)</span><br><span class=\"line\">nc       2005 root    3u  IPv4  22408      0t0  TCP 127.0.0.1:9999-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n\n<p>结果确实如我们期望的一致。</p>\n<p>当然，我们用 <strong>nc</strong> 命令连接上 <strong>server</strong> 进程以后，我们还给服务器发了一条消息”<strong>My name is zhangxf</strong>“，<strong>server</strong> 程序收到消息后把这条消息原封不动地返还给我们，以下是 <strong>server</strong> 端运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# ./server   </span><br><span class=\"line\">recv data from client, data: My name is zhangxf</span><br><span class=\"line\"></span><br><span class=\"line\">send data to client successfully, data: My name is zhangxf</span><br></pre></td></tr></table></figure>\n\n<p>关于 <strong>lsof</strong> 和 <strong>nc</strong> 命令我们会在后面的系列文章中详细讲解。</p>\n","text":"bind 函数重难点解析bind 函数如何选择绑定地址bind 函数的基本用法如下： 123456789struct sockaddr_in bindaddr;...","permalink":"/post/转载/网络编程/bind函数重难点解析","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#bind-%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">bind 函数重难点解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bind-%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">bind 函数如何选择绑定地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bind-%E5%87%BD%E6%95%B0%E7%AB%AF%E5%8F%A3%E5%8F%B7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">bind 函数端口号问题</span></a></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】TCP协议如何解决粘包、半包问题","uid":"2a3c3c9ace4b4758d78bedda5e2402e0","slug":"转载/网络编程/TCP协议如何解决粘包、半包问题","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.397Z","comments":true,"path":"api/articles/转载/网络编程/TCP协议如何解决粘包、半包问题.json","keywords":null,"cover":[],"text":"TCP 协议如何解决粘包、半包问题一 TCP 协议是流式协议很多读者从接触网络知识以来，应该听说过这句话：TCP 协议是流式协议。那么这句话到底是什么意思呢？所...","permalink":"/post/转载/网络编程/TCP协议如何解决粘包、半包问题","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】select函数重难点解析","uid":"424888f17e8d4fef03209498cc4923a5","slug":"转载/网络编程/select函数重难点解析","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/select函数重难点解析.json","keywords":null,"cover":[],"text":"select 函数重难点解析select 函数是网络通信编程中非常常用的一个函数，因此应该熟练掌握它。虽然它是 BSD 标准之一的 Socket 函数之一，但在...","permalink":"/post/转载/网络编程/select函数重难点解析","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}