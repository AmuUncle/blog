{"title":"【转载】select函数重难点解析","uid":"424888f17e8d4fef03209498cc4923a5","slug":"转载/网络编程/select函数重难点解析","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/select函数重难点解析.json","keywords":null,"cover":[],"content":"<h2 id=\"select-函数重难点解析\"><a href=\"#select-函数重难点解析\" class=\"headerlink\" title=\"select 函数重难点解析\"></a>select 函数重难点解析</h2><p><strong>select</strong> 函数是网络通信编程中非常常用的一个函数，因此应该熟练掌握它。虽然它是 BSD 标准之一的 Socket 函数之一，但在 Linux 和 Windows 平台，其行为表现还是有点区别的。我们先来看一下 Linux 平台上的 select 函数。</p>\n<h4 id=\"Linux-平台下的-select-函数\"><a href=\"#Linux-平台下的-select-函数\" class=\"headerlink\" title=\"Linux 平台下的 select 函数\"></a>Linux 平台下的 select 函数</h4><p><strong>select</strong> 函数的作用是检测一组 socket 中某个或某几个是否有“<strong>事件</strong>”，这里的“<strong>事件”</strong>一般分为如下三类：</p>\n<ul>\n<li>可读事件，一般意味着可以调用 <strong>recv</strong> 或 <strong>read</strong> 函数从该 socket 上读取数据；如果该 socket 是侦听 <strong>socket</strong>（即调用了 <strong>bind</strong> 函数绑定过 ip 地址和端口号，并调用了 <strong>listen</strong> 启动侦听的 socket），可读意味着此时可以有新的客户端连接到来，此时可调用 <strong>accept</strong> 函数接受新连接。</li>\n<li>可写事件，一般意味着此时调用 <strong>send</strong> 或 <strong>write</strong> 函数可以将数据“发出去”。</li>\n<li>异常事件，某个 socket 出现异常。</li>\n</ul>\n<p>函数签名如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int select(int nfds, </span><br><span class=\"line\">           fd_set *readfds,</span><br><span class=\"line\">           fd_set *writefds,</span><br><span class=\"line\">           fd_set *exceptfds,</span><br><span class=\"line\">           struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<ul>\n<li><p>参数 <strong>nfds</strong>， Linux 下 socket 也称 fd，这个参数的值设置成所有需要使用 select 函数监听的 fd 中最大 fd 值加 1。</p>\n</li>\n<li><p>参数 <strong>readfds</strong>，需要监听可读事件的 fd 集合。</p>\n</li>\n<li><p>参数 <strong>writefds</strong>，需要监听可写事件的 fd 集合。</p>\n</li>\n<li><p>参数 <strong>exceptfds</strong>，需要监听异常事件 fd 集合。</p>\n<p><strong>readfds</strong>、<strong>writefds</strong> 和 <strong>exceptfds</strong> 类型都是 <strong>fd_set</strong>，这是一个结构体信息，其定义位于 <strong>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;select.h</strong> 中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* The fd_set member is required to be an array of longs.  */</span><br><span class=\"line\">typedef long int __fd_mask;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */</span><br><span class=\"line\">#undef  __NFDBITS</span><br><span class=\"line\">/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */</span><br><span class=\"line\">#define __NFDBITS       (8 * (int) sizeof (__fd_mask))</span><br><span class=\"line\">#define __FD_ELT(d)     ((d) / __NFDBITS)</span><br><span class=\"line\">#define __FD_MASK(d)    ((__fd_mask) 1 &lt;&lt; ((d) % __NFDBITS))</span><br><span class=\"line\"></span><br><span class=\"line\">/* fd_set for select and pselect.  */</span><br><span class=\"line\">typedef struct</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  /* XPG4.2 requires this member name.  Otherwise avoid the name</span><br><span class=\"line\">     from the global namespace.  */</span><br><span class=\"line\">#ifdef __USE_XOPEN</span><br><span class=\"line\">  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class=\"line\"># define __FDS_BITS(set) ((set)-&gt;fds_bits)</span><br><span class=\"line\">#else</span><br><span class=\"line\">  // 在我的centOS 7.0 系统中的值：</span><br><span class=\"line\">  // __FD_SETSIZE = 1024</span><br><span class=\"line\">  //__NFDBITS = 64</span><br><span class=\"line\">  __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];     </span><br><span class=\"line\"># define __FDS_BITS(set) ((set)-&gt;__fds_bits)</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125; fd_set;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Maximum number of file descriptors in &#x27;fd_set&#x27;.  */</span><br><span class=\"line\">#define FD_SETSIZE              __FD_SETSIZE</span><br></pre></td></tr></table></figure>\n\n<p>我们假设未定义宏 <strong>__USE_XOPEN</strong>，将上面的代码整理一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  long int __fds_bits[16];     </span><br><span class=\"line\">&#125; fd_set;</span><br></pre></td></tr></table></figure>\n\n<p>将一个 fd 添加到 fd_set 这个集合中需要使用 <strong>FD_SET</strong> 宏，其定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void FD_SET(int fd, fd_set *set);</span><br></pre></td></tr></table></figure>\n\n<p>其实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)</span><br></pre></td></tr></table></figure>\n\n<p><strong>FD_SET</strong> 在内部又是通过宏 <strong>__FD_SET</strong> 来实现的，**__FD_SET** 的定义如下（位于 <strong>&#x2F;usr&#x2F;include&#x2F;bits&#x2F;select.h</strong> 中）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2</span><br><span class=\"line\"></span><br><span class=\"line\"># if __WORDSIZE == 64</span><br><span class=\"line\">#  define __FD_ZERO_STOS &quot;stosq&quot;</span><br><span class=\"line\"># else</span><br><span class=\"line\">#  define __FD_ZERO_STOS &quot;stosl&quot;</span><br><span class=\"line\"># endif</span><br><span class=\"line\"></span><br><span class=\"line\"># define __FD_ZERO(fdsp) \\</span><br><span class=\"line\">do &#123;                                                                        \\</span><br><span class=\"line\">  int __d0, __d1;                                                           \\</span><br><span class=\"line\">  __asm__ __volatile__ (&quot;cld; rep; &quot; __FD_ZERO_STOS                         \\</span><br><span class=\"line\">                        : &quot;=c&quot; (__d0), &quot;=D&quot; (__d1)                          \\</span><br><span class=\"line\">                        : &quot;a&quot; (0), &quot;0&quot; (sizeof (fd_set)                     \\</span><br><span class=\"line\">                                        / sizeof (__fd_mask)),              \\</span><br><span class=\"line\">                          &quot;1&quot; (&amp;__FDS_BITS (fdsp)[0])                       \\</span><br><span class=\"line\">                        : &quot;memory&quot;);                                        \\</span><br><span class=\"line\">&#125; while (0)</span><br><span class=\"line\"></span><br><span class=\"line\">#else   /* ! GNU CC */</span><br><span class=\"line\"></span><br><span class=\"line\">/* We don&#x27;t use `memset&#x27; because this would require a prototype and</span><br><span class=\"line\"> the array isn&#x27;t too big.  */</span><br><span class=\"line\"># define __FD_ZERO(set)  \\</span><br><span class=\"line\">do &#123;                                                                        \\</span><br><span class=\"line\">  unsigned int __i;                                                         \\</span><br><span class=\"line\">  fd_set *__arr = (set);                                                    \\</span><br><span class=\"line\">  for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)          \\</span><br><span class=\"line\">    __FDS_BITS (__arr)[__i] = 0;                                            \\</span><br><span class=\"line\">&#125; while (0)</span><br><span class=\"line\"></span><br><span class=\"line\">#endif  /* GNU CC */</span><br><span class=\"line\"></span><br><span class=\"line\">#define __FD_SET(d, set) \\</span><br><span class=\"line\">((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))</span><br><span class=\"line\">#define __FD_CLR(d, set) \\</span><br><span class=\"line\">((void) (__FDS_BITS (set)[__FD_ELT (d)] &amp;= ~__FD_MASK (d)))</span><br><span class=\"line\">#define __FD_ISSET(d, set) \\</span><br><span class=\"line\">((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)</span><br></pre></td></tr></table></figure>\n\n<p>重点看这一行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))</span><br></pre></td></tr></table></figure>\n\n<p><strong>__FD_MASK</strong> 和 <strong>__FD_ELT</strong> 宏在上面的代码中已经给出定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __FD_ELT(d)     ((d) / __NFDBITS)</span><br><span class=\"line\">#define __FD_MASK(d)    ((__fd_mask) 1 &lt;&lt; ((d) % __NFDBITS))</span><br></pre></td></tr></table></figure>\n\n<p><strong>__NFDBITS</strong> 的值是 <strong>64</strong> （<strong>8 * 8</strong>），也就是说 <strong>__FD_MASK (d)</strong> 先计算 fd 与 64 的余数 n，然后执行 1 &lt;&lt; n，这一操作实际上是将 fd 的值放在 0～63 这 64 的位置上去，这个位置索引就是 fd 与 64 取模的结果；同理 <strong>__FD_ELT(d)</strong> 就是计算位置索引值了。举个例子，假设现在 fd 的 值是 57，那么在这 64 个位置的 57 位，其值在 64 个长度的二进制中置位是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>\n\n<p>这个值就是 <strong>1 &lt;&lt; (57 % 64)</strong> 得到的数字。</p>\n<p>但是前面 fd 数组的定义是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  long int __fds_bits[16];    //可以看成是128 bit的数组 </span><br><span class=\"line\">&#125; fd_set;</span><br></pre></td></tr></table></figure>\n\n<p><strong>long int</strong> 占 8 个字节，一个 16 个 <strong>long int</strong>，如果换成二进制的位(<strong>bit</strong>)就是 <strong>8 * 16</strong> &#x3D; <strong>128</strong>， 也就是这个数组只用了低 64 位， 高 64 位并没有使用。这说明在我的机器上，select 函数支持操作的最大 fd 数量是 64。</p>\n<p>同理，如果我们需要从 fd_set 上删除一个 fd，我们可以调用 <strong>FD_CLR</strong>，其定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void FD_CLR(int fd, fd_set *set);</span><br></pre></td></tr></table></figure>\n\n<p>原理和 <strong>FD_SET</strong> 相同，即将对应的标志位由1变0即可。</p>\n<p>如果，我们需要将 fd_set 中所有的 fd 都清掉，则使用宏 <strong>FD_ZERO</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void FD_ZERO(fd_set *set);</span><br></pre></td></tr></table></figure>\n\n<p>当 select 函数返回时， 我们使用 <strong>FD_ISSET</strong> 宏来判断某个 fd 是否有我们关心的事件，<strong>FD_ISSET</strong> 宏的定义如下：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int  FD_ISSET(int fd, fd_set *set);</span><br></pre></td></tr></table></figure>\n\n<p><strong>FD_ISSET</strong> 宏本质上就是检测对应的位置上是否置 1，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __FD_ISSET(d, set) \\</span><br><span class=\"line\">    ((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提醒一下： __FD_ELT 和 __FD_MASK 宏前文的代码已经给过具体实现了。</p>\n</blockquote>\n<ul>\n<li><p>参数 <strong>timeout</strong>，超时时间，即在这个参数设定的时间内检测这些 fd 的事件，超过这个时间后 <strong>select</strong> 函数将立即返回。这是一个 <strong>timeval</strong> 类型结构体，其定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct timeval </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  long    tv_sec;         /* seconds */</span><br><span class=\"line\">  long    tv_usec;        /* microseconds */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>select</strong> 函数的总超时时间是 <strong>timeout-&gt;tv_sec</strong> 和 <strong>timeout-&gt;tv_usec</strong> 之和， 前者的时间单位是秒，后者的时间单位是微妙。</p>\n</li>\n</ul>\n<p>说了这么多理论知识，我们先看一个具体的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * select函数示例，server端, select_server.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.24</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;sys/time.h&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//自定义代表无效fd的值</span><br><span class=\"line\">#define INVALID_FD -1</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //创建一个侦听socket</span><br><span class=\"line\">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (listenfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //初始化服务器地址</span><br><span class=\"line\">    struct sockaddr_in bindaddr;</span><br><span class=\"line\">    bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //启动侦听</span><br><span class=\"line\">    if (listen(listenfd, SOMAXCONN) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //存储客户端socket的数组</span><br><span class=\"line\">    std::vector&lt;int&gt; clientfds;</span><br><span class=\"line\">    int maxfd = listenfd;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (true) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        fd_set readset;</span><br><span class=\"line\">        FD_ZERO(&amp;readset);</span><br><span class=\"line\"></span><br><span class=\"line\">        //将侦听socket加入到待检测的可读事件中去</span><br><span class=\"line\">        FD_SET(listenfd, &amp;readset);</span><br><span class=\"line\"></span><br><span class=\"line\">        //将客户端fd加入到待检测的可读事件中去</span><br><span class=\"line\">        int clientfdslength = clientfds.size();</span><br><span class=\"line\">        for (int i = 0; i &lt; clientfdslength; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (clientfds[i] != INVALID_FD)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                FD_SET(clientfds[i], &amp;readset);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        timeval tm;</span><br><span class=\"line\">        tm.tv_sec = 1;</span><br><span class=\"line\">        tm.tv_usec = 0;</span><br><span class=\"line\">        //暂且只检测可读事件，不检测可写和异常事件</span><br><span class=\"line\">        int ret = select(maxfd + 1, &amp;readset, NULL, NULL, &amp;tm);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //出错，退出程序。</span><br><span class=\"line\">            if (errno != EINTR)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (ret == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //select 函数超时，下次继续</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //检测到某个socket有事件</span><br><span class=\"line\">            if (FD_ISSET(listenfd, &amp;readset))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //侦听socket的可读事件，则表明有新的连接到来</span><br><span class=\"line\">                struct sockaddr_in clientaddr;</span><br><span class=\"line\">                socklen_t clientaddrlen = sizeof(clientaddr);</span><br><span class=\"line\">                //4. 接受客户端连接</span><br><span class=\"line\">                int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class=\"line\">                if (clientfd == -1)                 </span><br><span class=\"line\">                &#123;           </span><br><span class=\"line\">                    //接受连接出错，退出程序</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                //只接受连接，不调用recv收取任何数据</span><br><span class=\"line\">                std:: cout &lt;&lt; &quot;accept a client connection, fd: &quot; &lt;&lt; clientfd &lt;&lt; std::endl;</span><br><span class=\"line\">                clientfds.push_back(clientfd);</span><br><span class=\"line\">                //记录一下最新的最大fd值，以便作为下一轮循环中select的第一个参数</span><br><span class=\"line\">                if (clientfd &gt; maxfd)</span><br><span class=\"line\">                    maxfd = clientfd;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //假设对端发来的数据长度不超过63个字符</span><br><span class=\"line\">                char recvbuf[64];</span><br><span class=\"line\">                int clientfdslength = clientfds.size();</span><br><span class=\"line\">                for (int i = 0; i &lt; clientfdslength; ++i)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (clientfds[i] != -1 &amp;&amp; FD_ISSET(clientfds[i], &amp;readset))</span><br><span class=\"line\">                    &#123;               </span><br><span class=\"line\">                        memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class=\"line\">                        //非侦听socket，则接收数据</span><br><span class=\"line\">                        int length = recv(clientfds[i], recvbuf, 64, 0);</span><br><span class=\"line\">                        if (length &lt;= 0 &amp;&amp; errno != EINTR)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            //收取数据出错了</span><br><span class=\"line\">                            std::cout &lt;&lt; &quot;recv data error, clientfd: &quot; &lt;&lt; clientfds[i] &lt;&lt; std::endl;                            </span><br><span class=\"line\">                            close(clientfds[i]);</span><br><span class=\"line\">                            //不直接删除该元素，将该位置的元素置位-1</span><br><span class=\"line\">                            clientfds[i] = INVALID_FD;</span><br><span class=\"line\">                            continue;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        std::cout &lt;&lt; &quot;clientfd: &quot; &lt;&lt; clientfds[i] &lt;&lt; &quot;, recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;                   </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭所有客户端socket</span><br><span class=\"line\">    int clientfdslength = clientfds.size();</span><br><span class=\"line\">    for (int i = 0; i &lt; clientfdslength; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (clientfds[i] != INVALID_FD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            close(clientfds[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭侦听socket</span><br><span class=\"line\">    close(listenfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们编译并运行程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# g++ -g -o select_server select_server.cpp </span><br><span class=\"line\">[root@localhost testsocket]# ./select_server </span><br></pre></td></tr></table></figure>\n\n<p>然后，我们再多开几个 shell 窗口，我们这里不再专门编写客户端程序了，我们使用 Linux 下的 <strong>nc</strong> 指令模拟出两个客户端。</p>\n<p>shell 窗口1，连接成功以后发送字符串 <strong>hello123</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# nc -v 127.0.0.1 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Connected to 127.0.0.1:3000.</span><br><span class=\"line\">hello123</span><br></pre></td></tr></table></figure>\n\n<p>shell 窗口2，连接成功以后发送字符串 <strong>helloworld</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# nc -v 127.0.0.1 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Connected to 127.0.0.1:3000.</span><br><span class=\"line\">helloworld</span><br></pre></td></tr></table></figure>\n\n<p>此时服务器端输出结果如下：</p>\n<p><img src=\"/../imgs/select1.webp\"></p>\n<p>注意，由于 <strong>nc</strong> 发送的数据是按换行符来区分的，每一个数据包默认的换行符以<strong>\\n</strong> 结束（当然，你可以 <strong>-C</strong> 选项换成\\r\\n），所以服务器收到数据后，显示出来的数据每一行下面都有一个空白行。</p>\n<p>当断开各个客户端连接时，服务器端 select 函数对各个客户端 fd 检测时，仍然会触发可读事件，此时对这些 fd 调用 recv 函数会返回 <strong>0</strong>（recv 函数返回0，表明对端关闭了连接，这是一个很重要的知识点，下文我们会有一章节专门介绍这些函数的返回值），服务器端也关闭这些连接就可以了。</p>\n<p>客户端断开连接后，服务器端的运行输出结果：</p>\n<p><img src=\"/../imgs/select2.webp\"></p>\n<p>以上代码是一个简单的服务器程序实现的基本流程，代码虽然简单，但是非常具有典型性和代表性，而且同样适用于客户端网络通信，如果用于客户端的话，只需要用 select 检测连接 socket 就可以了，如果连接 socket 有可读事件，调用 recv 函数来接收数据，剩下的逻辑都是一样的。上面的代码我们画一张流程图如下：</p>\n<p><img src=\"/../imgs/select3.webp\"></p>\n<p>关于上述代码在实际开发中有几个需要注意的事项，这里逐一来说明一下：</p>\n<p><strong>1. select 函数调用前后会修改 readfds、writefds 和 exceptfds 这三个集合中的内容（如果有的话），所以如果您想下次调用 select 复用这个变量，记得在下次调用前再次调用 select 前先使用 FD_ZERO 将集合清零，然后调用 FD_SET 将需要检测事件的 fd 再次添加进去</strong>。</p>\n<blockquote>\n<p>select 函数调用之后，<strong>readfds</strong>、<strong>writefds</strong> 和 <strong>exceptfds</strong> 这三个集合中存放的不是我们之前设置进去的 fd，而是有相关有读写或异常事件的 fd，也就是说 select 函数会修改这三个参数的内容，这也要求我们<strong>当一个 fd_set 被 select 函数调用后，这个 fd_set 就已经发生了改变，下次如果我们需要使用它，必须使用 FD_ZERO 宏先清零，再重新将我们关心的 fd 设置进去</strong>。这点我们从 <strong>FD_ISSET</strong> 源码也可以看出来：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __FD_ISSET(d, set) \\</span><br><span class=\"line\">   ((__FDS_BITS (set)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)</span><br></pre></td></tr></table></figure>\n\n<p>如果调用 select 函数之后没有改变 fd_set 集合，那么即使某个 socket 上没有事件，调用 select 函数之后我们用 <strong>FD_ISSET</strong> 检测，会原路得到原来设置上去的 socket。这是很多初学者在学习 select 函数容易犯的一个错误，我们通过一个示例来验证一下，这次我们把 select 函数用在客户端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证调用select后必须重设fd_set，select_client.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.24</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd_set readset;</span><br><span class=\"line\">    FD_ZERO(&amp;readset);</span><br><span class=\"line\"></span><br><span class=\"line\">    //将侦听socket加入到待检测的可读事件中去</span><br><span class=\"line\">    FD_SET(clientfd, &amp;readset); </span><br><span class=\"line\">    timeval tm;</span><br><span class=\"line\">    tm.tv_sec = 5;</span><br><span class=\"line\">    tm.tv_usec = 0; </span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    fd_set backup_readset;</span><br><span class=\"line\">    memcpy(&amp;backup_readset, &amp;readset, sizeof(fd_set));</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (memcmp(&amp;readset, &amp;backup_readset, sizeof(fd_set)) == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;equal&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;not equal&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //暂且只检测可读事件，不检测可写和异常事件</span><br><span class=\"line\">        ret = select(clientfd + 1, &amp;readset, NULL, NULL, &amp;tm);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;tm.tv_sec: &quot; &lt;&lt; tm.tv_sec &lt;&lt; &quot;, tm.tv_usec: &quot; &lt;&lt; tm.tv_usec &lt;&lt; std::endl;</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">            if (errno != EINTR)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125; else if (ret == 0)&#123;</span><br><span class=\"line\">            //select函数超时</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;no event in specific time interval, count：&quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (FD_ISSET(clientfd, &amp;readset))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //检测到可读事件</span><br><span class=\"line\">                char recvbuf[32];</span><br><span class=\"line\">                memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class=\"line\">                //假设对端发数据的时候不超过31个字符。</span><br><span class=\"line\">                int n = recv(clientfd, recvbuf, 32, 0);</span><br><span class=\"line\">                if (n &lt; 0)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">                    if (errno != EINTR)</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125; else if (n == 0) &#123;</span><br><span class=\"line\">                    //对端关闭了连接</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 shell 窗口输入以下命令编译程序产生可执行文件 <strong>select_client</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -o select_client select_client.cpp</span><br></pre></td></tr></table></figure>\n\n<p>这次产生的是客户端程序，服务器程序我们这里使用 Linux <strong>nc</strong> 命令来模拟一下，由于客户端连接的是 <strong>127.0.0.1:3000</strong> 这个地址和端口号，所以我们在另外一个shell 窗口的 <strong>nc</strong> 命令的参数可以这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -v -l 0.0.0.0 3000</span><br></pre></td></tr></table></figure>\n\n<p>执行效果如下：接着我们启动客户端 <strong>select_client</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun testsocket]# ./select_client </span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，这里我故意将客户端代码中 select 函数的超时时间设置为5秒，以足够我们在这 5 秒内给客户端发一个数据。如果我们在 5 秒内给客户端发送 <strong>hello</strong> 字符串：</p>\n<p><img src=\"/../imgs/select4.webp\"></p>\n<p>客户端输出如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun testsocket]# ./select_client </span><br><span class=\"line\">equal</span><br><span class=\"line\">recv data: hello</span><br><span class=\"line\"></span><br><span class=\"line\">...部分数据省略...</span><br><span class=\"line\">not equal</span><br><span class=\"line\">tm.tv_sec: 0, tm.tv_usec: 0</span><br><span class=\"line\">no event in specific time interval, count：31454</span><br><span class=\"line\">not equal</span><br><span class=\"line\">tm.tv_sec: 0, tm.tv_usec: 0</span><br><span class=\"line\">no event in specific time interval, count：31455</span><br><span class=\"line\">not equal</span><br><span class=\"line\">tm.tv_sec: 0, tm.tv_usec: 0</span><br><span class=\"line\">no event in specific time interval, count：31456</span><br><span class=\"line\">not equal</span><br><span class=\"line\">tm.tv_sec: 0, tm.tv_usec: 0</span><br><span class=\"line\">no event in specific time interval, count：31457</span><br><span class=\"line\">...部分输出省略...</span><br></pre></td></tr></table></figure>\n\n<p>除了第一次 <strong>select_client</strong> 会输出 <strong>equal</strong> 字样，后面再也没输出，而 <strong>select</strong> 函数以后的执行结果也是超时，即使此时服务器端再次给客户端发送数据。因此验证了：<strong>select 函数执行后，确实会对三个参数的 fd_set 进行修改</strong> 。<strong>select</strong> 函数修改某个 fd_set 集合可以使用如下两张图来说明一下：</p>\n<p><img src=\"/../imgs/select5.webp\"></p>\n<p><img src=\"/../imgs/select6.webp\"></p>\n<p>因此在调用 <strong>select</strong> 函数以后， 原来位置的的标志位可能已经不复存在，这也就是为什么我们的代码中调用一次 <strong>select</strong> 函数以后，即使服务器端再次发送数据过来，<strong>select</strong> 函数也不会再因为存在可读事件而返回了，因为第二次 clientfd 已经不在那个 read_set 中了。因此如果复用这些 fd_set 变量，必须按上文所说的重新清零再重新添加关心的 socket 到集合中去。</p>\n<p><strong>2. select 函数也会修改 timeval 结构体的值，这也要求我们如果像复用这个变量，必须给 timeval 变量重新设置值。</strong></p>\n<p>注意观察上面的例子的输出，我们在调用 <strong>select</strong> 函数一次之后，变量 tv 的值也被修改了。具体修改成多少，得看系统的表现。当然这种特性却不是跨平台的，在 Linux 系统中是这样的，而在其他操作系统上却不一定是这样（Windows 上就不会修改这个结构体的值），这点在 Linux man 手册 <strong>select</strong> 函数的说明中说的很清楚：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On  Linux,  select()  modifies timeout to reflect the amount</span><br><span class=\"line\">of time not slept; most other implementations do not do this.</span><br><span class=\"line\">(POSIX.1-2001 permits either behavior.)  This causes problems </span><br><span class=\"line\">both when Linux code which reads timeout is ported to  other </span><br><span class=\"line\">operating systems, and when code is ported to Linux that reuses</span><br><span class=\"line\">a struct timeval for multiple select()s in a loop without</span><br><span class=\"line\">reinitializing it.  Consider timeout to be undefined after</span><br><span class=\"line\">select() returns.</span><br></pre></td></tr></table></figure>\n\n<p>由于不同系统的实现不一样，man 手册的建议将 <strong>select</strong> 函数修改 <strong>timeval</strong> 结构体的值的行为当作是未定义的，言下之意是<strong>如果你要下次使用 select 函数复用这个变量时，记得重新赋值</strong>。这是 select 函数需要注意的第二个地方。</p>\n<p><strong>3. select 函数的 timeval 结构体的 tv_sec 和 tv_sec 如果两个值设置为 0，即检测事件总时间设置为0，其行为是 select 会检测一下相关集合中的 fd，如果没有需要的事件，则立即返回</strong>。</p>\n<p>我们将上述 <strong>select_client.cpp</strong> 修改一下，修改后的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证select时间参数设置为0，select_client_tv0.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.25</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fd_set readset;</span><br><span class=\"line\">        FD_ZERO(&amp;readset);</span><br><span class=\"line\">        //将侦听socket加入到待检测的可读事件中去</span><br><span class=\"line\">        FD_SET(clientfd, &amp;readset); </span><br><span class=\"line\">        timeval tm;</span><br><span class=\"line\">        tm.tv_sec = 0;</span><br><span class=\"line\">        tm.tv_usec = 0; </span><br><span class=\"line\"></span><br><span class=\"line\">        //暂且只检测可读事件，不检测可写和异常事件</span><br><span class=\"line\">        ret = select(clientfd + 1, &amp;readset, NULL, NULL, &amp;tm);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;tm.tv_sec: &quot; &lt;&lt; tm.tv_sec &lt;&lt; &quot;, tm.tv_usec: &quot; &lt;&lt; tm.tv_usec &lt;&lt; std::endl;</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">            if (errno != EINTR)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125; else if (ret == 0)&#123;</span><br><span class=\"line\">            //select函数超时</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;no event in specific time interval.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (FD_ISSET(clientfd, &amp;readset))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //检测到可读事件</span><br><span class=\"line\">                char recvbuf[32];</span><br><span class=\"line\">                memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class=\"line\">                //假设对端发数据的时候不超过31个字符。</span><br><span class=\"line\">                int n = recv(clientfd, recvbuf, 32, 0);</span><br><span class=\"line\">                if (n &lt; 0)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">                    if (errno != EINTR)</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125; else if (n == 0) &#123;</span><br><span class=\"line\">                    //对端关闭了连接</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果确实如我们预期的，这里 select 函数只是简单地检测一下 clientfd，并不会等待固定的时间，然后立即返回。</p>\n<p><img src=\"/../imgs/select7.webp\"></p>\n<p><strong>4. 如果将 select 函数的 timeval 参数设置为 NULL，则 select 函数会一直阻塞下去，直到我们需要的事件触发。</strong></p>\n<p>我们将上述代码再修改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证select时间参数设置为NULL，select_client_tvnull.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.25</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int ret;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fd_set readset;</span><br><span class=\"line\">        FD_ZERO(&amp;readset);</span><br><span class=\"line\">        //将侦听socket加入到待检测的可读事件中去</span><br><span class=\"line\">        FD_SET(clientfd, &amp;readset); </span><br><span class=\"line\">        //timeval tm;</span><br><span class=\"line\">        //tm.tv_sec = 0;</span><br><span class=\"line\">        //tm.tv_usec = 0;   </span><br><span class=\"line\"></span><br><span class=\"line\">        //暂且只检测可读事件，不检测可写和异常事件</span><br><span class=\"line\">        ret = select(clientfd + 1, &amp;readset, NULL, NULL, NULL);</span><br><span class=\"line\">        if (ret == -1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">            if (errno != EINTR)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125; else if (ret == 0)&#123;</span><br><span class=\"line\">            //select函数超时</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;no event in specific time interval.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (FD_ISSET(clientfd, &amp;readset))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //检测到可读事件</span><br><span class=\"line\">                char recvbuf[32];</span><br><span class=\"line\">                memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class=\"line\">                //假设对端发数据的时候不超过31个字符。</span><br><span class=\"line\">                int n = recv(clientfd, recvbuf, 32, 0);</span><br><span class=\"line\">                if (n &lt; 0)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    //除了被信号中断的情形，其他情况都是出错</span><br><span class=\"line\">                    if (errno != EINTR)</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125; else if (n == 0) &#123;</span><br><span class=\"line\">                    //对端关闭了连接</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    std::cout &lt;&lt; &quot;recv data: &quot; &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;other socket event.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先在另外一个 shell 窗口用 <strong>nc</strong> 命令模拟一个服务器，监听的 ip 地址和端口号是 <strong>0.0.0.0:3000</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun ~]# nc -v -l 0.0.0.0 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Listening on 0.0.0.0:3000</span><br></pre></td></tr></table></figure>\n\n<p>然后回到原来的 shell 窗口，编译上述 <strong>select_client_tvnull.cpp</strong>，并使用 gdb 运行程序，这次使用 gdb 运行程序的目的是为了当程序“卡”在某个位置时，我们可以使用 Ctrl + C 把程序中断下来看看程序阻塞在哪个函数调用处：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun testsocket]# g++ -g -o select_client_tvnull select_client_tvnull.cpp </span><br><span class=\"line\">[root@myaliyun testsocket]# gdb select_client_tvnull</span><br><span class=\"line\">Reading symbols from /root/testsocket/select_client_tvnull...done.</span><br><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /root/testsocket/select_client_tvnull </span><br><span class=\"line\">^C</span><br><span class=\"line\">Program received signal SIGINT, Interrupt.</span><br><span class=\"line\">0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6</span><br><span class=\"line\">Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64 libgcc-4.8.5-16.el7_4.1.x86_64 libstdc++-4.8.5-16.el7_4.1.x86_64</span><br><span class=\"line\">(gdb) bt</span><br><span class=\"line\">#0  0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6</span><br><span class=\"line\">#1  0x0000000000400c75 in main (argc=1, argv=0x7fffffffe5f8) at select_client_tvnull.cpp:51</span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\">recv data: hello</span><br><span class=\"line\"></span><br><span class=\"line\">^C</span><br><span class=\"line\">Program received signal SIGINT, Interrupt.</span><br><span class=\"line\">0x00007ffff72e7783 in __select_nocancel () from /lib64/libc.so.6</span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\">recv data: world</span><br></pre></td></tr></table></figure>\n\n<p>如上输出结果所示，我们使用 gdb 的 <strong>r</strong> 命令（run）将程序跑起来后，程序卡在某个地方，我们按 Ctrl + C（代码中的 <strong>^C</strong>）中断程序后使用 <strong>bt</strong> 命令查看当前程序的调用堆栈，发现确实阻塞在 <strong>select</strong> 函数调用处；接着我们在服务器端给客户端发送一个 <strong>hello</strong> 数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun ~]# nc -v -l 0.0.0.0 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Listening on 0.0.0.0:3000</span><br><span class=\"line\">Ncat: Connection from 127.0.0.1.</span><br><span class=\"line\">Ncat: Connection from 127.0.0.1:55968.</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<p>客户端收到数据后，<strong>select</strong> 函数满足条件，立即返回，并将数据输出来后继续进行下一轮 <strong>select</strong> 检测，我们使用 Ctrl + C 将程序中断，发现程序又阻塞在 <strong>select</strong> 调用处；输入 <strong>c</strong> 命令（continue）让程序继续运行， 此时，我们再用服务器端给客户端发送 <strong>world</strong> 字符串，<strong>select</strong> 函数再次返回，并将数据打印出来，然后继续进入下一轮 select 检测，并继续在 select 处阻塞。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@myaliyun ~]# nc -v -l 0.0.0.0 3000</span><br><span class=\"line\">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class=\"line\">Ncat: Listening on 0.0.0.0:3000</span><br><span class=\"line\">Ncat: Connection from 127.0.0.1.</span><br><span class=\"line\">Ncat: Connection from 127.0.0.1:55968.</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>5. 在 Linux 平台上，select 函数的第一个参数必须设置成需要检测事件的所有 fd 中的最大值加1</strong>。所以上文中 <strong>select_server.cpp</strong> 中，每新产生一个 clientfd，我都会与当前最大的 <strong>maxfd</strong> 作比较，如果大于当前的 <strong>maxfd</strong> 则将 <strong>maxfd</strong> 更新成这个新的最大值。其最终目的是为了在 <strong>select</strong> 调用时作为第一个参数（加 1）传进去。</p>\n<blockquote>\n<p>在 Windows 平台上，select 函数的第一个值传任意值都可以，Windows 系统本身不使用这个值，只是为了兼容性而保留了这个参数，但是在实际开发中为了兼容跨平台代码，也会按惯例，将这个值设置为最大 socket 加 1。这点请读者注意。</p>\n</blockquote>\n<p>以上是我总结的 Linux 下 select 使用的<strong>五个注意事项</strong>，希望读者能理解它们。</p>\n","text":"select 函数重难点解析select 函数是网络通信编程中非常常用的一个函数，因此应该熟练掌握它。虽然它是 BSD 标准之一的 Socket 函数之一，但在...","permalink":"/post/转载/网络编程/select函数重难点解析","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#select-%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">select 函数重难点解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84-select-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Linux 平台下的 select 函数</span></a></li></ol></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】bind函数重难点解析","uid":"a48f84a55618baa7dd151ec12f4ef58e","slug":"转载/网络编程/bind函数重难点解析","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.398Z","comments":true,"path":"api/articles/转载/网络编程/bind函数重难点解析.json","keywords":null,"cover":null,"text":"bind 函数重难点解析bind 函数如何选择绑定地址bind 函数的基本用法如下： 123456789struct sockaddr_in bindaddr;...","permalink":"/post/转载/网络编程/bind函数重难点解析","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】socket的阻塞模式和非阻塞模式","uid":"fb6fadde5a0ca98e5162a3e35095bf9a","slug":"转载/网络编程/socket的阻塞模式和非阻塞模式","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/socket的阻塞模式和非阻塞模式.json","keywords":null,"cover":[],"text":"socket 的阻塞模式和非阻塞模式对 socket 在阻塞和非阻塞模式下的各个函数的行为差别深入的理解是掌握网络编程的基本要求之一，是重点也是难点。 阻塞和非...","permalink":"/post/转载/网络编程/socket的阻塞模式和非阻塞模式","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}