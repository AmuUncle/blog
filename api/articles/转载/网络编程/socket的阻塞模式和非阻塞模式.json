{"title":"【转载】socket的阻塞模式和非阻塞模式","uid":"fb6fadde5a0ca98e5162a3e35095bf9a","slug":"转载/网络编程/socket的阻塞模式和非阻塞模式","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/socket的阻塞模式和非阻塞模式.json","keywords":null,"cover":[],"content":"<h1 id=\"socket-的阻塞模式和非阻塞模式\"><a href=\"#socket-的阻塞模式和非阻塞模式\" class=\"headerlink\" title=\"socket 的阻塞模式和非阻塞模式\"></a>socket 的阻塞模式和非阻塞模式</h1><p>对 socket 在阻塞和非阻塞模式下的各个函数的行为差别深入的理解是掌握网络编程的基本要求之一，是重点也是难点。</p>\n<p>阻塞和非阻塞模式下，我们常讨论的具有不同行为表现的 socket 函数一般有如下几个，见下表：</p>\n<ul>\n<li>connect</li>\n<li>accept</li>\n<li>send (Linux 平台上对 socket 进行操作时也包括 <strong>write</strong> 函数，下文中对 send 函数的讨论也适用于 <strong>write</strong> 函数)</li>\n<li>recv (Linux 平台上对 socket 进行操作时也包括 <strong>read</strong> 函数，下文中对 recv 函数的讨论也适用于 <strong>read</strong> 函数)</li>\n</ul>\n<p>限于文章篇幅，本文只讨论 send 和recv函数，connect 和 accept 函数我们将在该系列的后面文章中讨论。在正式讨论之前，我们先解释一下阻塞模式和非阻塞模式的概念。所谓<strong>阻塞模式</strong>，<strong>就当某个函数“执行成功的条件”当前不能满足时，该函数会阻塞当前执行线程，程序执行流在超时时间到达或“执行成功的条件”满足后恢复继续执行</strong>。而<strong>非阻塞模式</strong>恰恰相反，即使某个函数的“执行成功的条件”不当前不能满足，该函数也不会阻塞当前执行线程，而是立即返回，继续运行执行程序流。如果读者不太明白这两个定义也没关系，后面我们会以具体的示例来讲解这两种模式的区别。</p>\n<h2 id=\"如何将-socket-设置成非阻塞模式\"><a href=\"#如何将-socket-设置成非阻塞模式\" class=\"headerlink\" title=\"如何将 socket 设置成非阻塞模式\"></a>如何将 socket 设置成非阻塞模式</h2><p>无论是 Windows 还是 Linux 平台，默认创建的 socket 都是阻塞模式的。</p>\n<p>在 Linux 平台上，我们可以使用 <strong>fcntl() 函数</strong>或 <strong>ioctl() 函数</strong>给创建的 socket 增加 <strong>O_NONBLOCK</strong> 标志来将 socket 设置成非阻塞模式。示例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int oldSocketFlag = fcntl(sockfd, F_GETFL, 0);</span><br><span class=\"line\">int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">fcntl(sockfd, F_SETFL,  newSocketFlag);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ioctl() 函数</strong> 与 <strong>fcntl()</strong> 函数使用方式基本一致，这里就不再给出示例代码了。</p>\n<p>当然，Linux 下的 <strong>socket()</strong> 创建函数也可以直接在创建时将 socket 设置为非阻塞模式，<strong>socket()</strong> 函数的签名如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>\n\n<p>给 <strong>type</strong> 参数增加一个 <strong>SOCK_NONBLOCK</strong> 标志即可，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);</span><br></pre></td></tr></table></figure>\n\n<p>不仅如此，Linux 系统下利用 accept() 函数返回的代表与客户端通信的 socket 也提供了一个扩展函数 **accept4()**，直接将 accept 函数返回的 socket 设置成非阻塞的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); </span><br><span class=\"line\">int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);</span><br></pre></td></tr></table></figure>\n\n<p>只要将 <strong>accept4()</strong> 函数最后一个参数 <strong>flags</strong> 设置成 <strong>SOCK_NONBLOCK</strong> 即可。也就是说以下代码是等价的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socklen_t addrlen = sizeof(clientaddr);</span><br><span class=\"line\">int clientfd = accept4(listenfd, &amp;clientaddr, &amp;addrlen, SOCK_NONBLOCK);</span><br><span class=\"line\">socklen_t addrlen = sizeof(clientaddr);</span><br><span class=\"line\">int clientfd = accept(listenfd, &amp;clientaddr, &amp;addrlen);</span><br><span class=\"line\">if (clientfd != -1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    fcntl(clientfd, F_SETFL,  newSocketFlag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Windows 平台上，可以调用 <strong>ioctlsocket() 函数</strong> 将 socket 设置成非阻塞模式，<strong>ioctlsocket()</strong> 签名如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctlsocket(SOCKET s, long cmd, u_long *argp);</span><br></pre></td></tr></table></figure>\n\n<p>将 <strong>cmd</strong> 参数设置为 <strong>FIONBIO</strong>，*<strong>argp*</strong> <em>设置为 <strong>0</strong> 即可将 socket 设置成阻塞模式，而将</em> <strong>argp</strong> 设置成非 <strong>0</strong> 即可设置成非阻塞模式。示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//将 socket 设置成非阻塞模式</span><br><span class=\"line\">u_long argp = 1;</span><br><span class=\"line\">ioctlsocket(s, FIONBIO, &amp;argp);</span><br><span class=\"line\"></span><br><span class=\"line\">//将 socket 设置成阻塞模式</span><br><span class=\"line\">u_long argp = 0;</span><br><span class=\"line\">ioctlsocket(s, FIONBIO, &amp;argp);</span><br></pre></td></tr></table></figure>\n\n<p>Windows 平台需要注意一个地方，如果对一个 socket 调用了 <strong>WSAAsyncSelect()</strong> 或 <strong>WSAEventSelect()</strong> 函数后，再调用 <strong>ioctlsocket()</strong> 函数将该 socket 设置为非阻塞模式会失败，你必须先调用 <strong>WSAAsyncSelect()</strong> 通过将 <strong>lEvent</strong> 参数为 <strong>0</strong> 或调用 <strong>WSAEventSelect()</strong> 通过设置 <strong>lNetworkEvents</strong> 参数为 <strong>0</strong> 来清除已经设置的 socket 相关标志位，再次调用 <strong>ioctlsocket()</strong> 将该 socket 设置成阻塞模式才会成功。因为调用 <strong>WSAAsyncSelect()</strong> 或<strong>WSAEventSelect()</strong> 函数会自动将 socket 设置成非阻塞模式。MSDN 上原文（<a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-ioctlsocket%EF%BC%89%E5%A6%82%E4%B8%8B%EF%BC%9A\">https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-ioctlsocket）如下：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The WSAAsyncSelect and WSAEventSelect functions automatically set a socket to nonblocking mode. If WSAAsyncSelect or WSAEventSelect has been issued on a socket, then any attempt to use ioctlsocket to set the socket back to blocking mode will fail with WSAEINVAL.</span><br><span class=\"line\"></span><br><span class=\"line\">To set the socket back to blocking mode, an application must first disable WSAAsyncSelect by calling WSAAsyncSelect with the lEvent parameter equal to zero, or disable WSAEventSelect by calling WSAEventSelect with the lNetworkEvents parameter equal to zero.</span><br></pre></td></tr></table></figure>\n\n<p>关于 <strong>WSAAsyncSelect()</strong> 和 <strong>WSAEventSelect()</strong> 这两个函数，后文中会详细讲解。</p>\n<blockquote>\n<p>注意事项：无论是 Linux 的 fcntl 函数，还是 Windows 的 ioctlsocket，建议读者在实际编码中判断一下函数返回值以确定是否调用成功。</p>\n</blockquote>\n<p><strong>send 和 recv 函数在阻塞和非阻塞模式下的行为</strong></p>\n<p>send 和 recv 函数其实名不符实。</p>\n<p>send 函数本质上并不是往网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区（下文为了叙述方便，我们以“网卡缓冲区”代指）中去，至于什么时候数据会从网卡缓冲区中真正地发到网络中去要根据 TCP&#x2F;IP 协议栈的行为来确定，这种行为涉及到一个叫 nagel 算法和 TCP_NODELAY 的 socket 选项，我们将在《<strong>nagle算法与 TCP_NODELAY</strong>》章节详细介绍。</p>\n<p>recv 函数本质上也并不是从网络上收取数据，而只是将内核缓冲区中的数据拷贝到应用程序的缓冲区中，当然拷贝完成以后会将内核缓冲区中该部分数据移除。</p>\n<p>可以用下面一张图来描述上述事实：</p>\n<p><img src=\"/../imgs/socketmode1.webp\"></p>\n<p>通过上图我们知道，不同的程序进行网络通信时，发送的一方会将内核缓冲区的数据通过网络传输给接收方的内核缓冲区。在应用程序 A 与 应用程序 B 建立了 TCP 连接之后，假设应用程序 A 不断调用 send 函数，这样数据会不断拷贝至对应的内核缓冲区中，如果 B 那一端一直不调用 recv 函数，那么 B 的内核缓冲区被填满以后，A 的内核缓冲区也会被填满，此时 A 继续调用 send 函数会是什么结果呢？ 具体的结果取决于该 socket 是否是阻塞模式。我们这里先给出结论：</p>\n<ul>\n<li>当 socket 是阻塞模式的，继续调用 send&#x2F;recv 函数会导致程序阻塞在 send&#x2F;recv 调用处。</li>\n<li>当 socket 是非阻塞模式，继续调用 send&#x2F;recv 函数，send&#x2F;recv 函数不会阻塞程序执行流，而是会立即出错返回，我们会得到一个相关的错误码，Linux 平台上该错误码为 EWOULDBLOCK 或 EAGAIN（这两个错误码值相同），Windows 平台上错误码为 WSAEWOULDBLOCK。</li>\n</ul>\n<p>我们实际来编写一下代码来验证一下以上说的两种情况。</p>\n<h2 id=\"socket-阻塞模式下的-send-行为\"><a href=\"#socket-阻塞模式下的-send-行为\" class=\"headerlink\" title=\"socket 阻塞模式下的 send 行为\"></a>socket 阻塞模式下的 send 行为</h2><p>服务端代码（blocking_server.cpp）如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证阻塞模式下send函数的行为，server端</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个侦听socket</span><br><span class=\"line\">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (listenfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.初始化服务器地址</span><br><span class=\"line\">    struct sockaddr_in bindaddr;</span><br><span class=\"line\">    bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //3.启动侦听</span><br><span class=\"line\">    if (listen(listenfd, SOMAXCONN) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        struct sockaddr_in clientaddr;</span><br><span class=\"line\">        socklen_t clientaddrlen = sizeof(clientaddr);</span><br><span class=\"line\">        //4. 接受客户端连接</span><br><span class=\"line\">        int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class=\"line\">        if (clientfd != -1)</span><br><span class=\"line\">        &#123;             </span><br><span class=\"line\">            //只接受连接，不调用recv收取任何数据</span><br><span class=\"line\">            std:: cout &lt;&lt; &quot;accept a client connection.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //7.关闭侦听socket</span><br><span class=\"line\">    close(listenfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码（blocking_client.cpp）如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证阻塞模式下send函数的行为，client端</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //3. 不断向服务器发送数据，或者出错退出</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);</span><br><span class=\"line\">        if (ret != strlen(SEND_DATA))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 shell 中分别编译这两个 cpp 文件得到两个可执行程序 <strong>blocking_server</strong> 和 <strong>blocking_client</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -o blocking_server blocking_server.cpp</span><br><span class=\"line\">g++ -g -o blocking_client blocking_client.cpp</span><br></pre></td></tr></table></figure>\n\n<p>我们先启动 <strong>blocking_server</strong>，然后用 gdb 启动 <strong>blocking_client</strong>，输入 <strong>run</strong> 命令让 <strong>blocking_client</strong>跑起来，<strong>blocking_client</strong> 会不断地向 <strong>blocking_server</strong> 发送”<strong>helloworld</strong>“字符串，每次 send 成功后，会将计数器 <strong>count</strong> 的值打印出来，计数器会不断增加，程序运行一段时间后，计数器 <strong>count</strong> 值不再增加且程序不再有输出。操作过程及输出结果如下：</p>\n<p><strong>blocking_server</strong> 端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# ./blocking_server </span><br><span class=\"line\">accept a client connection.</span><br><span class=\"line\">[root@localhost testsocket]# gdb blocking_client</span><br><span class=\"line\">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-100.el7_4.1</span><br><span class=\"line\">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class=\"line\">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class=\"line\">This is free software: you are free to change and redistribute it.</span><br><span class=\"line\">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class=\"line\">and &quot;show warranty&quot; for details.</span><br><span class=\"line\">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class=\"line\">For bug reporting instructions, please see:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class=\"line\">Reading symbols from /root/testsocket/blocking_client...done.</span><br><span class=\"line\">(gdb) run</span><br><span class=\"line\">//输出结果太多，省略部分...</span><br><span class=\"line\">send data successfully, count = 355384</span><br><span class=\"line\">send data successfully, count = 355385</span><br><span class=\"line\">send data successfully, count = 355386</span><br><span class=\"line\">send data successfully, count = 355387</span><br><span class=\"line\">send data successfully, count = 355388</span><br><span class=\"line\">send data successfully, count = 355389</span><br><span class=\"line\">send data successfully, count = 355390</span><br></pre></td></tr></table></figure>\n\n<p>此时程序不再有输出，说明我们的程序应该“卡在”某个地方，继续按 <strong>Ctrl + C</strong> 让 gdb 中断下来，输入 <strong>bt</strong> 命令查看此时的调用堆栈，我们发现我们的程序确实阻塞在 <strong>send</strong> 函数调用处：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^C</span><br><span class=\"line\">Program received signal SIGINT, Interrupt.</span><br><span class=\"line\">0x00007ffff72f130d in send () from /lib64/libc.so.6</span><br><span class=\"line\">(gdb) bt</span><br><span class=\"line\">#0  0x00007ffff72f130d in send () from /lib64/libc.so.6</span><br><span class=\"line\">#1  0x0000000000400b46 in main (argc=1, argv=0x7fffffffe598) at blocking_client.cpp:41</span><br><span class=\"line\">(gdb) </span><br></pre></td></tr></table></figure>\n\n<p>上面的示例验证了如果一端一直发数据，而对端应用层一直不取数据（或收取数据的速度慢于发送速度），则很快两端的内核缓冲区很快就会被填满，导致发送端调用 send 函数被阻塞。这里说的“<strong>内核缓冲区</strong>” 其实有个专门的名字，即 TCP 窗口。也就是说 socket 阻塞模式下， send 函数在 TCP 窗口太小时的行为是阻塞当前程序执行流（即阻塞 send 函数所在的线程的执行）。</p>\n<p>说点题外话，上面的例子，我们每次发送一个“<strong>helloworld</strong>”（10个字节），一共发了 355390 次（每次测试的结果略有不同），我们可以粗略地算出 TCP 窗口的大小大约等于 1.7 M左右 （10 * 355390 &#x2F; 2）。</p>\n<p>让我们再深入一点，我们利用 Linux tcpdump 工具来动态看一下这种情形下 TCP 窗口大小的动态变化。需要注意的是，Linux 下使用 tcpdump 这个命令需要有 root 权限。</p>\n<p>我们开启三个 shell 窗口，在第一个窗口先启动 <strong>blocking_server</strong> 进程，在第二个窗口用 tcpdump 抓经过 TCP 端口 3000 上的数据包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# tcpdump -i any -nn -S &#x27;tcp port 3000&#x27;    </span><br><span class=\"line\">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class=\"line\">listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br></pre></td></tr></table></figure>\n\n<p>接着在第三个 shell 窗口，启动 <strong>blocking_client</strong>。当 <strong>blocking_client</strong> 进程不再输出时，我们抓包的结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# tcpdump -i any -nn -S &#x27;tcp port 3000&#x27; </span><br><span class=\"line\">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class=\"line\">listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class=\"line\">11:52:35.907381 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [S], seq 1394135076, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">20:32:21.261484 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [S.], seq 1233000591, ack 1394135077, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 78907688,nop,wscale 7], length 0</span><br><span class=\"line\">11:52:35.907441 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0</span><br><span class=\"line\">11:52:35.907615 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135077:1394135087, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 10</span><br><span class=\"line\">11:52:35.907626 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135087, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0</span><br><span class=\"line\">11:52:35.907785 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135087:1394135097, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 10</span><br><span class=\"line\">11:52:35.907793 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135097, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0</span><br><span class=\"line\">11:52:35.907809 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1394135097:1394135107, ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 10</span><br><span class=\"line\">11:52:35.907814 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1394135107, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0</span><br><span class=\"line\">...内容太长， 部分省略...</span><br><span class=\"line\">11:52:40.075794 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395013717, win 374, options [nop,nop,TS val 78911856 ecr 78911816], length 0</span><br><span class=\"line\">11:52:40.075829 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395013717:1395030517, ack 1233000592, win 342, options [nop,nop,TS val 78911856 ecr 78911856], length 16800</span><br><span class=\"line\">11:52:40.115847 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395030517, win 305, options [nop,nop,TS val 78911896 ecr 78911856], length 0</span><br><span class=\"line\">11:52:40.115866 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395030517:1395047317, ack 1233000592, win 342, options [nop,nop,TS val 78911896 ecr 78911896], length 16800</span><br><span class=\"line\">11:52:40.155703 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395047317, win 174, options [nop,nop,TS val 78911936 ecr 78911896], length 0</span><br><span class=\"line\">11:52:40.155752 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395047317:1395064117, ack 1233000592, win 342, options [nop,nop,TS val 78911936 ecr 78911936], length 16800</span><br><span class=\"line\">11:52:40.195132 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395064117, win 43, options [nop,nop,TS val 78911976 ecr 78911936], length 0</span><br><span class=\"line\">11:52:40.435748 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [P.], seq 1395064117:1395069621, ack 1233000592, win 342, options [nop,nop,TS val 78912216 ecr 78911976], length 5504</span><br><span class=\"line\">11:52:40.435782 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78912216 ecr 78912216], length 0</span><br><span class=\"line\">11:52:40.670661 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78912451 ecr 78912216], length 0</span><br><span class=\"line\">11:52:40.670674 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78912451 ecr 78912216], length 0</span><br><span class=\"line\">11:52:41.141703 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78912922 ecr 78912451], length 0</span><br><span class=\"line\">11:52:42.083643 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78913864 ecr 78912451], length 0</span><br><span class=\"line\">11:52:42.083655 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78913864 ecr 78912216], length 0</span><br><span class=\"line\">11:52:43.967506 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78915748 ecr 78913864], length 0</span><br><span class=\"line\">11:52:43.967532 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78915748 ecr 78912216], length 0</span><br><span class=\"line\">11:52:47.739259 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78919520 ecr 78915748], length 0</span><br><span class=\"line\">11:52:47.739274 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78919520 ecr 78912216], length 0</span><br><span class=\"line\">11:52:55.275863 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78927056 ecr 78919520], length 0</span><br><span class=\"line\">11:52:55.275931 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [.], ack 1395069621, win 0, options [nop,nop,TS val 78927056 ecr 78912216], length 0</span><br></pre></td></tr></table></figure>\n\n<p>抓取到的前三个数据包是 <strong>blocking_client</strong> 与 <strong>blocking_server</strong> 建立三次握手的过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:52:35.907381 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [S], seq 1394135076, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">20:32:21.261484 IP 127.0.0.1.3000 &gt; 127.0.0.1.40846: Flags [S.], seq 1233000591, ack 1394135077, win 43690, options [mss 65495,sackOK,TS val 78907688 ecr 78907688,nop,wscale 7], length 0</span><br><span class=\"line\">11:52:35.907441 IP 127.0.0.1.40846 &gt; 127.0.0.1.3000: Flags [.], ack 1233000592, win 342, options [nop,nop,TS val 78907688 ecr 78907688], length 0</span><br></pre></td></tr></table></figure>\n\n<p>示意图如下：</p>\n<p><img src=\"/../imgs/socketmode2.webp\"></p>\n<p>当每次 <strong>blocking_client</strong> 给 <strong>blocking_server</strong> 发数据以后，<strong>blocking_server</strong> 会应答 <strong>blocking_server</strong>，在每次应答的数据包中会带上自己的当前可用 TCP 窗口大小（看上文中结果从 <strong>127.0.0.1.3000 &gt; 127.0.0.1.40846</strong>方向的数据包的 <strong>win</strong> 字段大小变化），由于 TCP 流量控制和拥赛控制机制的存在，<strong>blocking_server</strong> 端的 TCP 窗口大小短期内会慢慢增加，后面随着接收缓冲区中数据积压越来越多， TCP 窗口会慢慢变小，最终变为 0。</p>\n<p>另外，细心的读者如果实际去做一下这个实验会发现一个现象，即当 tcpdump 已经显示对端的 TCP 窗口是 0 时， <strong>blocking_client</strong> 仍然可以继续发送一段时间的数据，此时的数据已经不是在发往对端，而是逐渐填满到本端的内核发送缓冲区中去了，这也验证了 send 函数实际上是往内核缓冲区中拷贝数据这一行为。</p>\n<h2 id=\"socket-非阻塞模式下的-send-行为\"><a href=\"#socket-非阻塞模式下的-send-行为\" class=\"headerlink\" title=\"socket 非阻塞模式下的 send 行为\"></a>socket 非阻塞模式下的 send 行为</h2><p>我们再来验证一下非阻塞 socket 的 send 行为，<strong>server</strong> 端的代码不变，我们将 <strong>blocking_client.cpp</strong> 中 socket 设置成非阻塞的，修改后的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证非阻塞模式下send函数的行为，client端，nonblocking_client.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，</span><br><span class=\"line\">    //不能在创建时就设置，这样会影响到 connect 函数的行为</span><br><span class=\"line\">    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //3. 不断向服务器发送数据，或者出错退出</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);</span><br><span class=\"line\">        if (ret == -1) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //非阻塞模式下send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK</span><br><span class=\"line\">            if (errno == EWOULDBLOCK)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            else if (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //如果被信号中断，我们继续重试</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            else </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (ret == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //对端关闭了连接，我们也关闭</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            close(clientfd);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译 <strong>nonblocking_client.cpp</strong> 得到可执行程序 <strong>nonblocking_client</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -o nonblocking_client nonblocking_client.cpp </span><br></pre></td></tr></table></figure>\n\n<p>运行 <strong>nonblocking_client</strong>，运行一段时间后，由于对端和本端的 TCP 窗口已满，数据发不出去了，但是 send 函数不会阻塞，而是立即返回，返回值是 <strong>-1</strong>（Windows 系统上 返回 SOCKET_ERROR，这个宏的值也是 <strong>-1</strong>），此时得到错误码是 <strong>EWOULDBLOCK</strong>。执行结果如下：</p>\n<p><img src=\"/../imgs/socketmode3.webp\"></p>\n<h2 id=\"socket-阻塞模式下的-recv-行为\"><a href=\"#socket-阻塞模式下的-recv-行为\" class=\"headerlink\" title=\"socket 阻塞模式下的 recv 行为\"></a>socket 阻塞模式下的 recv 行为</h2><p>在了解了 send 函数的行为，我们再来看一下阻塞模式下的 recv 函数行为。服务器端代码不需要修改，我们修改一下客户端代码，如果服务器端不给客户端发数据，此时客户端调用 recv 函数执行流会阻塞在 recv 函数调用处。继续修改一下客户端代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证阻塞模式下recv函数的行为，client端，blocking_client_recv.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //直接调用recv函数，程序会阻塞在recv函数调用处</span><br><span class=\"line\">    char recvbuf[32] = &#123;0&#125;;</span><br><span class=\"line\">    int ret = recv(clientfd, recvbuf, 32, 0);</span><br><span class=\"line\">    if (ret &gt; 0) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    else </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译 <strong>blocking_client_recv.cpp</strong> 并使用启动，我们发现程序既没有打印 recv 调用成功的信息也没有调用失败的信息，将程序中断下来，使用 <strong>bt</strong> 命令查看此时的调用堆栈，发现程序确实阻塞在 recv 函数调用处。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost testsocket]# g++ -g -o blocking_client_recv blocking_client_recv.cpp </span><br><span class=\"line\">[root@localhost testsocket]# gdb blocking_client_recv</span><br><span class=\"line\">Reading symbols from /root/testsocket/blocking_client_recv...done.</span><br><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /root/testsocket/blocking_client_recv </span><br><span class=\"line\">^C</span><br><span class=\"line\">Program received signal SIGINT, Interrupt.</span><br><span class=\"line\">0x00007ffff72f119d in recv () from /lib64/libc.so.6</span><br><span class=\"line\">Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64 libgcc-4.8.5-16.el7_4.2.x86_64 libstdc++-4.8.5-16.el7_4.2.x86_64</span><br><span class=\"line\">(gdb) bt</span><br><span class=\"line\">#0  0x00007ffff72f119d in recv () from /lib64/libc.so.6</span><br><span class=\"line\">#1  0x0000000000400b18 in main (argc=1, argv=0x7fffffffe588) at blocking_client_recv.cpp:40</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"socket-非阻塞模式下的-recv-行为\"><a href=\"#socket-非阻塞模式下的-recv-行为\" class=\"headerlink\" title=\"socket 非阻塞模式下的 recv 行为\"></a>socket 非阻塞模式下的 recv 行为</h2><p>非阻塞模式下如果当前无数据可读，recv 函数将立即返回，返回值为 <strong>-1</strong>，错误码为 <strong>EWOULDBLOCK</strong>。将客户端代码修成一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 验证阻塞模式下recv函数的行为，client端，blocking_client_recv.cpp</span><br><span class=\"line\"> * zhangyl 2018.12.17</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define SERVER_PORT     3000</span><br><span class=\"line\">#define SEND_DATA       &quot;helloworld&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建一个socket</span><br><span class=\"line\">    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (clientfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.连接服务器</span><br><span class=\"line\">    struct sockaddr_in serveraddr;</span><br><span class=\"line\">    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，</span><br><span class=\"line\">    //不能在创建时就设置，这样会影响到 connect 函数的行为</span><br><span class=\"line\">    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(clientfd);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //直接调用recv函数，程序会阻塞在recv函数调用处</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        char recvbuf[32] = &#123;0&#125;;</span><br><span class=\"line\">        int ret = recv(clientfd, recvbuf, 32, 0);</span><br><span class=\"line\">        if (ret &gt; 0) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //收到了数据</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else if (ret == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //对端关闭了连接</span><br><span class=\"line\">            std::cout &lt;&lt; &quot;peer close the socket.&quot; &lt;&lt; std::endl; </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else if (ret == -1) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (errno == EWOULDBLOCK)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;There is no data available now.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            else if (errno == EINTR) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //如果被信号中断了，则继续重试recv函数</span><br><span class=\"line\">                std::cout &lt;&lt; &quot;recv data interrupted by signal.&quot; &lt;&lt; std::endl;               </span><br><span class=\"line\">            &#125; else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //真的出错了</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5. 关闭socket</span><br><span class=\"line\">    close(clientfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果与我们预期的一模一样， recv 函数在无数据可读的情况下并不会阻塞情绪，所以程序会一直有“**There is no data available now.**”相关的输出。</p>\n<p><img src=\"/../imgs/socketmode4.webp\"></p>\n","text":"socket 的阻塞模式和非阻塞模式对 socket 在阻塞和非阻塞模式下的各个函数的行为差别深入的理解是掌握网络编程的基本要求之一，是重点也是难点。 阻塞和非...","permalink":"/post/转载/网络编程/socket的阻塞模式和非阻塞模式","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#socket-%E7%9A%84%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">socket 的阻塞模式和非阻塞模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%B0%86-socket-%E8%AE%BE%E7%BD%AE%E6%88%90%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">如何将 socket 设置成非阻塞模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#socket-%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-send-%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">socket 阻塞模式下的 send 行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#socket-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-send-%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">socket 非阻塞模式下的 send 行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#socket-%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-recv-%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">socket 阻塞模式下的 recv 行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#socket-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-recv-%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">socket 非阻塞模式下的 recv 行为</span></a></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】select函数重难点解析","uid":"424888f17e8d4fef03209498cc4923a5","slug":"转载/网络编程/select函数重难点解析","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.399Z","comments":true,"path":"api/articles/转载/网络编程/select函数重难点解析.json","keywords":null,"cover":[],"text":"select 函数重难点解析select 函数是网络通信编程中非常常用的一个函数，因此应该熟练掌握它。虽然它是 BSD 标准之一的 Socket 函数之一，但在...","permalink":"/post/转载/网络编程/select函数重难点解析","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】connect函数在阻塞和非阻塞模式下的行为","uid":"c646ab357404b495e460a8a7d56a1d77","slug":"转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.398Z","comments":true,"path":"api/articles/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为.json","keywords":null,"cover":null,"text":"connect 函数在阻塞和非阻塞模式下的行为在 socket 是阻塞模式下 connect 函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务...","permalink":"/post/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}