{"title":"【转载】服务器开发通信协议设计介绍","uid":"f4314c9e2807b5be1e4e59a1606b1819","slug":"转载/网络编程/服务器开发通信协议设计介绍","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器开发通信协议设计介绍.json","keywords":null,"cover":[],"content":"<h2 id=\"服务器开发通信协议设计介绍\"><a href=\"#服务器开发通信协议设计介绍\" class=\"headerlink\" title=\"服务器开发通信协议设计介绍\"></a>服务器开发通信协议设计介绍</h2><p><img src=\"/../imgs/protocol1.webp\"></p>\n<h2 id=\"一、选择TCP还是UDP协议\"><a href=\"#一、选择TCP还是UDP协议\" class=\"headerlink\" title=\"一、选择TCP还是UDP协议\"></a>一、选择TCP还是UDP协议</h2><p>由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所以客户端和服务器需要保持长连接状态。另外即时通讯软件一般要求信息准确、有序、完整地到达对端，而这也是TCP协议的特点之一。综合这两个所以这里我们选择TCP协议，而不是UDP协议。</p>\n<h2 id=\"二、协议的结构\"><a href=\"#二、协议的结构\" class=\"headerlink\" title=\"二、协议的结构\"></a>二、协议的结构</h2><p>由于TCP协议是流式协议，所谓流式协议即通讯的内容是无边界的字节流：如A给B连续发送了三个数据包，每个包的大小都是100个字节，那么B可能会一次性收到300个字节；也可能先收到100个字节，再收到200个字节；也可能先收到100个字节，再收到50个字节，再收到150个字节；或者先收到50个字节，再收到50个字节，再收到50个字节，最后收到150个字节。也就是说，B可能以任何组合形式收到这300个字节。即像水流一样无明确的边界。为了能让对端知道如何给包分界，目前一般有三种做法：</p>\n<ol>\n<li>以固定大小字节数目来分界，上文所说的就是属于这种类型，如每个包100个字节，对端每收齐100个字节，就当成一个包来解析；</li>\n<li>以特定符号来分界，如每个包都以特定的字符来结尾（如\\n），当在字节流中读取到该字符时，则表明上一个包到此为止。</li>\n<li>固定包头+包体结构，这种结构中一般包头部分是一个固定字节长度的结构，并且包头中会有一个特定的字段指定包体的大小。这是目前各种网络应用用的最多的一种包格式。</li>\n</ol>\n<p>上面三种分包方式各有优缺点，方法1和方法2简单易操作，但是缺点也很明显，就是很不灵活，如方法一当包数据不足指定长度，只能使用占位符如0来凑，比较浪费；方法2中包中不能有包界定符，否则就会引起歧义，也就是要求包内容中不能有某些特殊符号。而方法3虽然解决了方法1和方法2的缺点，但是操作起来就比较麻烦。我们的即时通讯协议就采用第三种分包方式。所以我们的协议包的包头看起来像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct package_header</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int32_t bodysize;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一个应用中，有许多的应用数据，拿我们这里的即时通讯来说，有注册、登录、获取好友列表、好友消息等各种各样的协议数据包，而每个包因为业务内容不一样可能数据内容也不一样，所以各个包可能看起来像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct package_header</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int32_t bodysize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//登录数据包</span><br><span class=\"line\">struct register_package</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    package_header header;</span><br><span class=\"line\">    //命令号</span><br><span class=\"line\">    int32_t cmd;</span><br><span class=\"line\">    //注册用户名</span><br><span class=\"line\">    char username[16];</span><br><span class=\"line\">    //注册密码</span><br><span class=\"line\">    char password[16];</span><br><span class=\"line\">    //注册昵称</span><br><span class=\"line\">    char nickname[16];</span><br><span class=\"line\">    //注册手机号</span><br><span class=\"line\">    char mobileno[16];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//登录数据包</span><br><span class=\"line\">struct login_package</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    package_header header;</span><br><span class=\"line\">    //命令号</span><br><span class=\"line\">    int32_t cmd;</span><br><span class=\"line\">    //登录用户名</span><br><span class=\"line\">    char username[16];</span><br><span class=\"line\">    //密码</span><br><span class=\"line\">    char password[16];</span><br><span class=\"line\">    //客户端类型</span><br><span class=\"line\">    int32_t clienttype;</span><br><span class=\"line\">    //上线类型，如在线、隐身、忙碌、离开等</span><br><span class=\"line\">    int32_t onlinetype;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//获取好友列表</span><br><span class=\"line\">struct getfriend_package</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    package_header header;</span><br><span class=\"line\">    //命令号</span><br><span class=\"line\">    int32_t cmd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//聊天内容</span><br><span class=\"line\">struct chat_package</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    package_header header;</span><br><span class=\"line\">    //命令号</span><br><span class=\"line\">    int32_t cmd;</span><br><span class=\"line\">    //发送人userid</span><br><span class=\"line\">    int32_t senderid;</span><br><span class=\"line\">    //接收人userid</span><br><span class=\"line\">    int32_t targetid;</span><br><span class=\"line\">    //消息内容</span><br><span class=\"line\">    char chatcontent[8192];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>看到没有？由于每一个业务的内容不一样，定义的结构体也不一样。如果业务比较多的话，我们需要定义各种各样的这种结构体，这简直是一场噩梦。那么有没有什么方法可以避免这个问题呢？有，我受jdk中的流对象的WriteInt32、WriteByte、WriteInt64、WriteString，这样的接口的启发，也发明了一套这样的协议，而且这套协议基本上是通用协议，可用于任何场景。我们的包还是分为包头和包体两部分，包头和上文所说的一样，包体是一个不固定大小的二进制流，其长度由包头中的指定包体长度的字段决定。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct package_protocol</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int32_t bodysize;</span><br><span class=\"line\">    //注意：C/C++语法不能这么定义结构体，</span><br><span class=\"line\">    //这里只是为了说明含义的伪代码</span><br><span class=\"line\">    //bodycontent即为一个不固定大小的二进制流</span><br><span class=\"line\">    char    binarystream[bodysize];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来的核心部分就是如何操作这个二进制流，我们将流分为二进制读和二进制写两种流，下面给出接口定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//写</span><br><span class=\"line\">class BinaryWriteStream</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BinaryWriteStream(string* data);</span><br><span class=\"line\">    const char* GetData() const;</span><br><span class=\"line\">    size_t GetSize() const;</span><br><span class=\"line\">    bool WriteCString(const char* str, size_t len);</span><br><span class=\"line\">    bool WriteString(const string&amp; str);</span><br><span class=\"line\">    bool WriteDouble(double value, bool isNULL = false);</span><br><span class=\"line\">    bool WriteInt64(int64_t value, bool isNULL = false);</span><br><span class=\"line\">    bool WriteInt32(int32_t i, bool isNULL = false);</span><br><span class=\"line\">    bool WriteShort(short i, bool isNULL = false);</span><br><span class=\"line\">    bool WriteChar(char c, bool isNULL = false);</span><br><span class=\"line\">    size_t GetCurrentPos() const&#123; return m_data-&gt;length(); &#125;</span><br><span class=\"line\">    void Flush();</span><br><span class=\"line\">    void Clear();</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string* m_data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//读</span><br><span class=\"line\">class BinaryReadStream : public IReadStream</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    const char* const ptr;</span><br><span class=\"line\">    const size_t      len;</span><br><span class=\"line\">    const char*       cur;</span><br><span class=\"line\">    BinaryReadStream(const BinaryReadStream&amp;);</span><br><span class=\"line\">    BinaryReadStream&amp; operator=(const BinaryReadStream&amp;);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BinaryReadStream(const char* ptr, size_t len);</span><br><span class=\"line\">    const char* GetData() const;</span><br><span class=\"line\">    size_t GetSize() const;</span><br><span class=\"line\">    bool IsEmpty() const;</span><br><span class=\"line\">    bool ReadString(string* str, size_t maxlen, size_t&amp; outlen);</span><br><span class=\"line\">    bool ReadCString(char* str, size_t strlen, size_t&amp; len);</span><br><span class=\"line\">    bool ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen);</span><br><span class=\"line\">    bool ReadInt32(int32_t&amp; i);</span><br><span class=\"line\">    bool ReadInt64(int64_t&amp; i);</span><br><span class=\"line\">    bool ReadShort(short&amp; i);</span><br><span class=\"line\">    bool ReadChar(char&amp; c);</span><br><span class=\"line\">    size_t ReadAll(char* szBuffer, size_t iLen) const;</span><br><span class=\"line\">    bool IsEnd() const;</span><br><span class=\"line\">    const char* GetCurrent() const&#123; return cur; &#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool ReadLength(size_t &amp; len);</span><br><span class=\"line\">    bool ReadLengthWithoutOffset(size_t &amp;headlen, size_t &amp; outlen);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样如果是上文的一个登录数据包，我们只要写成如下形式就可以了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string outbuf;</span><br><span class=\"line\">BinaryWriteStream stream(&amp;outbuf);</span><br><span class=\"line\">stream.WriteInt32(cmd);</span><br><span class=\"line\">stream.WriteCString(username, 16);</span><br><span class=\"line\">stream.WriteCString(password, 16);</span><br><span class=\"line\">stream.WriteInt32(clienttype);</span><br><span class=\"line\">stream.WriteInt32(onlinetype);</span><br><span class=\"line\">//最终数据就存储到outbuf中去了</span><br><span class=\"line\">stream.Flush();</span><br></pre></td></tr></table></figure>\n\n<p>接着我们再对端，解得正确的包体后，我们只要按写入的顺序依次读出来即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryWriteStream stream(outbuf.c_str(), outbuf.length());</span><br><span class=\"line\">int32_t cmd;</span><br><span class=\"line\">stream.WriteInt32(cmd);</span><br><span class=\"line\">char username[16];</span><br><span class=\"line\">stream.ReadCString(username, 16, NULL);</span><br><span class=\"line\">char password[16];</span><br><span class=\"line\">stream.WriteCString(password, 16, NULL);</span><br><span class=\"line\">int32_t clienttype;</span><br><span class=\"line\">stream.WriteInt32(clienttype);</span><br><span class=\"line\">int32_t onlinetype;</span><br><span class=\"line\">stream.WriteInt32(onlinetype);</span><br></pre></td></tr></table></figure>\n\n<p>这里给出BinaryReadStream和BinaryWriteStream的完整实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//计算校验和</span><br><span class=\"line\">unsigned short checksum(const unsigned short *buffer, int size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned int cksum = 0;</span><br><span class=\"line\">    while (size &gt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cksum += *buffer++;</span><br><span class=\"line\">        size -= sizeof(unsigned short);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cksum += *(unsigned char*)buffer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //将32位数转换成16</span><br><span class=\"line\">    while (cksum &gt;&gt; 16)</span><br><span class=\"line\">        cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xffff);</span><br><span class=\"line\">    return (unsigned short)(~cksum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool compress_(unsigned int i, char *buf, size_t &amp;len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    len = 0;</span><br><span class=\"line\">    for (int a = 4; a &gt;= 0; a--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">        c = i &gt;&gt; (a * 7) &amp; 0x7f;</span><br><span class=\"line\">        if (c == 0x00 &amp;&amp; len == 0)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        if (a == 0)</span><br><span class=\"line\">            c &amp;= 0x7f;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            c |= 0x80;</span><br><span class=\"line\">        buf[len] = c;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (len == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        buf[0] = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //cout &lt;&lt; &quot;compress:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    //cout &lt;&lt; &quot;compress len:&quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool uncompress_(char *buf, size_t len, unsigned int &amp;i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    i = 0;</span><br><span class=\"line\">    for (int index = 0; index &lt; (int)len; index++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        char c = *(buf + index);</span><br><span class=\"line\">        i = i &lt;&lt; 7;</span><br><span class=\"line\">        c &amp;= 0x7f;</span><br><span class=\"line\">        i |= c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //cout &lt;&lt; &quot;uncompress:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinaryReadStream::BinaryReadStream(const char* ptr_, size_t len_)</span><br><span class=\"line\">    : ptr(ptr_), len(len_), cur(ptr_)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cur += BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::IsEmpty() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return len &lt;= BINARY_PACKLEN_LEN_2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">size_t BinaryReadStream::GetSize() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadCString(char* str, size_t strlen, /* out */ size_t&amp; outlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t fieldlen;</span><br><span class=\"line\">    size_t headlen;</span><br><span class=\"line\">    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // user buffer is not enough</span><br><span class=\"line\">    if (fieldlen &gt; strlen) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 偏移到数据的位置</span><br><span class=\"line\">    //cur += BINARY_PACKLEN_LEN_2;    </span><br><span class=\"line\">    cur += headlen;</span><br><span class=\"line\">    if (cur + fieldlen &gt; ptr + len)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        outlen = 0;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memcpy(str, cur, fieldlen);</span><br><span class=\"line\">    outlen = fieldlen;</span><br><span class=\"line\">    cur += outlen;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadString(string* str, size_t maxlen, size_t&amp; outlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t headlen;</span><br><span class=\"line\">    size_t fieldlen;</span><br><span class=\"line\">    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // user buffer is not enough</span><br><span class=\"line\">    if (maxlen != 0 &amp;&amp; fieldlen &gt; maxlen) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 偏移到数据的位置</span><br><span class=\"line\">    //cur += BINARY_PACKLEN_LEN_2;    </span><br><span class=\"line\">    cur += headlen;</span><br><span class=\"line\">    if (cur + fieldlen &gt; ptr + len)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        outlen = 0;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    str-&gt;assign(cur, fieldlen);</span><br><span class=\"line\">    outlen = fieldlen;</span><br><span class=\"line\">    cur += outlen;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadCCString(const char** str, size_t maxlen, size_t&amp; outlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t headlen;</span><br><span class=\"line\">    size_t fieldlen;</span><br><span class=\"line\">    if (!ReadLengthWithoutOffset(headlen, fieldlen)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // user buffer is not enough</span><br><span class=\"line\">    if (maxlen != 0 &amp;&amp; fieldlen &gt; maxlen) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 偏移到数据的位置</span><br><span class=\"line\">    //cur += BINARY_PACKLEN_LEN_2;    </span><br><span class=\"line\">    cur += headlen;</span><br><span class=\"line\">    //memcpy(str, cur, fieldlen);</span><br><span class=\"line\">    if (cur + fieldlen &gt; ptr + len)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        outlen = 0;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *str = cur;</span><br><span class=\"line\">    outlen = fieldlen;</span><br><span class=\"line\">    cur += outlen;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadInt32(int32_t&amp; i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const int VALUE_SIZE = sizeof(int32_t);</span><br><span class=\"line\">    if (cur + VALUE_SIZE &gt; ptr + len)</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    memcpy(&amp;i, cur, VALUE_SIZE);</span><br><span class=\"line\">    i = ntohl(i);</span><br><span class=\"line\">    cur += VALUE_SIZE;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadInt64(int64_t&amp; i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char int64str[128];</span><br><span class=\"line\">    size_t length;</span><br><span class=\"line\">    if (!ReadCString(int64str, 128, length))</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    i = atoll(int64str);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadShort(short&amp; i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const int VALUE_SIZE = sizeof(short);</span><br><span class=\"line\">    if (cur + VALUE_SIZE &gt; ptr + len) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memcpy(&amp;i, cur, VALUE_SIZE);</span><br><span class=\"line\">    i = ntohs(i);</span><br><span class=\"line\">    cur += VALUE_SIZE;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadChar(char&amp; c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const int VALUE_SIZE = sizeof(char);</span><br><span class=\"line\">    if (cur + VALUE_SIZE &gt; ptr + len) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memcpy(&amp;c, cur, VALUE_SIZE);</span><br><span class=\"line\">    cur += VALUE_SIZE;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadLength(size_t &amp; outlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t headlen;</span><br><span class=\"line\">    if (!ReadLengthWithoutOffset(headlen, outlen)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //cur += BINARY_PACKLEN_LEN_2;</span><br><span class=\"line\">    cur += headlen;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::ReadLengthWithoutOffset(size_t&amp; headlen, size_t &amp; outlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    headlen = 0;</span><br><span class=\"line\">    const char *temp = cur;</span><br><span class=\"line\">    char buf[5];</span><br><span class=\"line\">    for (size_t i = 0; i&lt;sizeof(buf); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memcpy(buf + i, temp, sizeof(char));</span><br><span class=\"line\">        temp++;</span><br><span class=\"line\">        headlen++;</span><br><span class=\"line\">        //if ((buf[i] &gt;&gt; 7 | 0x0) == 0x0)</span><br><span class=\"line\">        if ((buf[i] &amp; 0x80) == 0x00)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (cur + headlen &gt; ptr + len)</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    unsigned int value;</span><br><span class=\"line\">    uncompress_(buf, headlen, value);</span><br><span class=\"line\">    outlen = value;</span><br><span class=\"line\">    /*if ( cur + BINARY_PACKLEN_LEN_2 &gt; ptr + len ) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    unsigned int tmp;</span><br><span class=\"line\">    memcpy(&amp;tmp, cur, sizeof(tmp));</span><br><span class=\"line\">    outlen = ntohl(tmp);*/</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryReadStream::IsEnd() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    assert(cur &lt;= ptr + len);</span><br><span class=\"line\">    return cur == ptr + len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const char* BinaryReadStream::GetData() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">size_t BinaryReadStream::ReadAll(char * szBuffer, size_t iLen) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t iRealLen = min(iLen, len);</span><br><span class=\"line\">    memcpy(szBuffer, ptr, iRealLen);</span><br><span class=\"line\">    return iRealLen;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//=================class BinaryWriteStream implementation============//</span><br><span class=\"line\">BinaryWriteStream::BinaryWriteStream(string *data) :</span><br><span class=\"line\">    m_data(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    m_data-&gt;clear();</span><br><span class=\"line\">    char str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];</span><br><span class=\"line\">    m_data-&gt;append(str, sizeof(str));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteCString(const char* str, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char buf[5];</span><br><span class=\"line\">    size_t buflen;</span><br><span class=\"line\">    compress_(len, buf, buflen);</span><br><span class=\"line\">    m_data-&gt;append(buf, sizeof(char)*buflen);</span><br><span class=\"line\">    m_data-&gt;append(str, len);</span><br><span class=\"line\">    //unsigned int ulen = htonl(len);</span><br><span class=\"line\">    //m_data-&gt;append((char*)&amp;ulen,sizeof(ulen));</span><br><span class=\"line\">    //m_data-&gt;append(str,len);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteString(const string&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return WriteCString(str.c_str(), str.length());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const char* BinaryWriteStream::GetData() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return m_data-&gt;data();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">size_t BinaryWriteStream::GetSize() const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return m_data-&gt;length();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteInt32(int32_t i, bool isNULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int32_t i2 = 999999999;</span><br><span class=\"line\">    if (isNULL == false)</span><br><span class=\"line\">        i2 = htonl(i);</span><br><span class=\"line\">    m_data-&gt;append((char*)&amp;i2, sizeof(i2));</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteInt64(int64_t value, bool isNULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char int64str[128];</span><br><span class=\"line\">    if (isNULL == false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    #ifndef _WIN32</span><br><span class=\"line\">        sprintf(int64str, &quot;%ld&quot;, value);</span><br><span class=\"line\">    #else</span><br><span class=\"line\">        sprintf(int64str, &quot;%lld&quot;, value);</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">        WriteCString(int64str, strlen(int64str));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        WriteCString(int64str, 0);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteShort(short i, bool isNULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    short i2 = 0;</span><br><span class=\"line\">    if (isNULL == false)</span><br><span class=\"line\">        i2 = htons(i);</span><br><span class=\"line\">    m_data-&gt;append((char*)&amp;i2, sizeof(i2));</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteChar(char c, bool isNULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char c2 = 0;</span><br><span class=\"line\">    if (isNULL == false)</span><br><span class=\"line\">        c2 = c;</span><br><span class=\"line\">    (*m_data) += c2;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool BinaryWriteStream::WriteDouble(double value, bool isNULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char   doublestr[128];</span><br><span class=\"line\">    if (isNULL == false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sprintf(doublestr, &quot;%f&quot;, value);</span><br><span class=\"line\">        WriteCString(doublestr, strlen(doublestr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        WriteCString(doublestr, 0);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void BinaryWriteStream::Flush()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char *ptr = &amp;(*m_data)[0];</span><br><span class=\"line\">    unsigned int ulen = htonl(m_data-&gt;length());</span><br><span class=\"line\">    memcpy(ptr, &amp;ulen, sizeof(ulen));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void BinaryWriteStream::Clear()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    m_data-&gt;clear();</span><br><span class=\"line\">    char str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];</span><br><span class=\"line\">    m_data-&gt;append(str, sizeof(str));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里详细解释一下上面的实现原理，即如何把各种类型的字段写入这种所谓的流中，或者怎么从这种流中读出各种类型的数据。上文的字段在流中的格式如下图：</p>\n<p><img src=\"/../imgs/protocol2.webp\"></p>\n<p>这里最简便的方式就是每个字段的长度域都是固定字节数目，如4个字节。但是这里我们并没有这么做，而是使用了一个小小技巧去对字段长度进行了一点压缩。对于字符串类型的字段，我们将表示其字段长度域的整型值（int32类型，4字节）按照其数值的大小压缩成1～5个字节，对于每一个字节，如果我们只用其低7位。最高位为标志位，为1时，表示其左边的还有下一个字节，反之到此结束。例如，对于数字127，我们二进制表示成01111111，由于最高位是0，那么如果字段长度是127及以下，一个字节就可以存储下了。如果一个字段长度大于127，如等于256，对应二进制100000000，那么我们按照刚才的规则，先填充最低字节（从左往右依次是从低到高），由于最低的7位放不下，还有后续高位字节，所以我们在最低字节的最高位上填1，即10000000，接着次高位为00000100，由于次高位后面没有更高位的字节了，所以其最高位为0，组合起来两个字节就是10000000 0000100。对于数字50000，其二进制是1100001101010000，根据每7个一拆的原则是：11 0000110 1010000再加上标志位就是：10000011 10000110 01010000。采用这样一种策略将原来占4个字节的整型值根据数值大小压缩成了1～5个字节（由于我们对数据包最大长度有限制，所以不会出现长度需要占5个字节的情形）。反过来，解析每个字段的长度，就是先取出一个字节，看其最高位是否有标志位，如果有继续取下一个字节当字段长度的一部分继续解析，直到遇到某个字节最高位不为1为止。</p>\n<p>对一个整形压缩和解压缩的部分从上面的代码中摘录如下：</p>\n<p>压缩：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1    //将一个四字节的整形数值压缩成1~5个字节</span><br><span class=\"line\"> 2    bool compress_(unsigned int i, char *buf, size_t &amp;len)</span><br><span class=\"line\"> 3    &#123;</span><br><span class=\"line\"> 4        len = 0;</span><br><span class=\"line\"> 5        for (int a = 4; a &gt;= 0; a--)</span><br><span class=\"line\"> 6        &#123;</span><br><span class=\"line\"> 7            char c;</span><br><span class=\"line\"> 8            c = i &gt;&gt; (a * 7) &amp; 0x7f;</span><br><span class=\"line\"> 9            if (c == 0x00 &amp;&amp; len == 0)</span><br><span class=\"line\">10                continue;</span><br><span class=\"line\">11            if (a == 0)</span><br><span class=\"line\">12                c &amp;= 0x7f;</span><br><span class=\"line\">13            else</span><br><span class=\"line\">14                c |= 0x80;</span><br><span class=\"line\">15            buf[len] = c;</span><br><span class=\"line\">16            len++;</span><br><span class=\"line\">17        &#125;</span><br><span class=\"line\">18        if (len == 0)</span><br><span class=\"line\">19        &#123;</span><br><span class=\"line\">20            len++;</span><br><span class=\"line\">21            buf[0] = 0;</span><br><span class=\"line\">22        &#125;</span><br><span class=\"line\">23        //cout &lt;&lt; &quot;compress:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">24        //cout &lt;&lt; &quot;compress len:&quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">25        return true;</span><br><span class=\"line\">26    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>解压</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1    //将一个1~5个字节的值还原成四字节的整形值</span><br><span class=\"line\"> 2    bool uncompress_(char *buf, size_t len, unsigned int &amp;i)</span><br><span class=\"line\"> 3    &#123;</span><br><span class=\"line\"> 4        i = 0;</span><br><span class=\"line\"> 5        for (int index = 0; index &lt; (int)len; index++)</span><br><span class=\"line\"> 6        &#123;</span><br><span class=\"line\"> 7            char c = *(buf + index);</span><br><span class=\"line\"> 8            i = i &lt;&lt; 7;</span><br><span class=\"line\"> 9            c &amp;= 0x7f;</span><br><span class=\"line\">10            i |= c;</span><br><span class=\"line\">11        &#125;</span><br><span class=\"line\">12        //cout &lt;&lt; &quot;uncompress:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">13        return true;</span><br><span class=\"line\">14    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、关于跨系统与跨语言之间的网络通信协议解析与识别问题\"><a href=\"#三、关于跨系统与跨语言之间的网络通信协议解析与识别问题\" class=\"headerlink\" title=\"三、关于跨系统与跨语言之间的网络通信协议解析与识别问题\"></a>三、关于跨系统与跨语言之间的网络通信协议解析与识别问题</h2><p>由于我们的即时通讯同时涉及到Java和C++两种编程语言，且有windows、linux、安卓三个平台，而我们为了保障学习的质量和效果，所以我们不用第三跨平台库（其实我们也是在学习如何编写这些跨平台库的原理），所以我们需要学习以下如何在Java语言中去解析C++的网络数据包或者反过来。安卓端发送的数据使用Java语言编写，pc与服务器发送的数据使用C++编写，这里以在Java中解析C++网络数据包为例。 这对于很多人来说是一件很困难的事情，所以只能变着法子使用第三方的库。其实只要你掌握了一定的基础知识，利用一些现成的字节流抓包工具（如tcpdump、wireshark）很容易解决这个问题。我们这里使用tcpdump工具来尝试分析和解决这个问题。<br>首先，我们需要明确字节序列这样一个概念，即我们说的大端编码(big endian)和小端编码(little endian)，x86和x64系列的cpu使用小端编码，而数据在网络上传输，以及Java语言中，使用的是大端编码。那么这是什么意思呢？<br>我们举个例子，看一个x64机器上的32位数值在内存中的存储方式：</p>\n<p><img src=\"/../imgs/protocol3.webp\"></p>\n<p>i在内存中的地址序列是0x003CF7C4~0x003CF7C8，值为40 e2 01 00。</p>\n<p><img src=\"/../imgs/protocol4.webp\"></p>\n<p>十六进制0001e240正好等于10进制123456，也就是说小端编码中权重高的的字节值存储在内存地址高（地址值较大）的位置，权重值低的字节值存储在内存地址低（地址值较小）的位置，也就是所谓的高高低低。<br>相反，大端编码的规则应该是高低低高，也就是说权值高字节存储在内存地址低的位置，权值低的字节存储在内存地址高的位置。<br>所以，如果我们一个C++程序的int32值123456不作转换地传给Java程序，那么Java按照大端编码的形式读出来的值是：十六进制40E20100 &#x3D; 十进制1088553216。<br>所以，我们要么在发送方将数据转换成网络字节序（大端编码），要么在接收端再进行转换。</p>\n<p>下面看一下如果C++端传送一个如下数据结构，Java端该如何解析（由于Java中是没有指针的，也无法操作内存地址，导致很多人无从下手），下面利用tcpdump来解决这个问题的思路。<br>我们客户端发送的数据包：</p>\n<p><img src=\"/../imgs/protocol5.webp\"></p>\n<p>其结构体定义如下：</p>\n<p><img src=\"/../imgs/protocol6.jpeg\"></p>\n<p>利用tcpdump抓到的包如下：</p>\n<p><img src=\"/../imgs/protocol7.webp\"></p>\n<p>放大一点：</p>\n<p><img src=\"/../imgs/protocol8.webp\"></p>\n<p>我们白色标识出来就是我们收到的数据包。这里我想说明两点：</p>\n<ul>\n<li><p>如果我们知道发送端发送的字节流，再比照接收端收到的字节流，我们就能检测数据包的完整性，或者利用这个来排查一些问题；</p>\n</li>\n<li><p>对于Java程序只要按照这个顺序，先利用java.net.Socket的输出流java.io.DataOutputStream对象readByte、readInt32、readInt32、readBytes、readBytes方法依次读出一个char、int32、int32、16个字节的字节数组、63个字节数组即可，为了还原像int32这样的整形值，我们需要做一些小端编码向大端编码的转换。</p>\n</li>\n</ul>\n","text":"服务器开发通信协议设计介绍 一、选择TCP还是UDP协议由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所...","permalink":"/post/转载/网络编程/服务器开发通信协议设计介绍","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">服务器开发通信协议设计介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9TCP%E8%BF%98%E6%98%AFUDP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">一、选择TCP还是UDP协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">二、协议的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%85%B3%E4%BA%8E%E8%B7%A8%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">三、关于跨系统与跨语言之间的网络通信协议解析与识别问题</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】connect函数在阻塞和非阻塞模式下的行为","uid":"c646ab357404b495e460a8a7d56a1d77","slug":"转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.398Z","comments":true,"path":"api/articles/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为.json","keywords":null,"cover":null,"text":"connect 函数在阻塞和非阻塞模式下的行为在 socket 是阻塞模式下 connect 函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务...","permalink":"/post/转载/网络编程/connect函数在阻塞和非阻塞模式下的行为","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】服务器端发数据时，如果对端一直不收，怎么办？","uid":"e09bb655914509994c8e1511db91931a","slug":"转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？.json","keywords":null,"cover":null,"text":"服务器端发数据时，如果对端一直不收，怎么办？这类问题一般出现在跨部门尤其是与外部开发人员合作的时候。假设现在有这样一种情况，我们的服务器提供对外的服务，指定好了...","permalink":"/post/转载/网络编程/服务器端发数据时，如果对端一直不收，怎么办？","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}