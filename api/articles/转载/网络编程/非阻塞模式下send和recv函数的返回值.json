{"title":"【转载】非阻塞模式下send和recv函数的返回值","uid":"12ad89ee9300bed7e58f0d5f1f9116ca","slug":"转载/网络编程/非阻塞模式下send和recv函数的返回值","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.915Z","comments":true,"path":"api/articles/转载/网络编程/非阻塞模式下send和recv函数的返回值.json","keywords":null,"cover":[],"content":"<h2 id=\"非阻塞模式下-send-和-recv-函数的返回值\"><a href=\"#非阻塞模式下-send-和-recv-函数的返回值\" class=\"headerlink\" title=\"非阻塞模式下 send 和 recv 函数的返回值\"></a>非阻塞模式下 send 和 recv 函数的返回值</h2><p>我们来总结一下 <strong>send</strong> 和 <strong>recv</strong> 函数的各种返回值意义：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">返回值 n</th>\n<th align=\"center\">返回值含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">大于 0</td>\n<td align=\"center\">成功发送 n 个字节</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">对端关闭连接</td>\n</tr>\n<tr>\n<td align=\"center\">小于 0（ -1）</td>\n<td align=\"center\">出错或者被信号中断或者对端 TCP 窗口太小数据发不出去（send）或者当前网卡缓冲区已无数据可收（recv）</td>\n</tr>\n</tbody></table>\n<p>我们来逐一介绍下这三种情况：</p>\n<ul>\n<li><p><strong>返回值大于 0</strong></p>\n<p>对于 <strong>send</strong> 和 <strong>recv</strong> 函数返回值大于 <strong>0</strong>，表示发送或接收多少字节，需要注意的是，在这种情形下，我们一定要判断下 send 函数的返回值是不是我们期望发送的缓冲区长度，而不是简单判断其返回值大于 0。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1int n = send(socket, buf, buf_length, 0)；</span><br><span class=\"line\">2if (n &gt; 0)</span><br><span class=\"line\">3&#123;</span><br><span class=\"line\">4  printf(&quot;send data successfully\\n&quot;);</span><br><span class=\"line\">5&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很多新手会写出上述代码，虽然返回值 n 大于 0，但是实际情形下，由于对端的 TCP 窗口可能因为缺少一部分字节就满了，所以返回值 n 的值可能在 (0, buf_length] 之间，当 0 &lt; n &lt; buf_length 时，虽然此时 send 函数是调用成功了，但是业务上并不算正确，因为有部分数据并没发出去。你可能在一次测试中测不出 n 不等于 buf_length 的情况，但是不代表实际中不存在。所以，建议要么认为返回值 n 等于 buf_length 才认为正确，要么在一个循环中调用 send 函数，如果数据一次性发不完，记录偏移量，下一次从偏移量处接着发，直到全部发送完为止。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  //推荐的方式一</span><br><span class=\"line\">2  int n = send(socket, buf, buf_length, 0)；</span><br><span class=\"line\">3  if (n == buf_length)</span><br><span class=\"line\">4  &#123;</span><br><span class=\"line\">5      printf(&quot;send data successfully\\n&quot;);</span><br><span class=\"line\">6  &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1//推荐的方式二：在一个循环里面根据偏移量发送数据</span><br><span class=\"line\"> 2bool SendData(const char* buf , int buf_length)</span><br><span class=\"line\"> 3&#123;</span><br><span class=\"line\"> 4    //已发送的字节数目</span><br><span class=\"line\"> 5    int sent_bytes = 0;</span><br><span class=\"line\"> 6    int ret = 0;</span><br><span class=\"line\"> 7    while (true)</span><br><span class=\"line\"> 8    &#123;</span><br><span class=\"line\"> 9        ret = send(m_hSocket, buf + sent_bytes, buf_length - sent_bytes, 0);</span><br><span class=\"line\">10        if (nRet == -1)</span><br><span class=\"line\">11        &#123;</span><br><span class=\"line\">12            if (errno == EWOULDBLOCK)</span><br><span class=\"line\">13            &#123;</span><br><span class=\"line\">14                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span><br><span class=\"line\">15                break;</span><br><span class=\"line\">16            &#125;             </span><br><span class=\"line\">17            else if (errno == EINTR)</span><br><span class=\"line\">18                continue;</span><br><span class=\"line\">19            else</span><br><span class=\"line\">20                return false;</span><br><span class=\"line\">21        &#125;</span><br><span class=\"line\">22        else if (nRet == 0)</span><br><span class=\"line\">23        &#123;</span><br><span class=\"line\">24            return false;</span><br><span class=\"line\">25        &#125;</span><br><span class=\"line\">26</span><br><span class=\"line\">27        sent_bytes += ret;</span><br><span class=\"line\">28        if (sent_bytes == buf_length)</span><br><span class=\"line\">29            break;</span><br><span class=\"line\">30</span><br><span class=\"line\">31        //稍稍降低 CPU 的使用率</span><br><span class=\"line\">32        usleep(1);</span><br><span class=\"line\">33    &#125;</span><br><span class=\"line\">34</span><br><span class=\"line\">35    return true;</span><br><span class=\"line\">36&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>返回值等于 0</strong></p>\n<p>通常情况下，如果 <strong>send</strong> 或者 <strong>recv</strong> 函数返回 <strong>0</strong>，我们就认为对端关闭了连接，我们这端也关闭连接即可，这是实际开发时最常见的处理逻辑。</p>\n<p>但是，现在还有一种情形就是，假设调用 <strong>send</strong> 函数传递的数据长度就是 0 呢？<strong>send</strong> 函数会是什么行为？对端会 <strong>recv</strong> 到一个 0 字节的数据吗？需要强调的是，<strong>在实际开发中，你不应该让你的程序有任何机会去 send 0 字节的数据，这是一种不好的做法。</strong> 这里仅仅用于实验性讨论，我们来通过一个例子，来看下 <strong>send</strong> 一个长度为 <strong>0</strong> 的数据，<strong>send</strong> 函数的返回值是什么？对端会 <strong>recv</strong> 到 <strong>0</strong> 字节的数据吗？</p>\n<p><strong>server</strong> 端代码：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1  /**</span><br><span class=\"line\"> 2   * 验证recv函数接受0字节的行为，server端，server_recv_zero_bytes.cpp</span><br><span class=\"line\"> 3   * zhangyl 2018.12.17</span><br><span class=\"line\"> 4   */</span><br><span class=\"line\"> 5  #include &lt;sys/types.h&gt; </span><br><span class=\"line\"> 6  #include &lt;sys/socket.h&gt;</span><br><span class=\"line\"> 7  #include &lt;arpa/inet.h&gt;</span><br><span class=\"line\"> 8  #include &lt;unistd.h&gt;</span><br><span class=\"line\"> 9  #include &lt;iostream&gt;</span><br><span class=\"line\">10  #include &lt;string.h&gt;</span><br><span class=\"line\">11  #include &lt;vector&gt;</span><br><span class=\"line\">12</span><br><span class=\"line\">13  int main(int argc, char* argv[])</span><br><span class=\"line\">14  &#123;</span><br><span class=\"line\">15      //1.创建一个侦听socket</span><br><span class=\"line\">16      int listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">17      if (listenfd == -1)</span><br><span class=\"line\">18      &#123;</span><br><span class=\"line\">19          std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">20          return -1;</span><br><span class=\"line\">21      &#125;</span><br><span class=\"line\">22</span><br><span class=\"line\">23      //2.初始化服务器地址</span><br><span class=\"line\">24      struct sockaddr_in bindaddr;</span><br><span class=\"line\">25      bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">26      bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">27      bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">28      if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">29      &#123;</span><br><span class=\"line\">30          std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">31          close(listenfd);</span><br><span class=\"line\">32          return -1;</span><br><span class=\"line\">33      &#125;</span><br><span class=\"line\">34</span><br><span class=\"line\">35      //3.启动侦听</span><br><span class=\"line\">36      if (listen(listenfd, SOMAXCONN) == -1)</span><br><span class=\"line\">37      &#123;</span><br><span class=\"line\">38          std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">39          close(listenfd);</span><br><span class=\"line\">40          return -1;</span><br><span class=\"line\">41      &#125;</span><br><span class=\"line\">42</span><br><span class=\"line\">43      int clientfd;</span><br><span class=\"line\">44</span><br><span class=\"line\">45      struct sockaddr_in clientaddr;</span><br><span class=\"line\">46      socklen_t clientaddrlen = sizeof(clientaddr);</span><br><span class=\"line\">47      //4. 接受客户端连接</span><br><span class=\"line\">48      clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class=\"line\">49      if (clientfd != -1)</span><br><span class=\"line\">50      &#123;           </span><br><span class=\"line\">51          while (true)</span><br><span class=\"line\">52          &#123;</span><br><span class=\"line\">53              char recvBuf[32] = &#123;0&#125;;</span><br><span class=\"line\">54              //5. 从客户端接受数据,客户端没有数据来的时候会在recv函数处阻塞</span><br><span class=\"line\">55              int ret = recv(clientfd, recvBuf, 32, 0);</span><br><span class=\"line\">56              if (ret &gt; 0) </span><br><span class=\"line\">57              &#123;</span><br><span class=\"line\">58                  std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;               </span><br><span class=\"line\">59              &#125; </span><br><span class=\"line\">60              else if (ret == 0)</span><br><span class=\"line\">61              &#123;</span><br><span class=\"line\">62                  std::cout &lt;&lt; &quot;recv 0 byte data.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">63                  continue;</span><br><span class=\"line\">64              &#125; </span><br><span class=\"line\">65              else</span><br><span class=\"line\">66              &#123;</span><br><span class=\"line\">67                  //出错</span><br><span class=\"line\">68                  std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">69                  break;</span><br><span class=\"line\">70              &#125;</span><br><span class=\"line\">71          &#125;               </span><br><span class=\"line\">72      &#125;</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75      //关闭客户端socket</span><br><span class=\"line\">76      close(clientfd);</span><br><span class=\"line\">77      //7.关闭侦听socket</span><br><span class=\"line\">78      close(listenfd);</span><br><span class=\"line\">79</span><br><span class=\"line\">80      return 0;</span><br><span class=\"line\">81  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码侦听端口号是 <strong>3000</strong>，代码 <strong>55</strong> 行调用了 <strong>recv</strong> 函数，如果客户端一直没有数据，程序会阻塞在这里。</p>\n<p><strong>client</strong> 端代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1/**</span><br><span class=\"line\"> 2 * 验证非阻塞模式下send函数发送0字节的行为，client端，nonblocking_client_send_zero_bytes.cpp</span><br><span class=\"line\"> 3 * zhangyl 2018.12.17</span><br><span class=\"line\"> 4 */</span><br><span class=\"line\"> 5#include &lt;sys/types.h&gt; </span><br><span class=\"line\"> 6#include &lt;sys/socket.h&gt;</span><br><span class=\"line\"> 7#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\"> 8#include &lt;unistd.h&gt;</span><br><span class=\"line\"> 9#include &lt;iostream&gt;</span><br><span class=\"line\">10#include &lt;string.h&gt;</span><br><span class=\"line\">11#include &lt;stdio.h&gt;</span><br><span class=\"line\">12#include &lt;fcntl.h&gt;</span><br><span class=\"line\">13#include &lt;errno.h&gt;</span><br><span class=\"line\">14</span><br><span class=\"line\">15#define SERVER_ADDRESS &quot;127.0.0.1&quot;</span><br><span class=\"line\">16#define SERVER_PORT     3000</span><br><span class=\"line\">17#define SEND_DATA       &quot;&quot;</span><br><span class=\"line\">18</span><br><span class=\"line\">19int main(int argc, char* argv[])</span><br><span class=\"line\">20&#123;</span><br><span class=\"line\">21    //1.创建一个socket</span><br><span class=\"line\">22    int clientfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">23    if (clientfd == -1)</span><br><span class=\"line\">24    &#123;</span><br><span class=\"line\">25        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">26        return -1;</span><br><span class=\"line\">27    &#125;</span><br><span class=\"line\">28</span><br><span class=\"line\">29    //2.连接服务器</span><br><span class=\"line\">30    struct sockaddr_in serveraddr;</span><br><span class=\"line\">31    serveraddr.sin_family = AF_INET;</span><br><span class=\"line\">32    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class=\"line\">33    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class=\"line\">34    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class=\"line\">35    &#123;</span><br><span class=\"line\">36        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">37        close(clientfd);</span><br><span class=\"line\">38        return -1;</span><br><span class=\"line\">39    &#125;</span><br><span class=\"line\">40</span><br><span class=\"line\">41    //连接成功以后，我们再将 clientfd 设置成非阻塞模式，</span><br><span class=\"line\">42    //不能在创建时就设置，这样会影响到 connect 函数的行为</span><br><span class=\"line\">43    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">44    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">45    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">46    &#123;</span><br><span class=\"line\">47        close(clientfd);</span><br><span class=\"line\">48        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">49        return -1;</span><br><span class=\"line\">50    &#125;</span><br><span class=\"line\">51</span><br><span class=\"line\">52    //3. 不断向服务器发送数据，或者出错退出</span><br><span class=\"line\">53    int count = 0;</span><br><span class=\"line\">54    while (true)</span><br><span class=\"line\">55    &#123;</span><br><span class=\"line\">56        //发送 0 字节的数据</span><br><span class=\"line\">57        int ret = send(clientfd, SEND_DATA, 0, 0);</span><br><span class=\"line\">58        if (ret == -1) </span><br><span class=\"line\">59        &#123;</span><br><span class=\"line\">60            //非阻塞模式下send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK</span><br><span class=\"line\">61            if (errno == EWOULDBLOCK)</span><br><span class=\"line\">62            &#123;</span><br><span class=\"line\">63                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">64                continue;</span><br><span class=\"line\">65            &#125; </span><br><span class=\"line\">66            else if (errno == EINTR)</span><br><span class=\"line\">67            &#123;</span><br><span class=\"line\">68                //如果被信号中断，我们继续重试</span><br><span class=\"line\">69                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">70                continue;</span><br><span class=\"line\">71            &#125; </span><br><span class=\"line\">72            else </span><br><span class=\"line\">73            &#123;</span><br><span class=\"line\">74                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">75                break;</span><br><span class=\"line\">76            &#125;</span><br><span class=\"line\">77        &#125;</span><br><span class=\"line\">78        else if (ret == 0)</span><br><span class=\"line\">79        &#123;</span><br><span class=\"line\">80            //对端关闭了连接，我们也关闭</span><br><span class=\"line\">81            std::cout &lt;&lt; &quot;send 0 byte data.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">82        &#125; </span><br><span class=\"line\">83        else</span><br><span class=\"line\">84        &#123;</span><br><span class=\"line\">85            count ++;</span><br><span class=\"line\">86            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class=\"line\">87        &#125;</span><br><span class=\"line\">88</span><br><span class=\"line\">89        //每三秒发一次</span><br><span class=\"line\">90        sleep(3);</span><br><span class=\"line\">91    &#125;</span><br><span class=\"line\">92</span><br><span class=\"line\">93    //5. 关闭socket</span><br><span class=\"line\">94    close(clientfd);</span><br><span class=\"line\">95</span><br><span class=\"line\">96    return 0;</span><br><span class=\"line\">97&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>client</strong> 端连接服务器成功以后，每隔 3 秒调用 <strong>send</strong> 一次发送一个 0 字节的数据。除了先启动 <strong>server</strong> 以外，我们使用 tcpdump 抓一下经过端口 <strong>3000</strong> 上的数据包，使用如下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1tcpdump -i any &#x27;tcp port 3000&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>然后启动 <strong>client</strong> ，我们看下结果：</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/sendrecvreturnvalue1.png\"></p>\n<p>客户端确实是每隔 3 秒 <strong>send</strong> 一次数据。此时我们使用 <strong>lsof -i -Pn</strong> 命令查看连接状态，也是正常的：</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>然后，tcpdump 抓包结果输出中，除了连接时的三次握手数据包，再也无其他数据包，也就是说，<strong>send</strong> 函数发送 <strong>0</strong> 字节数据，<strong>client</strong> 的协议栈并不会把这些数据发出去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1[root@localhost ~]# tcpdump -i any &#x27;tcp port 3000&#x27;</span><br><span class=\"line\">2tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class=\"line\">3listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class=\"line\">417:37:03.028449 IP localhost.48820 &gt; localhost.hbci: Flags [S], seq 1632283330, win 43690, options [mss 65495,sackOK,TS val 201295556 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">517:37:03.028479 IP localhost.hbci &gt; localhost.48820: Flags [S.], seq 3669336158, ack 1632283331, win 43690, options [mss 65495,sackOK,TS val 201295556 ecr 201295556,nop,wscale 7], length 0</span><br><span class=\"line\">617:37:03.028488 IP localhost.48820 &gt; localhost.hbci: Flags [.], ack 1, win 342, options [nop,nop,TS val 201295556 ecr 201295556], length 0</span><br></pre></td></tr></table></figure>\n\n<p>因此，<strong>server</strong> 端也会一直没有输出，如果你用的是 gdb 启动 <strong>server</strong>，此时中断下来会发现，<strong>server</strong> 端由于没有数据会一直阻塞在 <strong>recv</strong> 函数调用处（<strong>55</strong> 行）。</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/sendrecvreturnvalue2.png\"></p>\n<p>上述示例再次验证了，<strong>send</strong> 一个 0 字节的数据没有任何意思，希望读者在实际开发时，避免写出这样的代码。</p>\n","text":"非阻塞模式下 send 和 recv 函数的返回值我们来总结一下 send 和 recv 函数的各种返回值意义： 返回值 n 返回值含义 大于 0 成功发送 n...","permalink":"/post/转载/网络编程/非阻塞模式下send和recv函数的返回值","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B-send-%E5%92%8C-recv-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">非阻塞模式下 send 和 recv 函数的返回值</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】网络通信中收发数据的正确姿势","uid":"fab0416ed78af2e60e15df3589b08519","slug":"转载/网络编程/网络通信中收发数据的正确姿势","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.400Z","comments":true,"path":"api/articles/转载/网络编程/网络通信中收发数据的正确姿势.json","keywords":null,"cover":[],"text":"网络通信中收发数据的正确姿势在网络通信中，我们可能既要通过 socket 去发送数据也要通过 socket 来收取数据。那么一般的网络通信框架是如何收发数据的呢...","permalink":"/post/转载/网络编程/网络通信中收发数据的正确姿势","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++中变量和对象可以存放在内存中的位置","uid":"3faf2e95846c995629df56586598456a","slug":"C++/C++中变量和对象可以存放在内存中的位置","date":"2018-05-12T05:52:41.000Z","updated":"2023-06-05T07:41:06.629Z","comments":true,"path":"api/articles/C++/C++中变量和对象可以存放在内存中的位置.json","keywords":null,"cover":null,"text":"在 C++ 中，变量和对象可以存放在各种不同的内存位置，具体取决于它们的定义方式、生命周期及其类型等因素。以下是常见的 C++ 变量和对象所存放的位置： 自动变...","permalink":"/post/C++/C++中变量和对象可以存放在内存中的位置","photos":[],"count_time":{"symbolsCount":969,"symbolsTime":"1 mins."},"categories":[{"name":"C++基础","slug":"C-基础","count":2,"path":"api/categories/C-基础.json"}],"tags":[{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"},{"name":"网络通信","slug":"网络通信","count":2,"path":"api/tags/网络通信.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}