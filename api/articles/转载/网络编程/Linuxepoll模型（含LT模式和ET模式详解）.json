{"title":"【转载】Linuxepoll模型（含LT模式和ET模式详解）","uid":"f803883e87085e50bdcf47ed5c086db3","slug":"转载/网络编程/Linuxepoll模型（含LT模式和ET模式详解）","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:26.970Z","comments":true,"path":"api/articles/转载/网络编程/Linuxepoll模型（含LT模式和ET模式详解）.json","keywords":null,"cover":[],"content":"<h1 id=\"Linux-epoll-模型（含LT-模式和-ET-模式详解）\"><a href=\"#Linux-epoll-模型（含LT-模式和-ET-模式详解）\" class=\"headerlink\" title=\"Linux epoll 模型（含LT 模式和 ET 模式详解）\"></a>Linux epoll 模型（含LT 模式和 ET 模式详解）</h1><p>综合 <strong>select</strong> 和 <strong>poll</strong> 的一些优缺点，Linux 从内核 2.6 版本开始引入了更高效的 epoll 模型，本节我们来详细介绍 epoll 模型。</p>\n<p>要想使用 epoll 模型，必须先需要创建一个 epollfd，这需要使用 <strong>epoll_create</strong> 函数去创建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;sys/epoll.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int epoll_create(int size);</span><br></pre></td></tr></table></figure>\n\n<p>参数 <strong>size</strong> 从 Linux 2.6.8 以后就不再使用，但是必须设置一个大于 0 的值。<strong>epoll_create</strong> 函数调用成功返回一个非负值的 epollfd，调用失败返回 -1。</p>\n<p>有了 epollfd 之后，我们需要将我们需要检测事件的其他 fd 绑定到这个 epollfd 上，或者修改一个已经绑定上去的 fd 的事件类型，或者在不需要时将 fd 从 epollfd 上解绑，这都可以使用 <strong>epoll_ctl</strong> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><p>参数 <strong>epfd</strong> 即上文提到的 epollfd；</p>\n</li>\n<li><p>参数 <strong>op</strong>，操作类型，取值有 <strong>EPOLL_CTL_ADD</strong>、<strong>EPOLL_CTL_MOD</strong> 和 <strong>EPOLL_CTL_DEL</strong>，分别表示向 epollfd 上添加、修改和移除一个其他 fd，当取值是 <strong>EPOLL_CTL_DEL</strong>，第四个参数 <strong>event</strong> 忽略不计，可以设置为 NULL；</p>\n</li>\n<li><p>参数 <strong>fd</strong>，即需要被操作的 fd；</p>\n</li>\n<li><p>参数 <strong>event</strong>，这是一个 <strong>epoll_event</strong> 结构体的地址，<strong>epoll_event</strong> 结构体定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct epoll_event</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  uint32_t     events;      /* 需要检测的 fd 事件，取值与 poll 函数一样 */</span><br><span class=\"line\">  epoll_data_t data;        /* 用户自定义数据 */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>epoll_event</strong> 结构体的 <strong>data</strong> 字段的类型是 <strong>epoll_data_t</strong>，我们可以利用这个字段设置一个自己的自定义数据，它本质上是一个 Union 对象，在 64 位操作系统中其大小是 8 字节，其定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef union epoll_data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  void*         ptr;</span><br><span class=\"line\">  int          fd;</span><br><span class=\"line\">  uint32_t     u32;</span><br><span class=\"line\">  uint64_t     u64;</span><br><span class=\"line\">&#125; epoll_data_t;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>函数返回值</strong>：<strong>epoll_ctl</strong> 调用成功返回 0，调用失败返回 -1，你可以通过 <strong>errno</strong> 错误码获取具体的错误原因。</p>\n</li>\n</ul>\n<p>创建了 epollfd，设置好某个 fd 上需要检测事件并将该 fd 绑定到 epollfd 上去后，我们就可以调用 <strong>epoll_wait</strong> 检测事件了，<strong>epoll_wait</strong> 函数签名如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p>参数的形式和 <strong>poll</strong> 函数很类似，参数 <strong>events</strong> 是一个 <strong>epoll_event</strong> 结构数组的首地址，这是一个输出参数，函数调用成功后，<strong>events</strong> 中存放的是与就绪事件相关 <strong>epoll_event</strong> 结构体数组；参数 <strong>maxevents</strong> 是数组元素的个数；<strong>timeout</strong> 是超时时间，单位是毫秒，如果设置为 0，<strong>epoll_wait</strong> 会立即返回。</p>\n<p>当 <strong>epoll_wait</strong> 调用成功会返回有事件的 fd 数目；如果返回 0 表示超时；调用失败返回 -1。</p>\n<p><strong>epoll_wait</strong> 使用示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    epoll_event epoll_events[1024];</span><br><span class=\"line\">    int n = epoll_wait(epollfd, epoll_events, 1024, 1000);</span><br><span class=\"line\">    if (n &lt; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //被信号中断</span><br><span class=\"line\">        if (errno == EINTR)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\"></span><br><span class=\"line\">        //出错，退出</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (n == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //超时，继续</span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (size_t i = 0; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 处理可读事件</span><br><span class=\"line\">        if (epoll_events[i].events &amp; POLLIN)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 处理可写事件</span><br><span class=\"line\">        else if (epoll_events[i].events &amp; POLLOUT)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //处理出错事件</span><br><span class=\"line\">        else if (epoll_events[i].events &amp; POLLERR)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"epoll-wait-与-poll-的区别\"><a href=\"#epoll-wait-与-poll-的区别\" class=\"headerlink\" title=\"epoll_wait 与 poll 的区别\"></a>epoll_wait 与 poll 的区别</h2><p>通过前面介绍 <strong>poll</strong> 与 <strong>epoll_wait</strong> 函数的介绍，我们可以发现：</p>\n<p><strong>epoll_wait</strong> 函数调用完之后，我们可以直接在 <strong>event</strong> 参数中拿到所有有事件就绪的 fd，直接处理即可（<strong>event</strong> 参数仅仅是个出参）；而 <strong>poll</strong> 函数的事件集合调用前后数量都未改变，只不过调用前我们通过 <strong>pollfd</strong> 结构体的 <strong>events</strong> 字段设置待检测事件，调用后我们需要通过 <strong>pollfd</strong> 结构体的 <strong>revents</strong> 字段去检测就绪的事件（ 参数 <strong>fds</strong> 既是入参也是出参）。</p>\n<p>举个生活中的例子，某人不断给你一些苹果，这些苹果有生有熟，调用 <strong>epoll_wait</strong> 相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 你把苹果挨个投入到 epoll 机器中(调用 epoll_ctl);</span><br><span class=\"line\">2. 调用 epoll_wait 加工，你直接通过另外一个袋子就能拿到所有熟苹果。</span><br></pre></td></tr></table></figure>\n\n<p>调用 <strong>poll</strong> 相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 把收到的苹果装入一个袋子里面然后调用 poll 加工；</span><br><span class=\"line\">2. 调用结束后，拿到原来的袋子，袋子中还是原来那么多苹果，只不过熟苹果被贴上了标签纸，你还是需要挨个去查看标签纸挑选熟苹果。 </span><br></pre></td></tr></table></figure>\n\n<p>当然，这并不意味着，<strong>poll</strong> 函数的效率不如 <strong>epoll_wait</strong>，一般在 fd 数量比较多，但某段时间内，就绪事件 fd 数量较少的情况下，<strong>epoll_wait</strong> 才会体现出它的优势，也就是说 socket 连接数量较大时而活跃连接较少时 epoll 模型更高效。</p>\n<h2 id=\"LT-模式和-ET-模式\"><a href=\"#LT-模式和-ET-模式\" class=\"headerlink\" title=\"LT 模式和 ET 模式\"></a>LT 模式和 ET 模式</h2><p>与 poll 的事件宏相比，epoll 新增了一个事件宏 <strong>EPOLLET</strong>，这就是所谓的<strong>边缘触发模式</strong>（<strong>E</strong>dge <strong>T</strong>rigger，ET），而默认的模式我们称为 <strong>水平触发模式</strong>（<strong>L</strong>evel <strong>T</strong>rigger，LT）。这两种模式的区别在于：</p>\n<ul>\n<li>对于水平触发模式，一个事件只要有，就会一直触发；</li>\n<li>对于边缘触发模式，只有一个事件从无到有才会触发。</li>\n</ul>\n<p>这两个词汇来自电学术语，你可以将 fd 上有数据认为是<strong>高电平</strong>，没有数据认为是<strong>低电平</strong>，将 fd 可写认为是<strong>高电平</strong>，fd 不可写认为是<strong>低电平</strong>。那么水平模式的触发条件是状态处于高电平，而边缘模式是状态改为高电平，即：</p>\n<p><strong>水平模式的触发条件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 低电平 =&gt; 高电平</span><br><span class=\"line\">2. 高电平 =&gt; 高电平</span><br></pre></td></tr></table></figure>\n\n<p><strong>边缘模式的触发条件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 低电平 =&gt; 高电平</span><br></pre></td></tr></table></figure>\n\n<p>说的有点抽象，以 socket 的读事件为例，对于水平模式，只要 socket 上有未读完的数据，就会一直产生 POLLIN 事件；而对于边缘模式，socket 上第一次有数据会触发一次，后续 socket 上存在数据也不会再触发，除非把数据读完后，再次产生数据才会继续触发。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 POLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 POLLOUT 事件。</p>\n<p><strong>socket 可读事件水平模式触发条件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. socket上无数据 =&gt; socket上有数据</span><br><span class=\"line\">2. socket上有数据 =&gt; socket上有数据</span><br></pre></td></tr></table></figure>\n\n<p><strong>socket 可读事件边缘模式触发条件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. socket上无数据 =&gt; socket上有数据</span><br></pre></td></tr></table></figure>\n\n<p><strong>socket 可写事件水平模式触发条件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. socket可写   =&gt; socket可写</span><br><span class=\"line\">2. socket不可写 =&gt; socket可写</span><br></pre></td></tr></table></figure>\n\n<p><strong>socket 可写事件边缘模式触发条件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. socket不可写 =&gt; socket可写</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果对于一个非阻塞 socket，如果使用 epoll 边缘模式去检测数据是否可读，触发可读事件以后，一定要一次性把 socket 上的数据收取干净才行，也就是一定要循环调用 recv 函数直到 recv 出错，错误码是<strong>EWOULDBLOCK</strong>（<strong>EAGAIN</strong> 一样）；如果使用水平模式，则不用，你可以根据业务一次性收取固定的字节数，或者收完为止。边缘模式下收取数据的代码示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool TcpSession::RecvEtMode()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //每次只收取256个字节</span><br><span class=\"line\">    char buff[256];</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;       </span><br><span class=\"line\">        int nRecv = ::recv(clientfd_, buff, 256, 0);</span><br><span class=\"line\">        if (nRecv == -1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (errno == EWOULDBLOCK)</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            else if (errno == EINTR)</span><br><span class=\"line\">                continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //对端关闭了socket</span><br><span class=\"line\">        else if (nRecv == 0)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\"></span><br><span class=\"line\">        inputBuffer_.add(buff, (size_t)nRecv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们来看一个 epoll 模型的完整例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 演示 epoll 通信模型，epoll_server.cpp</span><br><span class=\"line\"> * zhangyl 2019.03.16</span><br><span class=\"line\"> */</span><br><span class=\"line\">#include &lt;sys/types.h&gt; </span><br><span class=\"line\">#include &lt;sys/socket.h&gt;</span><br><span class=\"line\">#include &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;sys/epoll.h&gt;</span><br><span class=\"line\">#include &lt;poll.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;errno.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //创建一个侦听socket</span><br><span class=\"line\">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class=\"line\">    if (listenfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将侦听socket设置为非阻塞的</span><br><span class=\"line\">    int oldSocketFlag = fcntl(listenfd, F_GETFL, 0);</span><br><span class=\"line\">    int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">    if (fcntl(listenfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;set listenfd to nonblock error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //初始化服务器地址</span><br><span class=\"line\">    struct sockaddr_in bindaddr;</span><br><span class=\"line\">    bindaddr.sin_family = AF_INET;</span><br><span class=\"line\">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    bindaddr.sin_port = htons(3000);</span><br><span class=\"line\">    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //启动侦听</span><br><span class=\"line\">    if (listen(listenfd, SOMAXCONN) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //复用地址和端口号</span><br><span class=\"line\">    int on = 1;</span><br><span class=\"line\">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on));</span><br><span class=\"line\">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;on, sizeof(on));</span><br><span class=\"line\"></span><br><span class=\"line\">    //创建epollfd</span><br><span class=\"line\">    int epollfd = epoll_create(1);</span><br><span class=\"line\">    if (epollfd == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;create epollfd error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event listen_fd_event;</span><br><span class=\"line\">    listen_fd_event.events = POLLIN;</span><br><span class=\"line\">    listen_fd_event.data.fd = listenfd;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将侦听socket绑定到epollfd上去</span><br><span class=\"line\">    if(epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &amp;listen_fd_event) == -1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;epoll_ctl error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        close(listenfd);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;       </span><br><span class=\"line\">        epoll_event epoll_events[1024];</span><br><span class=\"line\">        n = epoll_wait(epollfd, epoll_events, 1024, 1000);</span><br><span class=\"line\">        if (n &lt; 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //被信号中断</span><br><span class=\"line\">            if (errno == EINTR)</span><br><span class=\"line\">                continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            //出错，退出</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (n == 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //超时，继续</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (size_t i = 0; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 事件可读</span><br><span class=\"line\">            if (epoll_events[i].events &amp; POLLIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (epoll_events[i].data.fd == listenfd)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    //侦听socket，接受新连接</span><br><span class=\"line\">                    struct sockaddr_in clientaddr;</span><br><span class=\"line\">                    socklen_t clientaddrlen = sizeof(clientaddr);</span><br><span class=\"line\">                    //接受客户端连接, 并加入到fds集合中</span><br><span class=\"line\">                    int clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class=\"line\">                    if (clientfd != -1)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        //将客户端socket设置为非阻塞的</span><br><span class=\"line\">                        int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);</span><br><span class=\"line\">                        int newSocketFlag = oldSocketFlag | O_NONBLOCK;</span><br><span class=\"line\">                        if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            close(clientfd);</span><br><span class=\"line\">                            std::cout &lt;&lt; &quot;set clientfd to nonblock error.&quot; &lt;&lt; std::endl;                        </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            epoll_event client_fd_event;</span><br><span class=\"line\">                            client_fd_event.events = POLLIN;</span><br><span class=\"line\">                            client_fd_event.data.fd = clientfd;                         </span><br><span class=\"line\">                            if(epoll_ctl(epollfd, EPOLL_CTL_ADD, clientfd, &amp;client_fd_event) != -1)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                std::cout &lt;&lt; &quot;new client accepted, clientfd: &quot; &lt;&lt; clientfd &lt;&lt; std::endl;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                std::cout &lt;&lt; &quot;add client fd to epollfd error.&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">                                close(clientfd);                            </span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;       </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else </span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    //普通clientfd,收取数据</span><br><span class=\"line\">                    char buf[64] = &#123; 0 &#125;;</span><br><span class=\"line\">                    int m = recv(epoll_events[i].data.fd, buf, 64, 0);</span><br><span class=\"line\">                    if (m == 0)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        //对端关闭了连接，从epollfd上移除clientfd</span><br><span class=\"line\">                        if(epoll_ctl(epollfd, EPOLL_CTL_DEL, epoll_events[i].data.fd, NULL) != -1)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            std::cout &lt;&lt; &quot;client disconnected, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        close(epoll_events[i].data.fd);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (m &lt; 0)</span><br><span class=\"line\">                    &#123;                                           </span><br><span class=\"line\">                        //出错，从epollfd上移除clientfd</span><br><span class=\"line\">                        if (errno != EWOULDBLOCK &amp;&amp; errno != EINTR)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            if(epoll_ctl(epollfd, EPOLL_CTL_DEL, epoll_events[i].data.fd, NULL) != -1)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                std::cout &lt;&lt; &quot;client disconnected, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            close(epoll_events[i].data.fd);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        //正常收到数据</span><br><span class=\"line\">                        std::cout &lt;&lt; &quot;recv from client: &quot; &lt;&lt; buf &lt;&lt; &quot;, clientfd: &quot; &lt;&lt; epoll_events[i].data.fd &lt;&lt; std::endl;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (epoll_events[i].events &amp; POLLERR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //TODO: 暂且不处理</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;// end  outer-for-loop</span><br><span class=\"line\">    &#125;// end  while-loop</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭侦听socket</span><br><span class=\"line\">    //（理论上应该关闭包括所有clientfd在内的fd，但这里只是为了演示问题，就不写额外的代码来处理啦）</span><br><span class=\"line\">    close(listenfd);            </span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译上述程序生成 <strong>epoll_server</strong> 并启动，然后使用 <strong>nc</strong> 命令启动三个客户端给服务器发数据效果如下图所示：</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/epoll.png\"></p>\n","text":"Linux epoll 模型（含LT 模式和 ET 模式详解）综合 select 和 poll 的一些优缺点，Linux 从内核 2.6 版本开始引入了更高效的...","permalink":"/post/转载/网络编程/Linuxepoll模型（含LT模式和ET模式详解）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux-epoll-%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%ABLT-%E6%A8%A1%E5%BC%8F%E5%92%8C-ET-%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">Linux epoll 模型（含LT 模式和 ET 模式详解）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#epoll-wait-%E4%B8%8E-poll-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">epoll_wait 与 poll 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LT-%E6%A8%A1%E5%BC%8F%E5%92%8C-ET-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">LT 模式和 ET 模式</span></a></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】服务器开发中网络数据分析与故障排查经验漫谈","uid":"cc903e63e370e497adde4ee0456deec1","slug":"转载/学习资料/服务器开发中网络数据分析与故障排查经验漫谈","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/学习资料/服务器开发中网络数据分析与故障排查经验漫谈.json","keywords":null,"cover":[],"text":"服务器开发中网络数据分析与故障排查经验漫谈​ 一、 操作系统提供的网络接口 为了能更好的排查网络通信问题，我们需要熟悉操作系统提供的以下网络接口函数，列表如下：...","permalink":"/post/转载/学习资料/服务器开发中网络数据分析与故障排查经验漫谈","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】TCP协议如何解决粘包、半包问题","uid":"2a3c3c9ace4b4758d78bedda5e2402e0","slug":"转载/网络编程/TCP协议如何解决粘包、半包问题","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:22.397Z","comments":true,"path":"api/articles/转载/网络编程/TCP协议如何解决粘包、半包问题.json","keywords":null,"cover":[],"text":"TCP 协议如何解决粘包、半包问题一 TCP 协议是流式协议很多读者从接触网络知识以来，应该听说过这句话：TCP 协议是流式协议。那么这句话到底是什么意思呢？所...","permalink":"/post/转载/网络编程/TCP协议如何解决粘包、半包问题","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"},{"name":"网络编程","slug":"网络编程","count":10,"path":"api/tags/网络编程.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}