{"title":"【转载】不定参数函数实现var_arg系列的宏","uid":"40a7e4f59089c11e355c8f7228d5379e","slug":"转载/cpp/不定参数函数实现var_arg系列的宏","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/cpp/不定参数函数实现var_arg系列的宏.json","keywords":null,"cover":[],"content":"<h2 id=\"不定参数函数实现var-arg系列的宏\"><a href=\"#不定参数函数实现var-arg系列的宏\" class=\"headerlink\" title=\"不定参数函数实现var_arg系列的宏\"></a>不定参数函数实现var_arg系列的宏</h2><p>电驴的源码日志模块有一个叫 <strong>DebugLogError</strong> 函数，其签名如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//代码位于easyMule-master/src/WorkLayer/Log.h 55行</span><br><span class=\"line\">void DebugLogError(LPCTSTR pszLine, ...);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>电驴的源码可以在公众号【 <strong>高性能服务器开发</strong> 】后台回复“<strong>获取电驴源码</strong>”即可获取。</p>\n</blockquote>\n<p>这个函数的申明在 <strong>Log.h</strong> 头文件中，是一个全局函数，其实现代码在 <strong>Log.cpp</strong> 文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//代码位于easyMule-master/src/WorkLayer/Log.cpp 111行</span><br><span class=\"line\">void DebugLogError(LPCTSTR pszFmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    va_list argp;</span><br><span class=\"line\">    va_start(argp, pszFmt);</span><br><span class=\"line\">    LogV(LOG_DEBUG | LOG_ERROR, pszFmt, argp);</span><br><span class=\"line\">    va_end(argp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数是一个具有不定参数的函数（也就是参数个数不确定），比如调用这个函数我们可以传入一个参数，也可以传入二个或者三个参数等等：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DebugLogError(L&quot;我喜欢你!&quot;);</span><br><span class=\"line\">DebugLogError(L&quot;我喜欢你!&quot;, L&quot;你喜欢谁？&quot;);</span><br><span class=\"line\">DebugLogError(L&quot;我喜欢你!&quot;, L&quot;你喜欢谁？&quot;, L&quot;萧雨萌!&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>与此类似， C 语言中最熟悉的函数 <strong>printf()</strong> 和 <strong>scanf()</strong> 就是能传入不定参数的函数的例子，可是你知道如何编写这样具有不定参数的函数么？</p>\n<p>你可以通过这段代码学习到编写方法，奥秘就在DebugLogError()中使用的几个你从来没见过的宏，让我们欢迎它们：</p>\n<ul>\n<li>va_list</li>\n<li>va_start</li>\n<li>va_end</li>\n</ul>\n<p>这几个宏是C函数库提供的，位于头文件stdarg.h中。下面我们利用这几个宏自定义一个ShowLove()函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;tchar.h&gt;</span><br><span class=\"line\">#include &lt;stdarg.h&gt;</span><br><span class=\"line\">#include &lt;locale.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int ShowLove(wchar_t* szFirstSentence, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   //用来统计可变参数数量</span><br><span class=\"line\">   int num = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   //第一步：</span><br><span class=\"line\">   //申明一个va_list类型对象ap，用于对参数进行遍历</span><br><span class=\"line\">   va_list ap;</span><br><span class=\"line\">   </span><br><span class=\"line\">   //第二步：</span><br><span class=\"line\">   //使用va_start对变量进行初始化</span><br><span class=\"line\">   //这里需要注意的是:</span><br><span class=\"line\">   //在传统C语言中，va_start把ap中内部指针设置为传递给函数参数的【第一个实参】；</span><br><span class=\"line\">   //而在标准的C中，va_start接受一个额外参数，也就是最后一个【固定参数】的名称，</span><br><span class=\"line\">   //并把ap中的内部指针设置为传递给函数的第一个【可变参数】.</span><br><span class=\"line\">   //所以你在VC++ 6.0和VS2008等高版本的编译器中使用va_start需要注意区别</span><br><span class=\"line\">   //这里使用标准C</span><br><span class=\"line\">   va_start(ap, szFirstSentence);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   //第三步：</span><br><span class=\"line\">   //使用va_arg宏返回实参列表中的下一个参数值，并把ap的内部指针推向下一个参数（如果有的话）</span><br><span class=\"line\">   //必须指定下一个参数的类型。</span><br><span class=\"line\">   //在调用va_start之后第一次调用va_arg将返回第一个可变参数的值</span><br><span class=\"line\">   wprintf(szFirstSentence);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   wchar_t* p = 0;</span><br><span class=\"line\">   while(p = va_arg(ap, wchar_t*))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       wprintf(L&quot;%s&quot;, p);</span><br><span class=\"line\">       num ++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   //第四步：</span><br><span class=\"line\">   //待所有可变参数都读取完毕以后，调用va_end宏对ap和va_list做必要的清理工作</span><br><span class=\"line\">   va_end(ap);</span><br><span class=\"line\">   return num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   setlocale(LC_ALL, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   int z = ShowLoveL&quot;我喜欢你！\\n&quot;);</span><br><span class=\"line\">   int y = ShowLove(L&quot;我喜欢你！&quot;, L&quot;你喜欢谁？\\n&quot;);</span><br><span class=\"line\">   int l = ShowLove(L&quot;我喜欢你！&quot;, L&quot;你喜欢谁？&quot;, L&quot;萧雨萌！\\n&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   printf(&quot;可变参数个数依次是：%d\\t%d\\t%d\\n&quot;, z, y, l);</span><br><span class=\"line\">   return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的运行结果是：</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/vargs.png\" alt=\"img\"></p>\n<p>这里顺便补充下，<strong>va</strong> 的是英文 varied arguments （可变参数）的意思。关于 <strong>va_list</strong> 等宏的实现原理其实也很容易搞明白，这里不再讲解了。</p>\n<p>我们现在来看看函数 DebugLogError()：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DebugLogError(LPCTSTR pszFmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tva_list argp;</span><br><span class=\"line\">\tva_start(argp, pszFmt);\t</span><br><span class=\"line\">\tLogV(LOG_DEBUG | LOG_ERROR, pszFmt, argp);</span><br><span class=\"line\">\tva_end(argp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的没什么，就是调用了一个函数叫 <strong>LogV()<strong>，</strong>LogV()</strong> 的的声明位于 <strong>Log.h</strong> 文件中，也是一个全局函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void LogV(UINT uFlags, LPCTSTR pszFmt, va_list argp);</span><br></pre></td></tr></table></figure>\n\n<p>其实现代码位于 <strong>Log.cpp</strong> 文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void LogV(UINT uFlags, LPCTSTR pszFmt, va_list argp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAddLogTextV(uFlags, DLP_DEFAULT, pszFmt, argp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里又调用了一个函数 **AddLogTextV()**，这个函数的也声明在 <strong>Log.h</strong> 中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)；</span><br></pre></td></tr></table></figure>\n\n<p>其实现代码在 <strong>Log.cpp</strong> 文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tASSERT(pszLine != NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif ((uFlags &amp; LOG_DEBUG) &amp;&amp; !thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;= thePrefs.GetVerboseLogPriority())</span><br><span class=\"line\">\t\treturn;\t</span><br><span class=\"line\">\t//Xman Anti-Leecher-Log</span><br><span class=\"line\">\tif ((uFlags &amp; LOG_LEECHER) &amp;&amp; !thePrefs.GetAntiLeecherLog())</span><br><span class=\"line\">\t\treturn;\t</span><br><span class=\"line\">\t//Xman end</span><br><span class=\"line\"></span><br><span class=\"line\">\tTCHAR szLogLine[1000];</span><br><span class=\"line\">\tif (_vsntprintf(szLogLine, ARRSIZE(szLogLine), pszLine, argptr) == -1)</span><br><span class=\"line\">\t\tszLogLine[ARRSIZE(szLogLine) - 1] = _T(&#x27;\\0&#x27;);</span><br><span class=\"line\">\tif(CGlobalVariable::m_hListenWnd)</span><br><span class=\"line\">\t\tUINotify(WM_ADD_LOGTEXT, uFlags, (LPARAM)new CString(szLogLine));</span><br><span class=\"line\">\t//  Comment UI</span><br><span class=\"line\">\t/*if (theApp.emuledlg)</span><br><span class=\"line\">\t\ttheApp.emuledlg-&gt;AddLogText(uFlags, szLogLine);</span><br><span class=\"line\">\telse*/</span><br><span class=\"line\">\t/*if(SendMessage(CGlobalVariable::m_hListenWnd, WM_ADD_LOGTEXT, uFlags, (LPARAM)szLogLine)==0)*/</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTRACE(_T(&quot;App Log: %s\\n&quot;), szLogLine);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTCHAR szFullLogLine[1060];</span><br><span class=\"line\">\t\tint iLen = _sntprintf(szFullLogLine, ARRSIZE(szFullLogLine), _T(&quot;%s: %s\\r\\n&quot;), CTime::GetCurrentTime().Format(thePrefs.GetDateTimeFormat4Log()), szLogLine);</span><br><span class=\"line\">\t\tif (iLen &gt;= 0)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t//Xman Anti-Leecher-Log //Xman Code Improvement</span><br><span class=\"line\">\t\t\tif (!((uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (thePrefs.GetLog2Disk())</span><br><span class=\"line\">\t\t\t\t\ttheLog.Log(szFullLogLine, iLen);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\tif (thePrefs.GetVerbose()) // &amp;&amp; ((uFlags &amp; LOG_DEBUG) || thePrefs.GetFullVerbose()))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (thePrefs.GetDebug2Disk())</span><br><span class=\"line\">\t\t\t\t\ttheVerboseLog.Log(szFullLogLine, iLen);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//Xman end</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们从源头函数调用来理下思路：</p>\n<ol>\n<li>首先用下列参数调用 **DebugLogError()**：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DebugLogError(L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>然后在上述函数内部又调用：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogV(LOG_DEBUG | LOG_ERROR,</span><br><span class=\"line\">\t L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;,</span><br><span class=\"line\">     argp);</span><br></pre></td></tr></table></figure>\n\n<p>其中，<strong>argp</strong> 是函数 <strong>DebugLogError()</strong> 的内部变量，而 <strong>LOG_DEBUG</strong> 和 <strong>LOG_ERROR</strong> 是 <strong>Log.h</strong> 中定义几个宏，其类型为整形：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log message type enumeration</span><br><span class=\"line\">#define\tLOG_INFO\t\t0</span><br><span class=\"line\">#define\tLOG_WARNING\t\t1</span><br><span class=\"line\">#define\tLOG_ERROR\t\t2</span><br><span class=\"line\">#define\tLOG_SUCCESS\t\t3</span><br><span class=\"line\">#define\tLOGMSGTYPEMASK\t0x03</span><br><span class=\"line\"></span><br><span class=\"line\">// Log message targets flags</span><br><span class=\"line\">#define\tLOG_DEFAULT\t\t0x00</span><br><span class=\"line\">#define\tLOG_DEBUG\t\t0x10</span><br><span class=\"line\">#define\tLOG_STATUSBAR\t0x20</span><br><span class=\"line\">#define\tLOG_DONTNOTIFY\t0x40</span><br><span class=\"line\">#define LOG_LEECHER\t\t0x80 //Xman Anti-Leecher-Log</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>最后调用：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddLogTextV(LOG_DEBUG | LOG_ERROR,</span><br><span class=\"line\">           DLP_DEFAULT,</span><br><span class=\"line\">           L&quot;Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks&quot;,</span><br><span class=\"line\">           argp);</span><br></pre></td></tr></table></figure>\n\n<p>这个函数的第二个参数类型是一个定义在 <strong>Log.h</strong> 中的枚举变量 <strong>EDebugLogPriority</strong>，代表调试的记录级别，其取值如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum EDebugLogPriority&#123;</span><br><span class=\"line\">\tDLP_VERYLOW = 0,</span><br><span class=\"line\">\tDLP_LOW,</span><br><span class=\"line\">\tDLP_DEFAULT,</span><br><span class=\"line\">\tDLP_HIGH,</span><br><span class=\"line\">\tDLP_VERYHIGH</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里提醒一点，由于枚举量 DLP_VERYLOW &#x3D; 0，所以后面的 DLP_LOW、 DLP_DEFAULT、  DLP_HIGH、 DLP_VERYHIGH 就依次等于1、2、3、4，这是C语言规定的，C语言规定枚举量如果不赋初值，根据前面一个量的值依次递增。</p>\n<p>我们来实际看看AddTextLogText()函数的实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void AddLogTextV(UINT uFlags, EDebugLogPriority dlpPriority, LPCTSTR pszLine, va_list argptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">ASSERT(pszLine != NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">if ((uFlags &amp; LOG_DEBUG) &amp;&amp; !thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;= thePrefs.GetVerboseLogPriority())</span><br><span class=\"line\">\treturn;\t</span><br><span class=\"line\"></span><br><span class=\"line\">//Xman Anti-Leecher-Log</span><br><span class=\"line\">if ((uFlags &amp; LOG_LEECHER) &amp;&amp; !thePrefs.GetAntiLeecherLog())</span><br><span class=\"line\">\treturn;\t</span><br><span class=\"line\">//Xman end</span><br></pre></td></tr></table></figure>\n\n<p>首先是一个ASSERT断言，这个断言要求 pszLine （函数第三个参数）不能为空。</p>\n<p>接着如果同时满足下列两个条件，则函数返回：</p>\n<ul>\n<li>条件1：表达式 <strong>((uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER))</strong> 为真；</li>\n<li>条件2：表达式 <strong>!(thePrefs.GetVerbose() &amp;&amp; dlpPriority &gt;&#x3D; thePrefs.GetVerboseLogPriority())</strong> 为真。</li>\n</ul>\n<p>我们先看<strong>条件1</strong>，很多年以前，我对这种按位或运算（**|**）和按位与运算（＆）来组合这些程序中的标志的原理一头雾水，虽然那个时候，我知道这些运算符的含义。</p>\n<p>现在就以这两个为例吧：</p>\n<p>按位<strong>或</strong>运算，就是把两个数在二进制层面上按位或，比如二进制数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 | 10 = 11</span><br></pre></td></tr></table></figure>\n\n<p>第一个数字高位上 <strong>1</strong> 与第二个数字高位上的 <strong>1</strong> 来进行或运算，等于 <strong>1</strong>，放在高位；</p>\n<p>第一个数字低位上 <strong>1</strong> 与第二个数字低位上的 <strong>0</strong> 来进行或运算，等于 <strong>1</strong>，放在低位。</p>\n<p>同理，<strong>与</strong>运算：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 &amp; 10 = 10</span><br></pre></td></tr></table></figure>\n\n<p>按位与，要求两个数字都是 <strong>1</strong> 才是 <strong>1</strong>；而按位或只要有一个是 <strong>1</strong> 就等于 <strong>1</strong>，除非两者都是 <strong>0</strong>，则为 <strong>0</strong>。</p>\n<p>看个复杂的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11001100 &amp; 10101010 = 10001000</span><br></pre></td></tr></table></figure>\n\n<p>这种做法有个两个好处：</p>\n<ul>\n<li><p>第一，可以将某个位置的上的数字来代表当前的状态，比如电路中 <strong>1</strong> 代表开，<strong>0</strong> 代表关。那么我用下面数字 <strong>a ＝ 10001000</strong> 表示电路开关状态，你会发现电路是开的。</p>\n<p>再比如，颜色值 RGB 表示法：CD1298， 我想把其中绿色值单独提取出来，怎么做？</p>\n<p>方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GreenValue = 0xCD1298 &amp; 0x001200,</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以做到了。</p>\n</li>\n<li><p>第二，因为是二进制层次上的操作，所以速度非常快。</p>\n</li>\n</ul>\n<p>我们现在分析下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(uFlags &amp; LOG_DEBUG) || (uFlags &amp; LOG_LEECHER)</span><br></pre></td></tr></table></figure>\n\n<p>先看第一部分：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uFlags &amp; LOG_DEBUG</span><br></pre></td></tr></table></figure>\n\n<p>再结合下面的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log message targets flags</span><br><span class=\"line\">#define LOG_DEFAULT      0x00</span><br><span class=\"line\">#define LOG_DEBUG       0x10</span><br><span class=\"line\">#define LOG_STATUSBAR 0x20</span><br><span class=\"line\">#define LOG_DONTNOTIFY   0x40</span><br><span class=\"line\">#define LOG_LEECHER      0x80 //Xman Anti-Leecher-Log</span><br></pre></td></tr></table></figure>\n\n<p>这几个常量定义的数值是有讲究的，不是任何数值都行的。我们将它们都化成二进制：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOG_DEFAULT      0000 0000</span><br><span class=\"line\">LOG_DEBUG        0001 0000</span><br><span class=\"line\">LOG_STATUSBAR    0010 0000</span><br><span class=\"line\">LOG_DONTNOTIFY   0100 0000</span><br><span class=\"line\">LOG_LEECHER      1000 0000</span><br></pre></td></tr></table></figure>\n\n<p>这样假如 uFlags &#x3D; 1010 0000，这样我要检测是否设置了LOG_DEBUG，我只要这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result = uFlags &amp; LOG_DEBUG</span><br></pre></td></tr></table></figure>\n\n<p>计算结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result =&gt; 0000 0000 =&gt; 0</span><br></pre></td></tr></table></figure>\n\n<p>这样 <strong>if（RESULT）{}</strong> 中条件为假；说明我没有设置这个标志位；同理我需要检测是否设置 LOG_STATUSBAR 标志，则执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result = uFlags &amp; LOG_STATUSBAR = 0001 0000</span><br></pre></td></tr></table></figure>\n\n<p>这个数字化为十进制不为 0，所以为真，因此在判断语句里面条件也为真，说明设置了这个标志位。</p>\n<p>这是正面检测，反过来我想设置这些标识位，而且可以一次设置多个标志位，比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uFlags = LOG_STATUSBAR  |  LOG_DONTNOTIFY | LOG_LEECHER = 1110 0000</span><br></pre></td></tr></table></figure>\n\n<p>是不是一目了然？</p>\n<p>而且我也可以很方便地从设置好的标志位中去掉某个或某些标识位，比如我想从上面的uFlags值中去掉<strong>LOG_DONTNOTIFY</strong> 标识，怎么办？这样做就可以了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uFlags &amp; (~LOG_DONTNOTIFY)</span><br></pre></td></tr></table></figure>\n\n<p>来解释下<strong>～</strong>符号是二进制层次上求反，将对应位上的 <strong>1</strong> 改为 <strong>0</strong>，<strong>0</strong> 改为 <strong>1</strong>，那么：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ LOG_DONTNOTIFY = 1011 1111</span><br></pre></td></tr></table></figure>\n\n<p>然后与 uFlags 或起来等于 <strong>1010 0000</strong>，你看下是不是刚好把 <strong>LOG_DONTNOTIFY</strong> 去掉了呀？</p>\n<p>这种方法效率高不仅是因为在二进制层次上运算，而且它可以用一个较小的数据类型代表多个信息，对数据的利用程度精准到二进制位。</p>\n","text":"不定参数函数实现var_arg系列的宏电驴的源码日志模块有一个叫 DebugLogError 函数，其签名如下： 12//代码位于easyMule-master...","permalink":"/post/转载/cpp/不定参数函数实现var_arg系列的宏","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0var-arg%E7%B3%BB%E5%88%97%E7%9A%84%E5%AE%8F\"><span class=\"toc-text\">不定参数函数实现var_arg系列的宏</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】C++必须掌握的pimpl惯用法","uid":"674a06ff970318ba143bc66d58326f5d","slug":"转载/cpp/C++必须掌握的pimpl惯用法","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:21.026Z","comments":true,"path":"api/articles/转载/cpp/C++必须掌握的pimpl惯用法.json","keywords":null,"cover":null,"text":"pimpl 惯用法现在这里有一个名为 CSocketClient 的网络通信类，定义如下： 1234567891011121314151617181920212...","permalink":"/post/转载/cpp/C++必须掌握的pimpl惯用法","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】你一定要搞明白的C函数调用方式与栈原理","uid":"c9abbbdef4e88dc3f27e1c9bd42d47df","slug":"转载/cpp/你一定要搞明白的C函数调用方式与栈原理","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/cpp/你一定要搞明白的C函数调用方式与栈原理.json","keywords":null,"cover":[],"text":"你一定要搞明白的C函数调用方式与栈原理写在前面的话 这绝对不是标题党。而是C/C++开发中你必须要掌握的基础知识，也是高级技术岗位面试中高频题。我真的真的真的希...","permalink":"/post/转载/cpp/你一定要搞明白的C函数调用方式与栈原理","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}