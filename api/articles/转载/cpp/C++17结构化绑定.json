{"title":"【转载】C++17结构化绑定","uid":"7e72488827dc1c1de5e7eda02fcbe24e","slug":"转载/cpp/C++17结构化绑定","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:21.026Z","comments":true,"path":"api/articles/转载/cpp/C++17结构化绑定.json","keywords":null,"cover":null,"content":"<h2 id=\"C-17-结构化绑定\"><a href=\"#C-17-结构化绑定\" class=\"headerlink\" title=\"C++ 17 结构化绑定\"></a>C++ 17 结构化绑定</h2><p>stl 的 map 容器很多读者应该都很熟悉，map 容器提供了一个 <strong>insert</strong> 方法，我们用该方法向 map 中插入元素，但是应该很少有人记得 <strong>insert</strong> 方法的返回值是什么类型，让我们来看一下 C++98&#x2F;03 提供的 <strong>insert</strong> 方法的签名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );</span><br></pre></td></tr></table></figure>\n\n<p>这里我们仅关心其返回值，这个返回值是一个 <strong>std::pair</strong> 类型，由于 map 中的元素的 key 不允许重复，所以如果 insert 方法调用成功，T1 是被成功插入到 map 中的元素的迭代器，T2 的类型为 bool，此时其值为 true（表示插入成功）；如果 insert 由于 key 重复，T1 是造成 insert 插入失败、已经存在于 map 中的元素的迭代器，此时 T2 的值为 false（表示插入失败）。</p>\n<p>在 C++98&#x2F;03 标准中我们可以使用 <strong>std::pair</strong> 的 <strong>first</strong> 和 <strong>second</strong> 属性来分别引用 T1 和 T2 的值。如下面的我们熟悉的代码所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;map&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;std::string, int&gt; cities;</span><br><span class=\"line\">    cities[&quot;beijing&quot;]   = 0;</span><br><span class=\"line\">    cities[&quot;shanghai&quot;]  = 1;</span><br><span class=\"line\">    cities[&quot;shenzhen&quot;]  = 2;</span><br><span class=\"line\">    cities[&quot;guangzhou&quot;] = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    //for (const auto&amp; [key, value] : m)</span><br><span class=\"line\">    //&#123;</span><br><span class=\"line\">    //    std::cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">    //&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //这一行在 C++11 之前写法实在太麻烦了，</span><br><span class=\"line\">    //std::pair&lt;std::map&lt;std::string, int&gt;::iterator, int&gt; insertResult = cities.insert(std::pair&lt;std::string, int&gt;(&quot;shanghai&quot;, 2));</span><br><span class=\"line\">    //C++ 11中我们写成：</span><br><span class=\"line\">    auto insertResult = cities.insert(std::pair&lt;std::string, int&gt;(&quot;shanghai&quot;, 2));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; &quot;Is insertion successful ? &quot; &lt;&lt; (insertResult.second ? &quot;true&quot; : &quot;false&quot;) </span><br><span class=\"line\">              &lt;&lt; &quot;, element key: &quot; &lt;&lt; insertResult.first-&gt;first &lt;&lt; &quot;, value: &quot; &lt;&lt; insertResult.first-&gt;second &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码 <strong>19</strong> 行实在太啰嗦了，我们使用 auto 关键字让编译器自动推导类型。</p>\n<p><strong>std::pair</strong> 一般只能表示两个元素，C++11 标准中引入了 <strong>std::tuple</strong> 类型，有了这个类型，我们就可以放任意个元素了，原来需要定义成结构体的 POD 对象我们可以直接使用 <strong>std::tuple</strong> 表示，例如下面表示用户信息的结构体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct UserInfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string username;</span><br><span class=\"line\">    std::string password;</span><br><span class=\"line\">    int         gender;</span><br><span class=\"line\">    int         age;</span><br><span class=\"line\">    std::string address;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UserInfo userInfo = &#123; &quot;Tom&quot;, &quot;123456&quot;, 0, 25, &quot;Pudong Street&quot; &#125;;</span><br><span class=\"line\">    std::string username = userInfo.username;</span><br><span class=\"line\">    std::string password = userInfo.password;</span><br><span class=\"line\">    int gender = userInfo.gender;</span><br><span class=\"line\">    int age = userInfo.age;</span><br><span class=\"line\">    std::string address = userInfo.address;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们不再需要定义 struct UserInfo 这样的对象，可以直接使用 <strong>std::tuple</strong> 表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    std::tuple&lt;std::string, std::string, int, int, std::string&gt; userInfo(&quot;Tom&quot;, &quot;123456&quot;, 0, 25, &quot;Pudong Street&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::string username = std::get&lt;0&gt;(userInfo);</span><br><span class=\"line\">    std::string password = std::get&lt;1&gt;(userInfo);</span><br><span class=\"line\">    int gender = std::get&lt;2&gt;(userInfo);</span><br><span class=\"line\">    int age = std::get&lt;3&gt;(userInfo);</span><br><span class=\"line\">    std::string address = std::get&lt;4&gt;(userInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从 <strong>std::tuple</strong> 中获取对应位置的元素，我们使用 <strong>std::get</strong> ，其中 N 是元素的序号（从 0 开始）。</p>\n<p>与定义结构体相比，通过 <strong>std::pair</strong> 的 <strong>first</strong> 和 <strong>second</strong> 还是 <strong>std::tuple</strong> 的 <strong>std::get</strong> 方法来获取元素子属性，这些代码都是非常难以维护的，其根本原因是 <strong>first</strong> 和 <strong>second</strong> 这样的命名不能做到见名知意。</p>\n<p>C++17 引入的<strong>结构化绑定</strong>（Structured Binding ）将我们从这类代码中解放出来。<strong>结构化绑定</strong>使用语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto [a, b, c, ...] = expression;</span><br><span class=\"line\">auto [a, b, c, ...] &#123; expression &#125;;</span><br><span class=\"line\">auto [a, b, c, ...] ( expression );</span><br></pre></td></tr></table></figure>\n\n<p>右边的 <strong>expression</strong> 可以是一个函数调用、花括号表达式或者支持结构化绑定的某个类型的变量。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//形式1</span><br><span class=\"line\">auto [iterator, inserted] = someMap.insert(...);</span><br><span class=\"line\">//形式2</span><br><span class=\"line\">double myArray[3] = &#123; 1.0, 2.0, 3.0 &#125;;</span><br><span class=\"line\">auto [a, b, c] = myArray;</span><br><span class=\"line\">//形式3</span><br><span class=\"line\">struct Point</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double x;</span><br><span class=\"line\">    double y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point myPoint(10.0, 20.0);</span><br><span class=\"line\">auto [myX, myY] = myPoint;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们可以给用于绑定到目标的变量名（语法中的 <strong>a</strong>、<strong>b</strong>、<strong>c</strong>）起一个有意义的名字。</p>\n<p>需要注意的是，绑定名称 <strong>a</strong>、<strong>b</strong>、<strong>c</strong> 是绑定目标的一份拷贝，当绑定类型不是基础数据类型时，如果你的本意不是想要得到绑定目标的副本，为了避免拷贝带来的不必要开销，建议使用引用，如果不需要修改绑定目标建议使用 const 引用。示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double myArray[3] = &#123; 1.0, 2.0, 3.0 &#125;;</span><br><span class=\"line\">auto&amp; [a, b, c] = myArray;</span><br><span class=\"line\">//形式3</span><br><span class=\"line\">struct Point</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double x;</span><br><span class=\"line\">    double y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point myPoint(10.0, 20.0);</span><br><span class=\"line\">const auto&amp; [myX, myY] = myPoint;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结构化绑定</strong>（Structured Binding ）是 C++17 引入的一个非常好用的语法特性。有了这种语法，在遍历像 map 这样的容器时，我们可以使用更简洁和清晰的代码去遍历这些容器了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::map&lt;std::string, int&gt; cities;</span><br><span class=\"line\">cities[&quot;beijing&quot;] = 0;</span><br><span class=\"line\">cities[&quot;shanghai&quot;] = 1;</span><br><span class=\"line\">cities[&quot;shenzhen&quot;] = 2;</span><br><span class=\"line\">cities[&quot;guangzhou&quot;] = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const auto&amp; [cityName, cityNumber] : cities)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; cityName &lt;&lt; &quot;: &quot; &lt;&lt; cityNumber &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中 <strong>cityName</strong> 和 <strong>cityNumber</strong> 可以更好地反映出这个 map 容器的元素内容。</p>\n<p>我们再来看一个例子，某 WebSocket 网络库（<a href=\"https://github.com/uNetworking/uWebSockets%EF%BC%89%E4%B8%AD%E6%9C%89%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A\">https://github.com/uNetworking/uWebSockets）中有如下代码：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::pair&lt;int, bool&gt; uncork(const char *src = nullptr, int length = 0, bool optionally = false) &#123;</span><br><span class=\"line\">        LoopData *loopData = getLoopData();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (loopData-&gt;corkedSocket == this) &#123;</span><br><span class=\"line\">            loopData-&gt;corkedSocket = nullptr;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (loopData-&gt;corkOffset) &#123;</span><br><span class=\"line\">                /* Corked data is already accounted for via its write call */</span><br><span class=\"line\">                auto [written, failed] = write(loopData-&gt;corkBuffer, loopData-&gt;corkOffset, false, length);</span><br><span class=\"line\">                loopData-&gt;corkOffset = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (failed) &#123;</span><br><span class=\"line\">                    /* We do not need to care for buffering here, write does that */</span><br><span class=\"line\">                    return &#123;0, true&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            /* We should only return with new writes, not things written to cork already */</span><br><span class=\"line\">            return write(src, length, optionally, 0);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            /* We are not even corked! */</span><br><span class=\"line\">            return &#123;0, false&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码的第 <strong>9</strong> 行 <strong>write</strong> 函数返回类型是 <strong>std::pair</strong>，被绑定到 <strong>[written, failed]</strong> 这两个变量中去。前者在写入成功的情况下表示实际写入的字节数，后者表示是否写入成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::pair&lt;int, bool&gt; write(const char *src, int length, bool optionally = false, int nextLength = 0) &#123;</span><br><span class=\"line\">    //具体实现省略...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结构化绑定的限制</strong></p>\n<p>结构化绑定不能使用 <strong>constexpr</strong> 修饰或被申明为 static，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//正常编译</span><br><span class=\"line\">auto [first, second] = std::pair&lt;int, int&gt;(1, 2);</span><br><span class=\"line\">//无法编译通过</span><br><span class=\"line\">//constexpr auto [first, second] = std::pair&lt;int, int&gt;(1, 2);</span><br><span class=\"line\">//无法编译通过</span><br><span class=\"line\">//static auto [first, second] = std::pair&lt;int, int&gt;(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p>注意：有些编译器也不支持在 lamda 表达式捕获列表中使用结构化绑定语法。</p>\n","text":"C++ 17 结构化绑定stl 的 map 容器很多读者应该都很熟悉，map 容器提供了一个 insert 方法，我们用该方法向 map 中插入元素，但是应该很...","permalink":"/post/转载/cpp/C++17结构化绑定","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-17-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">C++ 17 结构化绑定</span></a></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Qt应用程序中的 QApplication","uid":"5d28961e81afaf3d71dc0378d856ba40","slug":"Qt/基础教程/Qt应用程序中的 QApplication","date":"2021-06-05T08:34:06.000Z","updated":"2023-05-19T05:34:19.708Z","comments":true,"path":"api/articles/Qt/基础教程/Qt应用程序中的 QApplication.json","keywords":null,"cover":null,"text":"Qt应用程序中的 QApplicationQApplication类是一个Qt框架中核心的应用程序类，它提供了管理应用程序的框架、事件循环和系统级配置的基础。在...","permalink":"/post/Qt/基础教程/Qt应用程序中的 QApplication","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Qt基础教程","slug":"Qt基础教程","count":19,"path":"api/categories/Qt基础教程.json"}],"tags":[{"name":"Qt","slug":"Qt","count":59,"path":"api/tags/Qt.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】C++必须掌握的pimpl惯用法","uid":"674a06ff970318ba143bc66d58326f5d","slug":"转载/cpp/C++必须掌握的pimpl惯用法","date":"2021-05-06T09:27:48.000Z","updated":"2023-05-19T05:34:21.026Z","comments":true,"path":"api/articles/转载/cpp/C++必须掌握的pimpl惯用法.json","keywords":null,"cover":null,"text":"pimpl 惯用法现在这里有一个名为 CSocketClient 的网络通信类，定义如下： 1234567891011121314151617181920212...","permalink":"/post/转载/cpp/C++必须掌握的pimpl惯用法","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}