{"title":"【转载】你一定要搞明白的C函数调用方式与栈原理","uid":"c9abbbdef4e88dc3f27e1c9bd42d47df","slug":"转载/cpp/你一定要搞明白的C函数调用方式与栈原理","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/cpp/你一定要搞明白的C函数调用方式与栈原理.json","keywords":null,"cover":[],"content":"<h2 id=\"你一定要搞明白的C函数调用方式与栈原理\"><a href=\"#你一定要搞明白的C函数调用方式与栈原理\" class=\"headerlink\" title=\"你一定要搞明白的C函数调用方式与栈原理\"></a>你一定要搞明白的C函数调用方式与栈原理</h2><p><strong>写在前面的话</strong></p>\n<p><strong>这绝对不是标题党。而是C&#x2F;C++开发中你必须要掌握的基础知识，也是高级技术岗位面试中高频题。我真的真的真的希望无论是学生还是广大C&#x2F;C++开发者，都该掌握此文中介绍的知识。</strong></p>\n<p><strong>正文</strong></p>\n<p>这篇blog试图讲明当一个c函数被调用时，一个**栈帧(stack frame)**是如何被建立，又如何被消除的。这些细节跟操作系统平台及编译器的实现有关，下面的描述是针对运行在Intel奔腾芯片上Linux的gcc编译器而言。c语言的标准并没有描述实现的方式，所以，不同的编译器，处理器，操作系统都可能有自己的建立栈帧的方式。</p>\n<h3 id=\"一个典型的栈帧\"><a href=\"#一个典型的栈帧\" class=\"headerlink\" title=\"一个典型的栈帧\"></a>一个典型的栈帧</h3><p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack1.png\"></p>\n<p>图1是一个典型的栈帧，图中，栈顶在上，地址空间往下增长。<br>这是如下一个函数调用时的栈的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int foo(int arg1, int arg2, int arg3); </span><br></pre></td></tr></table></figure>\n\n<p>并且，foo有两个局部的int变量（4个字节）。在这个简化的场景中，main调用foo，而程序的控制仍在foo中。这里，main是调用者（caller），foo是被调用者（callee）。<br><strong>ESP被foo使用来指示栈顶。EBP相当于一个“基准指针”</strong>。从main传递到foo的参数以及foo本身的局部变量都可以通过这个基准指针为参考，加上偏移量找到。<br>由于被调用者允许使用EAX，ECX和EDX寄存器，所以如果调用者希望保存这些寄存器的值，就必须在调用子函数之前显式地把他们保存在栈中。另一方面，如果除了上面提到的几个寄存器，被调用者还想使用别的寄存器，比如EBX，ESI和EDI，那么，被调用者就必须在栈中保存这些被额外使用的寄存器，并在调用返回前回复他们。也就是说，如果被调用者只使用约定的EAX，ECX和EDX寄存器，他们由调用者负责保存并回复，但如果被调用这还额外使用了别的寄存器，则必须有他们自己保存并回复这些寄存器的值。<br>传递给foo的参数被压到栈中，最后一个参数先进栈，所以第一个参数是位于栈顶的。foo中声明的局部变量以及函数执行过程中需要用到的一些临时变量也都存在栈中。<br><strong>小于等于4个字节的返回值会被保存到<strong><strong>EAX</strong></strong>中</strong>，如果大于4字节，小于8字节，那么EDX也会被用来保存返回值。如果返回值占用的空间还要大，那么调用者会向被调用者传递一个额外的参数，这个额外的参数指向将要保存返回值的地址。用C语言来说，就是函数调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = foo(a, b, c);</span><br></pre></td></tr></table></figure>\n\n<p>被转化为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(&amp;x, a, b, c);</span><br></pre></td></tr></table></figure>\n\n<p>注意，这仅仅在返回值占用大于<strong>8个字节</strong>时才发生。有的编译器不用EDX保存返回值，所以当返回值大于4个字节时，就用这种转换。<br>当然，并不是所有函数调用都直接赋值给一个变量，还可能是直接参与到某个表达式的计算中，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m = foo(a, b, c) + foo(d, e, f);</span><br></pre></td></tr></table></figure>\n\n<p>有或者作为另外的函数的参数， 如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooo(foo(a, b, c), 3);</span><br></pre></td></tr></table></figure>\n\n<p>这些情况下，foo的返回值会被保存在一个临时变量中参加后续的运算，所以，foo(a, b, c)还是可以被转化成**foo(&amp;tmp, a, b, c)**。</p>\n<p>让我们一步步地看一下在c函数调用过程中，一个栈帧是如何建立及消除的。</p>\n<h3 id=\"函数调用前调用者的动作\"><a href=\"#函数调用前调用者的动作\" class=\"headerlink\" title=\"函数调用前调用者的动作\"></a>函数调用前调用者的动作</h3><p>在我们的例子中，调用者是main，它准备调用函数foo。在函数调用前，main正在用ESP和EBP寄存器指示它自己的栈帧。</p>\n<p>首先，main把EAX，ECX和EDX压栈。这是一个可选的步骤，只在这三个寄存器内容需要保留的时候执行此步骤。<br>接着，main把传递给foo的参数一一进栈，最后的参数最先进栈。例如，我们的函数调用是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = foo(12, 15, 18);</span><br></pre></td></tr></table></figure>\n\n<p>相应的汇编语言指令是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push dword 18</span><br><span class=\"line\">push dword 15</span><br><span class=\"line\">push dword 12</span><br></pre></td></tr></table></figure>\n\n<p>最后，main用call指令调用子函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call foo</span><br></pre></td></tr></table></figure>\n\n<p><strong>当call指令执行的时候，EIP指令指针寄存器的内容被压入栈中</strong>。因为EIP寄存器是指向main中的下一条指令，所以现在返回地址就在栈顶了。在call指令执行完之后，下一个执行周期将从名为foo的标记处开始。<br>图2展示了call指令完成后栈的内容。图2及后续图中的<strong>粗线</strong>指示了函数调用前栈顶的位置。我们将会看到，当整个函数调用过程结束后，栈顶又回到了这个位置。</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack2.png\"></p>\n<h3 id=\"被调用者在函数调用后的动作\"><a href=\"#被调用者在函数调用后的动作\" class=\"headerlink\" title=\"被调用者在函数调用后的动作\"></a>被调用者在函数调用后的动作</h3><p>当函数foo，也就是被调用者取得程序的控制权，它<strong>必须做3件事</strong>：建立它自己的栈帧，为局部变量分配空间，最后，如果需要，保存寄存器EBX，ESI和EDI的值。<br>首先foo必须建立它自己的栈帧。EBP寄存器现在正指向main的栈帧中的某个位置，这个值必须被保留，因此，EBP进栈。然后ESP的内容赋值给了EBP。这使得函数的参数可以通过对EBP附加一个偏移量得到，而栈寄存器ESP便可以空出来做其他事情。如此一来，几乎所有的c函数都由如下两个指令开始：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ebp</span><br><span class=\"line\">mov ebp, esp</span><br></pre></td></tr></table></figure>\n\n<p>此时的栈入图3所示。在这个场景中，第一个参数的地址是EBP加8，因为main的EBP和返回地址各在栈中占了4个字节。</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack3.png\"></p>\n<p>​       </p>\n<p>下一步，foo必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。比如，foo中的一些C语句可能包括复杂的表达式，其子表达式的中间值就必须得有地方存放。这些存放中间值的地方同城被称为临时的，因为他们可以为下一个复杂表达式所复用。为说明方便，我们假设我们的foo中有两个int类型（每个4字节）的局部变量，需要额外的12字节的临时存储空间。简单地把栈指针减去20便为这20个字节分配了空间：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub esp, 20</span><br></pre></td></tr></table></figure>\n\n<p>现在，局部变量和临时存储都可以通过基准指针EBP加偏移量找到了。<br>最后，如果foo用到EBX，ESI和EDI寄存器，则它f必须在栈里保存它们。结果，现在的栈如图4所示。 </p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack4.png\"></p>\n<p>​    </p>\n<p>foo的函数体现在可以执行了。这其中也许有进栈、出栈的动作，栈指针ESP也会上下移动，但EBP是保持不变的。这意味着我们可以一直用[EBP+8]找到第一个参数，而不管在函数中有多少进出栈的动作。<br>函数foo的执行也许还会调用别的函数，甚至递归地调用foo本身。然而，只要EBP寄存器在这些子调用返回时被恢复，就可以继续用EBP加上偏移量的方式访问实际参数，局部变量和临时存储。</p>\n<h3 id=\"被调用者返回前的动作\"><a href=\"#被调用者返回前的动作\" class=\"headerlink\" title=\"被调用者返回前的动作\"></a>被调用者返回前的动作</h3><p>在把程序控制权返还给调用者前，被调用者foo必须先把返回值保存在<strong>EAX</strong>寄存器中。我们前面已经讨论过，当返回值占用多于4个或8个字节时，接收返回值的变量地址会作为一个额外的指针参数被传到函数中，而函数本身就不需要返回值了。这种情况下，被调用者直接通过内存拷贝把返回值直接拷贝到接收地址，从而省去了一次通过栈的中转拷贝。<br>其次，foo必须恢复EBX，ESI和EDI寄存器的值。如果这些寄存器被修改，正如我们前面所说，我们会在foo执行开始时把它们的<strong>原始值压入栈中</strong>。如果ESP寄存器指向如图4所示的正确位置，寄存器的原始值就可以出栈并恢复。可见，在foo函数的执行过程中正确地跟踪ESP是多么的重要————也就是说，进栈和出栈操作的次数必须保持平衡。<br>这两步之后，我们不再需要foo的局部变量和临时存储了，我们可以通过下面的指令消除栈帧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov esp, ebp</span><br><span class=\"line\">pop ebp</span><br></pre></td></tr></table></figure>\n\n<p>其结果就是现在栈里的内容跟图2中所示的栈完全一样。现在可以执行返回指令了。从栈里弹出返回地址，赋值给EIP寄存器。栈如图5所示：</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack5.png\"> </p>\n<p>i386指令集有一条<strong>“leave”</strong>指令，它与上面提到的mov和pop指令所作的动作完全相同。所以，C函数通常以这样的指令结束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leave</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"调用者在返回后的动作\"><a href=\"#调用者在返回后的动作\" class=\"headerlink\" title=\"调用者在返回后的动作\"></a>调用者在返回后的动作</h3><p>在程序控制权返回到调用者（也就是我们例子中的main）后，栈如图5所示。这时，传递给foo的参数通常已经不需要了。我们可以把3个参数一起弹出栈，这可以通过把栈指针加12（&#x3D;3个4字节）实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add esp, 12</span><br></pre></td></tr></table></figure>\n\n<p>如果在函数调用前，EAX，ECX和EDX寄存器的值被保存在栈中，调用者main函数现在可以把它们弹出。这个动作之后，栈顶就回到了我们开始整个函数调用过程前的位置，也就是图5中粗线的位置。</p>\n<p>看个具体的实例：</p>\n<p>这段代码反汇编后，代码是什么呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">long test(int a, int b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ta = a + 3;</span><br><span class=\"line\">\tb = b + 5;</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprintf(&quot;%d&quot;, test(10,90));</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来看一个概貌：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9:   int main(int argc, char* argv[])</span><br><span class=\"line\">10:   &#123;</span><br><span class=\"line\">00401070   push        ebp</span><br><span class=\"line\">00401071   mov         ebp,esp</span><br><span class=\"line\">00401073   sub         esp,40h</span><br><span class=\"line\">00401076   push        ebx</span><br><span class=\"line\">00401077   push        esi</span><br><span class=\"line\">00401078   push        edi</span><br><span class=\"line\">00401079   lea         edi,[ebp-40h]</span><br><span class=\"line\">0040107C   mov         ecx,10h</span><br><span class=\"line\">00401081   mov         eax,0CCCCCCCCh</span><br><span class=\"line\">00401086   rep stos    dword ptr [edi]</span><br><span class=\"line\">11:        printf(&quot;%d&quot;,test(10,90));</span><br><span class=\"line\">00401088   push        5Ah</span><br><span class=\"line\">0040108A   push        0Ah</span><br><span class=\"line\">0040108C   call        @ILT+0(test) (00401005)</span><br><span class=\"line\">00401091   add         esp,8</span><br><span class=\"line\">00401094   push        eax</span><br><span class=\"line\">00401095   push        offset string &quot;%d&quot; (0042201c)</span><br><span class=\"line\">0040109A   call        printf (004010d0)</span><br><span class=\"line\">0040109F   add         esp,8</span><br><span class=\"line\">12:        return 0;</span><br><span class=\"line\">004010A2   xor         eax,eax</span><br><span class=\"line\">13:   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面来解释一下，</p>\n<p><img src=\"/images/posts/%E8%BD%AC%E8%BD%BD/imgs/../imgs/stack6.png\"><br>开始进入Main函数 esp&#x3D;0x12FF84  ebp&#x3D;0x12FFC0<br>完成椭圆形框起来的部分：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401070   push        ebp</span><br></pre></td></tr></table></figure>\n\n<p><strong>ebp的值入栈，保存现场(调用现场</strong>，从test函数看，如红线所示，即保存的0x12FF80用于从test函数堆栈返回到main函数)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401071    mov        ebp,esp </span><br></pre></td></tr></table></figure>\n\n<p>此时ebp＝0x12FF80 <strong>此时ebp就是“当前函数堆栈”的基址 以便访问堆栈中的信息；还有就是从当前函数栈顶返回到栈底：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401073     sub        esp,40h   </span><br></pre></td></tr></table></figure>\n\n<p>函数使用的堆栈，默认64个字节，堆栈上就是16个横条（密集线部分）此时esp&#x3D;0x12FF40。<br>在上图中，上面密集线是test函数堆栈空间，下面是Main的堆栈空间(补充，其实这个就叫做 <strong>Stack Frame</strong>)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401076   push        ebx</span><br><span class=\"line\">00401077   push        esi</span><br><span class=\"line\">00401078   push        edi    入栈 </span><br><span class=\"line\">00401079   lea         edi,[ebp-40h]</span><br><span class=\"line\">0040107C   mov         ecx,10h</span><br><span class=\"line\">00401081   mov         eax,0CCCCCCCCh</span><br><span class=\"line\">00401086   rep stos    dword ptr [edi]      </span><br></pre></td></tr></table></figure>\n\n<p>初始化用于该函数的栈空间为0XCCCCCCCC，即从0x12FF40~0x12FF80所有的值均为0xCCCCCCCC：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:        printf(&quot;%d&quot;,test(10,90));</span><br><span class=\"line\">00401088   push        5Ah    参数入栈 从右至左 先90  后10</span><br><span class=\"line\">0040108A   push        0Ah </span><br><span class=\"line\">0040108C   call        @ILT+0(test) (00401005)    </span><br></pre></td></tr></table></figure>\n\n<p>函数调用，转向eip 00401005 。<br><strong>注意，此时仍入栈，入栈的是call test 指令下一条指令的地址00401091下一条指令是add esp,8。</strong><br>@ILT+0(?test@@YAJHH@Z):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401005   jmp       test (00401020)   </span><br></pre></td></tr></table></figure>\n\n<p>即转向被调函数test：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 2:    long test(int a,int b)</span><br><span class=\"line\"> 3:    &#123;</span><br><span class=\"line\">00401020   push        ebp</span><br><span class=\"line\">00401021   mov         ebp,esp           </span><br><span class=\"line\">00401023   sub         esp,40h</span><br><span class=\"line\">00401026   push        ebx</span><br><span class=\"line\">00401027   push        esi</span><br><span class=\"line\">00401028   push        edi</span><br><span class=\"line\">00401029   lea         edi,[ebp-40h]</span><br><span class=\"line\">0040102C   mov         ecx,10h</span><br><span class=\"line\">00401031   mov         eax,0CCCCCCCCh</span><br><span class=\"line\">00401036   rep stos    dword ptr [edi]       //这些和上面一样</span><br><span class=\"line\">4:        a = a + 3;                                    </span><br><span class=\"line\">00401038   mov         eax,dword ptr [ebp+8] //ebp=0x12FF24 加8 [0x12FF30]即取到了参数10</span><br><span class=\"line\">0040103B   add         eax,3</span><br><span class=\"line\">0040103E   mov         dword ptr [ebp+8],eax</span><br><span class=\"line\">5:        b = b + 5;</span><br><span class=\"line\">00401041   mov         ecx,dword ptr [ebp+0Ch]</span><br><span class=\"line\">00401044   add         ecx,5</span><br><span class=\"line\">00401047   mov         dword ptr [ebp+0Ch],ecx</span><br><span class=\"line\">6:        return a + b;</span><br><span class=\"line\">0040104A   mov         eax,dword ptr [ebp+8]</span><br><span class=\"line\">0040104D   add         eax,dword ptr [ebp+0Ch]  //最后的结果保存在eax, 结果得以返回</span><br><span class=\"line\">7:   &#125;</span><br><span class=\"line\">00401050   pop         edi                 </span><br><span class=\"line\">00401051   pop         esi</span><br><span class=\"line\">00401052   pop         ebx</span><br><span class=\"line\">00401053   mov         esp,ebp    //esp指向0x12FF24, test函数的堆栈空间被放弃，从当前函数栈顶返回到栈底</span><br><span class=\"line\">00401055   pop         ebp        //此时ebp=0x12FF80, 恢复现场  esp=0x12FF28</span><br><span class=\"line\">00401056   ret                    //ret负责栈顶0x12FF28之值00401091弹出到指令寄存器中，esp=0x12FF30</span><br></pre></td></tr></table></figure>\n\n<p>因为win32汇编一般用eax返回结果 所以如果最终结果不是在eax里面的话 还要把它放到eax。</p>\n<p>注意，从被调函数返回时，是弹出EBP,恢复堆栈到函数调用前的地址，弹出返回地址到EIP以继续执行程序。</p>\n<p>从test函数返回，执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401091   add         esp,8       </span><br></pre></td></tr></table></figure>\n\n<p>清栈，清除两个压栈的参数10 90 调用者main负责。<br><strong>(所谓__cdecl调用由调用者负责恢复栈，调用者负责清理的只是入栈的参数，test函数自己的堆栈空间自己返回时自己已经清除，靠！一直理解错)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401094   push        eax          //入栈，计算结果108入栈，即printf函数的参数之一入栈</span><br><span class=\"line\">00401095   push        offset string &quot;%d&quot; (0042201c)//入栈，参数 &quot;%d&quot;  当然其实是％d的地址</span><br><span class=\"line\">0040109A   call        printf (004010d0)//函数调用 printf(&quot;%d&quot;,108) 因为printf函数时</span><br><span class=\"line\">0040109F   add         esp,8       //清栈，清除参数 (&quot;%d&quot;, 108)</span><br><span class=\"line\">19:        return 0;           </span><br><span class=\"line\">004010A2   xor         eax,eax     //eax清零</span><br><span class=\"line\">20:   &#125;     </span><br></pre></td></tr></table></figure>\n\n<p>main函数执行完毕 此时esp&#x3D;0x12FF34 ebp&#x3D;0x12FF80：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">004010A4   pop         edi</span><br><span class=\"line\">004010A5   pop         esi</span><br><span class=\"line\">004010A6   pop         ebx</span><br><span class=\"line\">004010A7   add         esp,40h    //为啥不用mov esp, ebp? 是为了下面的比较</span><br><span class=\"line\">004010AA   cmp         ebp,esp   //比较，若不同则调用chkesp抛出异常</span><br><span class=\"line\">004010AC   call        __chkesp (00401150)   </span><br><span class=\"line\">004010B1   mov         esp,ebp   </span><br><span class=\"line\">004010B3   pop         ebp          //ESP=0X12FF84  </span><br></pre></td></tr></table></figure>\n\n<p>EBP&#x3D;0x12FFC0 尘归尘 土归土 一切都恢复最初的平静了 :)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">004010B4   ret</span><br></pre></td></tr></table></figure>\n\n<p>另：</p>\n<ol>\n<li>如果函数调用方式是**__stdcall**不同之处在于main函数call 后面没有了add esp, 8；test函数最后一句是 ret 8  (由test函数清栈, ret 8意思是执行ret后，esp+8)。</li>\n<li>运行过程中0x12FF28 保存了指令地址 00401091是怎么保存的？栈每个空间保存4个字节（粒度4字节） 例如下一个栈空间0x12FF2C保存参数10，因此：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x12FF28 0x12FF29 0x12FF2A 0x12FF2B   </span><br><span class=\"line\">   91       10       40       00       </span><br></pre></td></tr></table></figure>\n\n<p>little-endian 认为其读的第一个字节为最小的那位上的数。</p>\n<ol start=\"3\">\n<li>char a[] &#x3D; “abcde”<br> 对局部字符数组变量（栈变量）赋值，是利用寄存器从全局数据内存区把字符串“abcde”拷贝到栈内存中的。</li>\n<li>int szNum[5] &#x3D; { 1, 2, 3, 4, 5 }; 栈中是如何分布的？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401798   mov         dword ptr [ebp-14h],1</span><br><span class=\"line\">0040179F   mov         dword ptr [ebp-10h],2</span><br><span class=\"line\">004017A6   mov         dword ptr [ebp-0Ch],3</span><br><span class=\"line\">004017AD   mov         dword ptr [ebp-8],4</span><br><span class=\"line\">004017B4   mov         dword ptr [ebp-4],5</span><br></pre></td></tr></table></figure>\n\n<p>可以看出来是从右边开始入栈，所以是 5 4 3 2 1 入栈，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *ptrA = (int*)(&amp;szNum+1);</span><br><span class=\"line\">int *ptrB = (int*)((int)szNum + 1);</span><br><span class=\"line\">std::cout&lt;&lt; ptrA[-1] &lt;&lt; *ptrB &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n\n<p>结果如何？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">28:       int *ptrA = (int*)(&amp;szNum+1);</span><br><span class=\"line\">004017BB   lea         eax,[ebp]</span><br><span class=\"line\">004017BE   mov         dword ptr [ebp-18h],eax</span><br></pre></td></tr></table></figure>\n\n<p>&amp;szNum是指向数组指针；加1是加一个数组宽度；&amp;szNum+1指向移动5个int单位之后的那个地方， 就是把EBP的地址赋给指针；<br>ptrA[-1]是回退一个int*宽度，即ebp-4；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">29:       int *ptrB = (int*)((int)szNum + 1);</span><br><span class=\"line\">004017C1   lea         ecx,[ebp-13h]</span><br><span class=\"line\">004017C4   mov         dword ptr [ebp-1Ch],ecx</span><br></pre></td></tr></table></figure>\n\n<p>如果上面是指针算术，那这里就是地址算术，只是首地址+1个字节的offset，即ebp-13h给指针。实际保存是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 00 00 00 02 00 00 00</span><br><span class=\"line\">ebp-14h ebp-13h ebp-10h</span><br></pre></td></tr></table></figure>\n\n<p>注意，是int*类型的，最后获得的是 00 00 00 02，由于Little-endian, 实际上逻辑数是02000000，转换为十进制数就为33554432，最后输出533554432。</p>\n","text":"你一定要搞明白的C函数调用方式与栈原理写在前面的话 这绝对不是标题党。而是C/C++开发中你必须要掌握的基础知识，也是高级技术岗位面试中高频题。我真的真的真的希...","permalink":"/post/转载/cpp/你一定要搞明白的C函数调用方式与栈原理","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E6%90%9E%E6%98%8E%E7%99%BD%E7%9A%84C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A0%88%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">你一定要搞明白的C函数调用方式与栈原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">一个典型的栈帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%89%8D%E8%B0%83%E7%94%A8%E8%80%85%E7%9A%84%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">函数调用前调用者的动作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E5%9C%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%90%8E%E7%9A%84%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">被调用者在函数调用后的动作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E8%BF%94%E5%9B%9E%E5%89%8D%E7%9A%84%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">被调用者返回前的动作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E8%80%85%E5%9C%A8%E8%BF%94%E5%9B%9E%E5%90%8E%E7%9A%84%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">调用者在返回后的动作</span></a></li></ol></li></ol>","author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"【转载】不定参数函数实现var_arg系列的宏","uid":"40a7e4f59089c11e355c8f7228d5379e","slug":"转载/cpp/不定参数函数实现var_arg系列的宏","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/cpp/不定参数函数实现var_arg系列的宏.json","keywords":null,"cover":[],"text":"不定参数函数实现var_arg系列的宏电驴的源码日志模块有一个叫 DebugLogError 函数，其签名如下： 12//代码位于easyMule-master...","permalink":"/post/转载/cpp/不定参数函数实现var_arg系列的宏","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【转载】利用cmake工具生成VisualStudio工程文件","uid":"0e9060ff12875a627166c3e18b56f8f7","slug":"转载/cpp/利用cmake工具生成VisualStudio工程文件","date":"2021-05-06T09:27:48.000Z","updated":"2024-11-11T08:31:27.041Z","comments":true,"path":"api/articles/转载/cpp/利用cmake工具生成VisualStudio工程文件.json","keywords":null,"cover":[],"text":"利用 cmake 工具生成 Visual Studio 工程文件对于习惯了 Visual Studio 强大的管理项目、编码和调试功能的读者来说，在 Linux...","permalink":"/post/转载/cpp/利用cmake工具生成VisualStudio工程文件","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"转载","slug":"转载","count":50,"path":"api/categories/转载.json"}],"tags":[{"name":"c++","slug":"c","count":35,"path":"api/tags/c.json"},{"name":"学习资料","slug":"学习资料","count":26,"path":"api/tags/学习资料.json"}],"author":{"name":"阿木大叔","slug":"blog-author","avatar":"/images/base/logo.png","link":"/","description":"坚持code，努力吹牛 <br /> @ <b>gitee：阿木大叔</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}